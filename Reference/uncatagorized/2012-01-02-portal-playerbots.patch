From af91e50bb2394ce74dc79c8ae47906c2a6cb09cd Mon Sep 17 00:00:00 2001
From: LordPsyan <uppp@juno.com>
Date: Mon, 2 Jan 2012 21:10:40 -0600
Subject: [PATCH] 2012-01-02-portal-playerbots

---
 README.NPCTELEPORT                                 |   14 +
 bot_readme.txt                                     |  232 +
 bot_todo.txt                                       |   29 +
 botguy_readme.txt                                  |   12 +
 doc/AuctionHouseBot.txt                            |  236 +
 sql/All/characters_jail.sql                        |   66 +
 sql/All/world-example_gmisland.sql                 |  117 +
 sql/All/world_command_Deutsch.sql                  |    7 +
 sql/All/world_command_English.sql                  |    7 +
 sql/All/world_command_Francais.sql                 |    7 +
 sql/All/world_creature_template.sql                |    5 +
 sql/All/world_guildhouses.sql                      |   54 +
 sql/All/world_npc_buff.sql                         |   63 +
 sql/All/world_trinity_string.sql                   |   41 +
 sql/FlamingLegion.net/auth_AIO.sql                 |   11 +
 sql/FlamingLegion.net/characters_AIO.sql           |    1 +
 sql/FlamingLegion.net/world_AIO.sql                |   27 +
 sql/Wintergrasp_world.sql                          |  134 +
 sql/beastmaster/world-beastmaster.sql              |    4 +
 sql/extras/World_TriniityChat.sql                  |   81 +
 sql/extras/character_VIPAccount.sql                |    8 +
 sql/extras/setup_ahbot.sql                         |   71 +
 sql/extras/setup_npc_teleport.sql                  |  119 +
 sql/world_botguy.sql                               |    1 +
 src/server/authserver/Server/AuthSocket.cpp        |    3 +
 src/server/game/AI/PlayerBots/PlayerbotAI.cpp      | 6576 ++++++++++++++++++++
 src/server/game/AI/PlayerBots/PlayerbotAI.h        |  492 ++
 src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp |   19 +
 src/server/game/AI/PlayerBots/PlayerbotClassAI.h   |   46 +
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp  |  502 ++
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.h    |  100 +
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp |  694 +++
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h   |  192 +
 .../game/AI/PlayerBots/PlayerbotHunterAI.cpp       |  406 ++
 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h  |  121 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp  |  468 ++
 src/server/game/AI/PlayerBots/PlayerbotMageAI.h    |  163 +
 src/server/game/AI/PlayerBots/PlayerbotMgr.cpp     | 1172 ++++
 src/server/game/AI/PlayerBots/PlayerbotMgr.h       |   64 +
 .../game/AI/PlayerBots/PlayerbotPaladinAI.cpp      |  538 ++
 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h |  185 +
 .../game/AI/PlayerBots/PlayerbotPriestAI.cpp       |  446 ++
 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h  |  156 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp |  346 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h   |  102 +
 .../game/AI/PlayerBots/PlayerbotShamanAI.cpp       |  527 ++
 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h  |  119 +
 .../game/AI/PlayerBots/PlayerbotWarlockAI.cpp      |  570 ++
 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h |  250 +
 .../game/AI/PlayerBots/PlayerbotWarriorAI.cpp      |  351 ++
 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h |  103 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  373 ++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 +
 .../AuctionHouseBot/AuctionHouseBot.cpp            | 1980 ++++++
 .../AuctionHouse/AuctionHouseBot/AuctionHouseBot.h | 1257 ++++
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |   11 +-
 src/server/game/AuctionHouse/AuctionHouseMgr.h     |    2 +
 src/server/game/CMakeLists.txt                     |   13 +
 src/server/game/Chat/Channels/Channel.cpp          |    4 +
 src/server/game/Chat/Chat.cpp                      |  419 ++-
 src/server/game/Chat/Chat.h                        |   42 +-
 src/server/game/Chat/Commands/Level0.cpp           |   53 +-
 src/server/game/Chat/Commands/Level1.cpp           |  319 +
 src/server/game/Chat/Commands/Level2.cpp           |  238 +-
 src/server/game/Chat/Commands/Level3.cpp           |  686 ++
 src/server/game/CityConquest/CityConquestMgr.cpp   |  321 +
 src/server/game/CityConquest/CityConquestMgr.h     |   84 +
 src/server/game/DataStores/DBCStructure.h          |    2 +-
 src/server/game/DataStores/DBCfmt.h                |    2 +-
 src/server/game/Entities/Creature/Creature.h       |    9 +-
 src/server/game/Entities/Creature/GossipDef.h      |    2 +
 src/server/game/Entities/GameObject/GameObject.cpp |    5 +
 src/server/game/Entities/Player/Player.cpp         |  334 +-
 src/server/game/Entities/Player/Player.h           |   55 +-
 src/server/game/Entities/Unit/Unit.h               |    9 +-
 src/server/game/Entities/Vehicle/Vehicle.cpp       |   26 +
 src/server/game/Entities/Vehicle/Vehicle.h         |    2 +
 src/server/game/Events/GameEventMgr.cpp            |    7 +
 src/server/game/Globals/ObjectMgr.cpp              |  115 +
 src/server/game/Globals/ObjectMgr.h                |   23 +
 src/server/game/Groups/Group.cpp                   |   11 +
 src/server/game/Guilds/Guild.h                     |    2 +-
 src/server/game/Mails/Mail.cpp                     |    8 +
 src/server/game/Miscellaneous/Formulas.h           |    4 +-
 src/server/game/Miscellaneous/Language.h           |   71 +-
 src/server/game/Miscellaneous/SharedDefines.h      |    2 +
 src/server/game/OutdoorPvP/OutdoorPvP.h            |    5 +-
 src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp       |    1 +
 src/server/game/Quests/QuestDef.h                  |    7 +-
 src/server/game/Scripting/ScriptLoader.cpp         |   52 +-
 src/server/game/Scripting/ScriptMgr.cpp            |    8 +
 .../Protocol/Handlers/AuctionHouseHandler.cpp      |    7 +
 .../Protocol/Handlers/BattleGroundHandler.cpp      |   14 +
 .../Server/Protocol/Handlers/CharacterHandler.cpp  |   52 +-
 .../game/Server/Protocol/Handlers/ChatHandler.cpp  |   39 +-
 .../game/Server/Protocol/Handlers/MiscHandler.cpp  |   36 +-
 .../game/Server/Protocol/Handlers/QuestHandler.cpp |   14 +-
 src/server/game/Server/WorldSession.cpp            |   56 +-
 src/server/game/Server/WorldSession.h              |    6 +-
 src/server/game/Server/WorldSocket.cpp             |   13 +-
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    7 +
 src/server/game/Spells/Spell.cpp                   |   12 +
 src/server/game/Spells/SpellEffects.cpp            |   34 +
 src/server/game/Spells/SpellMgr.cpp                |   17 +
 src/server/game/TriniChat/IRCClient.cpp            |  108 +
 src/server/game/TriniChat/IRCClient.h              |  253 +
 src/server/game/TriniChat/IRCCmd.cpp               |  930 +++
 src/server/game/TriniChat/IRCCmd.h                 |  141 +
 src/server/game/TriniChat/IRCCmde.cpp              | 2337 +++++++
 src/server/game/TriniChat/IRCFunc.h                |  278 +
 src/server/game/TriniChat/IRCIO.cpp                |  470 ++
 src/server/game/TriniChat/IRCLog.cpp               |   81 +
 src/server/game/TriniChat/IRCLog.h                 |   42 +
 src/server/game/TriniChat/IRCSock.cpp              |  166 +
 src/server/game/TriniChat/MCS_OnlinePlayers.cpp    |   97 +
 src/server/game/TriniChat/MCS_OnlinePlayers.h      |   38 +
 src/server/game/TriniChat/framework/CMakeLists.txt |   11 +
 .../TriniChat/framework/Dynamic/FactoryHolder.h    |   63 +
 .../TriniChat/framework/Dynamic/ObjectRegistry.h   |  111 +
 .../game/TriniChat/framework/GameSystem/Grid.h     |  143 +
 .../TriniChat/framework/GameSystem/GridLoader.h    |   79 +
 .../framework/GameSystem/GridRefManager.h          |   44 +
 .../TriniChat/framework/GameSystem/GridReference.h |   55 +
 .../game/TriniChat/framework/GameSystem/NGrid.h    |  189 +
 .../TriniChat/framework/GameSystem/TypeContainer.h |  126 +
 .../framework/GameSystem/TypeContainerFunctions.h  |  116 +
 .../GameSystem/TypeContainerFunctionsPtr.h         |  170 +
 .../framework/GameSystem/TypeContainerVisitor.h    |  119 +
 .../TriniChat/framework/Network/SocketDefines.h    |   49 +
 .../TriniChat/framework/Platform/CompilerDefs.h    |   64 +
 .../game/TriniChat/framework/Platform/Define.h     |   85 +
 .../TriniChat/framework/Policies/CreationPolicy.h  |  110 +
 .../framework/Policies/ObjectLifeTime.cpp          |   36 +
 .../TriniChat/framework/Policies/ObjectLifeTime.h  |   53 +
 .../game/TriniChat/framework/Policies/Singleton.h  |   65 +
 .../TriniChat/framework/Policies/SingletonImp.h    |   93 +
 .../TriniChat/framework/Policies/ThreadingModel.h  |  130 +
 .../TriniChat/framework/Utilities/ByteConverter.h  |   66 +
 .../game/TriniChat/framework/Utilities/Callback.h  |  386 ++
 .../Utilities/CountedReference/Reference.h         |  100 +
 .../Utilities/CountedReference/ReferenceHolder.h   |   42 +
 .../Utilities/CountedReference/ReferenceImpl.h     |  133 +
 .../TriniChat/framework/Utilities/LinkedList.h     |  247 +
 .../Utilities/LinkedReference/RefManager.h         |   94 +
 .../Utilities/LinkedReference/Reference.h          |   58 +
 .../game/TriniChat/framework/Utilities/TypeList.h  |   46 +
 .../TriniChat/framework/Utilities/UnorderedMap.h   |   73 +
 src/server/game/World/World.cpp                    |  255 +-
 src/server/game/World/World.h                      |   35 +
 src/server/scripts/CMakeLists.txt                  |    4 +
 src/server/scripts/Commands/cs_gm.cpp              |    4 +-
 src/server/scripts/Custom/AIO-4.0a.cpp             | 1351 ++++
 src/server/scripts/Custom/CMakeLists.txt           |   11 +
 src/server/scripts/Custom/beastmaster.cpp          |  915 +++
 src/server/scripts/Custom/city_conquest_boss.cpp   |   76 +
 .../scripts/Custom/city_conquest_generic.cpp       |   51 +
 src/server/scripts/Custom/city_conquest_portal.cpp |  201 +
 .../scripts/Custom/city_conquest_spawner.cpp       |   67 +
 src/server/scripts/Custom/guildmaster.cpp          |  339 +
 src/server/scripts/Custom/levelnpc.cpp             |  194 +
 src/server/scripts/Custom/npc_teleport.cpp         |  221 +
 src/server/scripts/Custom/npcbuff.cpp              |  425 ++
 src/server/scripts/Custom/professionnpc.cpp        |  397 ++
 src/server/scripts/Custom/summon.cpp               |   46 +
 src/server/scripts/Northrend/CMakeLists.txt        |    1 +
 .../VaultOfArchavon/instance_vault_of_archavon.cpp |   17 +
 src/server/scripts/Northrend/wintergrasp.cpp       |  438 ++
 src/server/scripts/OutdoorPvP/CMakeLists.txt       |    2 +
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp     | 2142 +++++++
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h       |  342 +
 .../Database/Implementation/LoginDatabase.cpp      |    3 +-
 .../shared/Database/Implementation/LoginDatabase.h |    1 +
 src/server/shared/Utilities/Util.h                 |    7 +-
 src/server/worldserver/CMakeLists.txt              |    1 +
 src/server/worldserver/CommandLine/CliRunnable.cpp |   10 +
 src/server/worldserver/Main.cpp                    |    1 +
 src/server/worldserver/Master.cpp                  |   11 +-
 src/server/worldserver/worldserver.conf.dist       |  862 +++
 178 files changed, 39550 insertions(+), 57 deletions(-)
 create mode 100644 README.NPCTELEPORT
 create mode 100644 bot_readme.txt
 create mode 100644 bot_todo.txt
 create mode 100644 botguy_readme.txt
 create mode 100644 doc/AuctionHouseBot.txt
 create mode 100644 sql/All/characters_jail.sql
 create mode 100644 sql/All/world-example_gmisland.sql
 create mode 100644 sql/All/world_command_Deutsch.sql
 create mode 100644 sql/All/world_command_English.sql
 create mode 100644 sql/All/world_command_Francais.sql
 create mode 100644 sql/All/world_creature_template.sql
 create mode 100644 sql/All/world_guildhouses.sql
 create mode 100644 sql/All/world_npc_buff.sql
 create mode 100644 sql/All/world_trinity_string.sql
 create mode 100644 sql/FlamingLegion.net/auth_AIO.sql
 create mode 100644 sql/FlamingLegion.net/characters_AIO.sql
 create mode 100644 sql/FlamingLegion.net/world_AIO.sql
 create mode 100644 sql/Wintergrasp_world.sql
 create mode 100644 sql/beastmaster/world-beastmaster.sql
 create mode 100644 sql/extras/World_TriniityChat.sql
 create mode 100644 sql/extras/character_VIPAccount.sql
 create mode 100644 sql/extras/setup_ahbot.sql
 create mode 100644 sql/extras/setup_npc_teleport.sql
 create mode 100644 sql/world_botguy.sql
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotClassAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMgr.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMgr.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
 create mode 100644 src/server/game/CityConquest/CityConquestMgr.cpp
 create mode 100644 src/server/game/CityConquest/CityConquestMgr.h
 create mode 100644 src/server/game/TriniChat/IRCClient.cpp
 create mode 100644 src/server/game/TriniChat/IRCClient.h
 create mode 100644 src/server/game/TriniChat/IRCCmd.cpp
 create mode 100644 src/server/game/TriniChat/IRCCmd.h
 create mode 100644 src/server/game/TriniChat/IRCCmde.cpp
 create mode 100644 src/server/game/TriniChat/IRCFunc.h
 create mode 100644 src/server/game/TriniChat/IRCIO.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.h
 create mode 100644 src/server/game/TriniChat/IRCSock.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.h
 create mode 100644 src/server/game/TriniChat/framework/CMakeLists.txt
 create mode 100644 src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
 create mode 100644 src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/Grid.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridLoader.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridReference.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/NGrid.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
 create mode 100644 src/server/game/TriniChat/framework/Network/SocketDefines.h
 create mode 100644 src/server/game/TriniChat/framework/Platform/CompilerDefs.h
 create mode 100644 src/server/game/TriniChat/framework/Platform/Define.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/CreationPolicy.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
 create mode 100644 src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/Singleton.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/SingletonImp.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/ThreadingModel.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/ByteConverter.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/Callback.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedList.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/TypeList.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
 create mode 100644 src/server/scripts/Custom/AIO-4.0a.cpp
 create mode 100644 src/server/scripts/Custom/beastmaster.cpp
 create mode 100644 src/server/scripts/Custom/city_conquest_boss.cpp
 create mode 100644 src/server/scripts/Custom/city_conquest_generic.cpp
 create mode 100644 src/server/scripts/Custom/city_conquest_portal.cpp
 create mode 100644 src/server/scripts/Custom/city_conquest_spawner.cpp
 create mode 100644 src/server/scripts/Custom/guildmaster.cpp
 create mode 100644 src/server/scripts/Custom/levelnpc.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/npcbuff.cpp
 create mode 100644 src/server/scripts/Custom/professionnpc.cpp
 create mode 100644 src/server/scripts/Custom/summon.cpp
 create mode 100644 src/server/scripts/Northrend/wintergrasp.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h

diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/bot_readme.txt b/bot_readme.txt
new file mode 100644
index 0000000..42e5ed8
--- /dev/null
+++ b/bot_readme.txt
@@ -0,0 +1,232 @@
+What it is:
+===========
+
+Playerbot lets you add another character from your account as a bot that you can control and which will hopefully help you. Only characters from your account can be used, so you can have a maximum of 9 bots at one time.
+
+This was taken from the Trinity site, and modified slightly by me to get some of the kinks out. I reworked the priest class and also added a mage class and a warrior class, which are still in crude form. Any class can be used as a bot - just don't expect much in the way of spells or abilities until someone writes the code for them.
+
+Bots will only use abilities that they have - for example, a priest will only use the renew spell if it has been trained. Also, bot's equipment will lose durability like any other character. So every so often you'll need to log in and repair and train your bot.
+
+For TrinityCore d3a7ac5d7dad8f3677de8b69d29ffbe36deb51dd
+
+Commands:
+=========
+
+/s .bot add BOTNAME (add character to world)
+/s .bot remove BOTNAME
+/s .bot co|combatorder BOTNAME COMBATORDER [TARGET]
+/invite BOTNAME (bot will auto accept invite)
+/t BOTNAME attack (bot will attack selected target, similar to the way a pet can attack)
+/t BOTNAME follow (orders bot to follow player; will also revive bot if dead or teleport bot if far away)
+/t BOTNAME stay
+/t BOTNAME assist (you'll need to be attacking something and the bot only does melee atm)
+/t BOTNAME spells (replies with all spells known to bot)
+/t BOTNAME cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME use [ITEM LINK]
+/t BOTNAME equip [ITEM LINK]
+/t BOTNAME reset (will reset states, orders and loot list)
+/t BOTNAME report (bot reports all items, creatures or gameobjects needed to finish quests)
+/t BOTNAME stats (bot shows available money, free inventory space and estimated item repair costs)
+/t BOTNAME survey (bot shows all available gameobjects, within a local perimeter around the bot)
+/t BOTNAME find [GAMEOBJECT LINK] (bot will travel to the gameobject location and then wait)
+/t BOTNAME get [GAMEOBJECT LINK] (bot will fetch the selected gameobject and then return to the player)
+/t BOTNAME quest (Shows bot's current quests)
+/t BOTNAME quest <(a)dd> [QUESTLINK] (Adds a quest)
+/t BOTNAME quest <(d)rop> [QUESTLINK] (Drop a quest)
+/t BOTNAME quest <(e)nd> (Turns in a completed quest)
+/t BOTNAME quest <(l)ist> (Shows new quests offered by questgiver)
+/t BOTNAME orders (Shows bot's combat orders)
+/t BOTNAME pet spells (Shows spells known to bot's pet. Autocast spells will be shown in green)
+/t BOTNAME pet cast <SPELLID | (part of) SPELLNAME | [SPELLLINK]>
+/t BOTNAME pet toggle <SPELLID | (part of) SPELLNAME | [SPELLLINK]> (Toggle autocast for a given spell)
+/t BOTNAME pet state (Shows current react mode of bot's pet)
+/t BOTNAME pet react <(a)ggressive | (d)efensive | (p)assive> (Set bot's pet reaction mode)
+/t BOTNAME collect (shows collect subcommand options and current collect status)
+/t BOTNAME collect <subcommand(s)> (subcommands can be alone or together [none combat loot objects profession quest])
+/t BOTNAME sell [ITEM LINK] (bot will add item to it's m_itemIds, for later sale)
+/t BOTNAME auction (bot will display all it's active owned auctions. Auction info will include an [AUCTION LINK] )
+/t BOTNAME auction add [ITEM LINK] (bot will add item to it's m_itemIds, for later auction)
+/t BOTNAME auction remove [AUCTION LINK] (bot will add auctionid to it's m_auctions, for later auction cancellation)
+/t BOTNAME repair [ITEM LINK] (bot will seek out armourer and repair selected items specified by [ITEM LINK] )
+/t BOTNAME repair all (bot(s) will seek out armourer and repair all damaged items equipped, or in bags )
+/t BOTNAME talent (Lists bot(s) active talents [TALENT LINK] & glyphs [GLYPH LINK], unspent talent points & cost to reset all talents)
+/t BOTNAME talent learn [TALENT LINK} .. (Learn selected talent from bot client 'inspect' dialog -> 'talent' tab or from talent command (shift click icon or link))
+/t BOTNAME talent reset (Resets all talents)
+/t BOTNAME bank  (Lists bot(s) bank balance)
+/t BOTNAME bank deposit [Item Link][Item Link] .. (Deposit item(s) in bank)
+/t BOTNAME bank withdraw [Item Link][Item Link] ..  (Withdraw item(s) from bank. ([Item Link] from bank))
+/t BOTNAME skill (lists all [PROFESSION LINK] bot Primary profession skills)
+/t BOTNAME skill train (lists [TRAINING LINK] available class, weapon & profession (Primary or Secondary) skills & spells, from selected trainer)
+/t BOTANME skill learn [TRAINING LINK] (learn selected skill or spell, from selected trainer)
+/t BOTNAME skill unlearn [PROFESSION LINK] (unlearn selected primary profession skill & all associated spells)
+
+Shortcuts:
+c = cast
+e = equip
+u = use
+
+Gameobject interaction with bots:
+=================================
+
+  The bot(s) can interact with gameobjects. This is particularly useful, in order to complete 'gather' type
+  quests (e.g Milly's harvest in Northshire). The bot(s) can also harvest 'ore deposits' and 'herbs'
+
+  Four commands have been introduced 'collect', 'survey, 'find' & 'get', to facilitate this feature.
+
+  The 'collect' command provides a way to have a bot automatically get loot or objects in the world.
+  The command by itself gives you a display of what settings the bots have. Defaults are stored in
+  the playerbot.conf. The subcommands do the actual work:
+    combat - bot will loot after combat for the options that are set
+    loot - bot will grab all loot available from corpse
+    quest - bot will grab all quest items on corpse
+    profession - bot will grab any profession related item that the bot has from corpse
+    skin - if you have skinning, and corpse has been looted, bot will skin corpse. Most of
+        the time you may want this option and the loot option enabled, but if you are grabbing
+        the stuff as you are going around, the bot will skin afterwards.
+    objects - bot will collect things that are specified by the survey and get <shift-click> commands
+    none - removes any collect options that have been set
+
+  The 'survey' command provides the means for bot(s) to detect gameobjects in the world. It can be used to detect
+  available gameobjects local to a single bot, or more effectively (wider area) those for a party of bots.
+
+  Suggestion: setup the 'survey' command as an assigned macro button, on the client (e.g /p survey). You can
+  then quickly refresh the gameobject list.
+
+  Gameobject list [GAMEOBJECT LINK] (Currently bots can only interact with ore, herb and needed quest items)
+  ---------------
+
+  [Copper Vein][Silverleaf][Earthroot][Milly's Harvest][Battered Chest][Food Crate]
+
+  Then, use the 'find' or 'get' commands to interect with the gameobject.
+
+  Using the gameobject list information, it is possible to locate and/or fetch each of the gameobjects. To select
+  a [GAMEOBJECT LINK], hold down the shift key and click on the relevant link with your mouse.
+
+Creature interaction with bots:
+===============================
+
+  The bot(s) can now interact directly with creatures. This will enable bot(s) to independently contact NPCs, without
+  the need for player's selection. This opens up new possiblities for bot/NPC commerce.
+
+  Each bot will maintain it's own item list (m_itemIds - This is a list of paired data). The first component (UNIT_NPC_FLAG)
+  dictates what is to done with the second component (itemid).
+
+  Each bot will also maintain it's own active auction list (m_auctions - This is a list of paired data). The first component
+  (ActionFlags) dictates the action to be performed on the second component (auctionid).
+
+  While(m_itemIds not empty)
+  {
+      bot will scan for surrounding creatures (findNearbyCreature()) who can service m_itemIds
+      if(found)
+          Search is carried out for all itemids that can be processed by this creature.
+          if(processed successfully)
+              This instance of the data pair (npcflag,itemid) will be removed from m_itemIds
+              While(m_auctions not empty)
+                  process contained auctionids according to ActionFlag & then update m_auctions
+  }
+
+  Please note that bot(s) m_itemIds & m_auctions will be emptied, when bot(s) are dismissed.
+
+Repair with bots:
+=================
+
+  bot(s) can now repair <all or selected> items, either equipped or in bags. If the bot(s) is a member of a guild, then they pay
+  else the bot(s) pays. If the bot(s) cannot pay for the repair, they remain damaged.
+
+  The new 'stats' command provides useful information to help in the repair decision.
+
+  First:  Money available to bot(s)
+  Second: Free inventory slots for bot(s)
+  Third:  Estimated (excludes NPC reputation discount) item damage cost for bot(s).
+
+Combat Orders explained:
+========================
+
+  There are primary and secondary commands which can be combined. In this way it is
+  possible to define a bot to assist the main tank and also protect the healer, making
+  combat management much easier.
+  The commands assist and protect require a target parameter or a friendly player
+  selected by bots master.
+  Available Combat Orders:
+    tank        pri     try to bind all targets involved in combat by gaining highest threat
+    assist      pri     do damage on selected targets attacker without getting highest threat
+    heal        pri     concentrate on healing - no offensive spells, try to keep threat low
+    protect     sec     if target of protect get's directly attacked gain higher threat on attacker
+    reset       -       clear out assist and protect targets and set combat order to nothing
+  Examples:
+    .bot co TheTank tank
+    .bot co MyHealer heal
+    .bot co TheBrutal assist TheTank
+    .bot co TheBrutal protect MyHealer
+
+Trading with bots:
+==================
+
+To trade items/money with your bot simply initiate a trade and the bot will tell you how much money and items are available. To request an item simple whisper the bot and shift click the link of the item you would like. You can link multiple items on the same line. You can also request money in the following manner when the trade window is open:
+/w BOTNAME 10g <-- request that the bot give you 10 gold
+/w BOTNAME 6g500s25c <-- request 6 gold, 500 silver, and 25 cooper
+
+A bot is also able to show an item in its 'Will not be traded' slot. The item can be either
+in its bags or be equipped and even be soulbound. By this you can cast spells/enchantments
+on soulbound items ('nt' stands for 'not trading').
+/w BOTNAME nt [Powerful Soulbound Item]
+
+More Information:
+=================
+
+If specifying a spell substring, the spell chosen will be in priority of exact name match, highest spell rank, and spell using no reagents. Case does not matter. Here's some examples:
+/t BOTNAME c greater heal
+/t BOTNAME cast pain
+/w BOTNAME c poly
+/w BOTNAME cast fort
+/t BOTNAME cast <SPELLID>
+- OR -
+/w BOTNAME c <SPELLID>
+
+Also all commands can be broadcast to the party. For example:
+/p follow
+/p spells
+
+To use or equip items for your bot say:
+/w BOTNAME use [ITEMLINK1][ITEMLINK2]
+/w BOTNAME equip [ITEMLINK1][ITEMLINK2]
+- OR -
+/w BOTNAME u [ITEMLINK1][ITEMLINK2]
+/w BOTNAME e [ITEMLINK1] [ITEMLINK2]
+
+If you inspect your bot, your bot will tell you what items you have in your inventory that you can equip. To create a link in the chat window, hold the shift key and press the left mouse button when clicking the link.
+
+
+Changes from Trinity to TrinityCore:
+===============================
+
+I added the following in SharedDefines.h.
+
+enum SpellCategory
+{
+	SPELL_CATEGORY_FOOD             = 11,
+	SPELL_CATEGORY_DRINK            = 59
+};
+
+I also had to add the following to Player.h:
+
+enum PlayerStateType
+{
+	PLAYER_STATE_NONE              = 0,
+	PLAYER_STATE_SIT               = 1
+};
+
+
+Configuration variables:
+========================
+Also see src/TrinityCored/TrinityCored.conf.dist for configuration variables!
+
+    PlayerbotAI.DebugWhisper
+        Enable debug output by whispering master
+        Default: 0 - off
+                 1 - on
+
+    PlayerbotAI.FollowDistanceMin
+    PlayerbotAI.FollowDistanceMax
+        Min. and max. follow distance for bots
+        Default: 0.5 / 1.0
diff --git a/bot_todo.txt b/bot_todo.txt
new file mode 100644
index 0000000..b73e423
--- /dev/null
+++ b/bot_todo.txt
@@ -0,0 +1,29 @@
+[DONE] ///---Quest---///
+[DONE] Bot can accept quest.
+[DONE] Bot can join quest.
+
+[DONE] ///---Loot---///
+[DONE] Bot can loot.
+[DONE] Bot can loot --- maybe only needed q item.
+
+//---Instance teleport Problems---///
+[DONE] Needs some fix.
+
+///---Combat and Movement Orders---///
+[DONE] Movement orders (stay, follow)
+[DONE] Combat orders (protect, assist)
+Combat order TANK
+Combat order HEAL
+
+///---Temporary item enchantments---///
+[DONE] Rogue	: Poison
+Warrior	: Sharpening Stone, Rune of Warding, Rune of Shielding.
+
+//---After fear bot's lose target---///
+Needs some fix.
+
+///---Move behind target---///
+[DONE] Rogue	: some abilitys require Rogue to be stealthed and behind target.
+
+///---Implement locale independet way of getting spellIDs---///
+[DONE] Hardcode lowest rank spellID, use function to get highest rank
diff --git a/botguy_readme.txt b/botguy_readme.txt
new file mode 100644
index 0000000..3e44da6
--- /dev/null
+++ b/botguy_readme.txt
@@ -0,0 +1,12 @@
+What it is:
+===========
+
+The new revised'botguy' utilizes NPCs already distributed throughout the world, to allow players to
+summon and dismiss bots at will, from their own account.
+
+This is a revised (more stable) version that utilizes the new 'GOSSIP MENU SYSTEM' to modify the menus of existing NPCs
+(e.g Trainers etc) to include the bot Recruit/Dismiss menu. (No GameMaster account necessary).
+
+Install (Server administrators only)
+=======
+Please apply 'world_botguy.sql' once to the world database to update the 'gossip_menu_option' table.
diff --git a/doc/AuctionHouseBot.txt b/doc/AuctionHouseBot.txt
new file mode 100644
index 0000000..cc15a08
--- /dev/null
+++ b/doc/AuctionHouseBot.txt
@@ -0,0 +1,236 @@
+Populates the auction houses with items. It can make the game feel a bit more
+like official on small servers. Items and prices are chosen randomly based on
+the parameters you define. If an auction expires, auctions are deleted quietly.
+AHBot will not buy it's own items, and will not receive mail from the AH
+or get returned mail.
+
+===============================================================================
+~~HOW TO CONFIGURE~~
+===============================================================================
+Step 1.) Create a character that you are going to use as the auction house bot
+         character. This character will be the auction's owner for all the
+         items created by the bot.
+Step 2.) Go into the realm database and note the account number for the
+         character.
+Step 3.) Go into the characters database and note the character's GUID.
+Step 4.) Log in at least once with this character.
+         (Do not change the configuration before this)
+Step 5.) Tune the configuration options in the configuration file and the
+         Database.
+
+#These are the settings in the configuration file:
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+AuctionHouseBot.DEBUG enables (1) or disables (0) Debug output
+AuctionHouseBot.EnableSeller enables (1) or disables (0) the Seller
+AuctionHouseBot.EnableBuyer enables (1) or disables (0) the Buyer
+AuctionHouseBot.UseBuyPriceForSeller Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.UseBuyPriceForBuyer Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.ItemsPerCycle determines how many items are added each time AHBot is run (once per minute, by default)
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+AuctionHouseBot.VendorItems is a boolean value (0 or 1) that indicates whether to include Vendor only items
+AuctionHouseBot.VendorTradeGoods is a boolean value (0 or 1) that indicates whether to include Vendor only Trade Goods
+AuctionHouseBot.LootItems  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only items
+AuctionHouseBot.LootTradeGoods  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only Trade Goods
+AuctionHouseBot.OtherItems  is a boolean value (0 or 1) that indicates whether to include Other items not covered by the first 2
+AuctionHouseBot.OtherTradeGoods  is a boolean value (0 or 1) that indicates whether to include Other Trade Goods not covered by the first 2
+AuctionHouseBot.No_Bind is a boolean value (0 or 1) that indicates whether to include items with a bonding of 0
+AuctionHouseBot.Bind_When_Picked_Up = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 1
+AuctionHouseBot.Bind_When_Equipped = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 2
+AuctionHouseBot.Bind_When_Use = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 3
+AuctionHouseBot.Bind_Quest_Item = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 4
+AuctionHouseBot.DisableBeta_PTR_Unused is a boolean value (0 or 1) that will Disable certain items that are usually unavailable to Players
+AuctionHouseBot.DisablePermEnchant is a boolean value (0 or 1) that will Disable Items with a Permanent Enchantment
+AuctionHouseBot.DisableConjured is a boolean value (0 or 1) that will Disable Conjured Items
+AuctionHouseBot.DisableGems is a boolean value (0 or 1) that will Disable Gems
+AuctionHouseBot.DisableMoney is a boolean value (0 or 1) that will Disable Items that are used as money
+AuctionHouseBot.DisableMoneyLoot is a boolean value (0 or 1) that will Disable Items that have Money as a loot
+AuctionHouseBot.DisableLootable is a boolean value (0 or 1) that will Disable Items that have other items as loot
+AuctionHouseBot.DisableKeys is a boolean value (0 or 1) that will Disable Items that are keys
+AuctionHouseBot.DisableDuration is a boolean value (0 or 1) that will Disable Items with a duration
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel is a boolean value (0 or 1) that will Disable items that are BOP or Quest Item with a Required level that is less than the Item Level
+
+#These Filters are boolean (0 or 1) and will disable items that are
+#specifically meant for the Class named.
+#(UnusedClass is Class 10, which was skipped for some reason)
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+#These are the settings in the Database:
+#Each Auctionhouse has it's own set of these
+
+MinItems = 0
+#The Minimum number of items you want to keep in the auction houses.
+#(default 0 - minimum will be the same as maximum).
+#If it is higher than the value of the corresponding maxItems setting,
+#it will be set down to match the maxItems setting.
+
+MaxItems = 0
+#The Maximum number of items you want to keep in the auction houses.
+
+#These must add up to 100 each one is the percentage
+#of the auction items that should be trade goods of
+#that quality. A value of 0 will disable.
+
+PercentGreyTradeGoods = 0
+PercentWhiteTradeGoods = 27
+PercentGreenTradeGoods = 12
+PercentBlueTradeGoods = 10
+PercentPurpleTradeGoods = 1
+PercentOrangeTradeGoods = 0
+PercentYellowTradeGoods = 0
+
+PercentGreyItems = 0
+PercentWhiteItems = 10
+PercentGreenItems = 30
+PercentBlueItems = 8
+PercentPurpleItems = 2
+PercentOrangeItems = 0
+PercentYellowItems = 0
+
+#MinPrice(Color)    is the minimum price adjustment for items. For example the default is 150, which means 150%. So if an item vendors for 1g it would go to auction for a minimum of 1.5g.
+#MaxPrice(Color)    is the maximum price adjustment for items.
+#MinBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxStack(Color)    is maximum stack size to create for this quality type. A value of zero will disable the maximum stack size for this quality allowing the bot to create stacks (of random size) of items as big as the item type allows.
+
+MinPriceGrey = 100
+MaxPriceGrey = 150
+MinBidPriceGrey = 70
+MaxBidPriceGrey = 100
+MaxStackGrey = 0
+MinPriceWhite = 150
+MaxPriceWhite = 250
+MinBidPriceWhite = 70
+MaxBidPriceWhite = 100
+MaxStackWhite = 0
+MinPriceGreen = 800
+MaxPriceGreen = 1400
+MinBidPriceGreen = 80
+MaxBidPriceGreen = 100
+MaxStackGreen = 0
+MinPriceBlue = 1250
+MaxPriceBlue = 1750
+MinBidPriceBlue = 75
+MaxBidPriceBlue = 100
+MaxStackBlue = 0
+MinPricePurple = 2250
+MaxPricePurple = 4550
+MinBidPricePurple = 80
+MaxBidPricePurple = 100
+MaxStackPurple = 0
+MinPriceOrange = 4250
+MaxPriceOrange = 5550
+MinBidPriceOrange = 80
+MaxBidPriceOrange = 100
+MaxStackOrange = 0
+MinPriceYellow = 5250
+MaxPriceYellow = 6550
+MinBidPriceYellow = 80
+MaxBidPriceYellow = 100
+MaxStackYellow = 0
+
+#These are the multipliers that are applied to the vendor price for an item, that determines if AHBot will buy it or not.
+#1 means AHBot will pay the same as (or less than) a vendor would pay, 2 means up to twice as much, etc.
+
+BuyerPriceGrey = 1
+BuyerPriceWhite = 3
+BuyerPriceGreen = 5
+BuyerPriceBlue = 12
+BuyerPricePurple = 15
+BuyerPriceOrange = 20
+BuyerPriceYellow = 22
+
+#BuyerBiddingInterval is the time (in minutes) between bids.
+#BuyerBidsPerInterval is the number of bids the buyer will make in a cycle
+
+BuyerBiddingInterval = 1
+BuyerBidsPerInterval = 1
+
+
+
+How to use ahcommands from the console (CLI) or in game with GM level 3 players:
+ahbotoptions - will display usage instructions
+ahbotoptions help - will display the list of commands
+
+ahexpire - will expire all the auctions in the requested auction house that were created by AHBot.
+minitems - will set the minimum number of items in the AH before it starts being filled again.
+maxitems - will set the maximum number of items in the AH.
+percentages - will set the percentage of each quality in the AH
+minprice - will set the minimum price multiplier for auctions.
+maxprice - will set the maximum price multiplier for auctions.
+minbidprice - will set the minimum starting bid as a percent of the buyout price for auctions.
+maxbidprice - will set the maximum starting bid as a percent of the buyout price for auctions.
+maxstack - will set the maximum number of items in stacks for auctions. 0 will set the maximum to the maximum for that item type.
+buyerprice - will set the bid price multiplier for auctions.
+biddinginterval - will set the number of minutes between bids on auctions.
+bidsperinterval - will set the number of bids to enter per cycle.
+
+The auction house IDs are:
+2 - Alliance
+6 - Horde
+7 - Neutral
+
+
+AHBot Originally made by Chris K. Currently maintained by Paradox
+Much thanks to Chris K, grether and Dolomit6!
+AHBot Now includes AHBuyer created by Kerbe as a derivative of AHBot, and later modified by Paradox
diff --git a/sql/All/characters_jail.sql b/sql/All/characters_jail.sql
new file mode 100644
index 0000000..1c33c58
--- /dev/null
+++ b/sql/All/characters_jail.sql
@@ -0,0 +1,66 @@
+/*
+MySQL Data Transfer
+Source Host: localhost
+Source Database: characters
+Target Host: localhost
+Target Database: characters
+Date: 25.04.2010 00:00:00
+*/
+DROP TABLE IF EXISTS `jail`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail
+-- ----------------------------
+CREATE TABLE `jail` (
+  `guid` int(11) unsigned NOT NULL COMMENT 'GUID of the jail brother',
+  `char` varchar(13) NOT NULL COMMENT 'Jailed charname',
+  `release` int(11) unsigned NOT NULL COMMENT 'Release time for the char',
+  `amnestietime` int(11) NOT NULL,
+  `reason` varchar(255) NOT NULL COMMENT 'Reason for the jail',
+  `times` int(11) unsigned NOT NULL COMMENT 'How many times this char already was jailed',
+  `gmacc` int(11) unsigned NOT NULL COMMENT 'Used GM acc to jail this char',
+  `gmchar` varchar(13) NOT NULL COMMENT 'Used GM char to jail this char',
+  `lasttime` timestamp NOT NULL default '0000-00-00 00:00:00' on update CURRENT_TIMESTAMP COMMENT 'Last time jailed',
+  `duration` int(11) unsigned NOT NULL default '0' COMMENT 'Duration of the jail',
+  PRIMARY KEY  (`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Jail table for Trinitycore by WarHead Edited by SPGM';
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+DROP TABLE IF EXISTS `jail_conf`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail_conf
+-- ----------------------------
+
+CREATE TABLE `jail_conf` (
+  `id` int(11) NOT NULL auto_increment,
+  `obt` varchar(50) default NULL,
+  `jail_conf` int(11) default NULL,
+  `jail_tele` float default NULL,
+  `help_ger` varchar(255) character set latin1 default '',
+  `help_enq` varchar(255) default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+INSERT INTO `jail_conf` VALUES ('1', 'm_jailconf_max_jails', '3', null, 'Hier legst ihre fest nach wie fielen Jails der Char gelöscht werden \r\nStandart = 3\r\n ', 'How many time the characters can be Jailed before being deleted\r\nDefault = 3');
+INSERT INTO `jail_conf` VALUES ('2', 'm_jailconf_max_duration', '672', null, 'Hier legst ihre fest wie hoch der maximale Jail Time in Stunden \r\nStandart = 672\r\n', 'Here put how high the maximum Jail Time in hours\r\nDefault = 672');
+INSERT INTO `jail_conf` VALUES ('3', 'm_jailconf_min_reason', '25', null, 'Hier legst ihre die minimalen Zeichen fest die als Grund angeben müsst  \r\nStandart = 25\r\n\r\n', 'Here list how many characters are needed as the minimum reason\r\nDefault = 25');
+INSERT INTO `jail_conf` VALUES ('4', 'm_jailconf_warn_player', '1', null, 'Hier legst ihre fest wann der Char gewarnt wirt  bevor er gelöscht wird \r\nStandart = 1\r\n', 'How many time to warn the player before jailing them\r\nDefault = 1');
+INSERT INTO `jail_conf` VALUES ('5', 'm_jailconf_amnestie', '180', null, 'Hier legst ihre in Tagen fest wann der Jail Status  auf 0 zurückgesetzt wird   \r\nStandart = 180 Tage (das entspricht ca. ½ Jahr)  \r\n                     0  Tage (Aus)\r\n', 'This is how many in days when the Jail is status is set to 0\r\nStandard = 180 days (approximately ½ year)\r\n                     0 days (off)');
+INSERT INTO `jail_conf` VALUES ('6', 'm_jailconf_ally_x', null, '31.7282', 'Teleport Alliance  X Achse \r\nStandart = 31,7282\r\n', 'Teleport Alliance  X Axis \r\nStandart = 31,7282\r\n');
+INSERT INTO `jail_conf` VALUES ('7', 'm_jailconf_ally_y', null, '135.794', 'Teleport Alliance  Y Achse \r\nStandart = 135,794\r\n', 'Teleport Alliance  Y Axis \r\nStandart = 135,794\r\n');
+INSERT INTO `jail_conf` VALUES ('8', 'm_jailconf_ally_z', null, '-40.0508', 'Teleport Alliance  Z Achse \r\nStandart = -40,0508', 'Teleport Alliance  Z Axis \r\nStandart = -40,0508');
+INSERT INTO `jail_conf` VALUES ('9', 'm_jailconf_ally_o', null, '4.73516', 'Teleport Alliance  blickrichtung\r\nStandart = 4,73516', 'Teleport Alliance  Orientation\r\nStandart = 4,73516');
+INSERT INTO `jail_conf` VALUES ('10', 'm_jailconf_ally_m', '35', null, 'Teleport Alliance  Mape\r\nStandart = 35', 'Teleport Alliance  Map\r\nStandart = 35');
+INSERT INTO `jail_conf` VALUES ('11', 'm_jailconf_horde_x', null, '2179.85', 'Teleport Horde  X Achse \r\nStandart = \r\n', 'Teleport Horde  X Axis \r\nStandart = \r\n');
+INSERT INTO `jail_conf` VALUES ('12', 'm_jailconf_horde_y', null, '-4763.96', 'Teleport Horde  Y Achse \r\nStandart = -4763,96', 'Teleport Horde  Y Axis \r\nStandart = -4763,96');
+INSERT INTO `jail_conf` VALUES ('13', 'm_jailconf_horde_z', null, '54.911', 'Teleport Horde  Z Achse \r\nStandart = 54,911', 'Teleport Horde  Z Axis \r\nStandart = 54,911');
+INSERT INTO `jail_conf` VALUES ('14', 'm_jailconf_horde_o', null, '4.44216', 'Teleport  Horde  blickrichtung\r\nStandart = 4,44216', 'Teleport  Horde  Orientation\r\nStandart = 4,44216');
+INSERT INTO `jail_conf` VALUES ('15', 'm_jailconf_horde_m', '1', null, 'Teleport Horde  Mape\r\nStandart = 1', 'eleport Horde  Map\r\nStandart = 1');
+INSERT INTO `jail_conf` VALUES ('16', 'm_jailconf_ban', '0', null, 'Nach wie vielen Jail soll der  Account Gebant werden\r\nStandart = 0  (aus)\r\n', 'After how many jails the account will be Banned\r\nDefault = 0 (off)');
+INSERT INTO `jail_conf` VALUES ('17', 'm_jailconf_radius', '10', null, 'Legt den Bewegung Radius in Metern waren des Jails fest\r\nStandart = 10\r\n', 'Sets the range of motion in meters of the jail\r\nDefault = 10'');
diff --git a/sql/All/world-example_gmisland.sql b/sql/All/world-example_gmisland.sql
new file mode 100644
index 0000000..022a9c2
--- /dev/null
+++ b/sql/All/world-example_gmisland.sql
@@ -0,0 +1,117 @@
+-- ----------------------------
+-- Table structure for `city_capture_bosses`
+-- ----------------------------
+DROP TABLE IF EXISTS `city_capture_bosses`;
+CREATE TABLE `city_capture_bosses` (
+  `city_id` int(11) NOT NULL default '0',
+  `boss_entry_A` int(11) default NULL,
+  `boss_entry_H` int(11) default NULL,
+  `spawner_entry` int(11) default NULL,
+  `spawn_timer` int(11) default NULL,
+  PRIMARY KEY  (`city_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of city_capture_bosses
+-- ----------------------------
+INSERT INTO `city_capture_bosses` VALUES ('1', '150001', '150002', '150000', '1');
+
+-- ----------------------------
+-- Table structure for `city_capture_cities`
+-- ----------------------------
+DROP TABLE IF EXISTS `city_capture_cities`;
+CREATE TABLE `city_capture_cities` (
+  `id` int(11) NOT NULL default '0',
+  `minlevel` int(11) default NULL,
+  `maxlevel` int(11) default NULL,
+  `name` text,
+  `controlled` tinyint(4) default NULL,
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of city_capture_cities
+-- ----------------------------
+INSERT INTO `city_capture_cities` VALUES ('1', '1', '80', 'GM Island', '1');
+
+-- ----------------------------
+-- Table structure for `city_capture_creatures`
+-- ----------------------------
+DROP TABLE IF EXISTS `city_capture_creatures`;
+CREATE TABLE `city_capture_creatures` (
+  `city_id` int(11) default NULL,
+  `entry` int(11) NOT NULL default '0',
+  `faction_A` int(11) default NULL,
+  `faction_H` int(11) default NULL,
+  PRIMARY KEY  (`entry`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of city_capture_creatures
+-- ----------------------------
+INSERT INTO `city_capture_creatures` VALUES ('1', '150003', '210', '83');
+INSERT INTO `city_capture_creatures` VALUES ('1', '150004', '210', '83');
+
+-- ----------------------------
+-- Table structure for `city_capture_ports`
+-- ----------------------------
+DROP TABLE IF EXISTS `city_capture_ports`;
+CREATE TABLE `city_capture_ports` (
+  `city_id` int(11) NOT NULL default '0',
+  `side` int(11) NOT NULL default '0',
+  `x` float default NULL,
+  `y` float default NULL,
+  `z` float default NULL,
+  `o` float default NULL,
+  `map` int(11) default NULL,
+  PRIMARY KEY  (`city_id`,`side`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of city_capture_ports
+-- ----------------------------
+INSERT INTO `city_capture_ports` VALUES ('1', '0', '16255.1', '16289.2', '21', '3.26', '1');
+INSERT INTO `city_capture_ports` VALUES ('1', '1', '16221.3', '16246.5', '12', '1.47', '1');
+
+-- ----------------------------
+-- Table structure for `city_capture_progress`
+-- ----------------------------
+DROP TABLE IF EXISTS `city_capture_progress`;
+CREATE TABLE `city_capture_progress` (
+  `city_id` int(11) NOT NULL default '0',
+  `time` int(11) default NULL,
+  PRIMARY KEY  (`city_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of city_capture_progress
+-- ----------------------------
+INSERT INTO `city_capture_progress` VALUES ('1', '1274630992');
+INSERT INTO `city_capture_progress` VALUES ('5', '1274628002');
+INSERT INTO `city_capture_progress` VALUES ('10', '1274628031');
+INSERT INTO `city_capture_progress` VALUES ('7', '1274628034');
+INSERT INTO `city_capture_progress` VALUES ('12', '1274628356');
+INSERT INTO `city_capture_progress` VALUES ('4', '1274628349');
+INSERT INTO `city_capture_progress` VALUES ('9', '1274628352');
+INSERT INTO `city_capture_progress` VALUES ('2', '1274628366');
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150000, 0, 0, 0, 0, 0, 328, 0, 328, 0, 'CQ: Boss Spawning Bunny GM ISLAND', '', '', 0, 82, 82, 0, 35, 35, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 2000, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 43, 1, 0, 0, 130, 'city_conquest_spawner', 0);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150001, 0, 0, 0, 0, 0, 19543, 0, 19543, 0, 'Alliance Commander', NULL, NULL, 0, 52, 52, 0, 210, 210, 0, 1.125, 1.14286, 1, 0, 571, 571, 0, 137, 1, 1400, 1900, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'city_conquest_boss', 0);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150002, 0, 0, 0, 0, 0, 1735, 0, 1735, 0, 'Horde Commander', NULL, NULL, 0, 80, 80, 0, 29, 29, 2, 1.1, 1.14286, 1, 1, 953, 1089, 0, 245, 1, 2000, 0, 2, 4608, 0, 0, 0, 0, 0, 0, 58.872, 80.949, 100, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'EventAI', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1115, 0, 0, 'city_conquest_boss', 0);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150003, 0, 0, 0, 0, 0, 103, 0, 103, 0, 'GM Island Creature 1', NULL, NULL, 0, 40, 50, 0, 83, 83, 0, 1.125, 1.14286, 1, 0, 19, 23, 0, 5, 1, 1400, 1900, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'city_conquest_generic', 0);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150004, 0, 0, 0, 0, 0, 146, 0, 146, 0, 'GM Island Ghost 1', NULL, NULL, 0, 15, 15, 0, 83, 83, 0, 0.99, 1.14286, 1, 0, 35, 40, 0, 9, 1, 1860, 2046, 2, 0, 0, 0, 0, 0, 0, 0, 24.552, 33.759, 100, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 57, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8388624, 2, 'city_conquest_generic', 0);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES (150005, 0, 0, 0, 0, 0, 26501, 0, 26501, 0, 'City Conquest', 'Portal & Manager', 'Interact', 0, 1, 1, 0, 35, 35, 1, 1, 1.14286, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'city_conquest_portal', 0);
+
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150000, 1, 1, 1, 0, 0, 16224.1, 16279.3, 20.885, 4.52855, 300, 0, 0, 4518, 4169, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150003, 1, 1, 1, 0, 0, 16225.4, 16271.1, 12.9997, 4.54034, 300, 0, 0, 1226, 1283, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150003, 1, 1, 1, 0, 0, 16230.3, 16295.1, 13.1757, 2.63968, 300, 0, 0, 1321, 1381, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150003, 1, 1, 1, 0, 0, 16235.2, 16301.1, 13.1757, 5.10582, 300, 0, 0, 1226, 1283, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150003, 1, 1, 1, 0, 0, 16226.1, 16317.2, 20.8459, 4.85056, 300, 0, 0, 1772, 1807, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150004, 1, 1, 1, 0, 0, 16220.7, 16271.6, 12.9754, 4.63851, 300, 0, 0, 301, 326, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150004, 1, 1, 1, 0, 0, 16224.1, 16284.6, 13.1756, 4.58746, 300, 0, 0, 301, 326, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150004, 1, 1, 1, 0, 0, 16221.3, 16298.9, 13.1756, 5.14117, 300, 0, 0, 301, 326, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150004, 1, 1, 1, 0, 0, 16234.9, 16299.6, 20.8456, 1.4812, 300, 0, 0, 301, 326, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150004, 1, 1, 1, 0, 0, 16217.7, 16284.2, 20.8895, 4.45001, 300, 0, 0, 301, 326, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150005, 1, 1, 1, 0, 0, 16228.4, 16244.6, 12.2895, 2.02771, 300, 0, 0, 41, 60, 0, 0);
+INSERT INTO `creature` (`id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES (150005, 530, 1, 1, 0, 0, -2047.61, 6658.8, 13.0538, 0.698243, 300, 0, 0, 41, 60, 0, 0);
+
diff --git a/sql/All/world_command_Deutsch.sql b/sql/All/world_command_Deutsch.sql
new file mode 100644
index 0000000..1a2db0b
--- /dev/null
+++ b/sql/All/world_command_Deutsch.sql
@@ -0,0 +1,7 @@
+/* World Command Deutsch */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail Charakter Stunden Grund\nBuchtet den \'Charakter\' für \'Stunden\' aus dem \'Grund\' ein.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nZeigt dir deinen Knast-Status an.'),
+('unjail', 1, 'Syntax: .unjail Charakter\nEntläßt den \'Charakter\' aus dem Knast.'),
+('jailreload', 3, 'Syntax: .jailreload\nLädt die Jail-Konfiguration neu.');
diff --git a/sql/All/world_command_English.sql b/sql/All/world_command_English.sql
new file mode 100644
index 0000000..0176922
--- /dev/null
+++ b/sql/All/world_command_English.sql
@@ -0,0 +1,7 @@
+/* World Command English */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail character hours reason\nJailed the \'character\' for \'hours\' with the \'reason\'.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nShows your jail status.'),
+('unjail', 1, 'Syntax: .unjail character\nRealeases the \'character\' out of the jail.'),
+('jailreload', 3, 'Syntax: .jailreload\nLoads the jail config new.');
diff --git a/sql/All/world_command_Francais.sql b/sql/All/world_command_Francais.sql
new file mode 100644
index 0000000..237f30d
--- /dev/null
+++ b/sql/All/world_command_Francais.sql
@@ -0,0 +1,7 @@
+/* World Command Francais */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntaxe: .jail #personage #heures #raison\nEmprisonner un \'personnage\' pendant \'heures\' pour la \'raison\'.'),
+('jailinfo', 0, 'Syntaxe: .jailinfo\nVoir le statut de vos emprisonnements.'),
+('unjail', 1, 'Syntaxe: .unjail #personnages\nLibérer le \'personnage\' de la prison.'),
+('jailreload', 3, 'Syntaxe: .jailreload\nRecharger la configuration du Jail.');
diff --git a/sql/All/world_creature_template.sql b/sql/All/world_creature_template.sql
new file mode 100644
index 0000000..765b402
--- /dev/null
+++ b/sql/All/world_creature_template.sql
@@ -0,0 +1,5 @@
+/**
+* Records Guildhouse Keeper
+*/
+DELETE FROM creature_template WHERE `entry`=13;
+INSERT INTO `creature_template` VALUES ('13', '0', '0', '0', '0', '0', '26789', '0', '0', '0', 'Beltez', 'Guildhouse Keeper', '', '0', '80', '80', '0', '35', '35', '1', '1.48', '1.14286', '0.75', '0', '181', '189', '0', '158', '1', '1400', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', 'guildmaster', '0');
diff --git a/sql/All/world_guildhouses.sql b/sql/All/world_guildhouses.sql
new file mode 100644
index 0000000..1c5a5d5
--- /dev/null
+++ b/sql/All/world_guildhouses.sql
@@ -0,0 +1,54 @@
+-- ----------------------------
+-- Table structure for guildhouses
+-- ----------------------------
+CREATE TABLE `guildhouses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `guildhouses` VALUES ('1', '0', '16222', '16266', '14.2', '1', 'GM Island');
+INSERT INTO `guildhouses` VALUES ('2', '0', '-10711', '2483', '8', '1', 'Tauren village at Veiled Sea (Silithus)');
+INSERT INTO `guildhouses` VALUES ('3', '0', '-8323', '-343', '146', '0', 'Fishing outside an Northshire Abbey (Elwynn Forest');
+INSERT INTO `guildhouses` VALUES ('4', '0', '7368', '-1560', '163', '1', 'Troll Village in mountains (Darkshore)');
+INSERT INTO `guildhouses` VALUES ('5', '0', '-4151', '-1400', '198', '0', 'Dwarven village outside Ironforge (Wetlands)');
+INSERT INTO `guildhouses` VALUES ('6', '0', '-1840', '-4233', '2.14', '0', 'Dwarven village (Arathi Highlands, Forbidding Sea)');
+INSERT INTO `guildhouses` VALUES ('8', '0', '-723', '-1076', '179', '1', 'Tauren camp (Mulgore, Red Rock)');
+INSERT INTO `guildhouses` VALUES ('9', '0', '-206', '1666', '80', '0', 'Shadowfang Keep an outside instance (Silverpine Forest)');
+INSERT INTO `guildhouses` VALUES ('10', '0', '-6374', '1262', '7', '0', 'Harbor house outside Stormwind (Elwynn Forest)');
+INSERT INTO `guildhouses` VALUES ('11', '0', '-8640', '580', '96', '0', 'Empty jail between canals (Stormwind) DELETE');
+INSERT INTO `guildhouses` VALUES ('12', '0', '-4844', '-1066', '502', '0', 'Old Ironforge');
+INSERT INTO `guildhouses` VALUES ('13', '0', '-4863', '-1658', '503.5', '0', 'Ironforge Airport');
+INSERT INTO `guildhouses` VALUES ('14', '0', '1146', '-165', '313', '37', 'Azshara Crater instance (Alliance entrance)');
+INSERT INTO `guildhouses` VALUES ('15', '0', '-123', '858', '298', '37', 'Azshara Crater instance (Horde entrance)');
+INSERT INTO `guildhouses` VALUES ('16', '0', '4303', '-2760', '16.8', '0', 'Quel\'Thalas Tower');
+INSERT INTO `guildhouses` VALUES ('17', '0', '-6161', '-790', '423', '0', 'Crashed gnome airplane (between Dun Morogh and Searing Gorge)');
+INSERT INTO `guildhouses` VALUES ('18', '0', '-11790', '-1640', '54.7', '0', 'Zul\'Gurub an outside instance (Stranglethorn Vale)');
+INSERT INTO `guildhouses` VALUES ('19', '0', '-11805', '-4754', '6', '1', 'Goblin village (Tanaris, South Seas)');
+INSERT INTO `guildhouses` VALUES ('20', '0', '-9296', '670', '132', '0', 'Villains camp outside an Stormwind (Elwynn Forest)');
+INSERT INTO `guildhouses` VALUES ('21', '0', '3414', '-3380', '142.2', '0', 'Stratholm an outside instance');
+INSERT INTO `guildhouses` VALUES ('22', '0', '4654', '-3772', '944', '1', 'Kalimdor Hyjal (Aka World Tree)');
+INSERT INTO `guildhouses` VALUES ('23', '0', '2176', '-4766', '55', '1', 'The Ring of Valor (Aka. Orgrimmar Arena)');
+INSERT INTO `guildhouses` VALUES ('24', '0', '1951.512085', '1530.475586', '247.288147', '1', 'Stonetalon Logging Camp');
+INSERT INTO `guildhouses` VALUES ('25', '0', '2813.660645', '2248.552979', '215.524643', '1', 'Stonetalon Ruins');
+INSERT INTO `guildhouses` VALUES ('28', '0', '9725.27', '-21.43', '20.03', '1', 'Teldrassil Furbold camp');
+INSERT INTO `guildhouses` VALUES ('29', '0', '-3855', '-3479', '579', '0', 'Wetlands mountain camp');
+INSERT INTO `guildhouses` VALUES ('30', '0', '-5362', '-2540', '485', '0', 'Ortell\'s Hideout');
+INSERT INTO `guildhouses` VALUES ('31', '0', '-12865', '-1396', '115', '0', 'Stranglethorn Secret Cave');
+INSERT INTO `guildhouses` VALUES ('32', '0', '-11073', '-1956', '39', '0', 'Karazhan Smiley');
+INSERT INTO `guildhouses` VALUES ('33', '0', '-11084', '-1801', '53', '0', 'Well of the Forgotten (Aka. Karazhan Crypt or Lower Karazhan)');
+INSERT INTO `guildhouses` VALUES ('34', '0', '1683.235474', '286.458801', '-45.451775', '0', 'Undercity Top Tier');
+INSERT INTO `guildhouses` VALUES ('35', '0', '-8521.3', '599.5', '101.399338', '0', 'Stormwind Cut-Throat Alley');
+INSERT INTO `guildhouses` VALUES ('36', '0', '-5933', '452', '509', '0', 'Forgotten gnome camp');
+INSERT INTO `guildhouses` VALUES ('37', '0', '-920.231323', '7096.489258', '170.35289', '530', 'Outland Nagrand : Newton\'s Remains');
+INSERT INTO `guildhouses` VALUES ('38', '0', '-2140.501953', '9142.6875', '137.041855', '530', 'Outland Nagrand : Tomb');
+INSERT INTO `guildhouses` VALUES ('39', '0', '-483.401794', '7461.944824', '186.120987', '530', 'Outland Nagrand: Challe\'s Home for Little Tykes');
+INSERT INTO `guildhouses` VALUES ('40', '0', '2387.753906', '3191.757324', '152.669388', '530', 'Outland Netherstorm: Nova\'s Shrine');
diff --git a/sql/All/world_npc_buff.sql b/sql/All/world_npc_buff.sql
new file mode 100644
index 0000000..ff31af9
--- /dev/null
+++ b/sql/All/world_npc_buff.sql
@@ -0,0 +1,63 @@
+DROP TABLE IF EXISTS `npc_buff_spells`;
+
+CREATE TABLE `npc_buff_spells` (
+  `spell_id` int(5) NOT NULL default '0' COMMENT 'Spell entry number',
+  `cat_number` int(5) NOT NULL default '0' COMMENT '0-small buff 1-great buff 2-gm buff 3-player tools',
+  `cost` int(10) NOT NULL default '0' COMMENT 'cost amount in copper',
+  `name` text COMMENT 'Name of spell',
+  PRIMARY KEY  (`spell_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `npc_buff_spells` */
+
+INSERT INTO `npc_buff_spells` (`spell_id`, `cat_number`, `cost`, `name`) VALUES
+-- Small Buff
+(48469,1001,10000,"Mark of the Wild"),
+(53307,1002,10000,"Thorns"),
+(43017,1003,10000,"Amplify Magic"),
+(42995,1004,10000,"Arcane Intellect"),
+(61024,1005,10000,"Dalaran Intellect"),
+(43015,1006,10000,"Dampen Magic"),
+(20217,1007,10000,"Blessing of Kings"),
+(48932,1008,10000,"Blessing of Might"),
+(48936,1009,10000,"Blessing of Wisdom"),
+(48072,1010,10000,"Divine Spirit"),
+(48161,1011,10000,"Power Word: Fortitude"),
+(48169,1012,10000,"Shadow Protection"),
+-- Great Buff
+(48470,2001,100000,"Gift of the Wild"),
+(43002,2002,100000,"Arcane Brilliance"),
+(61316,2003,100000,"Dalaran Brilliance"),
+(25898,2004,100000,"Greater Blessing of Kings"),
+(48934,2005,100000,"Greater Blessing of Might"),
+(25899,2006,100000,"Greater Blessing of Sanctuary"),
+(48938,2007,100000,"Greater Blessing of Wisdom"),
+(48162,2008,100000,"Prayer of Fortitude"),
+(48170,2009,100000,"Prayer of Shadow Protection"),
+(48074,2010,100000,"Prayer of Spirit"),
+-- GM Buff
+(17013,3001,0,"Agamaggan's Agility"),
+(16612,3002,0,"Agamaggan's Strength"),
+(58453,3003,0,"Armor Magic"),
+(34106,3004,0,"Armor Penetration"),
+(25661,3005,0,"Increased Stamina"),
+(16610,3006,0,"Razorhide"),
+(10767,3007,0,"Rising Spirit"),
+(16618,3008,0,"Spirit of the Wind"),
+(7764,3009,0,"Wisdom of Agamaggan"),
+-- Player Tools
+(46642,4001,0,"Give me Gold"),
+(24827,4002,0,"Give me Soul Shards"),
+(38588,4003,0,"Heal me please"),
+(53251,4004,0,"Heal me and party members Please"),
+(42956,4005,0,"Conjure Refreshment"),
+(42985,4006,0,"Conjure Mana Gem");
+
+REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+('70000', '0', '0', '0', '0', '0', '18', '0', '18', '0', 'LordPsyan', 'Buffs master', '', '0', '59', '61', '0', '35', '35', '1', '1.48', '1.14286', '0.0', '0', '655.0', '663.0', '0', '158', '1.0', '1500', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0.0', '0.0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1.0', '1.0', '1.0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', 'npc_buff', '1');
+REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+('70001', '0', '0', '0', '0', '0', '18', '0', '18', '0', 'Cyon', 'Profession master', '', '0', '59', '61', '0', '35', '35', '1', '1.48', '1.14286', '0.0', '0', '655.0', '663.0', '0', '158', '1.0', '1500', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0.0', '0.0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1.0', '1.0', '1.0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', 'professionnpc', '1');
+
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100002, 'Choose your Buff Type.'),
+   (100003, 'Choose your Buff.');
\ No newline at end of file
diff --git a/sql/All/world_trinity_string.sql b/sql/All/world_trinity_string.sql
new file mode 100644
index 0000000..d5cc99c
--- /dev/null
+++ b/sql/All/world_trinity_string.sql
@@ -0,0 +1,41 @@
+/* World trinity_string */
+SET NAMES 'utf8';
+DELETE FROM trinity_string WHERE `entry` IN (950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983);
+
+INSERT INTO `trinity_string` VALUES 
+('950', 'You are jailed by \'%s\' for %u hour(s)!', null, 'Vous tes emprisonn par \'%s\' pour %u heures!', 'Du wurdest von \'%s\' für %u Stunde(n) eingebuchtet!', null, null, null, null, null),
+('951', '\'%s\' wrote this as reason: \'%s\'', null, '%s a crit ceci comme tant la raison de votre emprisonnement: %s.', '\'%s\' gab dies als Grund an: \'%s\'', null, null, null, null, null),
+('952', '\'%s\' was jailed by you for %u hour(s).', null, 'Vous avez emprisonn %s pour %u heures!', '\'%s\' wurde von dir für %u Stunde(n) eingebuchtet.', null, null, null, null, null),
+('953', 'You was released out of the jail by %s.', null, 'Vous avez t liber de la prison par %s.', '\'%s\' hat dich aus dem Knast entlassen.', null, null, null, null, null),
+('954', 'You have released %s out of the jail.', null, 'Vous avez liber \'%s\' de la prison.', 'Du hast \'%s\' aus dem Knast geholt.', null, null, null, null, null),
+('955', 'No reason given or reason is < %u chars!', null, 'Aucune raison d\\\'emprisonnement donne ou la raison est < %u personnages.', 'Du hast keinen Grund angegeben, oder der Grund ist < %u Zeichen!', null, null, null, null, null),
+('956', 'No name given!', null, 'Aucun nom donn!', 'Du hast keinen Namen angegeben!', null, null, null, null, null),
+('957', 'No time given!', null, 'Aucun temps donn!', 'Du hast keine Zeit angegeben!', null, null, null, null, null),
+('958', 'The jailtime must be between 1 and %u hours!', null, 'Le temps d\\\'emprisonnement est situ entre 1 et %u heures!', 'Die Jail-Zeit muss zwischen 1 und %u Std. liegen!', null, null, null, null, null),
+('959', 'The character \'%s\' is not jailed!', null, '\'%s\' n\\\'est pas emprisonn!', 'Der Charakter \'%s\' ist Überhaupt nicht im Knast!', null, null, null, null, null),
+('960', 'Command forbidden for jailed characters!', null, 'Commandes interdites pour les personnages emprisons!', 'Sorry, aber das d?rfen Gefangene nicht!', null, null, null, null, null),
+('961', 'You have %u hour(s) left in the jail.', null, 'Vous avez %u heures  attendre avant de quitter la prison.', 'Du musst noch %u Stunde(n) absitzen.', null, null, null, null, null),
+('962', 'You have %u minute(s) left in the jail.', null, 'Vous avez %u minutes attendre avant de quitter la prison.', 'Du musst noch %u Minute(n) absitzen.', null, null, null, null, null),
+('963', 'You\'re a free like a bird! ;-)', null, 'Vous tes libre.', 'Du bist frei wie ein Vogel! ;-)', null, null, null, null, null),
+('964', '%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: \'%s\'', null, '%s a t librde prison, il avait t emprisonn pour %u et a t libr au aprs %u minutes. Il avait t emprisonn par %s, pour la raison suivante: %s', '\'%s\' war bis jetzt %u mal im Knast, und hat noch %u Minute(n) abzusitzen.\n Zuletzt eingebuchtet von: \'%s\'\nLetzter Grund: %s', null, null, null, null, null),
+('965', '\'%s\' was never jailed.', null, '\'%s\' n\\\'a jamais t emprisonn.', '\'%s\' hat eine weiße Weste.', null, null, null, null, null),
+('966', 'You can\'t jail yourself!', null, 'Vous ne pouvez pas vous emprisonner vous-m me!', 'Du kannst dich nicht selber einbuchten!', null, null, null, null, null),
+('967', 'You can\'t unjail yourself!', null, 'Vous ne pouvez pas vous librer vous m me!', 'So weit kommt es noch, daß Knastbruder sich selber befreien! :-(', null, null, null, null, null),
+('968', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your character will be deleted\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous étiez déjà %u fois en prison en %u fois, votre personnage supprimé\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du warst schon %u mal in Knast beim %u mal wird dein Charakter gelöscht\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('969', 'The character \'', null, 'Le personnage ', 'Der Charakter \'', null, null, null, null, null),
+('970', '\' was jailed for ', null, ' a t emprisonn pour ', '\' wurde für ', null, null, null, null, null),
+('971', ' hour(s) by the GM character \'', null, ' heure(s) par le MJ ', ' Stunde(n) von dem GM-Charakter \'', null, null, null, null, null),
+('972', '\'. The reason is: ', null, '. La raison est: ', '\' eingebuchtet. Der Grund ist: ', null, null, null, null, null),
+('973', 'The jail configuration was reloaded.', null, 'La configuration de jail a t recharge.', 'Die Gefängnis-Konfiguration wurde neu geladen.', null, null, null, null, null),
+('974', '>> Trinity Jail config loaded.', null, '>> Configuration du jail charge.', '>> Gefängnis-Konfiguration geladen.', null, null, null, null, null),
+('975', 'Can\'t load jail config! Table empty or missed! Use characters_jail.sql!', null, 'Impossible de charger la configuration du jail! Table vide ou innexistante! Appliquez characters_jail.sql!', 'Fehler beim laden der Gef?ngnis-Konfiguration! Der Table \'jail_conf\' ist leer oder nicht vorhanden! Nutze die \'characters_jail.sql\'!', null, null, null, null, null),
+('976', 'Set all jail config settings to default...', null, 'Placez tous les param tres de configuration de prison par d faut.', 'Setze die Konfiguration des Gef?ngnisses auf Standardwerte...', null, null, null, null, null),
+('977', 'The Character \'%s\'  is jailed and teleportet into the jail.', null, 'Le personnage \'%s\'  est emprisonn et t leport dans la prison.', 'Der Charakter \'%s\'  ist ein Knastbruder und wird in den Knast teleportiert.', null, null, null, null, null),
+('978', 'The Character \'%s\'  was released out of the jail.', null, 'Le personnage %s  est liber  de prison.', 'Der Charakter \'%s\'  wurde aus dem Knast entlassen.', null, null, null, null, null),
+('979', 'A character with this name doesn\'t exists!', null, 'Il n\'y a aucun personnage portant ce nom.', 'Ein Charakter mit diesem Namen gibt es nicht!', null, null, null, null, null),
+('980', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your account  will be banned!\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous avez %u fois en prison en %u fois votre compte sera banni\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du hast %u mal in Knast beim %u mal wird dein Account gebannt\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('981', 'Max. jailtimes reached!', null, 'Nombre maximum d\'Jails atteint!', 'Maximale Anzahl an Jails erreicht!', null, null, null, null, null),
+('982', 'Robotron', null, 'Robotron', 'Robotron', null, null, null, null, null),
+('983', 'Your Jail status was reset to 0 ', null, 'Votre statut a été Jail à 0 ', 'Dein Jail status wurde auf 0 zurück gesatzt', null, null, null, null, null);
+
+
diff --git a/sql/FlamingLegion.net/auth_AIO.sql b/sql/FlamingLegion.net/auth_AIO.sql
new file mode 100644
index 0000000..888f643
--- /dev/null
+++ b/sql/FlamingLegion.net/auth_AIO.sql
@@ -0,0 +1,11 @@
+CREATE TABLE `hacked` (
+ `charname` CHAR( 50) NOT NULL 
+);
+
+CREATE TABLE `lagreports` (
+ `account` CHAR( 50) NOT NULL 
+);
+
+CREATE TABLE `vipek2` (
+ `account` CHAR( 50) NOT NULL 
+);
\ No newline at end of file
diff --git a/sql/FlamingLegion.net/characters_AIO.sql b/sql/FlamingLegion.net/characters_AIO.sql
new file mode 100644
index 0000000..94d0708
--- /dev/null
+++ b/sql/FlamingLegion.net/characters_AIO.sql
@@ -0,0 +1 @@
+REPLACE INTO `mail` (`id`, `messageType`, `stationery`, `mailTemplateId`, `sender`, `receiver`, `subject`, `body`, `has_items`, `expire_time`, `deliver_time`, `money`, `cod`, `checked`) VALUES (60003, 0, 41, 0, 0, 0, 'Money For You!', NULL, 0, 0, 0, 4294967295, 0, 1);
diff --git a/sql/FlamingLegion.net/world_AIO.sql b/sql/FlamingLegion.net/world_AIO.sql
new file mode 100644
index 0000000..896058d
--- /dev/null
+++ b/sql/FlamingLegion.net/world_AIO.sql
@@ -0,0 +1,27 @@
+-- Updates
+-- WARNING! It's changes official blizz data!
+UPDATE `creature_template` SET `faction_A`=35, `faction_H`=35 WHERE `entry` IN(28474, 914, 23128, 17204, 5115, 4584, 16655, 28958, 4090, 23534);
+
+-- Inserts
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80000, 'Sorry, you are not VIP member.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80001, 'Welcome Dear VIP.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80006, 'Your skills are set to max.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80007, 'It\'s Time To choose!', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80010, 'Donation help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80011, 'Normal help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80012, 'Ingame help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80013, 'You Don\'t have resurrection sickness!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80014, 'You Don\'t have a pet!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`) VALUES (80016, 'Welcome! My Name is AIO. What can I help for you? Please choose one menu. Do not forget this script is made by Blue from the wowemuf.org', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (998, '|cffff0000<Announcer>: Join Warsong Guilch!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (999, '|cffff0000<Announcer>: Join Wintergrasp!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (997, '|cffff0000<Announcer>: Join Arathi Basin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (996, '|cffff0000<Announcer>: Join Eye of the Storm!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (995, '|cffff0000<Announcer>: Join Random Battleground!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (994, '|cffff0000<Announcer>: Join Arena 2v2!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (993, '|cffff0000<Announcer>: Join Arena 3v3!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (992, '|cffff0000<Announcer>: Join Arena 5v5!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (991, '|cffff0000<Announcer>: Join Alterac Valley!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (990, '|cffff0000<Announcer>: Join Strand of the Ancients!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
diff --git a/sql/Wintergrasp_world.sql b/sql/Wintergrasp_world.sql
new file mode 100644
index 0000000..b3b3129
--- /dev/null
+++ b/sql/Wintergrasp_world.sql
@@ -0,0 +1,134 @@
+/*NOTE! Included Cyrillic Fonts - open it in UTF8 coding*/
+
+SET NAMES 'utf8';
+
+DELETE FROM `trinity_string` WHERE entry IN (756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,780,781,782,783);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+('756', 'Battle begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð½Ð°ÑÐ°Ð»Ð°ÑÑ'),
+('757', '%s has successfully defended the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s ÑÑÐ¿ÐµÑÐ½Ð¾ Ð·Ð°ÑÐ¸ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ!'),
+('758', '%s has taken over the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð·Ð°ÑÐ²Ð°ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ'),
+('759', 'The %s siege workshop has been damaged by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('760', 'The %s siege workshop has been destroyed by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('761', 'The %s tower has been damaged!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð°'),
+('762', 'The %s tower has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ ÑÐ½Ð¸ÑÑÐ¾Ð¶ÐµÐ½Ð°!'),
+('763', 'Wintergrasp fortress is under attack!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('764', 'Wintergrasp is now under the control of the %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('765', 'Wintergrasp timer set to %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('766', 'Wintergrasp battle started.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('767', 'Wintergrasp battle finished.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('768', 'Wintergrasp info: %s controlled. Timer: %s. Wartime: %s. Number of Players: (Horde: %u, Alliance: %u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('769', 'Wintergrasp outdoorPvP is disabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('770', 'Wintergrasp outdoorPvP is enabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('771', 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 1: ÐÐ°Ð¿ÑÐ°Ð»'),
+('772', 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 2: ÐÐµÐ¹ÑÐµÐ½Ð°Ð½Ñ'),
+('780', '30 minutes left before the  Battle of Wintergrasp begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 30 Ð¼Ð¸Ð½ÑÑ!'),
+('781', '10 minutes left before the  Battle of Wintergrasp begins! Portal from Dalaran will work in 5 minutes.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 10 Ð¼Ð¸Ð½ÑÑ! ÐÐ¾ÑÑÐ°Ð» Ñ ÐÐ°Ð»Ð°ÑÐ°Ð½Ð° Ð½Ð°ÑÐ½ÐµÑ ÑÐ¾Ð±Ð¾ÑÑ ÑÐµÑÐµÐ· 5 Ð¼Ð¸Ð½ÑÑ.'),
+('782', 'The battle for Wintergrasp  has stopped! Not enough defenders. Wintergrasp Fortress remains  Attackers.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ¾Ð². ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¿ÐµÑÐµÑÐ¾Ð´Ð¸Ñ Ð°ÑÐ°ÐºÑÑÑÐµÐ¹  ÑÑÐ¾ÑÐ¾Ð½Ðµ.'),
+('783', 'The battle for Wintergrasp  has stopped! Not enough attackers. Wintergrasp Fortress remains  Defenders.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð½Ð°Ð¿Ð°Ð´Ð°ÑÑÐ¸Ñ. ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¾ÑÑÐ°ÐµÑÑÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ°Ð¼.');
+
+DELETE FROM `command` WHERE name IN ('wg','wg enable','wg start','wg status','wg stop','wg switch','wg timer');
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('wg', '3', 'Syntax: .wg $subcommand.'),
+('wg enable', '3', 'Syntax: .wg enable [on/off] Enable/Disable Wintergrasp outdoorPvP.'),
+('wg start', '3', 'Syntax: .wg start\r\nForce Wintergrasp battle start.'),
+('wg status', '3', 'Syntax: .wg status\r\nWintergrasp info, defender, timer, wartime.'),
+('wg stop', '3', 'Syntax: .wg stop\r\nForce Wintergrasp battle stop (No rewards).'),
+('wg switch', '3', 'Syntax: .wg switch\r\nSwitchs Wintergrasp defender team.'),
+('wg timer', '3', 'Syntax: .wg timer $minutes\r\nChange the current timer. Min value = 1, Max value 60 (Wartime), 1440 (Not Wartime)');
+
+/* WG scriptname */
+DELETE FROM `outdoorpvp_template` WHERE TypeId=7;
+INSERT INTO `outdoorpvp_template` (`TypeId`, `ScriptName`, `comment`) VALUES 
+('7', 'outdoorpvp_wg', 'Wintergrasp');
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+/* Teleport WG SPELLs*/
+DELETE FROM `spell_target_position` WHERE id IN ('59096', '58632', '58633');
+INSERT INTO `spell_target_position` (`id`, `target_map`, `target_position_x`, `target_position_y`, `target_position_z`, `target_orientation`) VALUES
+('59096', '571', '5325.06', '2843.36', '409.285', '3.20278'),
+('58632', '571', '5097.79', '2180.29', '365.61', '2.41'),
+('58633', '571', '5026.80', '3676.69', '362.58', '3.94');
+
+/* Defender's Portal Activate Proper Spell */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES 
+('54640','54643','0','Defender\'s Portal Activate Proper Spell');
+
+/* Temp removed gameobject stopping you getting to the relic
+* 194323 - [Wintergrasp Keep Collision Wall X:5396.209961 Y:2840.010010 Z:432.268005 MapId:571
+* 194162 - [Doodad_WG_Keep_Door01_collision01 X:5397.109863 Y:2841.540039 Z:425.901001 MapId:571]*/
+DELETE FROM gameobject WHERE id IN ('194323', '194162');
+UPDATE `gameobject_template` SET `type` = 6, `faction` = 0, `data2` = 10, `data3` = 54643, `ScriptName` = 'go_wg_veh_teleporter' WHERE `entry` = 192951;
+
+/* Titan Relic remove */
+DELETE FROM `gameobject` WHERE `id`=192829;
+
+/* Towers */
+UPDATE `gameobject_template` SET `faction` = 0, `flags` = 6553632 WHERE `entry` IN (190356,190357,190358);
+
+/*Spirit healer FIX */
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry IN (31841,31842);
+
+/* Creature template */
+UPDATE creature_template SET faction_A = '1802', faction_H = '1802' WHERE entry IN (30499,28312,28319);
+UPDATE creature_template SET faction_A = '1801', faction_H = '1801' WHERE entry IN (30400,32629,32627);
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry   IN (31841,31842);
+
+/* spell target for build vehicles */
+DELETE FROM `conditions` WHERE ConditionValue2=27852;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 0, 49899, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56575, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56661, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56663, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56665, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56667, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56669, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 61408, 0, 18, 1, 27852, 0, 0, '', NULL);
+
+/* Workshop */
+UPDATE `gameobject_template` SET `faction` = 35 WHERE `entry` IN (192028,192029,192030,192031,192032,192033);
+
+
+/*WG Spell area Data */
+/*For wg antifly */
+DELETE FROM `spell_area` WHERE spell IN (58730, 57940, 58045);
+INSERT INTO `spell_area` (`spell`, `area`, `quest_start`, `quest_start_active`, `quest_end`, `aura_spell`, `racemask`, `gender`, `autocast`) VALUES
+(58730, 4197, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4584, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4581, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4585, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4612, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4582, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4611, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4578, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4576, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4538, 0, 0, 0, 0, 0, 2, 1),
+(57940, 65, 0, 0, 0, 0, 0, 2, 1),
+(57940, 66, 0, 0, 0, 0, 0, 2, 1),
+(57940, 67, 0, 0, 0, 0, 0, 2, 1),
+(57940, 206, 0, 0, 0, 0, 0, 2, 1),
+(57940, 210, 0, 0, 0, 0, 0, 2, 1),
+(57940, 394, 0, 0, 0, 0, 0, 2, 1),
+(57940, 395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 1196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 2817, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3456, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3477, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3537, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3711, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4100, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4228, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4264, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4265, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4272, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4273, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4415, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4416, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4493, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4494, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4603, 0, 0, 0, 0, 0, 2, 1),
+(58045, 4197, 0, 0, 0, 0, 0, 2, 1);
\ No newline at end of file
diff --git a/sql/beastmaster/world-beastmaster.sql b/sql/beastmaster/world-beastmaster.sql
new file mode 100644
index 0000000..c5f14dc
--- /dev/null
+++ b/sql/beastmaster/world-beastmaster.sql
@@ -0,0 +1,4 @@
+-- Beastmaster
+DELETE FROM `creature_template` WHERE `entry` = 99990;
+insert into `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) values
+('99990','0','0','0','0','0','26789','0','0','0','Psyanide','Beastmaster Service','','0','80','80','0','35','35','1','1','1.14286','0.75','1','1755','1755','0','1504','1','1500','0','1','0','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','0','Npc_Beastmaster','0');
\ No newline at end of file
diff --git a/sql/extras/World_TriniityChat.sql b/sql/extras/World_TriniityChat.sql
new file mode 100644
index 0000000..b3a6950
--- /dev/null
+++ b/sql/extras/World_TriniityChat.sql
@@ -0,0 +1,81 @@
+/**
+* Table structure for irc_commands
+*/
+DROP TABLE IF EXISTS `irc_commands`;
+CREATE TABLE `irc_commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(350) default NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+/**
+* Records 
+*/
+INSERT INTO `irc_commands` VALUES ('acct', '[acct <Player> <(un)lock/email/pass/rename/gmlevel>] : Perform Action To <Player> Account.', '3');
+INSERT INTO `irc_commands` VALUES ('ban', '[ban <Player/IP> <ip/acct/unban/reason>] : Ban/Unban <Player>', '3');
+INSERT INTO `irc_commands` VALUES ('chan', '[chan <op/deop/voice/devoice> <*IRC Nick*>] : Set Mode On Yourself, If <IRC Nick> Is Specified Then Set mode On Nick.', '3');
+INSERT INTO `irc_commands` VALUES ('char', '[char <Player> <mailcheat/taxicheat/maxskill/setskill/combatstop/quest/mod>] : Perform Action To Character.', '3');
+INSERT INTO `irc_commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `irc_commands` VALUES ('inchan', '[inchan <Channel>] : Display Users In Selected In Game <Channel>', '0');
+INSERT INTO `irc_commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `irc_commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `irc_commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `irc_commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('login', '[login <UserName> <Password>] : Login To TriniChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `irc_commands` VALUES ('logout', '[logout] : Logout Of TriniChat Admin Mode.', '0');
+INSERT INTO `irc_commands` VALUES ('lookup', '[lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>] : ', '3');
+INSERT INTO `irc_commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `irc_commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `irc_commands` VALUES ('reload', '[reload] : Reload TriniChat Config Options And Security Level From DataBase.', '3');
+INSERT INTO `irc_commands` VALUES ('restart', '[restart] : Restart TriniChat, NOT Trinity Core World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `irc_commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('saveall', '[saveall] : Forces Trinity Core To Save All Players.', '3');
+INSERT INTO `irc_commands` VALUES ('server', '[server setmotd [<motd>]/flusharenapoints]', '3');
+INSERT INTO `irc_commands` VALUES ('shutdown', '[shutdown <TimeInSeconds>] : Shuts The Server Down In <TimeInSeconds>, Use 0 For Immediate Shut Down', '3');
+INSERT INTO `irc_commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('sysmsg', '[sysmsg <a/n/e/add/del/list> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(n-Broadcast Notify Message)(e-Event Message)', '3');
+INSERT INTO `irc_commands` VALUES ('tele', '[tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/Gameobject GUID>] : Teleport Player To Location, Coords, Recall Location, Another Player, Creature or Gameobject. (l-Location)(c-Coords)', '3');
+INSERT INTO `irc_commands` VALUES ('top', '[top <accttime/chartime/money> <limit>] : Display top stats for given option. Only GM Higher Than Config Option Can Use Limit.', '3');
+INSERT INTO `irc_commands` VALUES ('who', '[who] : Displays Users Currently Logged In To TriniChat.', '1');
+
+/**
+* Table structure for irc_inchan
+*/
+DROP TABLE IF EXISTS `irc_inchan`;
+CREATE TABLE `irc_inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+/**
+* Records 
+*/
+
+/**
+* Table structure for irc_autoannounce
+*/
+DROP TABLE IF EXISTS `irc_autoannounce`;
+CREATE TABLE `irc_autoannounce` (
+  `id` int(11) NOT NULL auto_increment,
+  `message` longtext NOT NULL,
+  `addedby` varchar(12) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='IRC Module System';
+
+/**
+* Records 
+*/
+INSERT INTO `irc_autoannounce` VALUES ('1', 'Welcome to IRC Channel', '');
+
+DELETE FROM `trinity_string` WHERE entry IN (6610,6611,6612);
+INSERT INTO `trinity_string` VALUES ('6610', '|cffff0000[System Message]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6611', '|cffff0000[Server Event]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6612', '|cffff0000[Automatic]: %s|r', null, null, null, null, null, null, null, null);
diff --git a/sql/extras/character_VIPAccount.sql b/sql/extras/character_VIPAccount.sql
new file mode 100644
index 0000000..df317ed
--- /dev/null
+++ b/sql/extras/character_VIPAccount.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `account_premium` (
+  `id` int(11) NOT NULL default '0' COMMENT 'Account id',
+  `setdate` bigint(40) NOT NULL default '0',
+  `unsetdate` bigint(40) NOT NULL default '0',
+  `premium_type` tinyint(4) unsigned NOT NULL default '1',
+  `active` tinyint(4) NOT NULL default '1',
+  PRIMARY KEY  (`id`,`setdate`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Premium Accounts';
\ No newline at end of file
diff --git a/sql/extras/setup_ahbot.sql b/sql/extras/setup_ahbot.sql
new file mode 100644
index 0000000..63b9a6d
--- /dev/null
+++ b/sql/extras/setup_ahbot.sql
@@ -0,0 +1,71 @@
+CREATE TABLE `auctionhousebot` (
+    `auctionhouse` INT(11) NOT NULL DEFAULT '0' COMMENT 'mapID of the auctionhouse.',
+    `name` CHAR(25) NULL DEFAULT NULL COMMENT 'Text name of the auctionhouse.',
+    `minitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the minimum number of items you want to keep in the auction house. a 0 here will make it the same as the maximum.',
+    `maxitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the number of items you want to keep in the auction house.',
+    `percentgreytradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Grey Trade Goods auction items',
+    `percentwhitetradegoods` INT(11) NULL DEFAULT '27' COMMENT 'Sets the percentage of the White Trade Goods auction items',
+    `percentgreentradegoods` INT(11) NULL DEFAULT '12' COMMENT 'Sets the percentage of the Green Trade Goods auction items',
+    `percentbluetradegoods` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the Blue Trade Goods auction items',
+    `percentpurpletradegoods` INT(11) NULL DEFAULT '1' COMMENT 'Sets the percentage of the Purple Trade Goods auction items',
+    `percentorangetradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Orange Trade Goods auction items',
+    `percentyellowtradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Yellow Trade Goods auction items',
+    `percentgreyitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Grey auction items',
+    `percentwhiteitems` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the non trade White auction items',
+    `percentgreenitems` INT(11) NULL DEFAULT '30' COMMENT 'Sets the percentage of the non trade Green auction items',
+    `percentblueitems` INT(11) NULL DEFAULT '8' COMMENT 'Sets the percentage of the non trade Blue auction items',
+    `percentpurpleitems` INT(11) NULL DEFAULT '2' COMMENT 'Sets the percentage of the non trade Purple auction items',
+    `percentorangeitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Orange auction items',
+    `percentyellowitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Yellow auction items',
+    `minpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Minimum price of Grey items (percentage).',
+    `maxpricegrey` INT(11) NULL DEFAULT '150' COMMENT 'Maximum price of Grey items (percentage).',
+    `minpricewhite` INT(11) NULL DEFAULT '150' COMMENT 'Minimum price of White items (percentage).',
+    `maxpricewhite` INT(11) NULL DEFAULT '250' COMMENT 'Maximum price of White items (percentage).',
+    `minpricegreen` INT(11) NULL DEFAULT '800' COMMENT 'Minimum price of Green items (percentage).',
+    `maxpricegreen` INT(11) NULL DEFAULT '1400' COMMENT 'Maximum price of Green items (percentage).',
+    `minpriceblue` INT(11) NULL DEFAULT '1250' COMMENT 'Minimum price of Blue items (percentage).',
+    `maxpriceblue` INT(11) NULL DEFAULT '1750' COMMENT 'Maximum price of Blue items (percentage).',
+    `minpricepurple` INT(11) NULL DEFAULT '2250' COMMENT 'Minimum price of Purple items (percentage).',
+    `maxpricepurple` INT(11) NULL DEFAULT '4550' COMMENT 'Maximum price of Purple items (percentage).',
+    `minpriceorange` INT(11) NULL DEFAULT '3250' COMMENT 'Minimum price of Orange items (percentage).',
+    `maxpriceorange` INT(11) NULL DEFAULT '5550' COMMENT 'Maximum price of Orange items (percentage).',
+    `minpriceyellow` INT(11) NULL DEFAULT '5250' COMMENT 'Minimum price of Yellow items (percentage).',
+    `maxpriceyellow` INT(11) NULL DEFAULT '6550' COMMENT 'Maximum price of Yellow items (percentage).',
+    `minbidpricegrey` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricewhite` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricewhite` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricegreen` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricegreen` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceblue` INT(11) NULL DEFAULT '75' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 75',
+    `maxbidpriceblue` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricepurple` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricepurple` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceorange` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceorange` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceyellow` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceyellow` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 100',
+    `maxstackgrey` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackwhite` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackgreen` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackblue` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackpurple` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackorange` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackyellow` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `buyerpricegrey` INT(11) NULL DEFAULT '1' COMMENT 'Multiplier to vendorprice when buying grey items from auctionhouse',
+    `buyerpricewhite` INT(11) NULL DEFAULT '3' COMMENT 'Multiplier to vendorprice when buying white items from auctionhouse',
+    `buyerpricegreen` INT(11) NULL DEFAULT '5' COMMENT 'Multiplier to vendorprice when buying green items from auctionhouse',
+    `buyerpriceblue` INT(11) NULL DEFAULT '12' COMMENT 'Multiplier to vendorprice when buying blue items from auctionhouse',
+    `buyerpricepurple` INT(11) NULL DEFAULT '15' COMMENT 'Multiplier to vendorprice when buying purple items from auctionhouse',
+    `buyerpriceorange` INT(11) NULL DEFAULT '20' COMMENT 'Multiplier to vendorprice when buying orange items from auctionhouse',
+    `buyerpriceyellow` INT(11) NULL DEFAULT '22' COMMENT 'Multiplier to vendorprice when buying yellow items from auctionhouse',
+    `buyerbiddinginterval` INT(11) NULL DEFAULT '1' COMMENT 'Interval how frequently AHB bids on each AH. Time in minutes',
+    `buyerbidsperinterval` INT(11) NULL DEFAULT '1' COMMENT 'number of bids to put in per bidding interval',
+    PRIMARY KEY (`auctionhouse`)
+)
+ENGINE=InnoDB ROW_FORMAT=DEFAULT;
+
+insert  into `auctionhousebot`(`auctionhouse`,`name`,`minitems`,`maxitems`,`percentgreytradegoods`,`percentwhitetradegoods`,`percentgreentradegoods`,`percentbluetradegoods`,`percentpurpletradegoods`,`percentorangetradegoods`,`percentyellowtradegoods`,`percentgreyitems`,`percentwhiteitems`,`percentgreenitems`,`percentblueitems`,`percentpurpleitems`,`percentorangeitems`,`percentyellowitems`,`minpricegrey`,`maxpricegrey`,`minpricewhite`,`maxpricewhite`,`minpricegreen`,`maxpricegreen`,`minpriceblue`,`maxpriceblue`,`minpricepurple`,`maxpricepurple`,`minpriceorange`,`maxpriceorange`,`minpriceyellow`,`maxpriceyellow`,`minbidpricegrey`,`maxbidpricegrey`,`minbidpricewhite`,`maxbidpricewhite`,`minbidpricegreen`,`maxbidpricegreen`,`minbidpriceblue`,`maxbidpriceblue`,`minbidpricepurple`,`maxbidpricepurple`,`minbidpriceorange`,`maxbidpriceorange`,`minbidpriceyellow`,`maxbidpriceyellow`,`maxstackgrey`,`maxstackwhite`,`maxstackgreen`,`maxstackblue`,`maxstackpurple`,`maxstackorange`,`maxstackyellow`,`buyerpricegrey`,`buyerpricewhite`,`buyerpricegreen`,`buyerpriceblue`,`buyerpricepurple`,`buyerpriceorange`,`buyerpriceyellow`,`buyerbiddinginterval`,`buyerbidsperinterval`) values
+(2,'Alliance',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(6,'Horde',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(7,'Neutral',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1);
\ No newline at end of file
diff --git a/sql/extras/setup_npc_teleport.sql b/sql/extras/setup_npc_teleport.sql
new file mode 100644
index 0000000..03b9e93
--- /dev/null
+++ b/sql/extras/setup_npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` VALUES (100000, 0, 0, 0, 0, 0, 26502, 0, 0, 0, 'Abisal Vortex', '', '', 0, 83, 83, 0, 35, 35, 1, 1, 1.14286, 2, 1, 509, 683, 0, 805, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 371, 535, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'npc_teleport', 1);
diff --git a/sql/world_botguy.sql b/sql/world_botguy.sql
new file mode 100644
index 0000000..e8b5ab2
--- /dev/null
+++ b/sql/world_botguy.sql
@@ -0,0 +1 @@
+INSERT INTO `gossip_menu_option` VALUES('0','18','0','GOSSIP_OPTION_BOT','99','1','0','0','0','0',NULL);
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index 1f85cb6..24e16b2 100755
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -350,6 +350,9 @@ bool AuthSocket::_HandleLogonChallenge()
     // Verify that this IP is not in the ip_banned table
     LoginDatabase.Execute(LoginDatabase.GetPreparedStatement(LOGIN_DEL_EXPIRED_IP_BANS));
 
+    LoginDatabase.Execute(
+        LoginDatabase.GetPreparedStatement(LOGIN_SET_ACCOUNT_PREMIUM)
+            );
     const std::string& ip_address = socket().get_remote_address();
     PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_IP_BANNED);
     stmt->setString(0, ip_address);
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
new file mode 100644
index 0000000..eab1c7a
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
@@ -0,0 +1,6576 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "ItemPrototype.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "Spell.h"
+#include "SpellInfo.h"
+#include "SharedDefines.h"
+#include "Log.h"
+#include "GossipDef.h"
+#include "MotionMaster.h"
+#include "AuctionHouseMgr.h"
+#include "Mail.h"
+#include "Language.h"
+#include "Object.h"
+
+// returns a float in range of..
+float rand_float(float low, float high)
+{
+    return (rand() / (static_cast<float> (RAND_MAX) + 1.0)) * (high - low) + low;
+}
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
+    bool revive(Player& botPlayer) { return HandleReviveCommand((char *) botPlayer.GetName()); }
+    bool teleport(Player& botPlayer) { return HandleSummonCommand((char *) botPlayer.GetName()); }
+    void sysmessage(const char *str) { SendSysMessage(str); }
+    bool dropQuest(char *str) { return HandleQuestRemoveCommand(str); }
+};
+
+PlayerbotAI::PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot) :
+    m_mgr(mgr), m_bot(bot), m_classAI(0), m_ignoreAIUpdatesUntilTime(0),
+    m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+    m_TimeDoneEating(0), m_TimeDoneDrinking(0),
+    m_CurrentlyCastingSpellId(0), m_spellIdCommand(0),
+    m_targetGuidCommand(uint64()),
+    m_taxiMaster(uint64())
+{
+
+    // set bot state and needed item list
+    m_botState = BOTSTATE_NORMAL;
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+
+    // reset some pointers
+    m_targetChanged = false;
+    m_targetType = TARGET_NORMAL;
+    m_targetCombat = 0;
+    m_targetAssist = 0;
+    m_targetProtect = 0;
+
+    // set collection options
+    m_collectionFlags = 0x07;
+    if (m_mgr->m_confCollectCombat)
+        SetCollectFlag(COLLECT_FLAG_COMBAT);
+    if (m_mgr->m_confCollectQuest)
+        SetCollectFlag(COLLECT_FLAG_QUEST);
+    if (m_mgr->m_confCollectProfession)
+        SetCollectFlag(COLLECT_FLAG_PROFESSION);
+    if (m_mgr->m_confCollectLoot)
+        SetCollectFlag(COLLECT_FLAG_LOOT);
+    if (m_mgr->m_confCollectSkin && m_bot->HasSkill(SKILL_SKINNING))
+        SetCollectFlag(COLLECT_FLAG_SKIN);
+    if (m_mgr->m_confCollectObjects)
+        SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+
+    // start following master (will also teleport bot to master)
+    SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
+
+    // get class specific ai
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DRUID:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(GetMaster(), m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    if (m_classAI) delete m_classAI;
+}
+
+Player* PlayerbotAI::GetMaster() const
+{
+    return m_mgr->GetMaster();
+}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if (master)
+        loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    else
+        loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE)
+            continue;
+
+        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+
+uint32 PlayerbotAI::getPetSpellId(const char* args) const
+{
+    if (!*args)
+        return 0;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || SPELL_ATTR0_PASSIVE)
+            continue;
+
+        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+
+uint32 PlayerbotAI::initSpell(uint32 spellId)
+{
+    /*SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    // Check if bot knows this spell
+    if (!m_bot->HasSpell(spellId))
+        return 0;
+
+        uint32 next_active_spell_id = 0;
+        if (!spellInfo->IsStackableWithRanks() && spellInfo->IsRanked())
+        {
+            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
+            {
+                if (m_bot->HasSpell(next))
+                {
+                    next_active_spell_id = next;
+                }
+            }
+        }
+    if (next_active_spell_id == 0)
+    {
+        const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: initSpell - Playerbot spell init: %s is %u", pSpellInfo->SpellName[0], spellId);
+
+        // Add spell to spellrange map
+        Spell *spell = new Spell(spellInfo);
+        SpellRangeEntry const* srange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
+        float range = GetSpellMaxRange(srange, IsPositiveSpell(spellId));
+        m_bot->ApplySpellMod(spellId, SPELLMOD_RANGE, range, spell);
+        m_spellRangeMap.insert(std::pair<uint32, float>(spellId, range));
+        delete spell;
+    }
+    return (next_active_spell_id == 0) ? spellId : next_active_spell_id;*/
+}
+
+
+// Pet spells do not form chains like player spells.
+// One of the options to initialize a spell is to use spell icon id
+uint32 PlayerbotAI::initPetSpell(uint32 spellIconId)
+{
+    Pet * pet = m_bot->GetPet();
+
+    if (!pet)
+        return 0;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || SPELL_ATTR0_PASSIVE)
+            continue;
+
+        const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (pSpellInfo->SpellIconID == spellIconId)
+            return spellId;
+    }
+
+    // Nothing found
+    return 0;
+}
+
+/*
+ * Send a list of equipment that is in bot's inventor that is currently unequipped.
+ * This is called when the master is inspecting the bot.
+ */
+
+void PlayerbotAI::SendNotEquipList(Player& /*player*/)
+{
+    // find all unequipped items and put them in
+    // a vector of dynamically created lists where the vector index is from 0-18
+    // and the list contains Item* that can be equipped to that slot
+    // Note: each dynamically created list in the vector must be deleted at end
+    // so NO EARLY RETURNS!
+    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+    std::list<Item*>* equip[19];
+    for (uint8 i = 0; i < 19; ++i)
+        equip[i] = NULL;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                // create a list if one doesn't already exist
+                if (equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item*>;
+
+                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip.");
+    ChatHandler ch(GetMaster());
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+                                  "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+                                  "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
+                                  "tabard" };
+
+    // now send client all items that can be equipped by slot
+    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if (equip[equipSlot] == NULL)
+            continue;
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            const ItemTemplate* proto = (*it)->GetTemplate();
+
+            std::string itemName = proto->Name1;
+            ItemLocalization(itemName, proto->ItemId);
+
+            out << " |cffffffff|Hitem:" << proto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+
+        delete itemListForEqSlot; // delete list of Item*
+    }
+}
+
+void PlayerbotAI::SendQuestNeedList()
+{
+    std::ostringstream out;
+
+    for (BotNeedItem::iterator itr = m_needItemList.begin(); itr != m_needItemList.end(); ++itr)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->first);
+        if(proto)
+        {
+            std::string itemName = proto->Name1;
+            ItemLocalization(itemName, proto->ItemId);
+
+            out << " " << itr->second << "x|cffffffff|Hitem:" << proto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+    }
+
+    for (BotNeedItem::iterator itr = m_needCreatureOrGOList.begin(); itr != m_needCreatureOrGOList.end(); ++itr)
+    {
+        CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(itr->first);
+        if (cinfo)
+        {
+            std::string creatureName = cinfo->Name;
+            CreatureLocalization(creatureName, cinfo->Entry);
+            out << " " << itr->second << "x|cFFFFFF00|Hcreature_entry:" << itr->first << "|h[" << creatureName << "]|h|r";
+        }
+
+        if (m_bot->HasQuestForGO(itr->first))
+        {
+            GameObjectTemplate const* ginfo = sObjectMgr->GetGameObjectTemplate(itr->first);
+            if (ginfo)
+            {
+                std::string gameobjectName = ginfo->name;
+                GameObjectLocalization(gameobjectName, ginfo->entry);
+                out << " " << itr->second << "x|cFFFFFF00|Hgameobject_entry:" << itr->first << "|h[" << gameobjectName << "]|h|r";
+            }
+        }
+    }
+
+    TellMaster("Here's a list of all things needed for quests:");
+    if (!out.str().empty())
+        TellMaster(out.str().c_str());
+}
+
+bool PlayerbotAI::IsItemUseful(uint32 itemid)
+{
+    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+    if (!pProto || pProto->Quality < ITEM_QUALITY_NORMAL)
+        return false;
+
+    // do we already have the max allowed of item if more than zero?
+    if (pProto->MaxCount > 0 && m_bot->HasItemCount(itemid, pProto->MaxCount, true))
+        return false;
+
+    // quest related items
+    if (pProto->StartQuest > 0 && HasCollectFlag(COLLECT_FLAG_QUEST))
+        return true;
+
+    switch (pProto->Class)
+    {
+        case ITEM_CLASS_QUEST:
+            if (!HasCollectFlag(COLLECT_FLAG_QUEST))
+                break;
+        case ITEM_CLASS_KEY:
+            return true;
+        case ITEM_CLASS_TRADE_GOODS:
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_PARTS:
+                case ITEM_SUBCLASS_EXPLOSIVES:
+                case ITEM_SUBCLASS_DEVICES:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_CLOTH:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_LEATHER:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_METAL_STONE:
+                    if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                         m_bot->HasSkill(SKILL_ENGINEERING) ||
+                         m_bot->HasSkill(SKILL_MINING)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_MEAT:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_HERB:
+                    if ((m_bot->HasSkill(SKILL_HERBALISM) ||
+                         m_bot->HasSkill(SKILL_ALCHEMY) ||
+                         m_bot->HasSkill(SKILL_INSCRIPTION)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ELEMENTAL:
+                    return true;    // pretty much every profession uses these a bit
+                case ITEM_SUBCLASS_ENCHANTING:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case ITEM_CLASS_RECIPE:
+        {
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            // skip recipes that we have
+            if (m_bot->HasSpell(pProto->Spells[2].SpellId))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_TAILORING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_BLACKSMITHING:
+                    if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_COOKING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                    if (m_bot->HasSkill(SKILL_ALCHEMY))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FIRST_AID))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FISHING_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FISHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+        }
+        default:
+            break;
+    }
+
+    return false;
+}
+
+void PlayerbotAI::ReloadAI()
+{
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_MAGE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(GetMaster(), m_bot, this);
+            break;
+    }
+}
+
+void PlayerbotAI::SendOrders(Player& /*player*/)
+{
+    std::ostringstream out;
+
+    if (!m_combatOrder)
+        out << "Got no combat orders!";
+    else if (m_combatOrder & ORDERS_TANK)
+        out << "I TANK";
+    else if (m_combatOrder & ORDERS_ASSIST)
+        out << "I ASSIST " << (m_targetAssist ? m_targetAssist->GetName() : "unknown");
+    else if (m_combatOrder & ORDERS_HEAL)
+        out << "I HEAL";
+    if ((m_combatOrder & ORDERS_PRIMARY) && (m_combatOrder & ORDERS_SECONDARY))
+        out << " and ";
+    if (m_combatOrder & ORDERS_PROTECT)
+        out << "I PROTECT " << (m_targetProtect ? m_targetProtect->GetName() : "unknown");
+    out << ".";
+
+    if (m_mgr->m_confDebugWhisper)
+    {
+        out << " " << (IsInCombat() ? "I'm in COMBAT! " : "Not in combat. ");
+        out << "Current state is ";
+        if (m_botState == BOTSTATE_NORMAL)
+            out << "NORMAL";
+        else if (m_botState == BOTSTATE_COMBAT)
+            out << "COMBAT";
+        else if (m_botState == BOTSTATE_DEAD)
+            out << "DEAD";
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+            out << "RELEASED";
+        else if (m_botState == BOTSTATE_LOOTING)
+            out << "LOOTING";
+        else if (m_botState == BOTSTATE_FLYING)
+            out << "FLYING";
+        out << ". Movement order is ";
+        if (m_movementOrder == MOVEMENT_NONE)
+            out << "NONE";
+        else if (m_movementOrder == MOVEMENT_FOLLOW)
+            out << "FOLLOW " << (m_followTarget ? m_followTarget->GetName() : "unknown");
+        else if (m_movementOrder == MOVEMENT_STAY)
+            out << "STAY";
+        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
+        out << " Next action in " << (m_ignoreAIUpdatesUntilTime - time(0)) << "sec.";
+    }
+
+    TellMaster(out.str().c_str());
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        case SMSG_DUEL_WINNER:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+        }
+        case SMSG_DUEL_COMPLETE:
+        {
+            m_ignoreAIUpdatesUntilTime = time(0) + 4;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            ReloadAI();
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+        }
+        case SMSG_DUEL_OUTOFBOUNDS:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+        }
+        case SMSG_DUEL_REQUESTED:
+        {
+            m_ignoreAIUpdatesUntilTime = 0;
+            WorldPacket p(packet);
+            uint64 flagGuid;
+            p >> flagGuid;
+            uint64 playerGuid;
+            p >> playerGuid;
+            Player* const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if (canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+                // follow target in casting range
+                float angle = rand_float(0, M_PI);
+                float dist = rand_float(4, 10);
+
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(uint64(playerGuid));
+                m_ignoreAIUpdatesUntilTime = time(0) + 4;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_AUCTION_COMMAND_RESULT:
+        {
+            uint32 auctionId, Action, ErrorCode;
+            std::string action[3] = {"Creating", "Cancelling", "Bidding"};
+            std::ostringstream out;
+
+            WorldPacket p(packet);
+            p >> auctionId;
+            p >> Action;
+            p >> ErrorCode;
+            p.resize(12);
+
+            switch (ErrorCode)
+            {
+                case AUCTION_OK:
+                {
+                    out << "|cff1eff00|h" << action[Action] << " was successful|h|r";
+                    break;
+                }
+                case AUCTION_INTERNAL_ERROR:
+                {
+                    out << "|cffff0000|hWhile" << action[Action] << ", an internal error occured|h|r";
+                    break;
+                }
+                case AUCTION_NOT_ENOUGHT_MONEY:
+                {
+                    out << "|cffff0000|hWhile " << action[Action] << ", I didn't have enough money|h|r";
+                    break;
+                }
+                case AUCTION_ITEM_NOT_FOUND:
+                {
+                    out << "|cffff0000|hItem was not found!|h|r";
+                    break;
+                }
+                case CANNOT_BID_YOUR_AUCTION_ERROR:
+                {
+                    out << "|cffff0000|hI cannot bid on my own auctions!|h|r";
+                    break;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 err;
+            p >> err;
+
+            if (m_inventory_full)
+                return;
+
+            m_inventory_full = true;
+
+            if (err != EQUIP_ERR_OK)
+            {
+                switch (err)
+                {
+                    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+                        TellMaster("I can't carry anymore of those.");
+                        return;
+                    case EQUIP_ERR_MISSING_REAGENT:
+                        TellMaster("I'm missing some reagents for that.");
+                        return;
+                    case EQUIP_ERR_ITEM_LOCKED:
+                        TellMaster("That item is locked.");
+                        return;
+                    case EQUIP_ERR_ALREADY_LOOTED:
+                        TellMaster("That is already looted.");
+                        return;
+                    case EQUIP_ERR_INVENTORY_FULL:
+                        TellMaster("My inventory is full.");
+                        return;
+                    case EQUIP_ERR_NOT_IN_COMBAT:
+                        TellMaster("I can't use that in combat.");
+                        return;
+                    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+                        TellMaster("I can't get that now.");
+                        return;
+                    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+                        TellMaster("I can only have one of those equipped.");
+                        return;
+                    case EQUIP_ERR_BANK_FULL:
+                        TellMaster("My bank is full.");
+                        return;
+                    case EQUIP_ERR_ITEM_NOT_FOUND:
+                        TellMaster("I can't find the item.");
+                        return;
+                    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+                        TellMaster("I'm too far from the bank.");
+                        return;
+                    default:
+                        TellMaster("I can't use that.");
+                        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_INVENTORY_CHANGE_FAILURE: %u", err);
+                        return;
+                }
+            }
+        }
+
+        case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            uint32 spellId;
+            uint8 result;
+            uint8 castCount;
+
+            p >> spellId >> castCount >> result;
+
+            if (result != SPELL_CAST_OK)
+            {
+                switch (result)
+                {
+                    case SPELL_FAILED_INTERRUPTED:
+                        //TellMaster("spell interrupted (%u)",result);
+                        //sLog->outDebug(LOG_FILTER_NETWORKIO, "spell interrupted (%u)",result);
+                        return;
+
+                    default:
+                        //TellMaster("Spell failed (%u)",result);
+                        //sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_CAST_FAIL: %u", result);
+                        return;
+                }
+            }
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            uint64 casterGuid;
+
+            p.readPackGUID(casterGuid);
+
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            p >> castCount >> spellId;
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                m_ignoreAIUpdatesUntilTime = time(0);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        // if a change in speed was detected for the master
+        // make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+
+            p.readPackGUID(guid);
+            if (guid != GetMaster()->GetGUID())
+                return;
+            if (GetMaster()->IsMounted() && !m_bot->IsMounted())
+            {
+                //Player Part
+                if (!GetMaster()->GetAuraEffectsByType(SPELL_AURA_MOUNTED).empty())
+                {
+                    int32 master_speed1 = 0;
+                    int32 master_speed2 = 0;
+                    //master_speed1 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[1].CalcValue();
+                    //master_speed2 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[2].CalcValue();
+
+                    //Bot Part
+                    uint32 spellMount = 0;
+                    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                    {
+                        uint32 spellId = itr->first;
+                        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE)
+                            continue;
+                        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+                        if (!pSpellInfo)
+                            continue;
+
+                        if (pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+                        {
+                            if (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                            {
+                                if (pSpellInfo->EffectBasePoints[1] == master_speed1)
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                            else if ((pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                     && (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                            {
+                                if ((pSpellInfo->EffectBasePoints[1] == master_speed1)
+                                    && (pSpellInfo->EffectBasePoints[2] == master_speed2))
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                            else if ((pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                     && (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                                if ((pSpellInfo->EffectBasePoints[2] == master_speed2)
+                                    && (pSpellInfo->EffectBasePoints[1] == master_speed1))
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                        }
+                    }
+                    if (spellMount > 0) m_bot->CastSpell(m_bot, spellMount, false);
+                }
+            }
+            else if (!GetMaster()->IsMounted() && m_bot->IsMounted())
+            {
+                WorldPacket emptyPacket;
+                m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+            }
+            return;
+        }
+
+        // handle flying acknowledgement
+        case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+
+           p.readPackGUID(guid);
+            if (guid != m_bot->GetGUID())
+                return;
+            m_bot->m_movementInfo.AddMovementFlag(MOVEMENTFLAG_FLYING);
+            //m_bot->SetSpeed(MOVE_RUN, GetMaster()->GetSpeed(MOVE_FLIGHT) +0.1f, true);
+            return;
+        }
+
+        // handle dismount flying acknowledgement
+        case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+
+            p.readPackGUID(guid);
+            if (guid != m_bot->GetGUID())
+                return;
+            m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //m_bot->SetSpeed(MOVE_RUN,GetMaster()->GetSpeedRate(MOVE_RUN),true);
+            return;
+        }
+
+        // If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name;
+            p >> name;
+            if (m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if (m_bot->GetGroup()->IsMember(GetMaster()->GetGUID()))
+                {
+                    p.resize(8);
+                    p << GetMaster()->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                }
+                else
+                {
+                    p.clear(); // not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+                }
+            }
+            return;
+        }
+
+        // If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation;
+            p >> operation;
+            std::string member;
+            p >> member;
+            uint32 result;
+            p >> result;
+            p.clear();
+            if (operation == PARTY_OP_LEAVE)
+                if (member == GetMaster()->GetName())
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p);  // packet not used updated code
+            return;
+        }
+
+        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
+        case SMSG_GROUP_INVITE:
+        {
+            if (m_bot->GetGroupInvite())
+            {
+                const Group* const grp = m_bot->GetGroupInvite();
+                if (!grp)
+                    return;
+
+                Player* const inviter = ObjectAccessor::FindPlayer(grp->GetLeaderGUID());
+                if (!inviter)
+                    return;
+
+                WorldPacket p;
+                if (!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += GetMaster()->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+                }
+                else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
+            }
+            return;
+        }
+
+        // Handle when another player opens the trade window with the bot
+        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if (m_bot->GetTrader() == NULL)
+                break;
+
+            WorldPacket p(packet);
+            uint32 status;
+            p >> status;
+            p.resize(4);
+
+            //4 == TRADE_STATUS_TRADE_ACCEPT
+            if (status == 4)
+                m_bot->GetSession()->HandleAcceptTradeOpcode(p);  // packet not used
+
+            //1 == TRADE_STATUS_BEGIN_TRADE
+            else if (status == 1)
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
+                {
+                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    return;
+                }
+
+                // list out items available for trade
+                std::ostringstream out;
+
+                out << "In my main backpack:";
+                // list out items in main backpack
+                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if (pItem)
+                        MakeItemLink(pItem, out, true);
+                }
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+
+                // list out items in other removable backpacks
+                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if (pBag)
+                    {
+                        std::ostringstream outbag;
+                        outbag << "In my ";
+                        const ItemTemplate* const pBagProto = pBag->GetTemplate();
+                        std::string bagName = pBagProto->Name1;
+                        ItemLocalization(bagName, pBagProto->ItemId);
+                        outbag << bagName << ":";
+
+                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                            if (pItem)
+                                MakeItemLink(pItem, outbag, true);
+                        }
+                        ch.SendSysMessage(outbag.str().c_str());
+                    }
+                }
+
+                // calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                // send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                        << "|r|cfffffc00g|r|cff00ff00" << silver
+                        << "|r|cffcdcdcds|r|cff00ff00" << copper
+                        << "|r|cffffd333c|r";
+                SendWhisper(whisper.str().c_str(), *(m_bot->GetTrader()));
+            }
+            return;
+        }
+
+        case SMSG_SPELL_START:
+        {
+            WorldPacket p(packet);
+
+            uint64 castItemGuid;
+            p.readPackGUID(castItemGuid);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                return;
+
+            if (pSpellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+                return;
+
+            m_ignoreAIUpdatesUntilTime = time(0) + (msTime / 1000) + 1;
+
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+
+            uint64 castItemGuid;
+            p.readPackGUID(castItemGuid);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            return;
+        }
+
+        // if someone tries to resurrect, then accept
+        case SMSG_RESURRECT_REQUEST:
+        {
+            if (!m_bot->isAlive())
+            {
+                WorldPacket p(packet);
+                uint64 guid;
+                p >> guid;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8 + 1);
+                *packet << guid;
+                *packet << uint8(1);                        // accept
+                m_bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+                // set back to normal
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            return;
+        }
+
+        case SMSG_LOOT_RESPONSE:
+        {
+            WorldPacket p(packet); // (8+1+4+1+1+4+4+4+4+4+1)
+            uint64 guid;
+            uint8 loot_type;
+            uint32 gold;
+            uint8 items;
+
+            p >> guid;      // 8 corpse guid
+            p >> loot_type; // 1 loot type
+            p >> gold;      // 4 money on corpse
+            p >> items;     // 1 number of items on corpse
+
+            if (gold > 0)
+            {
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+                m_bot->GetSession()->QueuePacket(packet);
+            }
+
+            for (uint8 i = 0; i < items; ++i)
+            {
+                uint32 itemid;
+                uint32 itemcount;
+                uint8 lootslot_type;
+                uint8 itemindex;
+
+                p >> itemindex;         // 1 counter
+                p >> itemid;            // 4 itemid
+                p >> itemcount;         // 4 item stack count
+                p.read_skip<uint32>();  // 4 item model
+                p.read_skip<uint32>();  // 4 randomSuffix
+                p.read_skip<uint32>();  // 4 randomPropertyId
+                p >> lootslot_type;     // 1 LootSlotType
+
+                if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+                    continue;
+
+                // skinning or collect loot flag = just auto loot everything for getting object
+                // corpse = run checks
+                if (loot_type == LOOT_SKINNING || HasCollectFlag(COLLECT_FLAG_LOOT) ||
+                    (loot_type == LOOT_CORPSE && (IsInQuestItemList(itemid) || IsItemUseful(itemid))))
+                {
+                    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+                    *packet << itemindex;
+                    m_bot->GetSession()->QueuePacket(packet);
+                }
+            }
+
+            // release loot
+            WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+            *packet << guid;
+            m_bot->GetSession()->QueuePacket(packet);
+
+            return;
+        }
+
+        case SMSG_LOOT_RELEASE_RESPONSE:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+
+            p >> guid;
+
+            if (guid == m_lootCurrent)
+            {
+                Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+
+                if (c && c->GetCreatureInfo()->SkinLootId && !c->lootForSkin)
+                {
+                    uint32 reqSkill = c->GetCreatureInfo()->GetRequiredLootSkill();
+                    // check if it is a leather skin and if it is to be collected (could be ore or herb)
+                    if (m_bot->HasSkill(reqSkill) && ((reqSkill != SKILL_SKINNING) ||
+                                                      (HasCollectFlag(COLLECT_FLAG_SKIN) && reqSkill == SKILL_SKINNING)))
+                    {
+                        // calculate skill requirement
+                        uint32 skillValue = m_bot->GetPureSkillValue(reqSkill);
+                        uint32 targetLevel = c->getLevel();
+                        uint32 reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                        if (skillValue >= reqSkillValue)
+                        {
+                            if (m_lootCurrent != m_lootPrev)    // if this wasn't previous loot try again
+                            {
+                                m_lootPrev = m_lootCurrent;
+                                SetIgnoreUpdateTime();
+                                return; // so that the DoLoot function is called again to get skin
+                            }
+                        }
+                        else
+                            TellMaster("My skill is %u but it requires %u", skillValue, reqSkillValue);
+                    }
+                }
+
+                // if previous is current, clear
+                if (m_lootPrev == m_lootCurrent)
+                    m_lootPrev = uint64();
+                // clear current target
+                m_lootCurrent = uint64();
+                // clear movement
+                m_bot->GetMotionMaster()->Clear();
+                m_bot->GetMotionMaster()->MoveIdle();
+                SetIgnoreUpdateTime();
+            }
+
+            return;
+        }
+
+        case SMSG_ITEM_PUSH_RESULT:
+        {
+            WorldPacket p(packet);  // (8+4+4+4+1+4+4+4+4+4+4)
+            uint64 guid;
+
+            p >> guid;              // 8 player guid
+            if (m_bot->GetGUID() != guid)
+                return;
+
+            uint8 bagslot;
+            uint32 itemslot, itemid, count, totalcount;
+
+            p.read_skip<uint32>();  // 4 0=looted, 1=from npc
+            p.read_skip<uint32>();  // 4 0=received, 1=created
+            p.read_skip<uint32>();  // 4 IsShowChatMessage
+            p >> bagslot;           // 1 bagslot
+            p >> itemslot;          // 4 item slot, but when added to stack: 0xFFFFFFFF
+            p >> itemid;            // 4 item entry id
+            p.read_skip<uint32>();  // 4 SuffixFactor
+            p.read_skip<uint32>();  // 4 random item property id
+            p >> count;             // 4 count of items
+            p >> totalcount;        // 4 count of items in inventory
+
+            if (IsInQuestItemList(itemid))
+            {
+                m_needItemList[itemid] = (m_needItemList[itemid] - count);
+                if (m_needItemList[itemid] <= 0)
+                    m_needItemList.erase(itemid);
+            }
+
+            return;
+        }
+
+            /* uncomment this and your bots will tell you all their outgoing packet opcode names
+               case SMSG_MONSTER_MOVE:
+               case SMSG_UPDATE_WORLD_STATE:
+               case SMSG_COMPRESSED_UPDATE_OBJECT:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_HEARTBEAT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case SMSG_UPDATE_OBJECT:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case SMSG_DESTROY_OBJECT:
+               case MSG_MOVE_START_BACKWARD:
+               case SMSG_AURA_UPDATE_ALL:
+               case MSG_MOVE_FALL_LAND:
+               case MSG_MOVE_JUMP:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+                std::ostringstream out;
+                out << "botout: " << oc;
+                sLog->outError(out.str().c_str());
+
+                //TellMaster(oc);
+               }
+             */
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
+{
+    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return (100);
+    else
+        return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit& target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
+{
+    if (spellId <= 0)
+        return false;
+
+    for (Unit::AuraMap::const_iterator iter = player.GetOwnedAuras().begin(); iter != player.GetOwnedAuras().end(); ++iter)
+    {
+        if (iter->second->GetId() == spellId)
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasAura(const char* spellName) const
+{
+    return HasAura(spellName, *m_bot);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return (spellId) ? HasAura(spellId, player) : false;
+}
+
+// looks through all items / spells that bot could have to get a mount
+Item* PlayerbotAI::FindMount(uint32 matchingRidingSkill) const
+{
+    // list out items in main backpack
+
+    Item* partialMatch = NULL;
+
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK || proto->RequiredSkill != SKILL_RIDING)
+                continue;
+
+            if (proto->RequiredSkillRank == matchingRidingSkill)
+                return pItem;
+
+            else if (!partialMatch || (partialMatch && partialMatch->GetTemplate()->RequiredSkillRank < proto->RequiredSkillRank))
+                partialMatch = pItem;
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK || proto->RequiredSkill != SKILL_RIDING)
+                        continue;
+
+                    if (proto->RequiredSkillRank == matchingRidingSkill)
+                        return pItem;
+
+                    else if (!partialMatch || (partialMatch && partialMatch->GetTemplate()->RequiredSkillRank < proto->RequiredSkillRank))
+                        partialMatch = pItem;
+                }
+            }
+    }
+    return partialMatch;
+}
+
+Item* PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                continue;
+
+            if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_FOOD)
+                // if is FOOD
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 11
+                if (proto->Spells[0].SpellCategory == 11)
+                    return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                        continue;
+
+                    // this enum is no longer defined in mangos. Is it no longer valid?
+                    // according to google it was 11
+                    if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_FOOD)
+                        // if is FOOD
+                        // this enum is no longer defined in mangos. Is it no longer valid?
+                        // according to google it was 11
+                        // if (proto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                        if (proto->Spells[0].SpellCategory == 11)
+                            return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                continue;
+
+            if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_FOOD)
+                // if (proto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 59
+                // if (proto->Spells[0].SpellCategory == 59)
+                if (proto->Spells[0].SpellCategory == 59)
+                    return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_FOOD)
+                        // if is WATER
+                        // SPELL_CATEGORY_DRINK is no longer defined in an enum in mangos
+                        // google says the valus is 59. Is this still valid?
+                        // if (proto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+                        if (proto->Spells[0].SpellCategory == 59)
+                            return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBandage() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                continue;
+
+            if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                continue;
+
+            if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == 6)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->SubClass == 6)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindConsumable(uint32 displayId) const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+
+            if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                continue;
+
+            if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->DisplayInfoID == displayId)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+
+                    if (!proto || m_bot->CanUseItem(proto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (proto->Class == ITEM_CLASS_CONSUMABLE && proto->DisplayInfoID == displayId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);  //changed from thetourist suggestion
+    *packet << m_CurrentlyCastingSpellId;
+    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    // stand up if we are done feasting
+    if (!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    // wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    m_ignoreAIUpdatesUntilTime = currentTime + 3;
+
+    // should we drink another
+    if (m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking
+        && ((static_cast<float> (m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item* pItem = FindDrink();
+        if (pItem != NULL)
+        {
+            UseItem(pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        }
+        TellMaster("I need water.");
+    }
+
+    // should we eat another
+    if (currentTime > m_TimeDoneEating && ((static_cast<float> (m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item* pItem = FindFood();
+        if (pItem != NULL)
+        {
+            //TellMaster("eating now...");
+            UseItem(pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        TellMaster("I need food.");
+    }
+
+    // if we are no longer eating or drinking
+    // because we are out of items or we are above 80% in both stats
+    if (currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        TellMaster("done feasting!");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_lootCurrent = uint64();
+        m_targetCombat = 0;
+    }
+
+    // update attacker info now
+    UpdateAttackerInfo();
+
+    // check for attackers on protected unit, and make it a forcedTarget if any
+    if (!forcedTarget && (m_combatOrder & ORDERS_PROTECT) && m_targetProtect != 0)
+    {
+        Unit *newTarget = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_HIGHESTTHREAT), m_targetProtect);
+        if (newTarget && newTarget != m_targetCombat)
+        {
+            forcedTarget = newTarget;
+            m_targetType = TARGET_THREATEN;
+            if (m_mgr->m_confDebugWhisper)
+                TellMaster("Changing target to %s to protect %s", forcedTarget->GetName(), m_targetProtect->GetName());
+        }
+    }
+    else if (forcedTarget)
+    {
+        if (m_mgr->m_confDebugWhisper)
+            TellMaster("Changing target to %s by force!", forcedTarget->GetName());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+    }
+
+    // we already have a target and we are not forced to change it
+    if (m_targetCombat && !forcedTarget)
+        return;
+
+    // are we forced on a target?
+    if (forcedTarget)
+    {
+        m_targetCombat = forcedTarget;
+        m_targetChanged = true;
+    }
+    // do we have to assist someone?
+    if (!m_targetCombat && (m_combatOrder & ORDERS_ASSIST) && m_targetAssist != 0)
+    {
+        m_targetCombat = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_LOWESTTHREAT), m_targetAssist);
+        if (m_mgr->m_confDebugWhisper && m_targetCombat)
+            TellMaster("Attacking %s to assist %s", m_targetCombat->GetName(), m_targetAssist->GetName());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // are there any other attackers?
+    if (!m_targetCombat)
+    {
+        m_targetCombat = FindAttacker();
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // no attacker found anyway
+    if (!m_targetCombat)
+    {
+        m_targetType = TARGET_NORMAL;
+        m_targetChanged = false;
+        return;
+    }
+
+    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    // this method never gets called when the bot is in a duel and this code
+    // prevents bot from helping
+    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && dynamic_cast<Player*> (m_targetCombat)->duel)
+    {
+        m_ignoreAIUpdatesUntilTime = time(0) + 6;
+        return;
+    }
+
+    m_bot->SetSelection((m_targetCombat->GetGUID()));
+    m_ignoreAIUpdatesUntilTime = time(0) + 1;
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_bot->Attack(m_targetCombat, true);
+
+    // add thingToAttack to loot list
+    m_lootTargets.push_back(m_targetCombat->GetGUID());
+
+    return;
+}
+
+void PlayerbotAI::GetDuelTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_targetChanged = true;
+        m_targetCombat = forcedTarget;
+        m_targetType = TARGET_THREATEN;
+        m_combatStyle = COMBAT_MELEE;
+    }
+    m_bot->Attack(m_targetCombat, true);
+}
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    // check for new targets
+    if (m_ScenarioType == SCENARIO_DUEL)
+        GetDuelTarget(GetMaster());
+    else
+        GetCombatTarget();
+    // check if we have a target - fixes crash reported by rrtn (kill hunter's pet bug)
+    // if current target for attacks doesn't make sense anymore
+    // clear our orders so we can get orders in next update
+    if (!m_targetCombat || m_targetCombat->isDead() || !m_targetCombat->IsInWorld() || !m_bot->IsHostileTo(m_targetCombat) || !m_bot->IsInMap(m_targetCombat))
+    {
+        m_bot->AttackStop();
+        m_bot->SetSelection(uint64());
+        MovementReset();
+        m_bot->InterruptNonMeleeSpells(true);
+        m_targetCombat = 0;
+        m_targetChanged = false;
+        m_targetType = TARGET_NORMAL;
+        SetQuestNeedCreatures();
+        return;
+    }
+
+    // do opening moves, if we changed target
+    if (m_targetChanged)
+    {
+        if (GetClassAI())
+            m_targetChanged = GetClassAI()->DoFirstCombatManeuver(m_targetCombat);
+        else
+            m_targetChanged = false;
+    }
+
+    // do normal combat movement
+    DoCombatMovement();
+
+    if (GetClassAI() && !m_targetChanged)
+        (GetClassAI())->DoNextCombatManeuver(m_targetCombat);
+}
+
+void PlayerbotAI::DoCombatMovement()
+{
+    if (!m_targetCombat) return;
+
+    float targetDist = m_bot->GetDistance(m_targetCombat);
+
+    m_bot->SetFacing(m_bot->GetAngle(m_targetCombat));
+
+    if (m_combatStyle == COMBAT_MELEE && !m_bot->HasUnitState(UNIT_STAT_CHASE) && ((m_movementOrder == MOVEMENT_STAY && targetDist <= ATTACK_DISTANCE) || (m_movementOrder != MOVEMENT_STAY)))
+        // melee combat - chase target if in range or if we are not forced to stay
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+    else if (m_combatStyle == COMBAT_RANGED && m_movementOrder != MOVEMENT_STAY)
+    {
+        // ranged combat - just move within spell range
+        // TODO: just follow in spell range! how to determine bots spell range?
+        if (targetDist > 25.0f)
+            m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        else
+            MovementClear();
+    }
+}
+
+void PlayerbotAI::SetQuestNeedCreatures()
+{
+    // reset values first
+    m_needCreatureOrGOList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredNpcOrGoCount[i] || (qInfo->RequiredNpcOrGoCount[i] - qData.m_creatureOrGOcount[i]) <= 0)
+                continue;
+            m_needCreatureOrGOList[qInfo->RequiredNpcOrGo[i]] = (qInfo->RequiredNpcOrGoCount[i] - qData.m_creatureOrGOcount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    // reset values first
+    m_needItemList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // check for items we not have enough of
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredItemCount[i] || (qInfo->RequiredItemCount[i] - qData.m_itemcount[i]) <= 0)
+                continue;
+            m_needItemList[qInfo->RequiredItemId[i]] = (qInfo->RequiredItemCount[i] - qData.m_itemcount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetState(BotState state)
+{
+    // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: SetState - %s switch state %d to %d", m_bot->GetName(), m_botState, state );
+    m_botState = state;
+}
+
+uint8 PlayerbotAI::GetFreeBagSpace() const
+{
+    uint8 space = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (!pItem)
+            ++space;
+    }
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        Bag* pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pBag && pBag->GetTemplate()->BagFamily == BAG_FAMILY_MASK_NONE)
+            space += pBag->GetFreeSlots();
+    }
+    return space;
+}
+
+void PlayerbotAI::DoFlight()
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: DoFlight - %s : %s", m_bot->GetName(), uint32(GUID_LOPART(m_taxiMaster)));
+
+    Creature *npc = m_bot->GetNPCIfCanInteractWith(m_taxiMaster, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!npc)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: DoFlight - %s not found or you can't interact with it.", GUID_LOPART(m_taxiMaster));
+        return;
+    }
+
+    m_bot->ActivateTaxiPathTo(m_taxiNodes, npc);
+}
+
+void PlayerbotAI::DoLoot()
+{
+    // clear BOTSTATE_LOOTING if no more loot targets
+    if (!m_lootCurrent && m_lootTargets.empty())
+    {
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: DoLoot - %s is going back to idle", m_bot->GetName() );
+        SetState(BOTSTATE_NORMAL);
+        m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+        m_inventory_full = false;
+        return;
+    }
+
+    // set first in list to current
+    if (m_lootCurrent)
+    {
+        m_lootCurrent = m_lootTargets.front();
+        m_lootTargets.pop_front();
+    }
+
+    WorldObject *wo = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+
+    // clear invalid object or object that is too far from master
+    if (!wo || GetMaster()->GetDistance(wo) > BOTLOOT_DISTANCE)
+    {
+        m_lootCurrent = uint64();
+        return;
+    }
+
+    Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+
+    // clear creature or object that is not spawned or if not creature or object
+    if ((c && c->getDeathState() != CORPSE) || (go && !go->isSpawned()) || (!c && !go))
+    {
+        m_lootCurrent = uint64();
+        return;
+    }
+
+    uint32 skillId = 0;
+
+    if (c)
+    {
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
+
+        // not a lootable creature, clear it
+        if (!c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) &&
+            (!c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) ||
+             (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && !m_bot->HasSkill(skillId))))
+        {
+            m_lootCurrent = uint64();
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            return;
+        }
+    }
+
+    if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+    {
+        float x, y, z;
+        wo->GetContactPoint(m_bot, x, y, z, 0.1f);
+        m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+        // give time to move to point before trying again
+        SetIgnoreUpdateTime(1);
+    }
+
+    if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+    {
+        uint32 reqSkillValue = 0;
+        uint32 SkillValue = 0;
+        bool keyFailed = false;
+        bool skillFailed = false;
+        bool forceFailed = false;
+
+        if (c)  // creature
+        {
+            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            {
+                // loot the creature
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+                *packet << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packet);
+                return; // no further processing is needed
+                // m_lootCurrent is reset in SMSG_LOOT_RELEASE_RESPONSE after checking for skinloot
+            }
+            else if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+                // not all creature skins are leather, some are ore or herb
+                if (m_bot->HasSkill(skillId) && ((skillId != SKILL_SKINNING) ||
+                                                 (HasCollectFlag(COLLECT_FLAG_SKIN) && skillId == SKILL_SKINNING)))
+                {
+                    // calculate skinning skill requirement
+                    uint32 targetLevel = c->getLevel();
+                    reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                }
+
+            // creatures cannot be unlocked or forced open
+            keyFailed = true;
+            forceFailed = true;
+        }
+
+        if (go) // object
+        {
+            // add this GO to our collection list if active and is chest/ore/herb
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+            {
+                m_collectObjects.push_back(go->GetEntry());
+                m_collectObjects.sort();
+                m_collectObjects.unique();
+            }
+
+            uint32 reqItem = 0;
+
+            // check skill or lock on object
+            uint32 lockId = go->GetGOInfo()->GetLockId();
+            LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+            if (lockInfo)
+                for (int i = 0; i < 8; ++i)
+                {
+                    if (lockInfo->Type[i] == LOCK_KEY_ITEM)
+                    {
+                        if (lockInfo->Index[i] > 0)
+                        {
+                            reqItem = lockInfo->Index[i];
+                            if (m_bot->HasItemCount(reqItem, 1))
+                                break;
+                            continue;
+                        }
+                    }
+                    else if (lockInfo->Type[i] == LOCK_KEY_SKILL)
+                    {
+                        switch (LockType(lockInfo->Index[i]))
+                        {
+                            case LOCKTYPE_OPEN:
+                                if (CastSpell(3365))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_CLOSE:
+                                if (CastSpell(6233))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_OPEN:
+                                if (CastSpell(6247))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_CLOSE:
+                                if (CastSpell(6247))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_TINKERING:
+                                if (CastSpell(6477))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_KNEELING:
+                                if (CastSpell(6478))    // Opening; listed with 17667 and 22810
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_ATTACKING:
+                                if (CastSpell(8386))    // Attacking
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_OPEN:
+                                if (CastSpell(21651))   // Opening; also had 26868
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_CLOSE:
+                                if (CastSpell(21652))   // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_FROM_VEHICLE:
+                                if (CastSpell(61437))   // Opening
+                                    return;
+                                break;
+                            default:
+                                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                                {
+                                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                                    reqSkillValue = lockInfo->Skill[i];
+                                }
+                        }
+                    }
+                }
+
+            // use key on object if available
+            if (reqItem > 0 && m_bot->HasItemCount(reqItem, 1))
+            {
+                UseItem(m_bot->GetItemByEntry(reqItem), TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                m_lootCurrent = uint64();
+                return;
+            }
+            else
+                keyFailed = true;
+        }
+
+        // determine bot's skill value for object's required skill
+        if (skillId != SKILL_NONE)
+            SkillValue = uint32(m_bot->GetPureSkillValue(skillId));
+
+        // bot has the specific skill or object requires no skill at all
+        if ((m_bot->HasSkill(skillId) && skillId != SKILL_NONE) || (skillId == SKILL_NONE && go))
+        {
+            if (SkillValue >= reqSkillValue)
+            {
+                switch (skillId)
+                {
+                    case SKILL_MINING:
+                        if (HasTool(TC_MINING_PICK) && CastSpell(MINING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_HERBALISM:
+                        if (CastSpell(HERB_GATHERING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_SKINNING:
+                        if (c && HasCollectFlag(COLLECT_FLAG_SKIN) &&
+                            HasTool(TC_SKINNING_KNIFE) && CastSpell(SKINNING, *c))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_LOCKPICKING:
+                        if (CastSpell(PICK_LOCK_1))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_NONE:
+                        if (CastSpell(3365)) //Spell 3365 = Opening?
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    default:
+                        TellMaster("I'm not sure how to get that.");
+                        skillFailed = true;
+                        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]:DoLoot Skill %u is not implemented", skillId);
+                        break;
+                }
+            }
+            else
+            {
+                TellMaster("My skill is not high enough. It requires %u, but mine is %u.",
+                           reqSkillValue, SkillValue);
+                skillFailed = true;
+            }
+        }
+        else
+        {
+            TellMaster("I do not have the required skill.");
+            skillFailed = true;
+        }
+
+        if (go) // only go's can be forced
+        {
+            // if pickable, check if a forcible item is available for the bot
+            if (skillId == SKILL_LOCKPICKING && (m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                                                 m_bot->HasSkill(SKILL_ENGINEERING)))
+            {
+                // check for skeleton keys appropriate for lock value
+                if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                {
+                    Item *kItem = FindKeyForLockValue(reqSkillValue);
+                    if (kItem)
+                    {
+                        TellMaster("I have a skeleton key that can open it!");
+                        UseItem(kItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have no skeleton keys that can open that lock.");
+                        forceFailed = true;
+                    }
+                }
+
+                // check for a charge that can blast it open
+                if (m_bot->HasSkill(SKILL_ENGINEERING))
+                {
+                    Item *bItem = FindBombForLockValue(reqSkillValue);
+                    if (bItem)
+                    {
+                        TellMaster("I can blast it open!");
+                        UseItem(bItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have nothing to blast it open with.");
+                        forceFailed = true;
+                    }
+                }
+            }
+            else
+                forceFailed = true;
+        }
+
+        // if all attempts failed in some way then clear because it won't get SMSG_LOOT_RESPONSE
+        if (keyFailed && skillFailed && forceFailed)
+        {
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: DoLoot attempts failed on [%s]",
+                       go ? go->GetGOInfo()->name : c->GetCreatureInfo()->Name);
+            m_lootCurrent = uint64();
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+void PlayerbotAI::AcceptQuest(Quest const *qInfo, Player *pGiver)
+{
+    if (!qInfo || !pGiver)
+        return;
+
+    uint32 quest = qInfo->GetQuestId();
+
+    if (!pGiver->CanShareQuest(qInfo->GetQuestId()))
+    {
+        // giver can't share quest
+        m_bot->SetDivider(0);
+        return;
+    }
+
+    if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        // can't take quest
+        m_bot->SetDivider(0);
+        return;
+    }
+
+    if (m_bot->GetDivider())
+    {
+        // send msg to quest giving player
+        pGiver->SendPushToPartyResponse(m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST);
+        m_bot->SetDivider(0);
+    }
+
+    if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, pGiver);
+
+        if (m_bot->CanCompleteQuest(quest))
+            m_bot->CompleteQuest(quest);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if (qInfo->GetSrcSpell() > 0)
+            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), true);
+    }
+}
+
+void PlayerbotAI::TurnInQuests(WorldObject *questgiver)
+{
+    uint64 giverGUID = questgiver->GetGUID();
+
+    if (!m_bot->IsInMap(questgiver))
+        TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(giverGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(giverGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.QuestId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (!m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemTemplate const *pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                    }
+
+                    // else multiple rewards - let master pick
+                    else
+                    {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i = 0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE)
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            else if (status == QUEST_STATUS_AVAILABLE)
+                out << "|cff00ff00Quest available:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            if (!out.str().empty())
+                TellMaster(out.str());
+        }
+    }
+}
+
+bool PlayerbotAI::IsInCombat()
+{
+    Pet *pet;
+    bool inCombat = false;
+    inCombat |= m_bot->isInCombat();
+    pet = m_bot->GetPet();
+    if (pet)
+        inCombat |= pet->isInCombat();
+    inCombat |= GetMaster()->isInCombat();
+    if (m_bot->GetGroup())
+    {
+        GroupReference *ref = m_bot->GetGroup()->GetFirstMember();
+        while (ref)
+        {
+            inCombat |= ref->getSource()->isInCombat();
+            pet = ref->getSource()->GetPet();
+            if (pet)
+                inCombat |= pet->isInCombat();
+            ref = ref->next();
+        }
+    }
+    return inCombat;
+}
+
+void PlayerbotAI::UpdateAttackersForTarget(Unit *victim)
+{
+    HostileReference *ref = victim->getHostileRefManager().getFirst();
+    while (ref)
+    {
+        ThreatManager *target = ref->getSource();
+        uint64 guid = target->getOwner()->GetGUID();
+        m_attackerInfo[guid].attacker = target->getOwner();
+        m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+        m_attackerInfo[guid].threat = target->getThreat(victim);
+        m_attackerInfo[guid].count = 1;
+        //m_attackerInfo[guid].source = 1; // source is not used so far.
+        ref = ref->next();
+    }
+}
+
+void PlayerbotAI::UpdateAttackerInfo()
+{
+    // clear old list
+    m_attackerInfo.clear();
+
+    // check own attackers
+    UpdateAttackersForTarget(m_bot);
+    Pet *pet = m_bot->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check master's attackers
+    UpdateAttackersForTarget(GetMaster());
+    pet = GetMaster()->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check all group members now
+    if (m_bot->GetGroup())
+    {
+        GroupReference *gref = m_bot->GetGroup()->GetFirstMember();
+        while (gref)
+        {
+            if (gref->getSource() == m_bot || gref->getSource() == GetMaster())
+            {
+                gref = gref->next();
+                continue;
+            }
+
+            UpdateAttackersForTarget(gref->getSource());
+            pet = gref->getSource()->GetPet();
+            if (pet)
+                UpdateAttackersForTarget(pet);
+
+            gref = gref->next();
+        }
+    }
+
+    // get highest threat not caused by bot for every entry in AttackerInfoList...
+    for (AttackerInfoList::iterator itr = m_attackerInfo.begin(); itr != m_attackerInfo.end(); ++itr)
+    {
+        if (!itr->second.attacker)
+            continue;
+        Unit *a = itr->second.attacker;
+        float t = 0.00;
+        std::list<HostileReference*>::const_iterator i = a->getThreatManager().getThreatList().begin();
+        for (; i != a->getThreatManager().getThreatList().end(); ++i)
+        {
+            if ((*i)->getThreat() > t && (*i)->getTarget() != m_bot)
+                t = (*i)->getThreat();
+        }
+        m_attackerInfo[itr->first].threat2 = t;
+    }
+
+    // DEBUG: output attacker info
+    //sLog->outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
+    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
+    //    sLog->outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
+    //        i->first,
+    //        (i->second.attacker?i->second.attacker->GetGUIDLow():0),
+    //        (i->second.victim?i->second.victim->GetGUIDLow():0),
+    //        i->second.threat,
+    //        i->second.threat2,
+    //        i->second.count,
+    //        i->second.source );
+    //sLog->outBasic( "[PlayerbotAI]: };" );
+}
+
+uint32 PlayerbotAI::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(((INVENTORY_SLOT_BAG_0 << 8) | i));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for (int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for (int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(((j << 8) | i));
+    return TotalCost;
+}
+
+uint32 PlayerbotAI::EstRepair(uint16 pos)
+{
+    Item* item = m_bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if (!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if (!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if (LostDurability > 0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if (!dcost)
+        {
+            sLog->outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if (!dQualitymodEntry)
+        {
+            sLog->outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod));
+
+        if (costs == 0)                                 //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
+
+Unit* PlayerbotAI::FindAttacker(ATTACKERINFOTYPE ait, Unit *victim)
+{
+    // list empty? why are we here?
+    if (m_attackerInfo.empty())
+        return 0;
+
+    // not searching something specific - return first in list
+    if (!ait)
+        return (m_attackerInfo.begin())->second.attacker;
+
+    float t = ((ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00);
+    Unit *a = 0;
+    AttackerInfoList::iterator itr = m_attackerInfo.begin();
+    for (; itr != m_attackerInfo.end(); ++itr)
+    {
+        if ((ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot)
+            continue;
+
+        if (!(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot)
+            continue;
+
+        if ((ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim)
+            continue;
+
+        if (!(ait & (AIT_LOWESTTHREAT | AIT_HIGHESTTHREAT)))
+        {
+            a = itr->second.attacker;
+            itr = m_attackerInfo.end();
+        }
+        else
+        {
+            if ((ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat >= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+            else if ((ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat <= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+        }
+    }
+    return a;
+}
+
+void PlayerbotAI::SetCombatOrderByStr(std::string str, Unit *target)
+{
+    CombatOrderType co;
+    if (str == "tank") co = ORDERS_TANK;
+    else if (str == "assist") co = ORDERS_ASSIST;
+    else if (str == "heal") co = ORDERS_HEAL;
+    else if (str == "protect") co = ORDERS_PROTECT;
+    else
+        co = ORDERS_RESET;
+    SetCombatOrder(co, target);
+}
+
+void PlayerbotAI::SetCombatOrder(CombatOrderType co, Unit *target)
+{
+    if ((co == ORDERS_ASSIST || co == ORDERS_PROTECT) && !target) {
+        TellMaster("Erf, you forget to target assist/protect characters!");
+        return;
+    }
+    if (co == ORDERS_RESET) {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+        TellMaster("Orders are cleaned!");
+        return;
+    }
+    if (co == ORDERS_PROTECT)
+        m_targetProtect = target;
+    else if (co == ORDERS_ASSIST)
+        m_targetAssist = target;
+    if ((co & ORDERS_PRIMARY))
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_SECONDARY) | (uint32) co);
+    else
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_PRIMARY) | (uint32) co);
+    SendOrders(*GetMaster());
+}
+
+void PlayerbotAI::SetMovementOrder(MovementOrderType mo, Unit *followTarget)
+{
+    m_movementOrder = mo;
+    m_followTarget = followTarget;
+    MovementReset();
+}
+
+void PlayerbotAI::MovementReset()
+{
+    // stop moving...
+    MovementClear();
+
+    if (m_movementOrder == MOVEMENT_FOLLOW)
+    {
+        if (!m_followTarget)
+            return;
+
+        WorldObject* distTarget = m_followTarget;   // target to distance check
+
+        // don't follow while in combat
+        if (m_bot->isInCombat())
+            return;
+
+        Player* pTarget;                            // target is player
+        if (m_followTarget->GetTypeId() == TYPEID_PLAYER)
+            pTarget = ((Player*) m_followTarget);
+
+        if (pTarget)
+        {
+            // check player for follow situations
+            if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+                return;
+
+            // use player's corpse as distance check target
+            if (pTarget->GetCorpse())
+                distTarget = pTarget->GetCorpse();
+        }
+
+        // is bot too far from the follow target
+        if (!m_bot->IsWithinDistInMap(distTarget, 50))
+        {
+            DoTeleport(*m_followTarget);
+            return;
+        }
+
+        if (m_bot->isAlive() && !m_bot->IsBeingTeleported())
+        {
+            float angle = rand_float(0, M_PI);
+            float dist = rand_float(m_mgr->m_confFollowDistance[0], m_mgr->m_confFollowDistance[1]);
+            m_bot->GetMotionMaster()->MoveFollow(m_followTarget, dist, angle);
+        }
+    }
+}
+
+void PlayerbotAI::MovementClear()
+{
+    // stop...
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->ClearUnitState(UNIT_STAT_CHASE);
+    m_bot->ClearUnitState(UNIT_STAT_FOLLOW);
+
+    // stand up...
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+void PlayerbotAI::PlaySound(uint32 soundid)
+{
+    WorldPacket data(SMSG_PLAY_SOUND, 4);
+    data << soundid;
+    GetMaster()->GetSession()->SendPacket(&data);
+}
+
+// PlaySound data from SoundEntries.dbc
+void PlayerbotAI::Announce(AnnounceFlags msg)
+{
+    switch (m_bot->getRace())
+    {
+        case RACE_HUMAN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1908) : PlaySound(2032); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1875) : PlaySound(1999); break;
+                default: break;
+            }
+            break;
+        case RACE_ORC:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2319) : PlaySound(2374); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2284) : PlaySound(2341); break;
+                default: break;
+            }
+            break;
+        case RACE_DWARF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1630) : PlaySound(1686); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1581) : PlaySound(1654); break;
+                default: break;
+            }
+            break;
+        case RACE_NIGHTELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2151) : PlaySound(2262); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2118) : PlaySound(2229); break;
+                default: break;
+            }
+            break;
+        case RACE_UNDEAD_PLAYER:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2096) : PlaySound(2207); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2054) : PlaySound(2173); break;
+                default: break;
+            }
+            break;
+        case RACE_TAUREN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2463) : PlaySound(2462); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2396) : PlaySound(2397); break;
+                default: break;
+            }
+            break;
+        case RACE_GNOME:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1743) : PlaySound(1798); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1708) : PlaySound(1709); break;
+                default: break;
+            }
+            break;
+        case RACE_TROLL:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1853) : PlaySound(1963); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1820) : PlaySound(1930); break;
+                default: break;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(9583) : PlaySound(9584); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(9549) : PlaySound(9550); break;
+                default: break;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(9498) : PlaySound(9499); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(9465) : PlaySound(9466); break;
+                default: break;
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+bool PlayerbotAI::IsMoving()
+{
+    return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
+}
+
+// some possible things to use in AI
+// GetRandomContactPoint
+// GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// HasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 /*p_time*/)
+{
+    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+        return;
+
+    time_t currentTime = time(0);
+    if (currentTime < m_ignoreAIUpdatesUntilTime)
+        return;
+
+    // default updates occur every two seconds
+    m_ignoreAIUpdatesUntilTime = time(0) + 2;
+
+    if (!m_bot->isAlive())
+    {
+        if (m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED)
+        {
+            // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - %s died and is not in correct state...", m_bot->GetName() );
+            // clear loot list on death
+            m_lootTargets.clear();
+            m_lootCurrent = uint64();
+            // clear combat orders
+            m_bot->SetSelection(uint64());
+            m_bot->GetMotionMaster()->Clear(true);
+            // set state to dead
+            SetState(BOTSTATE_DEAD);
+            // wait 30sec
+            m_ignoreAIUpdatesUntilTime = time(0) + 30;
+        }
+        else if (m_botState == BOTSTATE_DEAD)
+        {
+            // become ghost
+            if (m_bot->GetCorpse()) {
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - %s already has a corpse...", m_bot->GetName() );
+                SetState(BOTSTATE_DEADRELEASED);
+                return;
+            }
+            m_bot->SetBotDeathTimer();
+            m_bot->BuildPlayerRepop();
+            // relocate ghost
+            WorldLocation loc;
+            Corpse *corpse = m_bot->GetCorpse();
+            corpse->GetPosition(&loc);
+            m_bot->NearTeleportTo(loc.GetPositionX(), loc.GetPositionY(), loc.GetPositionZ(), m_bot->GetOrientation());
+            // set state to released
+            SetState(BOTSTATE_DEADRELEASED);
+        }
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+        {
+            // get bot's corpse
+            Corpse *corpse = m_bot->GetCorpse();
+            if (!corpse)
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - %s has no corpse!", m_bot->GetName() );
+                return;
+            // teleport ghost from graveyard to corpse
+            // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - Teleport %s to corpse...", m_bot->GetName() );
+            DoTeleport(*corpse);
+            // check if we are allowed to resurrect now
+            if (corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP) > time(0))
+            {
+                m_ignoreAIUpdatesUntilTime = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-time(0) );
+                return;
+            }
+            // resurrect now
+            // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: UpdateAI - Reviving %s to corpse...", m_bot->GetName() );
+            m_ignoreAIUpdatesUntilTime = time(0) + 6;
+            PlayerbotChatHandler ch(GetMaster());
+            if (!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return;
+            }
+            // set back to normal
+            SetState(BOTSTATE_NORMAL);
+        }
+    }
+    else
+    {
+        if (!m_findNPC.empty())
+            findNearbyCreature();
+
+        // if we are casting a spell then interrupt it
+        // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+        Spell* const pSpell = GetCurrentSpell();
+        if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat()))
+            InterruptCurrentCastingSpell();
+
+        // direct cast command from master
+        else if (m_spellIdCommand != 0)
+        {
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+            if (pTarget)
+                CastSpell(m_spellIdCommand, *pTarget);
+            m_spellIdCommand = 0;
+            m_targetGuidCommand = uint64();
+        }
+
+        //if master is unmounted, unmount the bot
+        else if (!GetMaster()->IsMounted() && m_bot->IsMounted())
+        {
+            WorldPacket emptyPacket;
+            m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+        }
+
+        // handle combat (either self/master/group in combat, or combat state and valid target)
+        else if (IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) ||  m_ScenarioType == SCENARIO_DUEL)
+        {
+            //check if the bot is Mounted
+            if (!m_bot->IsMounted())
+            {
+                if (!pSpell || !pSpell->IsChannelActive())
+                    DoNextCombatManeuver();
+                else
+                    SetIgnoreUpdateTime(1);  // It's better to update AI more frequently during combat
+            }
+        }
+        // bot was in combat recently - loot now
+        else if (m_botState == BOTSTATE_COMBAT)
+        {
+            SetState(BOTSTATE_LOOTING);
+            m_attackerInfo.clear();
+            if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+                m_lootTargets.unique();
+            else
+                m_lootTargets.clear();
+            SetIgnoreUpdateTime();
+        }
+        else if (m_botState == BOTSTATE_LOOTING)
+            DoLoot();
+        else if (m_botState == BOTSTATE_FLYING)
+        {
+            /* std::ostringstream out;
+               out << "Taxi: " << m_bot->GetName() << m_ignoreAIUpdatesUntilTime;
+               TellMaster(out.str().c_str()); */
+            DoFlight();
+            SetState(BOTSTATE_NORMAL);
+            SetIgnoreUpdateTime();
+        }
+        // if commanded to follow master and not already following master then follow master
+        else if (!m_bot->isInCombat() && !IsMoving())
+            MovementReset();
+
+        // do class specific non combat actions
+        else if (GetClassAI() && !m_bot->IsMounted())
+        {
+            (GetClassAI())->DoNonCombatActions();
+
+            // have we been told to collect GOs
+            if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+            {
+                findNearbyGO();
+                // start looting if have targets
+                if (!m_lootTargets.empty())
+                    SetState(BOTSTATE_LOOTING);
+            }
+        }
+    }
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0)
+        return NULL;
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string& text) const
+{
+    SendWhisper(text, *GetMaster());
+}
+
+void PlayerbotAI::TellMaster(const char *fmt, ...) const
+{
+    char temp_buf[1024];
+    va_list ap;
+    va_start(ap, fmt);
+    (void) vsnprintf(temp_buf, 1024, fmt, ap);
+    va_end(ap);
+    std::string str = temp_buf;
+    TellMaster(str);
+}
+
+void PlayerbotAI::SendWhisper(const std::string& text, Player& player) const
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
+{
+    return player.GetSession()->GetAccountId() == GetMaster()->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::IsInRange(Unit* Target, uint32 spellId)
+{
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    SpellRangeEntry const* TempRange = GetSpellRangeStore()->LookupEntry(pSpellInfo->rangeIndex);
+
+    //Spell has invalid range store so we can't use it
+    if (!TempRange)
+        return false;
+
+    if (TempRange->minRangeHostile == TempRange->maxRangeHostile == 0.0f)
+        return true;
+
+    //Unit is out of range of this spell
+    if (!m_bot->IsInRange(Target, TempRange->minRangeHostile, TempRange->maxRangeHostile))
+        return false;
+
+    return true;
+}
+
+bool PlayerbotAI::CastSpell(const char* args)
+{
+    uint32 spellId = getSpellId(args);
+    return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
+{
+    uint64 oldSel = m_bot->GetSelection();
+    m_bot->SetSelection(target.GetGUID());
+    bool rv = CastSpell(spellId);
+    m_bot->SetSelection(oldSel);
+    return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId)
+{
+    // some AIs don't check if the bot doesn't have spell before using it
+    // so just return false when this happens
+    if (spellId == 0)
+        return false;
+
+    // check spell cooldown
+    if (m_bot->HasSpellCooldown(spellId))
+        return false;
+
+    // see Creature.cpp 1738 for reference
+    // don't allow bot to cast damage spells on friends
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastSpell for spellid %u.", spellId);
+        return false;
+    }
+
+    // set target
+    uint64 targetGUID = m_bot->GetSelection();
+    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
+
+    if (!pTarget)
+        pTarget = m_bot;
+
+    /*if (spellInfo->IsPositive(spellId))
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {*/
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        m_bot->SetFacing(m_bot->GetAngle(pTarget));
+    //}
+
+    float CastTime = 0.0f;
+
+    // stop movement to prevent cancel spell casting
+    SpellCastTimesEntry const * castTimeEntry = sSpellCastTimesStore.LookupEntry(pSpellInfo->CastingTimeIndex);
+    if (castTimeEntry && castTimeEntry->CastTime)
+    {
+        CastTime = (castTimeEntry->CastTime / 1000);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: CastSpell - Bot movement reset for casting %s (%u)", pSpellInfo->SpellName[0], spellId);
+        m_bot->StopMoving();
+    }
+
+    uint32 target_type = TARGET_FLAG_UNIT;
+
+    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK)
+        target_type = TARGET_FLAG_GAMEOBJECT;
+
+    m_CurrentlyCastingSpellId = spellId;
+
+    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effect[0] == SPELL_EFFECT_SKINNING)
+    {
+        if (m_lootCurrent)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_CAST_SPELL, 1 + 4 + 1 + 4 + 8);
+            *packet << uint8(0);                            // spells cast count;
+            *packet << spellId;
+            *packet << uint8(0);                            // unk_flags
+            *packet << uint32(target_type);
+            //*packet << m_lootCurrent.WriteAsPacked();
+            m_bot->GetSession()->QueuePacket(packet);       // queue the packet to get around race condition
+
+            if (target_type == TARGET_FLAG_GAMEOBJECT)
+            {
+                WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+                *packetgouse << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packetgouse);  // queue the packet to get around race condition
+
+                GameObject *obj = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+                if (!obj)
+                    return false;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    m_bot->PrepareQuestMenu(m_lootCurrent);
+                    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.QuestId;
+                        if (!AddQuest(questID, obj))
+                            TellMaster("Couldn't take quest");
+                    }
+                    m_lootCurrent = uint64();
+                    m_bot->GetMotionMaster()->Clear();
+                    m_bot->GetMotionMaster()->MoveIdle();
+                }
+            }
+            return true;
+        }
+        else
+            return false;
+    }
+    else
+    {
+        // Check spell range
+        if (!IsInRange(pTarget, spellId))
+            return false;
+
+        // Check line of sight
+        if (!m_bot->IsWithinLOSInMap(pTarget))
+            return false;
+
+        m_bot->CastSpell(pTarget, spellId, true);       // actually cast spell
+    }
+
+    /*if (IsChanneledSpell(pSpellInfo))
+        m_ignoreAIUpdatesUntilTime = time(0) + CastTime + 1;
+    else*/
+        m_ignoreAIUpdatesUntilTime = time(0) + 2;
+
+    m_CurrentlyCastingSpellId = 0;
+
+    // if this caused the caster to move (blink) update the position
+    // I think this is normally done on the client
+    // this should be done on spell success
+    /*
+       if (name == "Blink") {
+       float x,y,z;
+       m_bot->GetPosition(x,y,z);
+       m_bot->GetNearPoint(m_bot, x, y, z, 1, 5, 0);
+       m_bot->Relocate(x,y,z);
+       m_bot->SendHeartBeat();
+
+       }
+     */
+
+    return true;
+}
+
+bool PlayerbotAI::CastPetSpell(uint32 spellId, Unit* target)
+{
+    if (spellId == 0)
+        return false;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return false;
+
+    if (pet->HasSpellCooldown(spellId))
+        return false;
+
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastPetSpell()");
+        return false;
+    }
+
+    // set target
+    Unit* pTarget;
+    if (!target)
+    {
+        uint64 targetGUID = m_bot->GetSelection();
+        pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
+    }
+    else
+        pTarget = target;
+
+    /*if (IsPositive(spellId))
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {*/
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        if (!pet->isInFrontInMap(pTarget, 10)) // distance probably should be calculated
+            pet->SetFacing(pet->GetAngle(pTarget));
+    //}
+
+    pet->CastSpell(pTarget, spellId, false);
+
+    Spell* const pSpell = pet->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell)
+        return false;
+
+    return true;
+}
+
+// Perform sanity checks and cast spell
+bool PlayerbotAI::Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player *))
+{
+    if (spellId == 0)
+        return false;
+
+    SpellEntry const * spellProto = sSpellStore.LookupEntry(spellId);
+
+    if (!spellProto)
+        return false;
+
+    if (!target)
+        return false;
+
+    // Select appropriate spell rank for target's level
+    /*spellProto = sSpellMgr->SelectAuraRankForPlayerLevel(spellProto, target->getLevel());
+    if (!spellProto)
+        return false;
+*/
+    // Check if spell will boost one of already existent auras
+    bool willBenefitFromSpell = false;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellProto->EffectApplyAuraName[i] == SPELL_AURA_NONE)
+            break;
+
+        bool sameOrBetterAuraFound = false;
+        //int32 bonus = m_bot->CalculateSpellDamage(target, spellProto, effect_index(i));
+        //Unit::AuraList const& auras = target->GetAuraEffectsByType(AuraType(spellProto->EffectApplyAuraName[i]));
+        /*for (Unit::AuraList::const_iterator it = auras.begin(); it != auras.end(); ++it)
+            if ((*it)->GetModifier()->m_miscvalue == spellProto->EffectMiscValue[i] && (*it)->GetModifier()->m_amount >= bonus)
+            {
+                sameOrBetterAuraFound = true;
+                break;
+            }*/
+        willBenefitFromSpell = willBenefitFromSpell || !sameOrBetterAuraFound;
+    }
+
+    if (!willBenefitFromSpell)
+        return false;
+
+    // Druids may need to shapeshift before casting
+    if (beforeCast)
+        (*beforeCast)(m_bot);
+
+    return CastSpell(spellProto->Id, *target);
+}
+
+// Can be used for personal buffs like Mage Armor and Inner Fire
+bool PlayerbotAI::SelfBuff(uint32 spellId)
+{
+    if (spellId == 0)
+        return false;
+
+    if (m_bot->HasAura(spellId))
+        return false;
+
+    return CastSpell(spellId, *m_bot);
+}
+
+// Checks if spell is single per target per caster and will make any effect on target
+bool PlayerbotAI::CanReceiveSpecificSpell(uint8 spec, Unit* target) const
+{
+    /*if (IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific(spec), SpellSpecific(spec)))
+    {
+        Unit::SpellAuraHolderMap holders = target->GetSpellAuraHolderMap();
+        Unit::SpellAuraHolderMap::iterator it;
+        for (it = holders.begin(); it != holders.end(); ++it)
+            if ((*it).second->GetCasterGuid() == m_bot->GetGUID() && GetSpellSpecific((*it).second->GetId()) == SpellSpecific(spec))
+                return false;
+    }*/
+    return true;
+}
+
+Item* PlayerbotAI::FindItem(uint32 ItemId)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+            if (!proto)
+                continue;
+
+            if (proto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+                    if (!proto)
+                        continue;
+
+                    if (proto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindItemInBank(uint32 ItemId)
+{
+    // list out items in bank item slots
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot);
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* proto = pItem->GetTemplate();
+            if (!proto)
+                continue;
+
+            if (proto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in bank bag slots
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug("[%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* proto = pItem->GetTemplate();
+                    if (!proto)
+                        continue;
+
+                    if (proto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindKeyForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 25 && m_bot->HasItemCount(SILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(SILVER_SKELETON_KEY);
+    if (reqSkillValue <= 125 && m_bot->HasItemCount(GOLDEN_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(GOLDEN_SKELETON_KEY);
+    if (reqSkillValue <= 200 && m_bot->HasItemCount(TRUESILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TRUESILVER_SKELETON_KEY);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(ARCANITE_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(ARCANITE_SKELETON_KEY);
+    if (reqSkillValue <= 375 && m_bot->HasItemCount(TITANIUM_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TITANIUM_SKELETON_KEY);
+    if (reqSkillValue <= 400 && m_bot->HasItemCount(COBALT_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(COBALT_SKELETON_KEY);
+
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBombForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 150 && m_bot->HasItemCount(SMALL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(SMALL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 250 && m_bot->HasItemCount(LARGE_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(LARGE_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(POWERFUL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(POWERFUL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 350 && m_bot->HasItemCount(ELEMENTAL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(ELEMENTAL_SEAFORIUM_CHARGE);
+
+    return NULL;
+}
+
+bool PlayerbotAI::HasTool(uint32 TC)
+{
+    std::ostringstream out;
+
+    switch (TC)
+    {
+        case TC_MINING_PICK:
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffffffffI do not have a pick!";
+            break;
+
+        case TC_SKINNING_KNIFE:
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffffffffI do not have a skinning knife!";
+            break;
+        default:
+            out << "|cffffffffI do not know what tool that needs!";
+    }
+    TellMaster(out.str().c_str());
+    return false;
+}
+
+bool PlayerbotAI::HasSpellReagents(uint32 spellId)
+{
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    if (pSpellInfo)
+        return true;
+
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+
+        if (!m_bot->HasItemCount(itemid, count))
+            return false;
+    }
+
+    return true;
+}
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractQuestIds(const std::string& text, std::list<uint32>& questIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hquest:", pos);
+        if (i == std::string::npos)
+            break;
+        pos = i + 7;
+        int endPos = text.find(':', pos);
+        if (endPos == std::string::npos)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            questIds.push_back(id);
+    }
+}
+
+// Build an hlink for Weapon skills in Aqua
+void PlayerbotAI::MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid)
+{
+    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    out << "|cff00ffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << " : " << m_bot->GetSkillValue(skillid) << " /" << m_bot->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+// Build an hlink for spells in White
+void PlayerbotAI::MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out)
+{
+    int    loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
+}
+
+// Builds a hlink for an item, but since its
+// only a ItemTemplate, we cant fill in everything
+void PlayerbotAI::MakeItemLink(const ItemTemplate *item, std::ostringstream &out)
+{
+    // Color
+    out << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << item->ItemId << ":";
+
+    // Permanent enchantment, gems, 4 unknowns, and reporter_level
+    // ->new items wont have enchantments or gems so..
+    out << "0:0:0:0:0:0:0:0:0";
+
+    // Name
+    std::string name = item->Name1;
+    ItemLocalization(name, item->ItemId);
+    out << "|h[" << name << "]|h|r";
+}
+
+// Builds a hlink for an item, includes everything
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
+void PlayerbotAI::MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemTemplate *proto = item->GetTemplate();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << proto->ItemId << ":";
+
+    // Permanent enchantment
+    out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    // Gems
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+        if (!eId) continue;
+
+        SpellItemEnchantmentEntry const* entry = sSpellItemEnchantmentStore.LookupEntry(eId);
+        if (!entry) continue;
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 1: g1 = entry->GemID; break;
+            case 2: g2 = entry->GemID; break;
+            case 3: g3 = entry->GemID; break;
+        }
+    }
+    out << g1 << ":" << g2 << ":" << g3 << ":";
+
+    // Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
+    // Other stuff, don't know what it is
+    out << "0:0:0:0:";
+
+    // Reporter Level
+    out << "0";
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+void PlayerbotAI::extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htitle:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            auctionIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractSpellId(const std::string& text, uint32 &spellId) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+
+    int i = text.find("Hspell:", pos);
+    if (i == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: extractSpellId - first pos %u i %u",pos,i);
+    pos = i + 7;     // start of window in text 16 + 7 = 23
+    int endPos = text.find('|', pos);
+    if (endPos == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: extractSpellId - second endpos : %u pos : %u",endPos,pos);
+    std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+    spellId = atol(idC.c_str());
+    pos = endPos;     // end
+}
+
+void PlayerbotAI::extractSpellIdList(const std::string& text, BotSpellList& m_spellsToLearn) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hspell:", pos);
+        if (i == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: extractSpellIdList - first pos %u i %u",pos,i);
+        pos = i + 7;     // start of window in text 16 + 7 = 23
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: extractSpellIdList - second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+        uint32 spellId = atol(idC.c_str());
+        pos = endPos;     // end
+
+        if (spellId)
+            m_spellsToLearn.push_back(spellId);
+    }
+}
+
+void PlayerbotAI::extractTalentIds(const std::string &text, std::list<talentPair> &talentIds) const
+{
+    // Link format:
+    // |color|Htalent:talent_id:rank|h[name]|h|r
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htalent:", pos);
+        if (i == -1)
+            break;
+        pos = i + 8;
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "extractTalentIds first pos %u i %u",pos,i);
+        // extract talent_id
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "extractTalentId second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos + 1;
+        // extract rank
+        endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "extractTalentId third endpos : %u pos : %u",endPos,pos);
+        std::string rankC = text.substr(pos, endPos - pos);
+        uint32 rank = atol(rankC.c_str());
+        pos = endPos + 1;
+
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "extractTalentId second id : %u  rank : %u",id,rank);
+
+        if (id)
+            talentIds.push_back(std::pair<uint32, uint32>(id, rank));
+    }
+}
+
+void PlayerbotAI::extractGOinfo(const std::string& text, BotLootTarget& m_lootTargets) const
+{
+
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << ginfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        std::string guidC = text.substr(pos, endPos - pos);     // get string within window i.e guid 22 - 18 =  4
+        uint32 guid = atol(guidC.c_str());     // convert ascii to long int
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        uint64 lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+
+        if (guid)
+            m_lootTargets.push_back(lootCurrent);
+    }
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const
+{
+    // if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; itemIdSearchList.size() > 0 && slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    // look for items in main bag
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    // for all for items in other bags
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (!pBag)
+            continue;
+
+        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item* const pItem = m_bot->GetItemByPos(bag, slot);
+            if (!pItem)
+                continue;
+
+            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if (pItem->GetTemplate()->ItemId != *it)
+                    continue;
+
+                if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                    continue;
+
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyGO()
+{
+    if (m_collectObjects.empty())
+        return;
+
+    std::list<GameObject*> tempTargetGOList;
+    float radius = 20.0f;
+
+    for (BotLootEntry::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); itr++)
+    {
+        uint32 entry = *(itr);
+        GameObjectTemplate const * ginfo = sObjectMgr->GetGameObjectTemplate(entry);
+        bool questGO = false;
+        uint8 needCount = 0;
+
+        for (uint32 i = 0; i < 6; ++i)
+        {
+            if (ginfo->questItems[i] != 0)  // check whether the gameobject contains quest items
+            {
+                questGO = true;
+                if (IsInQuestItemList(ginfo->questItems[i]))    // quest item needed
+                    needCount++;
+            }
+        }
+
+        if (questGO && needCount == 0)
+        {
+            m_collectObjects.remove(entry); // remove gameobject from collect list
+            return;
+        }
+
+        // search for GOs with entry, within range of m_bot
+        Trinity::GameObjectInRangeCheck go_check(m_bot->m_positionX, m_bot->m_positionY, m_bot->m_positionZ, radius, entry);
+        Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> checker(m_bot, tempTargetGOList, go_check);
+        m_bot->GetMap()->VisitGrid(m_bot->m_positionX, m_bot->m_positionY, radius, checker);
+
+        // no objects found, continue to next entry
+        if (tempTargetGOList.empty())
+            continue;
+
+        // add any objects found to our lootTargets
+        for (std::list<GameObject*>::iterator iter = tempTargetGOList.begin(); iter != tempTargetGOList.end(); iter++)
+        {
+            GameObject* go = (*iter);
+            if (go->isSpawned())
+                m_lootTargets.push_back(go->GetGUID());
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyCreature()
+{
+    std::list<Creature*> creatureList;
+    float radius = INTERACTION_DISTANCE;
+
+    CellCoord pair(Trinity::ComputeCellCoord(m_bot->GetPositionX(), m_bot->GetPositionY()));
+    Cell cell(pair);
+
+    Trinity::AnyUnitInObjectRangeCheck go_check(m_bot, radius);
+    Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck> go_search(m_bot, creatureList, go_check);
+    TypeContainerVisitor<Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck>, GridTypeMapContainer> go_visit(go_search);
+
+    // Get Creatures
+    cell.Visit(pair, go_visit, *(m_bot->GetMap()), *(m_bot), radius);
+
+    // if (!creatureList.empty())
+    //    TellMaster("Found %i Creatures.", creatureList.size());
+
+    for (std::list<Creature*>::iterator iter = creatureList.begin(); iter != creatureList.end(); iter++)
+    {
+        Creature* currCreature = *iter;
+
+        for (std::list<enum NPCFlags>::iterator itr = m_findNPC.begin(); itr != m_findNPC.end(); itr = m_findNPC.erase(itr))
+        {
+            uint32 npcflags = currCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+            if (!(*itr & npcflags))
+                continue;
+
+            if ((*itr == UNIT_NPC_FLAG_TRAINER_CLASS) && !currCreature->isCanTrainingAndResetTalentsOf(m_bot))
+                continue;
+
+            WorldObject *wo = m_bot->GetMap()->GetGameObject(currCreature->GetGUID());
+
+            if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+            {
+                float x, y, z;
+                wo->GetContactPoint(m_bot, x, y, z, 1.0f);
+                m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+                // give time to move to point before trying again
+                SetIgnoreUpdateTime(1);
+            }
+
+            if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+            {
+
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "%s is interacting with (%s)",m_bot->GetName(),currCreature->GetCreatureInfo()->Name);
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(currCreature->GetCreatureInfo()->GossipMenuId);
+
+                // prepares quest menu when true
+                bool canSeeQuests = currCreature->GetCreatureInfo()->GossipMenuId == m_bot->GetDefaultGossipMenuForSource(wo);
+
+                // if canSeeQuests (the default, top level menu) and no menu options exist for this, use options from default options
+                if (pMenuItemBounds.first == pMenuItemBounds.second && canSeeQuests)
+                    pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);
+
+                for (GossipMenuItemsMap::const_iterator it = pMenuItemBounds.first; it != pMenuItemBounds.second; it++)
+                {
+                    if (!(it->second.OptionNpcflag & npcflags))
+                        continue;
+
+                    switch (it->second.OptionType)
+                    {
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // Manage banking actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // withdraw items
+                                        case BANK_WITHDRAW:
+                                        {
+                                            // TellMaster("Withdraw items");
+                                            if (!Withdraw(ait->second))
+                                                sLog->outDebug(LOG_FILTER_NETWORKIO, "Withdraw: Couldn't withdraw (%u)", ait->second);
+                                            break;
+                                        }
+                                        // deposit items
+                                        case BANK_DEPOSIT:
+                                        {
+                                            // TellMaster("Deposit items");
+                                            if (!Deposit(ait->second))
+                                                sLog->outDebug(LOG_FILTER_NETWORKIO, "Deposit: Couldn't deposit (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            BankBalance();
+                            break;
+                        }
+                        case GOSSIP_OPTION_INNKEEPER:
+                        case GOSSIP_OPTION_TRAINER:
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        case GOSSIP_OPTION_VENDOR:
+                        case GOSSIP_OPTION_UNLEARNTALENTS:
+                        {
+                            // Manage questgiver, trainer, innkeeper & vendor actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // reset talents
+                                        case RESET_TALENTS:
+                                        {
+                                            // TellMaster("Reset all talents");
+                                            if (Talent(currCreature))
+                                                InspectUpdate();
+                                            break;
+                                        }
+                                        // take new quests
+                                        case TAKE_QUEST:
+                                        {
+                                            // TellMaster("Accepting quest");
+                                            if (!AddQuest(ait->second, wo))
+                                                sLog->outDebug(LOG_FILTER_NETWORKIO, "AddQuest: Couldn't add quest (%u)", ait->second);
+                                            break;
+                                        }
+                                        // list npc quests
+                                        case LIST_QUEST:
+                                        {
+                                            // TellMaster("Show available npc quests");
+                                            ListQuests(wo);
+                                            break;
+                                        }
+                                        // end quests
+                                        case END_QUEST:
+                                        {
+                                            // TellMaster("Turn in available quests");
+                                            TurnInQuests(wo);
+                                            break;
+                                        }
+                                        // sell items
+                                        case SELL_ITEMS:
+                                        {
+                                            // TellMaster("Selling items");
+                                            Sell(ait->second);
+                                            break;
+                                        }
+                                        // repair items
+                                        case REPAIR_ITEMS:
+                                        {
+                                            // TellMaster("Repairing items");
+                                            Repair(ait->second, currCreature);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // Manage auctioneer actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // add new auction item
+                                        case ADD_AUCTION:
+                                        {
+                                            // TellMaster("Creating auction");
+                                            AddAuction(ait->second, currCreature);
+                                            break;
+                                        }
+                                        // cancel active auction
+                                        case REMOVE_AUCTION:
+                                        {
+                                            // TellMaster("Cancelling auction");
+                                            if (!RemoveAuction(ait->second))
+                                                sLog->outDebug(LOG_FILTER_NETWORKIO, "RemoveAuction: Couldn't remove auction (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            ListAuctions();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+                }
+            }
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+bool PlayerbotAI::CanStore()
+{
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+    }
+    return totalfree;
+}
+
+// use item on self
+void PlayerbotAI::UseItem(Item *item)
+{
+    UseItem(item, TARGET_FLAG_NONE, uint64());
+}
+
+// use item on equipped item
+void PlayerbotAI::UseItem(Item *item, uint8 targetInventorySlot)
+{
+    if (targetInventorySlot >= EQUIPMENT_SLOT_END)
+        return;
+
+    Item* const targetItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, targetInventorySlot);
+    if (!targetItem)
+        return;
+
+    UseItem(item, TARGET_FLAG_ITEM, targetItem->GetGUID());
+}
+
+// use item on unit
+void PlayerbotAI::UseItem(Item *item, Unit *target)
+{
+    if (!target)
+        return;
+
+    UseItem(item, TARGET_FLAG_UNIT, target->GetGUID());
+}
+
+// generic item use method
+void PlayerbotAI::UseItem(Item *item, uint32 targetFlag, uint64 targetGUID)
+{
+    if (!item)
+        return;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    if (uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        std::ostringstream report;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            m_bot->GetMotionMaster()->Clear(true);
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8 + 4 + 4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            report << "|cffffff00Quest taken |r" << qInfo->GetTitle();
+            TellMaster(report.str());
+        }
+        return;
+    }
+
+    uint32 spellId = 0;
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (item->GetTemplate()->Spells[i].SpellId > 0)
+        {
+            spellId = item->GetTemplate()->Spells[i].SpellId;
+            break;
+        }
+    }
+
+    WorldPacket *packet = new WorldPacket(CMSG_USE_ITEM, 28);
+    *packet << bagIndex << slot << cast_count << spellId << item_guid
+            << glyphIndex << unk_flags << targetFlag;
+
+    if (targetFlag & (TARGET_FLAG_UNIT | TARGET_FLAG_ITEM | TARGET_FLAG_GAMEOBJECT))
+        *packet/* << targetGUID.WriteAsPacked()*/;
+
+    m_bot->GetSession()->QueuePacket(packet);
+
+    SpellEntry const * spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+    {
+        TellMaster("Can't find spell entry for spell %u on item %u", spellId, item->GetEntry());
+        return;
+    }
+
+    SpellCastTimesEntry const * castingTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
+    if (!castingTimeEntry)
+    {
+        TellMaster("Can't find casting time entry for spell %u with index %u", spellId, spellInfo->CastingTimeIndex);
+        return;
+    }
+
+    uint8 duration, castTime;
+    castTime = (uint8) ((float) castingTimeEntry->CastTime / 1000.0f);
+
+    /*if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        duration = (uint8) ((float) spellInfo->GetDuration() / 1000.0f);
+        SetIgnoreUpdateTime(castTime + duration);
+    }
+    else*/
+        SetIgnoreUpdateTime(castTime);
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item* src_Item)
+{
+    uint8 src_bagIndex = src_Item->GetBagSlot();
+    uint8 src_slot = src_Item->GetSlot();
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "PlayerbotAI::EquipItem: %s in srcbag = %u, srcslot = %u", src_Item->GetTemplate()->Name1, src_bagIndex, src_slot);
+
+    uint16 dest;
+    InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, src_Item, !src_Item->IsBag());
+    if (msg != EQUIP_ERR_OK)
+    {
+        m_bot->SendEquipError(msg, src_Item, NULL);
+        return;
+    }
+
+    uint16 src = src_Item->GetPos();
+    if (dest == src)                                        // prevent equip in same slot, only at cheat
+        return;
+
+    Item *dest_Item = m_bot->GetItemByPos(dest);
+    if (!dest_Item)                                          // empty slot, simple case
+    {
+        m_bot->RemoveItem(src_bagIndex, src_slot, true);
+        m_bot->EquipItem(dest, src_Item, true);
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+    else                                                    // have currently equipped item, not simple case
+    {
+        uint8 dest_bagIndex = dest_Item->GetBagSlot();
+        uint8 dest_slot = dest_Item->GetSlot();
+
+        msg = m_bot->CanUnequipItem(dest, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, NULL);
+            return;
+        }
+
+        // check dest->src move possibility
+        ItemPosCountVec sSrc;
+        uint16 eSrc = 0;
+        if (m_bot->IsInventoryPos(src))
+        {
+            msg = m_bot->CanStoreItem(src_bagIndex, src_slot, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(src_bagIndex, NULL_SLOT, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dest_Item, true);
+        }
+
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, src_Item);
+            return;
+        }
+
+        // now do moves, remove...
+        m_bot->RemoveItem(dest_bagIndex, dest_slot, false);
+        m_bot->RemoveItem(src_bagIndex, src_slot, false);
+
+        // add to dest
+        m_bot->EquipItem(dest, src_Item, true);
+
+        // add to src
+        if (m_bot->IsInventoryPos(src))
+            m_bot->StoreItem(sSrc, dest_Item, true);
+
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: TradeItem - slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+               slot,
+               (m_bot->GetTrader() ? 1 : 0),
+               (item.IsInTrade() ? 1 : 0),
+               (item.CanBeTraded() ? 1 : 0)
+               );
+
+    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED))
+        return false;
+
+    int8 tradeSlot = -1;
+
+    TradeData* pTrade = m_bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+    else
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                tradeSlot = i;
+                // reserve trade slot to allow multiple items to be traded
+                pTrade->SetItem(TradeSlots(i), const_cast<Item*>(&item));
+            }
+        }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::DoTeleport(WorldObject &obj)
+{
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+    PlayerbotChatHandler ch(GetMaster());
+    if (!ch.teleport(*m_bot))
+    {
+        ch.sysmessage(".. could not be teleported ..");
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+        return false;
+    }
+    return true;
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+    m_bot->GetMotionMaster()->Clear(true);
+    if (m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; // supposed to be flags? not used currently
+        p << (uint32) time(0); // time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if (m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+// Localization support
+void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if (pItemInfo)
+        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if (Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+}
+
+void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if (pQuestInfo)
+        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if (Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+}
+
+void PlayerbotAI::CreatureLocalization(std::string& creatureName, const uint32 entry) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const *pCreatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (pCreatureInfo)
+        if (pCreatureInfo->Name.size() > loc && !pCreatureInfo->Name[loc].empty())
+        {
+            const std::string title = pCreatureInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                creatureName = title.c_str();
+        }
+}
+
+void PlayerbotAI::GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const *pGameObjectTemplate = sObjectMgr->GetGameObjectLocale(entry);
+    if (pGameObjectTemplate)
+        if (pGameObjectTemplate->Name.size() > loc && !pGameObjectTemplate->Name[loc].empty())
+        {
+            const std::string title = pGameObjectTemplate->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                gameobjectName = title.c_str();
+        }
+}
+
+// Helper function for automatically selling poor quality items to the vendor
+void PlayerbotAI::_doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold)
+{
+    if (!item)
+        return;
+
+    if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR)
+    {
+        uint32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(item);
+
+        ++TotalSold;
+        TotalCost += cost;
+
+        report << "Sold ";
+        MakeItemLink(item, report, true);
+        report << " for ";
+
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver > 0)
+            report << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        report << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t\n";
+    }
+    else if (item->GetTemplate()->SellPrice > 0)
+        MakeItemLink(item, canSell, true);
+}
+
+bool PlayerbotAI::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->StoreItem(dest, pItem, true);
+
+        report << "Withdrawn ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+bool PlayerbotAI::Deposit(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->BankItem(dest, pItem, true);
+
+        report << "Deposited ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+void PlayerbotAI::BankBalance()
+{
+    std::ostringstream report;
+
+    report << "In my bank\n ";
+    report << "My item slots: ";
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            MakeItemLink(item, report, true);
+    }
+    TellMaster(report.str());
+
+    // and each of my bank bags
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            goods << "\nMy ";
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+            ItemLocalization(bagName, pBagProto->ItemId);
+            goods << bagName << " slot: ";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    MakeItemLink(item, goods, true);
+            }
+            TellMaster(goods.str());
+        }
+    }
+}
+
+bool PlayerbotAI::Talent(Creature* trainer)
+{
+    if (!(m_bot->resetTalents()))
+    {
+        WorldPacket* const packet = new WorldPacket(MSG_TALENT_WIPE_CONFIRM, 8 + 4);    //you do not have any talent
+        *packet << uint64(0);
+        *packet << uint32(0);
+        m_bot->GetSession()->QueuePacket(packet);
+        return false;
+    }
+
+    m_bot->SendTalentsInfoData(false);
+    trainer->CastSpell(m_bot, 14867, true);                  //spell: "Untalent Visual Effect"
+    return true;
+}
+
+void PlayerbotAI::InspectUpdate()
+{
+    WorldPacket packet(SMSG_INSPECT_RESULTS_UPDATE, 50);
+    //packet << m_bot->GetPackGUID();
+    m_bot->BuildPlayerTalentsInfoData(&packet);
+    m_bot->BuildEnchantmentsInfoData(&packet);
+    GetMaster()->GetSession()->SendPacket(&packet);
+}
+
+void PlayerbotAI::Repair(const uint32 itemid, Creature* rCreature)
+{
+    Item* rItem = FindItem(itemid); // if item equipped or in bags
+    uint8 IsInGuild = (m_bot->GetGuildId() != 0) ? uint8(1) : uint8(0);
+    uint64 itemGuid = (rItem) ? rItem->GetGUID() : uint64();
+
+    WorldPacket* const packet = new WorldPacket(CMSG_REPAIR_ITEM, 8 + 8 + 1);
+    *packet << rCreature->GetGUID();  // repair npc guid
+    *packet << itemGuid; // if item specified then repair this, else repair all
+    *packet << IsInGuild;  // guildbank yes=1 no=0
+    m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+}
+
+bool PlayerbotAI::RemoveAuction(const uint32 auctionid)
+{
+    QueryResult result = CharacterDatabase.PQuery(
+        "SELECT houseid,itemguid,item_template,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auction WHERE id = '%u'", auctionid);
+
+    AuctionEntry *auction;
+
+    if (result)
+    {
+        Field *fields = result->Fetch();
+
+        auction = new AuctionEntry;
+        auction->Id = auctionid;
+        uint32 houseid  = fields[0].GetUInt32();
+        auction->item_guidlow = fields[1].GetUInt32();
+        auction->item_template = fields[2].GetUInt32();
+        auction->owner = fields[3].GetUInt32();
+        auction->buyout = fields[4].GetUInt32();
+        auction->expire_time = fields[5].GetUInt32();
+        auction->bidder = fields[6].GetUInt32();
+        auction->bid = fields[7].GetUInt32();
+        auction->startbid = fields[8].GetUInt32();
+        auction->deposit = fields[9].GetUInt32();
+        auction->auctionHouseEntry = NULL;                  // init later
+
+        // check if sold item exists for guid
+        // and item_template in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        Item* pItem = sAuctionMgr->GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            auction->DeleteFromDB(trans);
+            sLog->outError("Auction %u has not a existing item : %u, deleted", auction->Id, auction->item_guidlow);
+            delete auction;
+            return false;
+        }
+
+        auction->auctionHouseEntry = sAuctionHouseStore.LookupEntry(houseid);
+
+        // Attempt send item back to owner
+        std::ostringstream msgAuctionCanceledOwner;
+        msgAuctionCanceledOwner << auction->item_template << ":0:" << AUCTION_CANCELED << ":0:0";
+
+        // item will deleted or added to received mail list
+        MailDraft(msgAuctionCanceledOwner.str(), "")    // TODO: fix body
+        .AddItem(pItem);
+		//.SendMailTo(trans, this, MailReceiver(auction->owner), MAIL_CHECK_MASK_COPIED);
+        //.SendMailTo(MailReceiver(MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER)), auction, MAIL_CHECK_MASK_COPIED);
+
+        if (sAuctionMgr->RemoveAItem(auction->item_guidlow))
+            m_bot->GetSession()->SendAuctionCommandResult(0, AUCTION_CANCEL, AUCTION_OK);
+
+        auction->DeleteFromDB(trans);
+
+        delete auction;
+    }
+    return true;
+}
+
+void PlayerbotAI::ListQuests(WorldObject * questgiver)
+{
+    if (!questgiver)
+        return;
+
+    // list all bot quests this NPC has
+    m_bot->PrepareQuestMenu(questgiver->GetGUID());
+    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+    std::ostringstream out;
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+        std::string questTitle  = pQuest->GetTitle();
+        QuestLocalization(questTitle, questID);
+
+        QuestStatus status = m_bot->GetQuestStatus(questID);
+
+        if (m_bot->SatisfyQuestStatus(pQuest, false))
+            out << "|cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+    }
+    if (!out.str().empty())
+        TellMaster(out.str());
+}
+
+bool PlayerbotAI::AddQuest(const uint32 entry, WorldObject * questgiver)
+{
+    std::ostringstream out;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(entry);
+    if (!qInfo)
+    {
+        ChatHandler(GetMaster()).PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        return false;
+    }
+
+    if (m_bot->GetQuestStatus(entry) == QUEST_STATUS_COMPLETE)
+    {
+        TellMaster("I already completed that quest.");
+        return false;
+    }
+    else if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        if (!m_bot->SatisfyQuestStatus(qInfo, false))
+            TellMaster("I already have that quest.");
+        else
+            TellMaster("I can't take that quest.");
+        return false;
+    }
+    else if (!m_bot->SatisfyQuestLog(false))
+    {
+        TellMaster("My quest log is full.");
+        return false;
+    }
+    else if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, questgiver);
+
+        std::string questTitle  = qInfo->GetTitle();
+        QuestLocalization(questTitle, entry);
+
+        out << "|cffffff00Quest taken " << "|cff808080|Hquest:" << entry << ':' << qInfo->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+        if (m_bot->CanCompleteQuest(entry))
+            m_bot->CompleteQuest(entry);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        TellMaster(out.str());
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::ListAuctions()
+{
+    std::ostringstream report;
+
+    QueryResult result = CharacterDatabase.PQuery(
+        "SELECT id,itemguid,item_template,time,buyguid,lastbid FROM auction WHERE itemowner = '%u'", m_bot->GetGUID());
+    if (result)
+    {
+        report << "My active auctions are: \n";
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 Id = fields[0].GetUInt32();
+            uint32 item_guidlow = fields[1].GetUInt32();
+            uint32 itemTemplate = fields[2].GetUInt32();
+            time_t expireTime = fields[3].GetUInt32();
+            uint32 bidder = fields[4].GetUInt32();
+            uint32 bid = fields[5].GetUInt32();
+
+            // current time
+            time_t currtime = time(NULL);
+            time_t remtime = expireTime - currtime;
+
+            tm* aTm = gmtime(&remtime);
+
+            if (expireTime > currtime)
+            {
+                Item* aItem = sAuctionMgr->GetAItem(item_guidlow);
+                if (aItem)
+                {
+                    // Name
+                    uint32 count = aItem->GetCount();
+                    std::string name = aItem->GetTemplate()->Name1;
+                    ItemLocalization(name, itemTemplate);
+                    report << "\n|cffffffff|Htitle:" << Id << "|h[" << name;
+                    if (count > 1)
+                        report << "|cff00ff00x" << count << "|cffffffff" << "]|h|r";
+                    else
+                        report << "]|h|r";
+                }
+
+                if (bidder)
+                {
+                    uint64 guid = MAKE_NEW_GUID(guid, bidder, HIGHGUID_PLAYER);
+                    std::string bidder_name;
+                    if (sObjectMgr->GetPlayerNameByGUID(guid, bidder_name))
+                        report << " " << bidder_name << ": ";
+
+                    uint32 gold = uint32(bid / 10000);
+                    bid -= (gold * 10000);
+                    uint32 silver = uint32(bid / 100);
+                    bid -= (silver * 100);
+
+                    if (gold > 0)
+                        report << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                    if (silver > 0)
+                        report << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                    report << bid << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+                }
+                if (aItem)
+                    report << " ends: " << aTm->tm_hour << "|cff0070dd|hH|h|r " << aTm->tm_min << "|cff0070dd|hmin|h|r";
+            }
+        } while (result->NextRow());
+
+        TellMaster(report.str().c_str());
+    }
+}
+
+void PlayerbotAI::AddAuction(const uint32 itemid, Creature* aCreature)
+{
+    Item* aItem = FindItem(itemid);
+    if (aItem)
+    {
+        std::ostringstream out;
+        srand(time(NULL));
+        uint32 duration[3] = { 720, 1440, 2880 };  // 720 = 12hrs, 1440 = 24hrs, 2880 = 48hrs
+        uint32 etime = duration[rand() % 3];
+
+        uint32 min = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+        uint32 max = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+
+        out << "Auctioning ";
+        MakeItemLink(aItem, out, true);
+        out << " with " << aCreature->GetCreatureInfo()->Name;
+        TellMaster(out.str().c_str());
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUCTION_SELL_ITEM, 8 + 4 + 8 + 4 + 4 + 4 + 4);
+        *packet << aCreature->GetGUID();     // auctioneer guid
+        *packet << uint32(1);                      // const 1
+        *packet << aItem->GetGUID();         // item guid
+        *packet << aItem->GetCount();      // stacksize
+        *packet << uint32((min < max) ? min : max);  // starting bid
+        *packet << uint32((max > min) ? max : min);  // buyout
+        *packet << uint32(etime);  // auction duration
+
+        m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+    }
+}
+
+void PlayerbotAI::Sell(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        uint32 cost = pItem->GetCount() * pItem->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(pItem);
+
+        report << "Sold ";
+        MakeItemLink(pItem, report, true);
+        report << " for ";
+
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver > 0)
+            report << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        report << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+
+        TellMaster(report.str());
+    }
+}
+
+void PlayerbotAI::SellGarbage(bool verbose)
+{
+    uint32 TotalCost = 0;
+    uint32 TotalSold = 0;
+    std::ostringstream report, goods;
+
+    goods << "Items that are not trash and can be sold: \n";
+    goods << "In my main backpack:";
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            _doSellItem(item, report, goods, TotalCost, TotalSold);
+    }
+    if (verbose)
+        TellMaster(goods.str());
+
+    // and each of our other packs
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            goods << "\nIn my ";
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+            ItemLocalization(bagName, pBagProto->ItemId);
+            goods << bagName << ":";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    _doSellItem(item, report, goods, TotalCost, TotalSold);
+            }
+            if (verbose)
+                TellMaster(goods.str());
+        }
+    }
+
+    if (TotalSold > 0)
+    {
+        report << "Sold total " << TotalSold << " item(s) for ";
+        uint32 gold = uint32(TotalCost / 10000);
+        TotalCost -= (gold * 10000);
+        uint32 silver = uint32(TotalCost / 100);
+        TotalCost -= (silver * 100);
+
+        if (gold > 0)
+            report << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver > 0)
+            report << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        report << TotalCost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+
+        TellMaster(report.str());
+    }
+}
+
+void PlayerbotAI::GetTaxi(uint64 guid, BotTaxiNode& nodes)
+{
+    // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: GetTaxi - %s node[0] %d node[1] %d", m_bot->GetName(), nodes[0], nodes[1]);
+
+    Creature *unit = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!unit)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: GetTaxi - %s not found or you can't interact with it.", GUID_LOPART(guid));
+        return;
+    }
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[0]) ? 0 : 1)
+        return;
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[nodes.size() - 1]) ? 0 : 1)
+        return;
+
+    if (m_bot->GetPlayerbotAI()->GetMovementOrder() != MOVEMENT_STAY)
+    {
+        m_taxiNodes = nodes;
+        m_taxiMaster = guid;
+        SetState(BOTSTATE_FLYING);
+    }
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
+{
+    // prevent bot task spam
+    m_tasks.unique();
+    m_findNPC.unique();
+
+    // ignore any messages from Addons
+    if (text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos ||
+        text.find("GathX") == 0) // Gatherer
+        return;
+
+    // if message is not from a player in the masters account auto reply and ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {
+        std::string msg = "I can't talk to you. Please speak to my master ";
+        msg += GetMaster()->GetName();
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+    }
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID())
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else if (!strncmp(text.c_str(), "nt ", 3))
+        {
+            if (itemIds.size() > 1)
+                SendWhisper("There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer);
+            else
+            {
+                std::list<Item*> itemList;
+                findItemsInEquip(itemIds, itemList);
+                findItemsInInv(itemIds, itemList);
+                if (itemList.size() > 0)
+                    TradeItem((**itemList.begin()), TRADE_SLOT_NONTRADED);
+                else
+                    SendWhisper("I do not have this item equipped or in my bags!", fromPlayer);
+            }
+        }
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+    // if we are turning in a quest
+
+    else if (text == "reset")
+    {
+        SetState(BOTSTATE_NORMAL);
+        MovementReset();
+        SetQuestNeedItems();
+        SetQuestNeedCreatures();
+        UpdateAttackerInfo();
+        m_lootTargets.clear();
+        m_lootCurrent = uint64();
+        m_targetCombat = 0;
+    }
+    else if (text == "report")
+        SendQuestNeedList();
+    else if (text == "orders")
+        SendOrders(*GetMaster());
+    else if (text == "follow" || text == "come")
+        SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
+    else if (text == "stay" || text == "stop")
+        SetMovementOrder(MOVEMENT_STAY);
+    else if (text == "attack")
+    {
+        uint64 attackOnGuid = fromPlayer.GetSelection();
+        if (attackOnGuid)
+        {
+            if (Unit * thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid))
+                if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack))
+                    GetCombatTarget(thingToAttack);
+        }
+        else
+        {
+            TellMaster("No target is selected.");
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+
+    // handle cast command
+    else if ((text.size() > 2 && text.substr(0, 2) == "c ") || (text.size() > 5 && text.substr(0, 5) == "cast "))
+    {
+        // sLog->outErrorDb("Selected link : %s", text.c_str());
+
+        std::string spellStr = text.substr(text.find(" ") + 1);
+        uint32 spellId = (uint32) atol(spellStr.c_str());
+
+        // try and get spell ID by name
+        if (spellId == 0)
+        {
+            spellId = getSpellId(spellStr.c_str(), true);
+
+            // try link if text NOT (spellid OR spellname)
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (m_bot->HasAura(spellId))
+        {
+            m_bot->RemoveAura(spellId, m_bot->GetGUID());
+            return;
+        }
+
+        uint64 castOnGuid = fromPlayer.GetSelection();
+        if (spellId != 0 && castOnGuid && m_bot->HasSpell(spellId))
+        {
+            m_spellIdCommand = spellId;
+            m_targetGuidCommand = castOnGuid;
+        }
+
+    }
+
+    // Handle selling items
+    // sell [Item Link][Item Link] .. -- Sells bot(s) items from inventory
+    else if (text.size() > 5 && text.substr(0, 5) == "sell ")
+    {
+        enum NPCFlags VENDOR_MASK = (enum NPCFlags) (UNIT_NPC_FLAG_VENDOR
+                                                     | UNIT_NPC_FLAG_VENDOR_AMMO
+                                                     | UNIT_NPC_FLAG_VENDOR_FOOD
+                                                     | UNIT_NPC_FLAG_VENDOR_POISON
+                                                     | UNIT_NPC_FLAG_VENDOR_REAGENT);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(SELL_ITEMS, *it));
+        m_findNPC.push_back(VENDOR_MASK);
+    }
+
+    // Handle repair items
+    // repair  all                      -- repair all bot(s) items
+    // repair [Item Link][Item Link] .. -- repair select bot(s) items
+    else if (text.size() >= 6 && text.substr(0, 6) == "repair")
+    {
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 6 && text.substr(0, 7) == "repair ")
+            part = text.substr(7);  // Truncate 'repair ' part
+
+        if (part.find(" ") > 0)
+            subcommand = part.substr(0, part.find(" "));
+
+        std::list<uint32> itemIds;
+        extractItemIds(part, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); it++)
+        {
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REPAIR_ITEMS, *it));
+            m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+        }
+        if (itemIds.empty() && subcommand == "all")
+        {
+            m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REPAIR_ITEMS, 0));
+            m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+        }
+    }
+
+    // Handle auctions:
+    // auction                                        -- Lists bot(s) active auctions.
+    // auction add [Item Link][Item Link] ..          -- Create bot(s) active auction.
+    // auction remove [Auction Link][Auction Link] .. -- Cancel bot(s) active auction. ([Auction Link] from auction)
+    else if (text.size() >= 7 && text.substr(0, 7) == "auction")
+    {
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 7 && text.substr(0, 8) == "auction ")
+            part = text.substr(8);  // Truncate 'auction ' part
+
+        if (part.find(" ") > 0)
+        {
+            subcommand = part.substr(0, part.find(" "));
+            if (part.size() > subcommand.size())
+                part = part.substr(subcommand.size() + 1);
+        }
+        else
+            subcommand = part;
+
+        if (subcommand == "add" || subcommand == "remove")
+        {
+            if (subcommand == "add")
+            {
+                std::list<uint32> itemIds;
+                extractItemIds(part, itemIds);
+                for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+                    m_tasks.push_back(std::pair<enum TaskFlags,uint32>(ADD_AUCTION, *it));
+                m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+            }
+
+            if (subcommand == "remove")
+            {
+                std::list<uint32> auctionIds;
+                extractAuctionIds(part, auctionIds);
+                for (std::list<uint32>::iterator it = auctionIds.begin(); it != auctionIds.end(); ++it)
+                    m_tasks.push_back(std::pair<enum TaskFlags,uint32>(REMOVE_AUCTION, *it));
+                m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+            }
+        }
+        else // list all bot auctions
+            m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+
+    // Handle bank:
+    // bank                                        -- Lists bot(s) bank balance.
+    // bank deposit [Item Link][Item Link] ..      -- Deposit item(s) in bank.
+    // bank withdraw [Item Link][Item Link] ..     -- Withdraw item(s) from bank. ([Item Link] from bank)
+    else if (text.size() >= 4 && text.substr(0, 4) == "bank")
+    {
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 4 && text.substr(0, 5) == "bank ")
+            part = text.substr(5);  // Truncate 'bank ' part
+
+        if (part.find(" ") > 0)
+        {
+            subcommand = part.substr(0, part.find(" "));
+            if (part.size() > subcommand.size())
+                part = part.substr(subcommand.size() + 1);
+        }
+        else
+            subcommand = part;
+
+        if (subcommand == "deposit" || subcommand == "withdraw")
+        {
+            if (subcommand == "deposit")
+            {
+                std::list<uint32> itemIds;
+                extractItemIds(part, itemIds);
+                for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+                    m_tasks.push_back(std::pair<enum TaskFlags,uint32>(BANK_DEPOSIT, *it));
+                m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+            }
+
+            if (subcommand == "withdraw")
+            {
+                std::list<uint32> itemIds;
+                extractItemIds(part, itemIds);
+                for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+                    m_tasks.push_back(std::pair<enum TaskFlags,uint32>(BANK_WITHDRAW, *it));
+                m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+            }
+        }
+        else // list all bot balance
+            m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+
+    // Handle talents & glyphs:
+    // talent                           -- Lists bot(s) active talents [TALENT LINK] & glyphs [GLYPH LINK], unspent points & cost to reset
+    // talent learn [TALENT LINK] ..    -- Learn selected talent from bot client 'inspect' dialog -> 'talent' tab or from talent command (shift click icon/link)
+    // talent reset                     -- Resets all talents
+    else if (text.size() >= 6 && text.substr(0, 6) == "talent")
+    {
+        std::ostringstream out;
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 6 && text.substr(0, 7) == "talent ")
+            part = text.substr(7);  // Truncate 'talent ' part
+
+        if (part.find(" ") > 0)
+        {
+            subcommand = part.substr(0, part.find(" "));
+            if (part.size() > subcommand.size())
+                part = part.substr(subcommand.size() + 1);
+        }
+        else
+            subcommand = part;
+
+        if (subcommand == "learn" || subcommand == "reset")
+        {
+            if (subcommand == "learn")
+            {
+                std::list<talentPair>talents;
+                extractTalentIds(part, talents);
+
+                for (std::list<talentPair>::iterator itr = talents.begin(); itr != talents.end(); itr++)
+                {
+                    uint32 talentid;
+                    uint32 rank;
+
+                    talentid = itr->first;
+                    rank = itr->second;
+
+                    m_bot->LearnTalent(talentid, ++rank);
+                    m_bot->SendTalentsInfoData(false);
+                    InspectUpdate();
+                }
+                m_bot->MakeTalentGlyphLink(out);
+                SendWhisper(out.str(), fromPlayer);
+
+            }
+            else if (subcommand == "reset")
+            {
+                m_tasks.push_back(std::pair<enum TaskFlags,uint32>(RESET_TALENTS, 0));
+                m_findNPC.push_back(UNIT_NPC_FLAG_TRAINER_CLASS);
+            }
+        }
+        else
+        {
+            uint32 gold = uint32(m_bot->resetTalentsCost() / 10000);
+
+            if (gold > 0)
+                out << "Cost to reset all Talents is " << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+
+            m_bot->MakeTalentGlyphLink(out);
+            SendWhisper(out.str(), fromPlayer);
+        }
+    }
+
+    // use items
+    else if ((text.size() > 2 && text.substr(0, 2) == "u ") || (text.size() > 4 && text.substr(0, 4) == "use "))
+    {
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        // set target
+        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelection());
+
+        for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        {
+            if (unit)
+                UseItem(*it, unit);
+            else
+                UseItem(*it);
+        }
+    }
+
+    // equip items
+    else if ((text.size() > 2 && text.substr(0, 2) == "e ") || (text.size() > 6 && text.substr(0, 6) == "equip "))
+    {
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+            EquipItem(*it);
+        InspectUpdate();
+        SendNotEquipList(*m_bot);
+    }
+
+    // find project: 20:50 02/12/10 rev.4 item in world and wait until ordered to follow
+    else if ((text.size() > 2 && text.substr(0, 2) == "f ") || (text.size() > 5 && text.substr(0, 5) == "find "))
+    {
+        extractGOinfo(text, m_lootTargets);
+
+        m_lootCurrent = m_lootTargets.front();
+        m_lootTargets.pop_front();
+
+        GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+        if (!go)
+        {
+            m_lootTargets.clear();
+            m_lootCurrent = uint64();
+            return;
+        }
+
+        SetMovementOrder(MOVEMENT_STAY);
+        m_bot->GetMotionMaster()->MovePoint(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
+        m_lootTargets.clear();
+        m_lootCurrent = uint64();
+    }
+
+    // get project: 20:50 02/12/10 rev.4 compact edition, handles multiple linked gameobject & improves visuals
+    else if ((text.size() > 2 && text.substr(0, 2) == "g ") || (text.size() > 4 && text.substr(0, 4) == "get "))
+    {
+        extractGOinfo(text, m_lootTargets);
+        SetState(BOTSTATE_LOOTING);
+    }
+    else if (text == "g" || text == "get") // get a selected lootable corpse
+    {
+        uint64 getOnGuid = fromPlayer.GetSelection();
+        if (getOnGuid)
+        {
+            Creature *c = m_bot->GetMap()->GetCreature(getOnGuid);
+            if (!c)
+                return;
+
+            uint32 skillId = 0;
+            if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+                skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
+
+            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) ||
+                (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && m_bot->HasSkill(skillId)))
+            {
+                m_lootTargets.push_back(getOnGuid);
+                SetState(BOTSTATE_LOOTING);
+            }
+            else
+                TellMaster("Target is not lootable by me.");
+        }
+        else
+        {
+            TellMaster("No target is selected.");
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+        return;
+    }
+
+    // Handle all collection related commands here
+    else if (text.size() >= 7 && text.substr(0, 7) == "collect")
+    {
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 7 && text.substr(0, 8) == "collect ")
+            part = text.substr(8);  // Truncate 'collect ' part
+
+        while (true)
+        {
+            if (part.find(" ") > 0)
+            {
+                subcommand = part.substr(0, part.find(" "));
+                if (part.size() > subcommand.size())
+                    part = part.substr(subcommand.size() + 1);
+            }
+            else
+                subcommand = part;
+
+            if (subcommand == "combat")
+                SetCollectFlag(COLLECT_FLAG_COMBAT);
+            else if (subcommand == "loot")
+                SetCollectFlag(COLLECT_FLAG_LOOT);
+            else if (subcommand == "quest")
+                SetCollectFlag(COLLECT_FLAG_QUEST);
+            else if (subcommand == "profession" || subcommand == "skill")
+                SetCollectFlag(COLLECT_FLAG_PROFESSION);
+            else if (subcommand == "skin" && m_bot->HasSkill(SKILL_SKINNING))
+                SetCollectFlag(COLLECT_FLAG_SKIN);
+            else if (subcommand == "objects" || subcommand == "nearby")
+            {
+                SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+                if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+                    m_collectObjects.clear();
+            }
+            else if (subcommand == "none" || subcommand == "nothing")
+            {
+                m_collectionFlags = 0;
+                m_collectObjects.clear();
+            }
+            else
+            {
+                std::string collout = "";
+                if (m_bot->HasSkill(SKILL_SKINNING))
+                    collout += ", skin";
+                // TODO: perhaps change the command syntax, this way may be lacking in ease of use
+                TellMaster("Collect <what>?: none, combat, loot, quest, profession, objects" + collout);
+                break;
+            }
+            if (part == subcommand)
+                break;
+        }
+
+        std::string collset = "";
+        if (HasCollectFlag(COLLECT_FLAG_LOOT))
+            collset += ", all loot";
+        if (HasCollectFlag(COLLECT_FLAG_PROFESSION))
+            collset += ", profession";
+        if (HasCollectFlag(COLLECT_FLAG_QUEST))
+            collset += ", quest";
+        if (HasCollectFlag(COLLECT_FLAG_SKIN))
+            collset += ", skin";
+        if (collset.length() > 1)
+        {
+            if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+                collset += " items after combat";
+            else
+                collset += " items";
+        }
+
+        if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+        {
+            if (collset.length() > 1)
+                collset += " and ";
+            else
+                collset += "  ";    // padding for substr
+            collset += "nearby objects (";
+            if (!m_collectObjects.empty())
+            {
+                std::string strobjects = "";
+                for (BotLootEntry::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
+                {
+                    uint32 objectentry = *(itr);
+                    GameObjectTemplate const * ginfo = sObjectMgr->GetGameObjectTemplate(objectentry);
+                    strobjects += ", ";
+                    strobjects += ginfo->name;
+                }
+                collset += strobjects.substr(2);
+            }
+            else
+                collset += "use survey and get to set";
+            collset += ")";
+        }
+
+        if (collset.length() > 1)
+            TellMaster("I'm collecting " + collset.substr(2));
+        else
+            TellMaster("I'm collecting nothing.");
+    }
+
+    // Handle bot quests
+    else if (text.size() >= 5 && text.substr(0, 5) == "quest")
+    {
+        std::ostringstream msg;
+
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 5 && text.substr(0, 6) == "quest ")
+            part = text.substr(6);  // Truncate 'quest ' part
+
+        if (part.find(" ") != std::string::npos)
+        {
+            subcommand = part.substr(0, part.find(" "));
+            if (part.size() > subcommand.size())
+                part = part.substr(subcommand.size() + 1);
+
+        }
+        else
+            subcommand = part;
+
+        if (subcommand == "a" || subcommand == "add")
+        {
+            std::list<uint32> questIds;
+            extractQuestIds(part, questIds);
+            for (std::list<uint32>::iterator it = questIds.begin(); it != questIds.end(); it++)
+                m_tasks.push_back(std::pair<enum TaskFlags, uint32>(TAKE_QUEST, *it));
+            m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+        }
+        else if (subcommand == "d" || subcommand == "drop")
+        {
+            fromPlayer.SetSelection(m_bot->GetGUID());
+            PlayerbotChatHandler ch(GetMaster());
+            int8 linkStart = part.find("|");
+            if (part.find("|") != std::string::npos)
+                if (!ch.dropQuest((char *) part.substr(linkStart).c_str()))
+                    ch.sysmessage("ERROR: could not drop quest");
+                else
+                {
+                    SetQuestNeedItems();
+                    SetQuestNeedCreatures();
+                }
+        }
+        else if (subcommand == "l" || subcommand == "list")
+        {
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_QUEST, 0));
+            m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+        }
+        else if (subcommand == "e" || subcommand == "end")
+        {
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(END_QUEST, 0));
+            m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+        }
+        else
+        {
+            bool hasIncompleteQuests = false;
+            std::ostringstream incomout;
+            incomout << "my incomplete quests are:";
+            bool hasCompleteQuests = false;
+            std::ostringstream comout;
+            comout << "my complete quests are:";
+            for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+            {
+                if (uint32 questId = m_bot->GetQuestSlotQuestId(slot))
+                {
+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+
+                    std::string questTitle  = pQuest->GetTitle();
+                    m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questId);
+
+                    if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+                    {
+                        hasCompleteQuests = true;
+                        comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                    }
+                    else
+                    {
+                        Item* qitem = FindItem(pQuest->GetSrcItemId());
+                        if (qitem)
+                            incomout << " use " << "|cffffffff|Hitem:" << qitem->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << qitem->GetTemplate()->Name1 << "]|h|r" << " on ";
+                        hasIncompleteQuests = true;
+                        incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
+                    }
+                }
+            }
+            if (hasCompleteQuests)
+                SendWhisper(comout.str(), fromPlayer);
+            if (hasIncompleteQuests)
+                SendWhisper(incomout.str(), fromPlayer);
+            if (!hasCompleteQuests && !hasIncompleteQuests)
+                SendWhisper("I have no quests!", fromPlayer);
+        }
+    }
+
+    // Handle all pet related commands here
+    else if (text.size() > 4 && text.substr(0, 4) == "pet ")
+    {
+        Pet * pet = m_bot->GetPet();
+        if (!pet)
+        {
+            SendWhisper("I have no pet.", fromPlayer);
+            return;
+        }
+
+        std::string part = text.substr(4); // Truncate `pet` part
+        std::string subcommand = part.substr(0, part.find(" "));
+        std::string argument;
+        bool argumentFound = false;
+
+        if (part.find(" ") != std::string::npos)
+        {
+            argument = part.substr(part.find(" ") + 1);
+            if (argument.length() > 0)
+                argumentFound = true;
+        }
+
+        if (subcommand == "react" && argumentFound)
+        {
+            if (argument == "a" || argument == "aggressive")
+                pet->GetCharmInfo()->SetReactState(REACT_AGGRESSIVE);
+            else if (argument == "d" || argument == "defensive")
+                pet->GetCharmInfo()->SetReactState(REACT_DEFENSIVE);
+            else if (argument == "p" || argument == "passive")
+                pet->GetCharmInfo()->SetReactState(REACT_PASSIVE);
+        }
+        else if (subcommand == "state" && !argumentFound)
+        {
+            std::string state;
+            switch (pet->GetCharmInfo()->GetReactState())
+            {
+                case REACT_AGGRESSIVE:
+                    SendWhisper("My pet is aggressive.", fromPlayer);
+                    break;
+                case REACT_DEFENSIVE:
+                    SendWhisper("My pet is defensive.", fromPlayer);
+                    break;
+                case REACT_PASSIVE:
+                    SendWhisper("My pet is passive.", fromPlayer);
+            }
+        }
+        else if (subcommand == "cast" && argumentFound)
+        {
+            uint32 spellId = (uint32) atol(argument.c_str());
+
+            if (spellId == 0)
+            {
+                spellId = getPetSpellId(argument.c_str());
+                if (spellId == 0)
+                    extractSpellId(argument, spellId);
+            }
+
+            if (spellId != 0 && pet->HasSpell(spellId))
+            {
+                if (pet->HasAura(spellId))
+                {
+                    pet->RemoveAura(spellId, pet->GetGUID());
+                    return;
+                }
+
+                uint64 castOnGuid = fromPlayer.GetSelection();
+                Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, castOnGuid);
+                CastPetSpell(spellId, pTarget);
+            }
+        }
+        else if (subcommand == "toggle" && argumentFound)
+        {
+            uint32 spellId = (uint32) atol(argument.c_str());
+
+            if (spellId == 0)
+            {
+                spellId = getPetSpellId(argument.c_str());
+                if (spellId == 0)
+                    extractSpellId(argument, spellId);
+            }
+
+            /*if (spellId != 0 && pet->HasSpell(spellId))
+            {
+                PetSpellMap::iterator itr = pet->m_spells.find(spellId);
+                if (itr != pet->m_spells.end())
+                {
+                    if (itr->second.active == ACT_ENABLED)
+                    {
+                        pet->ToggleAutocast(spellId, false);
+                        if (pet->HasAura(spellId))
+                            pet->RemoveAura(spellId, pet->GetGUID());
+                    }
+                    else
+                        pet->ToggleAutocast(spellId, true);
+                }
+            }*/
+        }
+        else if (subcommand == "spells" && !argumentFound)
+        {
+            int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+            std::ostringstream posOut;
+            std::ostringstream negOut;
+
+            for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+            {
+                const uint32 spellId = itr->first;
+
+                //if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || SPELL_ATTR0_PASSIVE)
+				if (itr->second.state == PETSPELL_REMOVED || SPELL_ATTR0_PASSIVE)
+                    continue;
+
+                const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+
+                std::string color;
+                switch (itr->second.active)
+                {
+                    case ACT_ENABLED:
+                        color = "cff35d22d"; // Some flavor of green
+                        break;
+                    default:
+                        color = "cffffffff";
+                }
+
+                /*if (IsPositiveSpell(spellId))
+                    posOut << " |" << color << "|Hspell:" << spellId << "|h["
+                           << pSpellInfo->SpellName[loc] << "]|h|r";
+                else*/
+                    negOut << " |" << color << "|Hspell:" << spellId << "|h["
+                           << pSpellInfo->SpellName[loc] << "]|h|r";
+            }
+
+            ChatHandler ch(&fromPlayer);
+            SendWhisper("Here's my pet's non-attack spells:", fromPlayer);
+            ch.SendSysMessage(posOut.str().c_str());
+            SendWhisper("and here's my pet's attack spells:", fromPlayer);
+            ch.SendSysMessage(negOut.str().c_str());
+        }
+    }
+
+    else if (text == "spells")
+    {
+
+        int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        typedef std::map<std::string, uint32> spellMap;
+
+        spellMap posSpells, negSpells;
+        std::string spellName;
+
+        uint32 ignoredSpells[] = {1843, 5019, 2479, 6603, 3365, 8386, 21651, 21652, 6233, 6246, 6247,
+                                  61437, 22810, 22027, 45927, 7266, 7267, 6477, 6478, 7355, 68398};
+        uint32 ignoredSpellsCount = sizeof(ignoredSpells) / sizeof(uint32);
+
+        for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE)
+                continue;
+
+            const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            spellName = pSpellInfo->SpellName[loc];
+
+            SkillLineAbilityMapBounds const bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);
+
+            bool isProfessionOrRidingSpell = false;
+            for (SkillLineAbilityMap::const_iterator skillIter = bounds.first; skillIter != bounds.second; ++skillIter)
+            {
+                if (IsProfessionOrRidingSkill(skillIter->second->skillId) && skillIter->first == spellId) {
+                    isProfessionOrRidingSpell = true;
+                    break;
+                }
+            }
+            if (isProfessionOrRidingSpell)
+                continue;
+
+            bool isIgnoredSpell = false;
+            for (uint8 i = 0; i < ignoredSpellsCount; ++i)
+            {
+                if (spellId == ignoredSpells[i]) {
+                    isIgnoredSpell = true;
+                    break;
+                }
+            }
+            if (isIgnoredSpell)
+                continue;
+
+            //if (IsPositiveSpell(spellId)) {
+                if (posSpells.find(spellName) == posSpells.end())
+                    posSpells[spellName] = spellId;
+                else
+                if (posSpells[spellName] < spellId)
+                    posSpells[spellName] = spellId;
+            //}
+            //else
+            //{
+                if (negSpells.find(spellName) == negSpells.end())
+                    negSpells[spellName] = spellId;
+                else
+                if (negSpells[spellName] < spellId)
+                    negSpells[spellName] = spellId;
+            //}
+        }
+
+        for (spellMap::const_iterator iter = posSpells.begin(); iter != posSpells.end(); ++iter)
+        {
+            posOut << " |cffffffff|Hspell:" << iter->second << "|h["
+                   << iter->first << "]|h|r";
+        }
+
+        for (spellMap::const_iterator iter = negSpells.begin(); iter != negSpells.end(); ++iter)
+        {
+            negOut << " |cffffffff|Hspell:" << iter->second << "|h["
+                   << iter->first << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("and here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+
+    // survey project: 20:50 02/12/10 rev.4 compact edition
+    else if (text == "survey")
+    {
+        uint32 count = 0;
+        std::ostringstream detectout;
+        QueryResult result;
+        GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
+        std::ostringstream eventFilter;
+        eventFilter << " AND (event IS NULL ";
+        bool initString = true;
+
+        for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+        {
+            if (initString)
+            {
+                eventFilter <<  "OR event IN (" << *itr;
+                initString = false;
+            }
+            else
+                eventFilter << "," << *itr;
+        }
+
+        if (!initString)
+            eventFilter << "))";
+        else
+            eventFilter << ")";
+
+        result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
+                                      "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
+                                      "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
+                                      m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(), eventFilter.str().c_str());
+
+        if (result)
+        {
+            do
+            {
+                Field *fields = result->Fetch();
+                uint32 guid = fields[0].GetUInt32();
+                uint32 entry = fields[1].GetUInt32();
+
+                GameObject *go = m_bot->GetMap()->GetGameObject(MAKE_NEW_GUID(HIGHGUID_GAMEOBJECT, entry, guid));
+                if (!go)
+                    continue;
+
+                if (!go->isSpawned())
+                    continue;
+
+                detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+                ++count;
+            } while (result->NextRow());
+
+        }
+        SendWhisper(detectout.str().c_str(), fromPlayer);
+    }
+
+    // Handle class & professions training:
+    // skill                           -- Lists bot(s) Primary profession skills & weapon skills
+    // skill train                     -- List available class or profession (Primary or Secondary) skills & spells, from selected trainer.
+    // skill learn [HLINK][HLINK] ..   -- Learn selected skill and spells, from selected trainer ([HLINK] from skill train).
+    // skill unlearn [HLINK][HLINK] .. -- Unlearn selected primary profession skill(s) and all associated spells ([HLINK] from skill)
+    else if (text.size() >= 5 && text.substr(0, 5) == "skill")
+    {
+        uint32 rank[8] = {0, 75, 150, 225, 300, 375, 450, 525};
+
+        std::ostringstream msg;
+
+        std::string part = "";
+        std::string subcommand = "";
+
+        if (text.size() > 5 && text.substr(0, 6) == "skill ")
+            part = text.substr(6);  // Truncate 'skill ' part
+
+        if (part.find(" ") > 0)
+        {
+            subcommand = part.substr(0, part.find(" "));
+            if (part.size() > subcommand.size())
+                part = part.substr(subcommand.size() + 1);
+        }
+        else
+            subcommand = part;
+
+        if (subcommand == "train" || subcommand == "learn")
+        {
+            uint32 totalCost = 0;
+
+            Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelection());
+            if (!unit)
+            {
+                SendWhisper("Please select the trainer!", fromPlayer);
+                return;
+            }
+
+            if (!unit->isTrainer())
+            {
+                SendWhisper("This is not a trainer!", fromPlayer);
+                return;
+            }
+
+            Creature *creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetSelection());
+            if (!creature)
+                return;
+
+            if (!creature->isCanTrainingOf(m_bot, false))
+            {
+                SendWhisper("This trainer can not teach me anything!", fromPlayer);
+                return;
+            }
+
+            // check present spell in trainer spell list
+            TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+            TrainerSpellData const* tSpells = creature->GetTrainerSpells();
+            if (!cSpells && !tSpells)
+            {
+                SendWhisper("No spells can be learnt from this trainer", fromPlayer);
+                return;
+            }
+
+            // reputation discount
+            float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+
+            // Handle: Learning class or profession (primary or secondary) skill & spell(s) for selected trainer, skill learn [HLINK][HLINK][HLINK].. ([HLINK] from skill train)
+            if (subcommand == "learn")
+            {
+                msg << "I have learnt the following spells:\r";
+                uint32 totalSpellLearnt = 0;
+                bool visuals = true;
+                m_spellsToLearn.clear();
+                extractSpellIdList(part, m_spellsToLearn);
+                for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); it++)
+                {
+                    uint32 spellId = *it;
+
+                    if (!spellId)
+                        break;
+
+                    TrainerSpell const* trainer_spell = cSpells->Find(spellId);
+                    if (!trainer_spell)
+                        trainer_spell = tSpells->Find(spellId);
+
+                    if (!trainer_spell || !trainer_spell->learnedSpell)
+                        continue;
+
+                    // apply reputation discount
+                    uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
+                    // check money requirement
+                    if (m_bot->GetMoney() < cost)
+                    {
+                        Announce(CANT_AFFORD);
+                        continue;
+                    }
+
+                    m_bot->ModifyMoney(-int32(cost));
+                    // learn explicitly or cast explicitly
+                    if (trainer_spell->IsCastable())
+                        m_bot->CastSpell(m_bot, trainer_spell->spell, true);
+                    else
+                        m_bot->learnSpell(spellId, false);
+                    ++totalSpellLearnt;
+                    totalCost += cost;
+                    const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                    if (!pSpellInfo)
+                        continue;
+
+                    if (visuals)
+                    {
+                        visuals = false;
+                        WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
+                        data << uint64(fromPlayer.GetSelection());
+                        data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
+                        GetMaster()->GetSession()->SendPacket(&data);
+
+                        data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
+                        data << m_bot->GetGUID();
+                        data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
+                        GetMaster()->GetSession()->SendPacket(&data);
+                    }
+
+                    WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
+                    data << uint64(fromPlayer.GetSelection());
+                    data << uint32(spellId);                                // should be same as in packet from client
+                    GetMaster()->GetSession()->SendPacket(&data);
+
+                    MakeSpellLink(pSpellInfo, msg);
+                    uint32 gold = uint32(cost / 10000);
+                    cost -= (gold * 10000);
+                    uint32 silver = uint32(cost / 100);
+                    cost -= (silver * 100);
+                    msg << " ";
+                    if (gold > 0)
+                        msg << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                    if (silver > 0)
+                        msg << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                    msg << cost <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t\r";
+                }
+                ReloadAI();
+                uint32 gold = uint32(totalCost / 10000);
+                totalCost -= (gold * 10000);
+                uint32 silver = uint32(totalCost / 100);
+                totalCost -= (silver * 100);
+                msg << "Total of " << totalSpellLearnt << " spell";
+                if (totalSpellLearnt != 1) msg << "s";
+                msg << " learnt, ";
+                if (gold > 0)
+                    msg << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                if (silver > 0)
+                    msg << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                msg << totalCost <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t spent.";
+            }
+            // Handle: List class or profession skill & spells for selected trainer, skill train
+            else
+            if (subcommand == "train")
+            {
+                msg << "The spells I can learn and their cost:\r";
+
+                TrainerSpellData const* trainer_spells = cSpells;
+                if (!trainer_spells)
+                    trainer_spells = tSpells;
+
+                for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+                {
+                    TrainerSpell const* tSpell = &itr->second;
+
+                    if (!tSpell)
+                        break;
+
+                    //if (!tSpell->learnedSpell && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell))
+                        //continue;
+
+                    //if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell) && m_bot->HasSpell(tSpell->learnedSpell))
+                        //continue;
+
+                    TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+                    if (state != TRAINER_SPELL_GREEN)
+                        continue;
+
+                    uint32 spellId = tSpell->spell;
+                    const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                    if (!pSpellInfo)
+                        continue;
+                    uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+                    totalCost += cost;
+
+                    uint32 gold = uint32(cost / 10000);
+                    cost -= (gold * 10000);
+                    uint32 silver = uint32(cost / 100);
+                    cost -= (silver * 100);
+                    MakeSpellLink(pSpellInfo, msg);
+                    msg << " ";
+                    if (gold > 0)
+                        msg << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                    if (silver > 0)
+                        msg << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                    msg << cost <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t\r";
+                }
+                int32 moneyDiff = m_bot->GetMoney() - totalCost;
+                if (moneyDiff >= 0)
+                {
+                    // calculate how much money bot has
+                    uint32 gold = uint32(moneyDiff / 10000);
+                    moneyDiff -= (gold * 10000);
+                    uint32 silver = uint32(moneyDiff / 100);
+                    moneyDiff -= (silver * 100);
+                    msg << " ";
+                    if (gold > 0)
+                        msg << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                    if (silver > 0)
+                        msg << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                    msg << moneyDiff <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t left.";
+                }
+                else
+                {
+                    Announce(CANT_AFFORD);
+                    moneyDiff *= -1;
+                    uint32 gold = uint32(moneyDiff / 10000);
+                    moneyDiff -= (gold * 10000);
+                    uint32 silver = uint32(moneyDiff / 100);
+                    moneyDiff -= (silver * 100);
+                    msg << "I need ";
+                    if (gold > 0)
+                        msg << " " << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+                    if (silver > 0)
+                        msg << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+                    msg << moneyDiff <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t more to learn all the spells!";
+                }
+            }
+        }
+        // Handle: Unlearning selected primary profession skill(s) and all associated spells, skill unlearn [HLINK][HLINK].. ([HLINK] from skill)
+        else
+        if (subcommand == "unlearn")
+        {
+            m_spellsToLearn.clear();
+            extractSpellIdList(part, m_spellsToLearn);
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+            {
+                if (/*sSpellMgr->IsPrimaryProfessionSkill(*it) &&*/ subcommand != "learn")
+                {
+                    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(*it);
+
+                    uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(*it);
+                    if (!prev_spell)                                    // first rank, remove skill
+                        GetPlayer()->SetSkill(0, spellLearnSkill->skill, 0, 0);
+                    else
+                    {
+                        // search prev. skill setting by spell ranks chain
+                        SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
+                        while (!prevSkill && prev_spell)
+                        {
+                            prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
+                            prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
+                        }
+                        if (!prevSkill)                                 // not found prev skill setting, remove skill
+                            GetPlayer()->SetSkill(0, spellLearnSkill->skill, 0, 0);
+                    }
+                }
+            }
+        }
+        // Handle: Lists bot(s) primary profession skills & weapon skills.
+        else
+        {
+            m_spellsToLearn.clear();
+            m_bot->skill(m_spellsToLearn);
+            msg << "My Primary Professions: ";
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+            {
+                if (IsPrimaryProfessionSkill(*it))
+                    for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                    {
+                        SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                        if (!skillLine)
+                            continue;
+
+                        // has skill
+                        if (skillLine->skillId == *it && skillLine->learnOnGetSkill == 0)
+                        {
+                            SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                            if (!spellInfo)
+                                continue;
+
+                            if (m_bot->GetSkillValue(*it) <= rank[sSpellMgr->GetSpellRank(skillLine->spellId)] && m_bot->HasSpell(skillLine->spellId))
+                            {
+                                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: HandleCommand - skill (%u)(%u)(%u):",skillLine->spellId, rank[sSpellMgr->GetSpellRank(skillLine->spellId)], m_bot->GetSkillValue(*it));
+                                MakeSpellLink(spellInfo, msg);
+                                break;
+                            }
+                        }
+                    }
+            }
+
+            msg << "\nMy Weapon skills: ";
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+            {
+                SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+                // has weapon skill
+                if (SkillLine->categoryId == SKILL_CATEGORY_WEAPON)
+                {
+                    for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                    {
+                        SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                        if (!skillLine)
+                            continue;
+
+                        SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                        if (!spellInfo)
+                            continue;
+
+                        if (skillLine->skillId == *it && spellInfo->Effect[0] == SPELL_EFFECT_WEAPON)
+                            MakeWeaponSkillLink(spellInfo,msg,*it);
+                    }
+                }
+            }
+        }
+        SendWhisper(msg.str(), fromPlayer);
+        m_spellsToLearn.clear();
+        m_bot->GetPlayerbotAI()->GetClassAI();
+    }
+
+    // stats project: 11:30 15/12/10 rev.2 display bot statistics
+    else if (text == "stats")
+    {
+        std::ostringstream out;
+
+        uint32 totalused = 0;
+        // list out items in main backpack
+        for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+        {
+            const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+            if (pItem)
+                totalused++;
+        }
+        uint32 totalfree = 16 - totalused;
+        // list out items in other removable backpacks
+        for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+        {
+            const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+            if (pBag)
+            {
+                ItemTemplate const* pBagProto = pBag->GetTemplate();
+                if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                    totalfree =  totalfree + pBag->GetFreeSlots();
+            }
+
+        }
+
+        // estimate how much item damage the bot has
+        uint32 copper = EstRepairAll();
+        uint32 gold = uint32(copper / 10000);
+        copper -= (gold * 10000);
+        uint32 silver = uint32(copper / 100);
+        copper -= (silver * 100);
+
+        out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff] has |cff00ff00";
+        out << totalfree << " |h|cffffffff bag slots,|h" << " |cff00ff00";
+        if (gold > 0)
+            out << "|r|cff00ff00" << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver > 0)
+            out << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        out << copper <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+
+        // calculate how much money bot has
+        copper = m_bot->GetMoney();
+        gold = uint32(copper / 10000);
+        copper -= (gold * 10000);
+        silver = uint32(copper / 100);
+        copper -= (silver * 100);
+
+        out << "|h|cffffffff item damage & has " << "|r|cff00ff00";
+        if (gold > 0)
+            out << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver > 0)
+            out << silver <<  " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        out << copper <<  " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+        ChatHandler ch(&fromPlayer);
+        ch.SendSysMessage(out.str().c_str());
+    }
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT|TYPEMASK_PLAYER);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.GetMenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.QuestId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    !m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+            }
+        }
+        else
+        {
+            std::string msg = "What? follow, stay, (c)ast <spellname>, spells, (e)quip <itemlink>, (u)se <itemlink>, drop <questlink>, report, quests, stats, collect";
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.h b/src/server/game/AI/PlayerBots/PlayerbotAI.h
new file mode 100644
index 0000000..4c61fdc
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.h
@@ -0,0 +1,492 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+#include "QuestDef.h"
+#include "GameEventMgr.h"
+#include "Unit.h"
+
+class WorldPacket;
+class WorldObject;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+class PlayerbotMgr;
+
+#define BOTLOOT_DISTANCE 75.0f
+
+enum RacialTraits
+{
+    ARCANE_TORRENT_MANA_CLASSES    = 28730,
+    ARCANE_TORRENT_DEATH_KNIGHT    = 50613,
+    ARCANE_TORRENT_ROGUE           = 25046,
+    BERSERKING_ALL                 = 26297,
+    BLOOD_FURY_MELEE_CLASSES       = 20572,
+    BLOOD_FURY_WARLOCK             = 33702,
+    BLOOD_FURY_SHAMAN              = 33697,
+    ESCAPE_ARTIST_ALL              = 20589,
+    EVERY_MAN_FOR_HIMSELF_ALL      = 59752,
+    GIFT_OF_THE_NAARU_DEATH_KNIGHT = 59545,
+    GIFT_OF_THE_NAARU_HUNTER       = 59543,
+    GIFT_OF_THE_NAARU_MAGE         = 59548,
+    GIFT_OF_THE_NAARU_PALADIN      = 59542,
+    GIFT_OF_THE_NAARU_PRIEST       = 59544,
+    GIFT_OF_THE_NAARU_SHAMAN       = 59547,
+    GIFT_OF_THE_NAARU_WARRIOR      = 28880,
+    SHADOWMELD_ALL                 = 58984,
+    STONEFORM_ALL                  = 20594,
+    WAR_STOMP_ALL                  = 20549,
+    WILL_OF_THE_FORSAKEN_ALL       = 7744
+};
+
+enum ProfessionSkills
+{
+    ALCHEMY_1                      = 2259,
+    BLACKSMITHING_1                = 2018,
+    COOKING_1                      = 2550,
+    ENCHANTING_1                   = 7411,
+    ENGINEERING_1                  = 4036,
+    FIRST_AID_1                    = 3273,
+    FISHING_1                      = 7620,
+    HERB_GATHERING_1               = 2366,
+    INSCRIPTION_1                  = 45357,
+    JEWELCRAFTING_1                = 25229,
+    MINING_1                       = 2575,
+    SKINNING_1                     = 8613,
+    TAILORING_1                    = 3908
+};
+
+enum NotableItems
+{
+    // Skeleton Keys
+    SILVER_SKELETON_KEY = 15869,
+    GOLDEN_SKELETON_KEY = 15870,
+    TRUESILVER_SKELETON_KEY = 15871,
+    ARCANITE_SKELETON_KEY = 15872,
+    TITANIUM_SKELETON_KEY = 43853,
+    COBALT_SKELETON_KEY = 43854,
+    // Lock Charges
+    SMALL_SEAFORIUM_CHARGE = 4367,
+    LARGE_SEAFORIUM_CHARGE = 4398,
+    POWERFUL_SEAFORIUM_CHARGE = 18594,
+    ELEMENTAL_SEAFORIUM_CHARGE = 23819
+};
+
+class PlayerbotAI
+{
+public:
+    enum ScenarioType
+    {
+        SCENARIO_PVEEASY,
+        SCENARIO_PVEHARD,
+        SCENARIO_DUEL,
+        SCENARIO_PVPEASY,
+        SCENARIO_PVPHARD
+    };
+
+    enum CombatStyle
+    {
+        COMBAT_MELEE                = 0x01,             // class melee attacker
+        COMBAT_RANGED               = 0x02              // class is ranged attacker
+    };
+
+    // masters orders that should be obeyed by the AI during the updateAI routine
+    // the master will auto set the target of the bot
+    enum CombatOrderType
+    {
+        ORDERS_NONE                 = 0x00,             // no special orders given
+        ORDERS_TANK                 = 0x01,             // bind attackers by gaining threat
+        ORDERS_ASSIST               = 0x02,             // assist someone (dps type)
+        ORDERS_HEAL                 = 0x04,             // concentrate on healing (no attacks, only self defense)
+        ORDERS_PROTECT              = 0x10,             // combinable state: check if protectee is attacked
+        ORDERS_PRIMARY              = 0x0F,
+        ORDERS_SECONDARY            = 0xF0,
+        ORDERS_RESET                = 0xFF
+    };
+
+    enum CombatTargetType
+    {
+        TARGET_NORMAL               = 0x00,
+        TARGET_THREATEN             = 0x01
+    };
+
+    enum BotState
+    {
+        BOTSTATE_NORMAL,            // normal AI routines are processed
+        BOTSTATE_COMBAT,            // bot is in combat
+        BOTSTATE_DEAD,              // we are dead and wait for becoming ghost
+        BOTSTATE_DEADRELEASED,      // we released as ghost and wait to revive
+        BOTSTATE_LOOTING,           // looting mode, used just after combat
+        BOTSTATE_FLYING             // bot is flying
+    };
+
+    enum CollectionFlags
+    {
+        COLLECT_FLAG_NOTHING    = 0x00,     // skip looting of anything
+        COLLECT_FLAG_COMBAT     = 0x01,     // loot after combat
+        COLLECT_FLAG_QUEST      = 0x02,     // quest and needed items
+        COLLECT_FLAG_PROFESSION = 0x04,     // items related to skills
+        COLLECT_FLAG_LOOT       = 0x08,     // all loot on corpses
+        COLLECT_FLAG_SKIN       = 0x10,     // skin creatures if available
+        COLLECT_FLAG_NEAROBJECT = 0x20      // collect specified nearby object
+    };
+
+    enum MovementOrderType
+    {
+        MOVEMENT_NONE               = 0x00,
+        MOVEMENT_FOLLOW             = 0x01,
+        MOVEMENT_STAY               = 0x02
+    };
+
+    enum TaskFlags
+    {
+        NONE                        = 0x00,  // do nothing
+        SELL_ITEMS                  = 0x01,  // sell items
+        REPAIR_ITEMS                = 0x02,  // repair items
+        ADD_AUCTION                 = 0x03,  // add auction
+        REMOVE_AUCTION              = 0x04,  // remove auction
+        RESET_TALENTS               = 0x05,  // reset all talents
+        BANK_WITHDRAW               = 0x06,  // withdraw item from bank
+        BANK_DEPOSIT                = 0x07,  // deposit item in bank
+        LIST_QUEST                  = 0x08,  // list quests
+        END_QUEST                   = 0x09,  // turn in quests
+        TAKE_QUEST                  = 0x0A   // take quest
+    };
+
+    enum AnnounceFlags
+    {
+        NOTHING                     = 0x00,
+        INVENTORY_FULL              = 0x01,
+        CANT_AFFORD                 = 0x02
+    };
+
+    typedef std::pair<enum TaskFlags, uint32> taskPair;
+    typedef std::list<taskPair> BotTaskList;
+    typedef std::list<enum NPCFlags> BotNPCList;
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::pair<uint32, uint32>talentPair;
+    typedef std::list<uint64> BotLootTarget;
+    typedef std::list<uint32> BotLootEntry;
+    typedef std::list<uint32> BotSpellList;
+    typedef std::vector<uint32> BotTaxiNode;
+
+    // attacker query used in PlayerbotAI::FindAttacker()
+    enum ATTACKERINFOTYPE
+    {
+        AIT_NONE                    = 0x00,
+        AIT_LOWESTTHREAT            = 0x01,
+        AIT_HIGHESTTHREAT           = 0x02,
+        AIT_VICTIMSELF              = 0x04,
+        AIT_VICTIMNOTSELF           = 0x08      // !!! must use victim param in FindAttackers
+    };
+    struct AttackerInfo
+    {
+        Unit*    attacker;            // reference to the attacker
+        Unit*    victim;              // combatant's current victim
+        float threat;                 // own threat on this combatant
+        float threat2;                // highest threat not caused by bot
+        uint32 count;                 // number of units attacking
+        uint32 source;                // 1=bot, 2=master, 3=group
+    };
+    typedef std::map<uint64, AttackerInfo> AttackerInfoList;
+    typedef std::map<uint32, float> SpellRanges;
+
+public:
+    PlayerbotAI(PlayerbotMgr * const mgr, Player * const bot);
+    virtual ~PlayerbotAI();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called from ChatHandler.cpp when there is an incoming message to the bot
+    // from a whisper or from the party channel
+    void HandleCommand(const std::string& text, Player& fromPlayer);
+
+    // This is called by WorldSession.cpp
+    // It provides a view of packets normally sent to the client.
+    // Since there is no client at the other end, the packets are dropped of course.
+    // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+    // This is called by WorldSession.cpp
+    // when it detects that a bot is being teleported. It acknowledges to the server to complete the
+    // teleportation
+    void HandleTeleportAck();
+
+    // Returns what kind of situation we are in so the ai can react accordingly
+    ScenarioType GetScenarioType() { return m_ScenarioType; }
+
+    PlayerbotClassAI* GetClassAI() { return m_classAI; }
+    PlayerbotMgr* GetManager() { return m_mgr; }
+    void ReloadAI();
+
+    // finds spell ID for matching substring args
+    // in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char* args, bool master = false) const;
+    uint32 getPetSpellId(const char* args) const;
+    // Initialize spell using rank 1 spell id
+    uint32 initSpell(uint32 spellId);
+    uint32 initPetSpell(uint32 spellIconId);
+
+    // extract quest ids from links
+    void extractQuestIds(const std::string& text, std::list<uint32>& questIds) const;
+
+    // extract auction ids from links
+    void extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const;
+
+    // extracts talent ids to list
+    void extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const;
+
+    // extracts item ids from links
+    void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+    // extract spellid from links
+    void extractSpellId(const std::string& text, uint32 &spellId) const;
+
+    // extract spellids from links to list
+    void extractSpellIdList(const std::string& text, BotSpellList& m_spellsToLearn) const;
+
+    // extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string& text) const;
+
+    // extracts gameobject info from link
+    void extractGOinfo(const std::string& text, BotLootTarget& m_lootTargets) const;
+
+    // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds nearby game objects that are specified in m_collectObjects then adds them to the m_lootTargets list
+    void findNearbyGO();
+    // finds nearby creatures, whose UNIT_NPC_FLAGS match the flags specified in item list m_itemIds
+    void findNearbyCreature();
+
+    void MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out);
+    void MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid);
+
+    // currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player& player) const;
+
+    // get current casting spell (will return NULL if no spell!)
+    Spell* GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit& player) const;
+    bool HasAura(const char* spellName, const Unit& player) const;
+    bool HasAura(const char* spellName) const;
+
+    bool CanReceiveSpecificSpell(uint8 spec, Unit* target) const;
+
+    bool HasTool(uint32 TC);
+    bool HasSpellReagents(uint32 spellId);
+
+    uint8 GetHealthPercent(const Unit& target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit& target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit& target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit& target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit& target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit& target) const;
+    uint8 GetRunicPower() const;
+
+    Item* FindFood() const;
+    Item* FindDrink() const;
+    Item* FindBandage() const;
+    Item* FindPoison() const;
+    Item* FindMount(uint32 matchingRidingSkill) const;
+    Item* FindItem(uint32 ItemId);
+    Item* FindItemInBank(uint32 ItemId);
+    Item* FindKeyForLockValue(uint32 reqSkillValue);
+    Item* FindBombForLockValue(uint32 reqSkillValue);
+    Item* FindConsumable(uint32 displayId) const;
+    bool CanStore();
+
+    // ******* Actions ****************************************
+    // Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string& text) const;
+    void TellMaster(const char *fmt, ...) const;
+    void SendWhisper(const std::string& text, Player& player) const;
+    bool CastSpell(const char* args);
+    bool CastSpell(uint32 spellId);
+    bool CastSpell(uint32 spellId, Unit& target);
+    bool CastPetSpell(uint32 spellId, Unit* target = NULL);
+    bool Buff(uint32 spellId, Unit * target, void (*beforeCast)(Player *) = NULL);
+    bool SelfBuff(uint32 spellId);
+    bool IsInRange(Unit* Target, uint32 spellId);
+
+    void UseItem(Item *item, uint32 targetFlag, uint64 targetGUID);
+    void UseItem(Item *item, uint8 targetInventorySlot);
+    void UseItem(Item *item, Unit *target);
+    void UseItem(Item *item);
+
+    void PlaySound(uint32 soundid);
+    void Announce(AnnounceFlags msg);
+
+    void EquipItem(Item* src_Item);
+    //void Stay();
+    //bool Follow(Player& player);
+    void SendNotEquipList(Player& player);
+    void Feast();
+    void InterruptCurrentCastingSpell();
+    void GetCombatTarget(Unit* forcedTarged = 0);
+    void GetDuelTarget(Unit* forcedTarget);
+    Unit *GetCurrentTarget() { return m_targetCombat; };
+    void DoNextCombatManeuver();
+    void DoCombatMovement();
+    void SetIgnoreUpdateTime(uint8 t = 0) { m_ignoreAIUpdatesUntilTime = time(0) + t; };
+
+    Player *GetPlayerBot() const { return m_bot; }
+    Player *GetPlayer() const { return m_bot; }
+    Player *GetMaster() const;
+
+    BotState GetState() { return m_botState; };
+    void SetState(BotState state);
+    void SetQuestNeedItems();
+    void SetQuestNeedCreatures();
+    void SendQuestNeedList();
+    bool IsInQuestItemList(uint32 itemid) { return m_needItemList.find(itemid) != m_needItemList.end(); };
+    bool IsInQuestCreatureList(uint32 id) { return m_needCreatureOrGOList.find(id) != m_needCreatureOrGOList.end(); };
+    bool IsItemUseful(uint32 itemid);
+    void SendOrders(Player& player);
+    bool DoTeleport(WorldObject &obj);
+    void DoLoot();
+    void DoFlight();
+    void GetTaxi(uint64 guid, BotTaxiNode& nodes);
+
+    bool HasCollectFlag(uint8 flag) { return m_collectionFlags & flag; }
+    void SetCollectFlag(uint8 flag)
+    {
+        if (HasCollectFlag(flag)) m_collectionFlags &= ~flag;
+        else m_collectionFlags |= flag;
+    }
+
+    uint32 EstRepairAll();
+    uint32 EstRepair(uint16 pos);
+
+    void AcceptQuest(Quest const *qInfo, Player *pGiver);
+    void TurnInQuests(WorldObject *questgiver);
+    void ListQuests(WorldObject* questgiver);
+    bool AddQuest(const uint32 entry, WorldObject* questgiver);
+
+    bool IsInCombat();
+    void UpdateAttackerInfo();
+    Unit* FindAttacker(ATTACKERINFOTYPE ait = AIT_NONE, Unit *victim = 0);
+    uint32 GetAttackerCount() { return m_attackerInfo.size(); };
+    void SetCombatOrderByStr(std::string str, Unit *target = 0);
+    void SetCombatOrder(CombatOrderType co, Unit *target = 0);
+    CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
+    void SetMovementOrder(MovementOrderType mo, Unit *followTarget = 0);
+    MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
+    void MovementReset();
+    void MovementClear();
+    bool IsMoving();
+
+    void SetInFront(const Unit* obj);
+
+    void ItemLocalization(std::string& itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string& questTitle, const uint32 questID) const;
+    void CreatureLocalization(std::string& creatureName, const uint32 entry) const;
+    void GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const;
+
+    uint8 GetFreeBagSpace() const;
+    void SellGarbage(bool verbose = true);
+    void Sell(const uint32 itemid);
+    void AddAuction(const uint32 itemid, Creature* aCreature);
+    void ListAuctions();
+    bool RemoveAuction(const uint32 auctionid);
+    void Repair(const uint32 itemid, Creature* rCreature);
+    bool Talent(Creature* tCreature);
+    void InspectUpdate();
+    bool Withdraw(const uint32 itemid);
+    bool Deposit(const uint32 itemid);
+    void BankBalance();
+
+private:
+    // ****** Closed Actions ********************************
+    // These actions may only be called at special times.
+    // Trade methods are only applicable when the trade window is open
+    // and are only called from within HandleCommand.
+    bool TradeItem(const Item& item, int8 slot = -1);
+    bool TradeCopper(uint32 copper);
+
+    // Helper routines not needed by class AIs.
+    void UpdateAttackersForTarget(Unit *victim);
+
+    void _doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold);
+    void MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemLink(const ItemTemplate *item, std::ostringstream &out);
+
+    // it is safe to keep these back reference pointers because m_bot
+    // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    PlayerbotMgr* const m_mgr;
+    Player* const m_bot;
+    PlayerbotClassAI* m_classAI;
+
+    // ignores AI updates until time specified
+    // no need to waste CPU cycles during casting etc
+    time_t m_ignoreAIUpdatesUntilTime;
+
+    CombatStyle m_combatStyle;
+    CombatOrderType m_combatOrder;
+    MovementOrderType m_movementOrder;
+
+    ScenarioType m_ScenarioType;
+
+    // defines the state of behaviour of the bot
+    BotState m_botState;
+
+    // list of items, creatures or gameobjects needed to fullfill quests
+    BotNeedItem m_needItemList;
+    BotNeedItem m_needCreatureOrGOList;
+
+    // list of creatures we recently attacked and want to loot
+    BotNPCList m_findNPC;               // list of NPCs
+    BotTaskList m_tasks;                // list of tasks
+    BotLootTarget m_lootTargets;        // list of targets
+    BotSpellList m_spellsToLearn;       // list of spells
+    uint64 m_lootCurrent;           // current remains of interest
+    uint64 m_lootPrev;              // previous loot
+    BotLootEntry m_collectObjects;      // object entries searched for in findNearbyGO
+    BotTaxiNode m_taxiNodes;            // flight node chain;
+
+    uint8 m_collectionFlags;            // what the bot should look for to loot
+    bool m_inventory_full;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    uint32 m_CurrentlyCastingSpellId;
+    //bool m_IsFollowingMaster;
+
+    // if master commands bot to do something, store here until updateAI
+    // can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+    uint64 m_taxiMaster;
+
+    AttackerInfoList m_attackerInfo;
+
+    bool m_targetChanged;
+    CombatTargetType m_targetType;
+
+    Unit *m_targetCombat;       // current combat target
+    Unit *m_targetAssist;       // get new target by checking attacker list of assisted player
+    Unit *m_targetProtect;      // check
+
+    Unit *m_followTarget;       // whom to follow in non combat situation?
+
+    uint32 FISHING,
+           HERB_GATHERING,
+           MINING,
+           SKINNING;
+
+    SpellRanges m_spellRangeMap;
+
+    float m_destX, m_destY, m_destZ; // latest coordinates for chase and point movement types
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..8df85e7
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
@@ -0,0 +1,19 @@
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : m_master(master), m_bot(bot), m_ai(ai) {}
+PlayerbotClassAI::~PlayerbotClassAI() {}
+
+bool PlayerbotClassAI::DoFirstCombatManeuver(Unit *)
+{
+    // return false, if done with opening moves/spells
+    return false;
+}
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *) {}
+
+void PlayerbotClassAI::DoNonCombatActions() {}
+
+bool PlayerbotClassAI::BuffPlayer(Player* target)
+{
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotClassAI.h b/src/server/game/AI/PlayerBots/PlayerbotClassAI.h
new file mode 100644
index 0000000..c8a46cc
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotClassAI.h
@@ -0,0 +1,46 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "Group.h"
+
+class Player;
+class PlayerbotAI;
+
+class PlayerbotClassAI
+{
+public:
+    PlayerbotClassAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotClassAI();
+
+    // all combat actions go here
+    virtual bool DoFirstCombatManeuver(Unit*);
+    virtual void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    virtual void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    virtual bool BuffPlayer(Player* target);
+
+    // Utilities
+    Player* GetMaster() { return m_master; }
+    Player* GetPlayerBot() { return m_bot; }
+    PlayerbotAI* GetAI() { return m_ai; };
+
+
+private:
+    Player* m_master;
+    Player* m_bot;
+    PlayerbotAI* m_ai;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..feb57d5
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,502 @@
+// a simple DK class by rrtn :)
+
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+
+    PLAGUE_STRIKE     = ai->initSpell(PLAGUE_STRIKE_1); // Unholy
+    DEATH_GRIP        = ai->initSpell(DEATH_GRIP_1);
+    DEATH_COIL        = ai->initSpell(DEATH_COIL_DEATH_KNIGHT_1);
+    DEATH_STRIKE      = ai->initSpell(DEATH_STRIKE_1);
+    UNHOLY_BLIGHT     = 0; // Passive
+    SCOURGE_STRIKE    = ai->initSpell(SCOURGE_STRIKE_1);
+    DEATH_AND_DECAY   = ai->initSpell(DEATH_AND_DECAY_1);
+    CORPSE_EXPLOSION  = ai->initSpell(CORPSE_EXPLOSION_1);
+    BONE_SHIELD       = ai->initSpell(BONE_SHIELD_1); // buffs
+    ANTI_MAGIC_SHELL  = ai->initSpell(ANTI_MAGIC_SHELL_1);
+    ANTI_MAGIC_ZONE   = ai->initSpell(ANTI_MAGIC_ZONE_1);
+    GHOUL_FRENZY      = ai->initSpell(GHOUL_FRENZY_1);
+    RAISE_DEAD        = ai->initSpell(RAISE_DEAD_1); // pets
+    SUMMON_GARGOYLE   = ai->initSpell(SUMMON_GARGOYLE_1);
+    ARMY_OF_THE_DEAD  = ai->initSpell(ARMY_OF_THE_DEAD_1);
+    ICY_TOUCH         = ai->initSpell(ICY_TOUCH_1); // Frost
+    OBLITERATE        = ai->initSpell(OBLITERATE_1);
+    HOWLING_BLAST     = ai->initSpell(HOWLING_BLAST_1);
+    FROST_STRIKE      = ai->initSpell(FROST_STRIKE_1);
+    CHAINS_OF_ICE     = ai->initSpell(CHAINS_OF_ICE_1);
+    RUNE_STRIKE       = ai->initSpell(RUNE_STRIKE_1);
+    ICY_CLUTCH        = 0; // No such spell
+    MIND_FREEZE       = ai->initSpell(MIND_FREEZE_1);
+    HUNGERING_COLD    = ai->initSpell(HUNGERING_COLD_1);
+    KILLING_MACHINE   = 0; // Passive
+    DEATHCHILL        = ai->initSpell(DEATHCHILL_1);
+    HORN_OF_WINTER    = ai->initSpell(HORN_OF_WINTER_1);
+    ICEBOUND_FORTITUDE = ai->initSpell(ICEBOUND_FORTITUDE_1);
+    EMPOWER_WEAPON    = ai->initSpell(EMPOWER_RUNE_WEAPON_1);
+    UNBREAKABLE_ARMOR = ai->initSpell(UNBREAKABLE_ARMOR_1);
+    BLOOD_STRIKE      = ai->initSpell(BLOOD_STRIKE_1); // Blood
+    PESTILENCE        = ai->initSpell(PESTILENCE_1);
+    STRANGULATE       = ai->initSpell(STRANGULATE_1);
+    BLOOD_BOIL        = ai->initSpell(BLOOD_BOIL_1);
+    HEART_STRIKE      = ai->initSpell(HEART_STRIKE_1);
+    DANCING_WEAPON    = ai->initSpell(DANCING_RUNE_WEAPON_1);
+    DARK_COMMAND      = ai->initSpell(DARK_COMMAND_1);
+    MARK_OF_BLOOD     = ai->initSpell(MARK_OF_BLOOD_1); // buffs
+    RUNE_TAP          = ai->initSpell(RUNE_TAP_1);
+    VAMPIRIC_BLOOD    = ai->initSpell(VAMPIRIC_BLOOD_1);
+    DEATH_PACT        = ai->initSpell(DEATH_PACT_1);
+    HYSTERIA          = ai->initSpell(HYSTERIA_1);
+    UNHOLY_PRESENCE   = ai->initSpell(UNHOLY_PRESENCE_1); // presence (TODO: better spell == presence)
+    FROST_PRESENCE    = ai->initSpell(FROST_PRESENCE_1);
+    BLOOD_PRESENCE    = ai->initSpell(BLOOD_PRESENCE_1);
+
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_DEATH_KNIGHT); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_DEATH_KNIGHT); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+bool PlayerbotDeathKnightAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(PLAGUE_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // DK Attacks: Unholy, Frost & Blood
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+    float dist = m_bot->GetDistance(pTarget);
+    std::ostringstream out;
+
+    switch (SpellSequence)
+    {
+        case SPELL_DK_UNHOLY:
+            if (UNHOLY_PRESENCE > 0)
+                (!m_bot->HasAura(UNHOLY_PRESENCE) && !m_bot->HasAura(BLOOD_PRESENCE) && !m_bot->HasAura(FROST_PRESENCE) && ai->CastSpell (UNHOLY_PRESENCE, *m_bot));
+
+            // check for BONE_SHIELD in combat
+            if (BONE_SHIELD > 0)
+                (!m_bot->HasAura(BONE_SHIELD) && !m_bot->HasAura(ARMY_OF_THE_DEAD) && ai->CastSpell (BONE_SHIELD, *m_bot));
+
+            if (ARMY_OF_THE_DEAD > 0 && ai->GetAttackerCount() >= 5 && LastSpellUnholyDK < 1)
+            {
+                ai->CastSpell(ARMY_OF_THE_DEAD);
+                out << " summoning Army of the Dead!";
+                if (ARMY_OF_THE_DEAD > 0 && m_bot->HasAura(ARMY_OF_THE_DEAD))
+                    ai->SetIgnoreUpdateTime(7);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (PLAGUE_STRIKE > 0 && !pTarget->HasAura(PLAGUE_STRIKE) && LastSpellUnholyDK < 2)
+            {
+                ai->CastSpell(PLAGUE_STRIKE, *pTarget);
+                out << " Plague Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_GRIP > 0 && !pTarget->HasAura(DEATH_GRIP) && LastSpellUnholyDK < 3)
+            {
+                ai->CastSpell(DEATH_GRIP, *pTarget);
+                out << " Death Grip";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_COIL > 0 && LastSpellUnholyDK < 4 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(DEATH_COIL, *pTarget);
+                out << " Death Coil";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_STRIKE > 0 && !pTarget->HasAura(DEATH_STRIKE) && LastSpellUnholyDK < 5)
+            {
+                ai->CastSpell(DEATH_STRIKE, *pTarget);
+                out << " Death Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (UNHOLY_BLIGHT > 0 && !pTarget->HasAura(UNHOLY_BLIGHT) && LastSpellUnholyDK < 6)
+            {
+                ai->CastSpell(UNHOLY_BLIGHT);
+                out << " Unholy Blight";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SCOURGE_STRIKE > 0 && LastSpellUnholyDK < 7)
+            {
+                ai->CastSpell(SCOURGE_STRIKE, *pTarget);
+                out << " Scourge Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_AND_DECAY > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(DEATH_AND_DECAY) && LastSpellUnholyDK < 8)
+            {
+                ai->CastSpell(DEATH_AND_DECAY);
+                out << " Death and Decay";
+                ai->SetIgnoreUpdateTime(1);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SUMMON_GARGOYLE > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD) && !pTarget->HasAura(SUMMON_GARGOYLE) && LastSpellUnholyDK < 9 && ai->GetRunicPower() >= 60)
+            {
+                ai->CastSpell(SUMMON_GARGOYLE, *pTarget);
+                out << " summoning Gargoyle";
+                ai->SetIgnoreUpdateTime(2);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (CORPSE_EXPLOSION > 0 && dist <= ATTACK_DISTANCE && LastSpellUnholyDK < 10)
+            {
+                ai->CastSpell(CORPSE_EXPLOSION, *pTarget);
+                out << " Corpse Explosion";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_SHELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL) && LastSpellUnholyDK < 11 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ANTI_MAGIC_SHELL, *m_bot);
+                out << " Anti-Magic Shell";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_ZONE > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL) && LastSpellUnholyDK < 12)
+            {
+                ai->CastSpell(ANTI_MAGIC_ZONE, *m_bot);
+                out << " Anti-Magic Zone";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((!pet)
+                     && (RAISE_DEAD > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD) && LastSpellUnholyDK < 13))
+            {
+                ai->CastSpell(RAISE_DEAD);
+                out << " summoning Ghoul";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (GHOUL_FRENZY > 0 && pVictim == pet && !pet->HasAura(GHOUL_FRENZY) && LastSpellUnholyDK < 14))
+            {
+                ai->CastSpell(GHOUL_FRENZY, *pet);
+                out << " casting Ghoul Frenzy on pet";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (LastSpellUnholyDK > 15)
+            {
+                LastSpellUnholyDK = 0;
+                SpellSequence = SPELL_DK_FROST;
+                break;
+            }
+
+            LastSpellUnholyDK = 0;
+
+        case SPELL_DK_FROST:
+            if (FROST_PRESENCE > 0)
+                (!m_bot->HasAura(FROST_PRESENCE) && !m_bot->HasAura(BLOOD_PRESENCE) && !m_bot->HasAura(UNHOLY_PRESENCE) && ai->CastSpell (FROST_PRESENCE, *m_bot));
+
+            if (DEATHCHILL > 0)
+                (!m_bot->HasAura(DEATHCHILL) && !m_bot->HasAura(KILLING_MACHINE) && ai->CastSpell (DEATHCHILL, *m_bot));
+            else if (KILLING_MACHINE > 0)
+                (!m_bot->HasAura(KILLING_MACHINE) && !m_bot->HasAura(DEATHCHILL) && ai->CastSpell (KILLING_MACHINE, *m_bot));
+
+            if (ICY_TOUCH > 0 && !pTarget->HasAura(ICY_TOUCH) && LastSpellFrostDK < 1)
+            {
+                ai->CastSpell(ICY_TOUCH, *pTarget);
+                out << " Icy Touch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (OBLITERATE > 0 && LastSpellFrostDK < 2)
+            {
+                ai->CastSpell(OBLITERATE, *pTarget);
+                out << " Obliterate";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (FROST_STRIKE > 0 && LastSpellFrostDK < 3 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(FROST_STRIKE, *pTarget);
+                out << " Frost Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HOWLING_BLAST > 0 && ai->GetAttackerCount() >= 3 && LastSpellFrostDK < 4)
+            {
+                ai->CastSpell(HOWLING_BLAST, *pTarget);
+                out << " Howling Blast";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (CHAINS_OF_ICE > 0 && !pTarget->HasAura(CHAINS_OF_ICE) && LastSpellFrostDK < 5)
+            {
+                ai->CastSpell(CHAINS_OF_ICE, *pTarget);
+                out << " Chains of Ice";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (RUNE_STRIKE > 0 && LastSpellFrostDK < 6 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(RUNE_STRIKE, *pTarget);
+                out << " Rune Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICY_CLUTCH > 0 && !pTarget->HasAura(ICY_CLUTCH) && LastSpellFrostDK < 7)
+            {
+                ai->CastSpell(ICY_CLUTCH, *pTarget);
+                out << " Icy Clutch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICEBOUND_FORTITUDE > 0 && ai->GetHealthPercent() < 50 && pVictim == m_bot && !m_bot->HasAura(ICEBOUND_FORTITUDE) && LastSpellFrostDK < 8 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ICEBOUND_FORTITUDE, *m_bot);
+                out << " Icebound Fortitude";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (MIND_FREEZE > 0 && pTarget->IsNonMeleeSpellCasted(true) && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 9 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(MIND_FREEZE, *pTarget);
+                out << " Mind Freeze";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HUNGERING_COLD > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 10 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(HUNGERING_COLD, *pTarget);
+                out << " Hungering Cold";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (EMPOWER_WEAPON > 0 && ai->GetRunicPower() < 20 && LastSpellFrostDK < 11)
+            {
+                ai->CastSpell(EMPOWER_WEAPON, *m_bot);
+                out << " Empower Rune Weapon";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (UNBREAKABLE_ARMOR > 0 && !m_bot->HasAura(UNBREAKABLE_ARMOR) && ai->GetHealthPercent() < 70 && pVictim == m_bot && LastSpellFrostDK < 12)
+            {
+                ai->CastSpell(UNBREAKABLE_ARMOR, *m_bot);
+                out << " Unbreakable Armor";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (LastSpellFrostDK > 13)
+            {
+                LastSpellFrostDK = 0;
+                SpellSequence = SPELL_DK_BLOOD;
+                break;
+            }
+
+            LastSpellFrostDK = 0;
+
+        case SPELL_DK_BLOOD:
+            if (BLOOD_PRESENCE > 0)
+                (!m_bot->HasAura(BLOOD_PRESENCE) && !m_bot->HasAura(UNHOLY_PRESENCE) && !m_bot->HasAura(FROST_PRESENCE) && ai->CastSpell (BLOOD_PRESENCE, *m_bot));
+
+            if (MARK_OF_BLOOD > 0 && !pTarget->HasAura(MARK_OF_BLOOD) && LastSpellBloodDK < 1)
+            {
+                ai->CastSpell(MARK_OF_BLOOD, *pTarget);
+                out << " Mark of Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_STRIKE > 0 && LastSpellBloodDK < 2)
+            {
+                ai->CastSpell(BLOOD_STRIKE, *pTarget);
+                out << " Blood Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK =  LastSpellBloodDK + 1;
+                break;
+            }
+            else if (PESTILENCE > 0 && dist <= ATTACK_DISTANCE && ai->GetAttackerCount() >= 3 && LastSpellBloodDK < 3)
+            {
+                ai->CastSpell(PESTILENCE, *pTarget);
+                out << " Pestilence";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (STRANGULATE > 0 && !pTarget->HasAura(STRANGULATE) && LastSpellBloodDK < 4)
+            {
+                ai->CastSpell(STRANGULATE, *pTarget);
+                out << " Strangulate";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_BOIL > 0 && ai->GetAttackerCount() >= 5 && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 5)
+            {
+                ai->CastSpell(BLOOD_BOIL, *pTarget);
+                out << " Blood Boil";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HEART_STRIKE > 0 && LastSpellBloodDK < 6)
+            {
+                ai->CastSpell(HEART_STRIKE, *pTarget);
+                out << " Heart Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (VAMPIRIC_BLOOD > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD) && LastSpellBloodDK < 7)
+            {
+                ai->CastSpell(VAMPIRIC_BLOOD, *m_bot);
+                out << " Vampiric Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (RUNE_TAP > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD) && LastSpellBloodDK < 8)
+            {
+                ai->CastSpell(RUNE_TAP, *m_bot);
+                out << " Rune Tap";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HYSTERIA > 0 && ai->GetHealthPercent() > 25 && !m_bot->HasAura(HYSTERIA) && LastSpellBloodDK < 9)
+            {
+                ai->CastSpell(HYSTERIA, *m_bot);
+                out << " Hysteria";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DANCING_WEAPON > 0 && !m_bot->HasAura(DANCING_WEAPON) && ai->GetRunicPower() >= 60 && LastSpellBloodDK < 10)
+            {
+                ai->CastSpell(DANCING_WEAPON, *pTarget);
+                out << " summoning Dancing Rune Weapon";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DARK_COMMAND > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !pTarget->HasAura(DARK_COMMAND) && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 11)
+            {
+                ai->CastSpell(DARK_COMMAND, *pTarget);
+                out << " Dark Command";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (DEATH_PACT > 0 && ai->GetHealthPercent() < 50 && LastSpellBloodDK < 12 && ai->GetRunicPower() >= 40))
+            {
+                ai->CastSpell(DEATH_PACT, *pet);
+                out << " Death Pact (sacrifice pet)";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (LastSpellBloodDK > 13)
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+                break;
+            }
+            else
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+            }
+    }
+    if (ai->GetManager()->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_DK_UNHOLY;
+
+    // buff master with HORN_OF_WINTER
+    if (HORN_OF_WINTER > 0)
+        (!GetMaster()->HasAura(HORN_OF_WINTER) && ai->CastSpell (HORN_OF_WINTER, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..bb9c4dd
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,100 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_DK_UNHOLY,
+    SPELL_DK_FROST,
+    SPELL_DK_BLOOD
+};
+
+enum DeathKnightSpells
+{
+    ANTI_MAGIC_SHELL_1              = 48707,
+    ANTI_MAGIC_ZONE_1               = 51052,
+    ARMY_OF_THE_DEAD_1              = 42650,
+    BLOOD_BOIL_1                    = 48721,
+    BLOOD_PRESENCE_1                = 48266,
+    BLOOD_STRIKE_1                  = 45902,
+    BLOOD_TAP_1                     = 45529,
+    BONE_SHIELD_1                   = 49222,
+    CHAINS_OF_ICE_1                 = 45524,
+    CORPSE_EXPLOSION_1              = 49158,
+    DANCING_RUNE_WEAPON_1           = 49028,
+    DARK_COMMAND_1                  = 56222,
+    DEATH_AND_DECAY_1               = 43265,
+    DEATH_COIL_DEATH_KNIGHT_1       = 47541,
+    DEATH_GRIP_1                    = 49576,
+    DEATH_PACT_1                    = 48743,
+    DEATH_STRIKE_1                  = 49998,
+    DEATHCHILL_1                    = 49796,
+    EMPOWER_RUNE_WEAPON_1           = 47568,
+    FROST_PRESENCE_1                = 48263,
+    FROST_STRIKE_1                  = 49143,
+    GHOUL_FRENZY_1                  = 63560,
+    HEART_STRIKE_1                  = 55050,
+    HORN_OF_WINTER_1                = 57330,
+    HOWLING_BLAST_1                 = 49184,
+    HUNGERING_COLD_1                = 49203,
+    HYSTERIA_1                      = 49016,
+    ICEBOUND_FORTITUDE_1            = 48792,
+    ICY_TOUCH_1                     = 45477,
+    LICHBORNE_1                     = 49039,
+    MARK_OF_BLOOD_1                 = 49005,
+    MIND_FREEZE_1                   = 47528,
+    OBLITERATE_1                    = 49020,
+    PATH_OF_FROST_1                 = 3714,
+    PESTILENCE_1                    = 50842,
+    PLAGUE_STRIKE_1                 = 45462,
+    RAISE_ALLY_1                    = 61999,
+    RAISE_DEAD_1                    = 46584,
+    RUNE_STRIKE_1                   = 56815,
+    RUNE_TAP_1                      = 48982,
+    SCOURGE_STRIKE_1                = 55090,
+    STRANGULATE_1                   = 47476,
+    SUMMON_GARGOYLE_1               = 49206,
+    UNBREAKABLE_ARMOR_1             = 51271,
+    UNHOLY_PRESENCE_1               = 48265,
+    VAMPIRIC_BLOOD_1                = 55233
+};
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDeathKnightAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDeathKnightAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // Unholy
+    uint32 BONE_SHIELD, PLAGUE_STRIKE, DEATH_GRIP, DEATH_COIL, DEATH_STRIKE, UNHOLY_BLIGHT, SCOURGE_STRIKE, DEATH_AND_DECAY, UNHOLY_PRESENCE, RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, GHOUL_FRENZY, CORPSE_EXPLOSION;
+
+    // Frost
+    uint32 ICY_TOUCH, OBLITERATE, HOWLING_BLAST, FROST_STRIKE, CHAINS_OF_ICE, RUNE_STRIKE, ICY_CLUTCH, HORN_OF_WINTER, KILLING_MACHINE, FROST_PRESENCE, DEATHCHILL, ICEBOUND_FORTITUDE, MIND_FREEZE, EMPOWER_WEAPON, HUNGERING_COLD, UNBREAKABLE_ARMOR;
+
+    // Blood
+    uint32 BLOOD_STRIKE, PESTILENCE, STRANGULATE, BLOOD_BOIL, HEART_STRIKE, MARK_OF_BLOOD, BLOOD_PRESENCE, RUNE_TAP, VAMPIRIC_BLOOD, DEATH_PACT, DEATH_RUNE_MASTERY, HYSTERIA, DANCING_WEAPON, DARK_COMMAND;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellUnholyDK, LastSpellFrostDK, LastSpellBloodDK;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..6ab57ed
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
@@ -0,0 +1,694 @@
+/*
+    Name    : PlayerbotDruidAI.cpp
+    Complete: maybe around 33%
+    Authors : rrtn, Natsukawa
+    Version : 0.42
+ */
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    MOONFIRE                      = ai->initSpell(MOONFIRE_1); // attacks
+    STARFIRE                      = ai->initSpell(STARFIRE_1);
+    STARFALL                      = ai->initSpell(STARFALL_1);
+    WRATH                         = ai->initSpell(WRATH_1);
+    ROOTS                         = ai->initSpell(ENTANGLING_ROOTS_1);
+    INSECT_SWARM                  = ai->initSpell(INSECT_SWARM_1);
+    FORCE_OF_NATURE               = ai->initSpell(FORCE_OF_NATURE_1);
+    HURRICANE                     = ai->initSpell(HURRICANE_1);
+    MARK_OF_THE_WILD              = ai->initSpell(MARK_OF_THE_WILD_1); // buffs
+    GIFT_OF_THE_WILD              = ai->initSpell(GIFT_OF_THE_WILD_1);
+    THORNS                        = ai->initSpell(THORNS_1);
+    BARKSKIN                      = ai->initSpell(BARKSKIN_1);
+    INNERVATE                     = ai->initSpell(INNERVATE_1);
+    FAERIE_FIRE                   = ai->initSpell(FAERIE_FIRE_1); // debuffs
+    REJUVENATION                  = ai->initSpell(REJUVENATION_1); // heals
+    REGROWTH                      = ai->initSpell(REGROWTH_1);
+    WILD_GROWTH                   = ai->initSpell(WILD_GROWTH_1);
+    LIFEBLOOM                     = ai->initSpell(LIFEBLOOM_1);
+    NOURISH                       = ai->initSpell(NOURISH_1);
+    HEALING_TOUCH                 = ai->initSpell(HEALING_TOUCH_1);
+    SWIFTMEND                     = ai->initSpell(SWIFTMEND_1);
+    TRANQUILITY                   = ai->initSpell(TRANQUILITY_1);
+    REVIVE                        = ai->initSpell(REVIVE_1);
+    // Druid Forms
+    MOONKIN_FORM                  = ai->initSpell(MOONKIN_FORM_1);
+    DIRE_BEAR_FORM                = ai->initSpell(DIRE_BEAR_FORM_1);
+    BEAR_FORM                     = ai->initSpell(BEAR_FORM_1);
+    CAT_FORM                      = ai->initSpell(CAT_FORM_1);
+    TREE_OF_LIFE                  = ai->initSpell(TREE_OF_LIFE_1);
+    TRAVEL_FORM                   = ai->initSpell(TRAVEL_FORM_1);
+    // Cat Attack type's
+    RAKE                          = ai->initSpell(RAKE_1);
+    CLAW                          = ai->initSpell(CLAW_1); // 45
+    COWER                         = ai->initSpell(COWER_1); // 20
+    MANGLE                        = ai->initSpell(MANGLE_1); // 45
+    TIGERS_FURY                   = ai->initSpell(TIGERS_FURY_1);
+    // Cat Finishing Move's
+    RIP                           = ai->initSpell(RIP_1); // 30
+    FEROCIOUS_BITE                = ai->initSpell(FEROCIOUS_BITE_1); // 35
+    MAIM                          = ai->initSpell(MAIM_1); // 35
+    // Bear/Dire Bear Attacks & Buffs
+    BASH                          = ai->initSpell(BASH_1);
+    MAUL                          = ai->initSpell(MAUL_1); // 15
+    SWIPE                         = ai->initSpell(SWIPE_BEAR_1); // 20
+    DEMORALIZING_ROAR             = ai->initSpell(DEMORALIZING_ROAR_1); // 10
+    CHALLENGING_ROAR              = ai->initSpell(CHALLENGING_ROAR_1);
+    ENRAGE                        = ai->initSpell(ENRAGE_1);
+    GROWL                         = ai->initSpell(GROWL_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI() {}
+
+bool PlayerbotDruidAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    if (hp >= 70)
+        return false;
+
+    // Reset form if needed
+    GoBuffForm(GetPlayerBot());
+
+    if (hp < 70 && REJUVENATION > 0 && !target->HasAura(REJUVENATION) && ai->CastSpell(REJUVENATION, *target))
+        return true;
+
+    if (hp < 60 && LIFEBLOOM > 0 && !target->HasAura(LIFEBLOOM) && ai->CastSpell(LIFEBLOOM, *target))
+        return true;
+
+    if (hp < 55 && REGROWTH > 0 && !target->HasAura(REGROWTH) && ai->CastSpell(REGROWTH, *target))
+        return true;
+
+    if (hp < 50 && SWIFTMEND > 0 && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && ai->CastSpell(SWIFTMEND, *target))
+        return true;
+
+    if (hp < 45 && WILD_GROWTH > 0 && !target->HasAura(WILD_GROWTH) && ai->CastSpell(WILD_GROWTH, *target))
+        return true;
+
+    if (hp < 30 && NOURISH > 0 && ai->CastSpell(NOURISH, *target))
+        return true;
+
+    if (hp < 25 && HEALING_TOUCH > 0 && ai->CastSpell(HEALING_TOUCH, *target))
+        return true;
+
+    return false;
+} // end HealTarget
+
+bool PlayerbotDruidAI::IsFeral()
+{
+    if (MOONKIN_FORM > 0)
+        return true;
+    else if (DIRE_BEAR_FORM > 0)
+        return true;
+    else if (BEAR_FORM > 0)
+        return true;
+    else if (CAT_FORM > 0)
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(MOONFIRE);
+            return;
+    }
+
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL) // && ai->GetMovementOrder() == PlayerbotAI::MOVEMENT_STAY)
+        SpellSequence = DruidHeal;
+    else if (IsFeral() && ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST) // && ai->GetMovementOrder() == PlayerbotAI::MOVEMENT_STAY)
+        SpellSequence = DruidCombat;
+    else if (IsFeral() && ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK)
+        SpellSequence = DruidTank;
+    else
+        SpellSequence = DruidSpell;
+
+    switch (SpellSequence)
+    {
+        case DruidTank: // Its now a tank druid!
+            //ai->TellMaster("DruidTank");
+
+            if (!m_bot->HasInArc(M_PI, pTarget))
+            {
+                m_bot->SetFacing(m_bot->GetAngle(pTarget));
+                if (pVictim)
+                    pVictim->Attack(pTarget, true);
+            }
+            if (m_bot->HasAura(CAT_FORM))
+                m_bot->RemoveAurasDueToSpell(768);
+            //ai->TellMaster("FormClearCat");
+            if (MOONKIN_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM))
+                ai->CastSpell (MOONKIN_FORM);
+            else if (DIRE_BEAR_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM) && !m_bot->HasAura(DIRE_BEAR_FORM))
+                ai->CastSpell (DIRE_BEAR_FORM);
+            else if (BEAR_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM) && !m_bot->HasAura(DIRE_BEAR_FORM) && !m_bot->HasAura(BEAR_FORM))
+                ai->CastSpell (BEAR_FORM);
+            else if (DEMORALIZING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && !m_bot->HasAura(MOONKIN_FORM) && !pTarget->HasAura(DEMORALIZING_ROAR) && ai->GetRageAmount() >= 10)
+                ai->CastSpell(DEMORALIZING_ROAR, *pTarget);
+            if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE))
+            {
+                ai->CastSpell(FAERIE_FIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (MOONFIRE > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE) && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(MOONFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (ROOTS > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ROOTS, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (HURRICANE > 0 && m_bot->HasAura(MOONKIN_FORM) && ai->GetAttackerCount() >= 5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+            {
+                //ai->TellMaster("casting hurricane!");
+                ai->CastSpell(HURRICANE, *pTarget);
+                ai->SetIgnoreUpdateTime(10);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (WRATH > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(WRATH, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INSECT_SWARM > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(INSECT_SWARM, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFIRE > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(STARFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (FORCE_OF_NATURE > 0 && m_bot->HasAura(MOONKIN_FORM) && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+            {
+                //ai->TellMaster("summoning treants.");
+                ai->CastSpell(FORCE_OF_NATURE);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFALL > 0 && m_bot->HasAura(MOONKIN_FORM) && !m_bot->HasAura(STARFALL) && ai->GetAttackerCount() >= 3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+            {
+                ai->CastSpell(STARFALL, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (BARKSKIN > 0 && pVictim == m_bot && m_bot->HasAura(MOONKIN_FORM) && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN))
+            {
+                ai->CastSpell(BARKSKIN, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INNERVATE > 0 && m_bot->HasAura(MOONKIN_FORM) && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE))
+            {
+                ai->CastSpell(INNERVATE, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (ENRAGE > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && DruidSpellCombat < 2 && !m_bot->HasAura(ENRAGE))
+            {
+                ai->CastSpell(ENRAGE, *m_bot);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (SWIPE > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && DruidSpellCombat < 4 && ai->GetRageAmount() >= 20)
+            {
+                ai->CastSpell(SWIPE, *pTarget);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (MAUL > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && DruidSpellCombat < 6 && ai->GetRageAmount() >= 15)
+            {
+                ai->CastSpell(MAUL, *pTarget);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (BASH > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && !pTarget->HasAura(BASH) && DruidSpellCombat < 8 && ai->GetRageAmount() >= 10)
+            {
+                ai->CastSpell(BASH, *pTarget);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (CHALLENGING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && pVictim != m_bot && DruidSpellCombat < 10 && !pTarget->HasAura(CHALLENGING_ROAR) && !pTarget->HasAura(GROWL) && ai->GetRageAmount() >= 15)
+            {
+                ai->CastSpell(CHALLENGING_ROAR, *pTarget);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (GROWL > 0 && (m_bot->HasAura(DIRE_BEAR_FORM) || m_bot->HasAura(BEAR_FORM)) && pVictim != m_bot && DruidSpellCombat < 12 && !pTarget->HasAura(CHALLENGING_ROAR) && !pTarget->HasAura(GROWL))
+            {
+                ai->CastSpell(GROWL, *pTarget);
+                DruidSpellCombat = DruidSpellCombat + 2;
+                break;
+            }
+            else if (DruidSpellCombat > 13)
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidSpell:
+            //ai->TellMaster("DruidSpell");
+            if (m_bot->HasAura(CAT_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(768);
+                //ai->TellMaster("FormClearCat");
+                break;
+            }
+            if (m_bot->HasAura(BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+            if (m_bot->HasAura(DIRE_BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+            if (m_bot->HasAura(MOONKIN_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(FAERIE_FIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (MOONFIRE > 0 && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE) && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(MOONFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (ROOTS > 0 && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ROOTS, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (HURRICANE > 0 && ai->GetAttackerCount() >= 5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+            {
+                //ai->TellMaster("casting hurricane!");
+                ai->CastSpell(HURRICANE, *pTarget);
+                ai->SetIgnoreUpdateTime(10);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (WRATH > 0 && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(WRATH, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INSECT_SWARM > 0 && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(INSECT_SWARM, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFIRE > 0 && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(STARFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (FORCE_OF_NATURE > 0 && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+            {
+                //ai->TellMaster("summoning treants.");
+                ai->CastSpell(FORCE_OF_NATURE);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFALL > 0 && !m_bot->HasAura(STARFALL) && ai->GetAttackerCount() >= 3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+            {
+                ai->CastSpell(STARFALL, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (BARKSKIN > 0 && pVictim == m_bot && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN))
+            {
+                ai->CastSpell(BARKSKIN, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INNERVATE > 0 && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE))
+            {
+                ai->CastSpell(INNERVATE, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (DruidSpellCombat > 13)
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidHeal:
+            //ai->TellMaster("DruidHeal");
+            if (m_bot->HasAura(CAT_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(768);
+                //ai->TellMaster("FormClearCat");
+                break;
+            }
+            if (m_bot->HasAura(BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+            if (m_bot->HasAura(DIRE_BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+            if (m_bot->HasAura(MOONKIN_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (m_bot);
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (GetMaster());
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidCombat:
+            //ai->TellMaster("DruidCombat");
+            if (!m_bot->HasInArc(M_PI, pTarget))
+            {
+                m_bot->SetFacing(m_bot->GetAngle(pTarget));
+                if (pVictim)
+                    pVictim->Attack(pTarget, true);
+            }
+            if (m_bot->HasAura(BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+            if (m_bot->HasAura(DIRE_BEAR_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+            if (m_bot->HasAura(MOONKIN_FORM))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (CAT_FORM > 0 && !m_bot->HasAura(CAT_FORM))
+                ai->CastSpell (CAT_FORM);
+/*
+            if (COWER > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 20)
+            {
+                ai->CastSpell(COWER);
+                //ai->TellMaster("Cower");
+            }*/
+            if (MAIM > 0 && m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true))
+            {
+                ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("SpellPreventing Maim");
+                break;
+            }
+
+            if (RAKE > 0 && m_bot->GetComboPoints() <= 1 && ai->GetEnergyAmount() >= 40)
+            {
+                ai->CastSpell (RAKE, *pTarget);
+                //ai->TellMaster("Rake");
+                break;
+            }
+            else if (CLAW > 0 && m_bot->GetComboPoints() <= 2 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (CLAW, *pTarget);
+                //ai->TellMaster("Claw");
+                break;
+            }
+            else if (MANGLE > 0 && m_bot->GetComboPoints() <= 3 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (MANGLE, *pTarget);
+                //ai->TellMaster("Mangle");
+                break;
+            }
+            else if (CLAW > 0 && m_bot->GetComboPoints() <= 4 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (CLAW, *pTarget);
+                //ai->TellMaster("Claw2");
+                break;
+            }
+
+            if (m_bot->GetComboPoints() == 5)
+            {
+                if (RIP > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 30)
+                    ai->CastSpell(RIP, *pTarget);
+                //ai->TellMaster("Rogue Rip");
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_DRUID && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Druid Maim");
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_SHAMAN && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Shaman Maim");
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_WARLOCK && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Warlock Maim");
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_HUNTER && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                //ai->TellMaster("Hunter Ferocious Bite");
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_WARRIOR && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                //ai->TellMaster("Warrior Ferocious Bite");
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_PALADIN && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                //ai->TellMaster("Paladin Ferocious Bite");
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_DEATH_KNIGHT && ai->GetEnergyAmount() >= 25)
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                //ai->TellMaster("DK Ferocious Bite");
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_MAGE && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Mage Maim");
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_PRIEST && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Priest Maim");
+                else if (MAIM > 0 && ai->GetEnergyAmount() >= 35)
+                    ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("Else Maim");
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (!pItem && INNERVATE > 0 && !m_bot->HasAura(INNERVATE) && ai->GetManaPercent() <= 20 && ai->CastSpell(INNERVATE, *m_bot))
+        return;
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff
+        if (!master->IsInDuel(master))
+            if (master->isAlive() && GIFT_OF_THE_WILD && ai->HasSpellReagents(GIFT_OF_THE_WILD) && ai->Buff(GIFT_OF_THE_WILD, master))
+                return;
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || tPlayer == m_bot)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == master && tPlayer->duel->startTime != 0)
+                continue;
+
+            // Resurrect member if needed
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(REVIVE, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->IsInDuel(master))
+            return;
+
+        if (master->isAlive())
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else
+        if (ai->CastSpell(REVIVE, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+
+    Pet * pet = target->GetPet();
+    if (pet)
+    {
+        if (ai->Buff(MARK_OF_THE_WILD, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+        else if (ai->Buff(THORNS, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+    }
+
+    if (ai->Buff(MARK_OF_THE_WILD, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else if (ai->Buff(THORNS, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotDruidAI::GoBuffForm(Player *self)
+{
+    // RANK_1 spell ids used because this is a static method which does not have access to instance.
+    // There is only one rank for these spells anyway.
+    if (self->HasAura(CAT_FORM_1))
+        self->RemoveAurasDueToSpell(CAT_FORM_1);
+    if (self->HasAura(BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(BEAR_FORM_1);
+    if (self->HasAura(DIRE_BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    if (self->HasAura(MOONKIN_FORM_1))
+        self->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    if (self->HasAura(TRAVEL_FORM_1))
+        self->RemoveAurasDueToSpell(TRAVEL_FORM_1);
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..0e190e4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
@@ -0,0 +1,192 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    DruidCombat,
+    DruidTank,
+    DruidHeal,
+    DruidSpell
+};
+
+enum DruidSpells
+{
+    ABOLISH_POISON_1                = 2893,
+    AQUATIC_FORM_1                  = 1066,
+    BARKSKIN_1                      = 22812,
+    BASH_1                          = 5211,
+    BEAR_FORM_1                     = 5487,
+    BERSERK_1                       = 50334,
+    CAT_FORM_1                      = 768,
+    CHALLENGING_ROAR_1              = 5209,
+    CLAW_1                          = 1082,
+    COWER_1                         = 8998,
+    CURE_POISON_1                   = 8946,
+    CYCLONE_1                       = 33786,
+    DASH_1                          = 1850,
+    DEMORALIZING_ROAR_1             = 99,
+    DIRE_BEAR_FORM_1                = 9634,
+    ENRAGE_1                        = 5229,
+    ENTANGLING_ROOTS_1              = 339,
+    FAERIE_FIRE_1                   = 770,
+    FAERIE_FIRE_FERAL_1             = 16857,
+    FERAL_CHARGE_1                  = 49377,
+    FERAL_CHARGE_BEAR_1             = 16979,
+    FERAL_CHARGE_CAT_1              = 49376,
+    FEROCIOUS_BITE_1                = 22568,
+    FLIGHT_FORM_1                   = 33943,
+    FORCE_OF_NATURE_1               = 33831,
+    FRENZIED_REGENERATION_1         = 22842,
+    GIFT_OF_THE_WILD_1              = 21849,
+    GROWL_1                         = 6795,
+    HEALING_TOUCH_1                 = 5185,
+    HIBERNATE_1                     = 2637,
+    HURRICANE_1                     = 16914,
+    INNERVATE_1                     = 29166,
+    INSECT_SWARM_1                  = 5570,
+    LACERATE_1                      = 33745,
+    LIFEBLOOM_1                     = 33763,
+    MAIM_1                          = 22570,
+    MANGLE_1                        = 33917,
+    MANGLE_BEAR_1                   = 33878,
+    MANGLE_CAT_1                    = 33876,
+    MARK_OF_THE_WILD_1              = 1126,
+    MAUL_1                          = 6807,
+    MOONFIRE_1                      = 8921,
+    MOONKIN_FORM_1                  = 24858,
+    NATURES_GRASP_1                 = 16689,
+    NATURES_SWIFTNESS_DRUID_1       = 17116,
+    NOURISH_1                       = 50464,
+    POUNCE_1                        = 9005,
+    PROWL_1                         = 5215,
+    RAKE_1                          = 1822,
+    RAVAGE_1                        = 6785,
+    REBIRTH_1                       = 20484,
+    REGROWTH_1                      = 8936,
+    REJUVENATION_1                  = 774,
+    REMOVE_CURSE_DRUID_1            = 2782,
+    REVIVE_1                        = 50769,
+    RIP_1                           = 1079,
+    SAVAGE_ROAR_1                   = 52610,
+    SHRED_1                         = 5221,
+    SOOTHE_ANIMAL_1                 = 2908,
+    STARFALL_1                      = 48505,
+    STARFIRE_1                      = 2912,
+    SURVIVAL_INSTINCTS_1            = 61336,
+    SWIFTMEND_1                     = 18562,
+    SWIFT_FLIGHT_FORM_1             = 40120,
+    SWIPE_BEAR_1                    = 779,
+    SWIPE_CAT_1                     = 62078,
+    THORNS_1                        = 467,
+    TIGERS_FURY_1                   = 5217,
+    TRANQUILITY_1                   = 740,
+    TRAVEL_FORM_1                   = 783,
+    TREE_OF_LIFE_1                  = 33891,
+    TYPHOON_1                       = 50516,
+    WILD_GROWTH_1                   = 48438,
+    WRATH_1                         = 5176
+};
+
+//class Player;
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDruidAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDruidAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Callback method to reset shapeshift forms blocking buffs and heals
+    static void GoBuffForm(Player *self);
+    // Has the ability to change to animal form
+    bool IsFeral();
+
+    // druid cat/bear/dire bear/moonkin/tree of life forms
+    uint32 CAT_FORM,
+           BEAR_FORM,
+           DIRE_BEAR_FORM,
+           MOONKIN_FORM,
+           TREE_OF_LIFE,
+           TRAVEL_FORM;
+
+    // druid cat attacks
+    uint32 CLAW,
+           COWER,
+           TIGERS_FURY,
+           RAKE,
+           RIP,
+           FEROCIOUS_BITE,
+           MAIM,
+           MANGLE;
+
+    // druid bear/dire bear attacks & buffs
+    uint32 BASH,
+           MAUL,
+           SWIPE,
+           DEMORALIZING_ROAR,
+           CHALLENGING_ROAR,
+           GROWL,
+           ENRAGE;
+
+    // druid attacks & debuffs
+    uint32 MOONFIRE,
+           ROOTS,
+           WRATH,
+           STARFALL,
+           STARFIRE,
+           INSECT_SWARM,
+           FAERIE_FIRE,
+           FORCE_OF_NATURE,
+           HURRICANE;
+
+    // druid buffs
+    uint32 MARK_OF_THE_WILD,
+           GIFT_OF_THE_WILD,
+           THORNS,
+           INNERVATE,
+           BARKSKIN;
+
+    // druid heals
+    uint32 LIFEBLOOM,
+           REJUVENATION,
+           REGROWTH,
+           NOURISH,
+           HEALING_TOUCH,
+           WILD_GROWTH,
+           SWIFTMEND,
+           TRANQUILITY,
+           REVIVE;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, DruidSpellCombat;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..b1a7365
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
@@ -0,0 +1,406 @@
+// an improved Hunter by rrtn & Runsttren :)
+
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // PET CTRL
+    PET_SUMMON                    = ai->initSpell(CALL_PET_1);
+    PET_DISMISS                   = ai->initSpell(DISMISS_PET_1);
+    PET_REVIVE                    = ai->initSpell(REVIVE_PET_1);
+    PET_MEND                      = ai->initSpell(MEND_PET_1);
+    PET_FEED                      = 1539;
+
+    INTIMIDATION                  = ai->initSpell(INTIMIDATION_1); // (generic)
+
+    // PET SKILLS must be initialized by pets
+    SONIC_BLAST                   = 0; // bat
+    DEMORALIZING_SCREECH          = 0;
+    BAD_ATTITUDE                  = 0; // crocolisk
+    NETHER_SHOCK                  = 0;
+
+    // RANGED COMBAT
+    AUTO_SHOT                     = ai->initSpell(AUTO_SHOT_1);
+    HUNTERS_MARK                  = ai->initSpell(HUNTERS_MARK_1);
+    ARCANE_SHOT                   = ai->initSpell(ARCANE_SHOT_1);
+    CONCUSSIVE_SHOT               = ai->initSpell(CONCUSSIVE_SHOT_1);
+    DISTRACTING_SHOT              = ai->initSpell(DISTRACTING_SHOT_1);
+    MULTI_SHOT                    = ai->initSpell(MULTISHOT_1);
+    EXPLOSIVE_SHOT                = ai->initSpell(EXPLOSIVE_SHOT_1);
+    SERPENT_STING                 = ai->initSpell(SERPENT_STING_1);
+    SCORPID_STING                 = ai->initSpell(SCORPID_STING_1);
+    WYVERN_STING                  = ai->initSpell(WYVERN_STING_1);
+    VIPER_STING                   = ai->initSpell(VIPER_STING_1);
+    AIMED_SHOT                    = ai->initSpell(AIMED_SHOT_1);
+    STEADY_SHOT                   = ai->initSpell(STEADY_SHOT_1);
+    CHIMERA_SHOT                  = ai->initSpell(CHIMERA_SHOT_1);
+    VOLLEY                        = ai->initSpell(VOLLEY_1);
+    BLACK_ARROW                   = ai->initSpell(BLACK_ARROW_1);
+    KILL_SHOT                     = ai->initSpell(KILL_SHOT_1);
+
+    // MELEE
+    RAPTOR_STRIKE                 = ai->initSpell(RAPTOR_STRIKE_1);
+    WING_CLIP                     = ai->initSpell(WING_CLIP_1);
+    MONGOOSE_BITE                 = ai->initSpell(MONGOOSE_BITE_1);
+    DISENGAGE                     = ai->initSpell(DISENGAGE_1);
+    MISDIRECTION                  = ai->initSpell(MISDIRECTION_1);
+    DETERRENCE                    = ai->initSpell(DETERRENCE_1);
+
+    // TRAPS
+    BEAR_TRAP                     = 0; // non-player spell
+    FREEZING_TRAP                 = ai->initSpell(FREEZING_TRAP_1);
+    IMMOLATION_TRAP               = ai->initSpell(IMMOLATION_TRAP_1);
+    FROST_TRAP                    = ai->initSpell(FROST_TRAP_1);
+    EXPLOSIVE_TRAP                = ai->initSpell(EXPLOSIVE_TRAP_1);
+    ARCANE_TRAP                   = 0; // non-player spell
+    SNAKE_TRAP                    = ai->initSpell(SNAKE_TRAP_1);
+
+    // BUFFS
+    ASPECT_OF_THE_HAWK            = ai->initSpell(ASPECT_OF_THE_HAWK_1);
+    ASPECT_OF_THE_MONKEY          = ai->initSpell(ASPECT_OF_THE_MONKEY_1);
+    RAPID_FIRE                    = ai->initSpell(RAPID_FIRE_1);
+    TRUESHOT_AURA                 = ai->initSpell(TRUESHOT_AURA_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_HUNTER); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY                    = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+
+    m_petSummonFailed = false;
+    m_rangedCombat = true;
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+bool PlayerbotHunterAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')", bot->GetGUIDLow(), PET_SAVE_AS_CURRENT, PET_SAVE_NOT_IN_SLOT);
+
+    if (result)
+        return true;  //hunter has current pet
+    else
+        return false;  //hunter either has no pet or stabled
+} // end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(RAPTOR_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Hunter
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    // check for pet and heal if neccessary
+    Pet *pet = m_bot->GetPet();
+    if ((pet)
+        && (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        && (PET_MEND > 0 && !pet->getDeathState() != ALIVE && pVictim != m_bot && !pet->HasAura(PET_MEND) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot)))
+    {
+        ai->TellMaster("healing pet.");
+        return;
+    }
+    else if ((pet)
+             && (INTIMIDATION > 0 && pVictim == pet && !pet->HasAura(INTIMIDATION) && ai->CastSpell(INTIMIDATION, *m_bot)))
+        //ai->TellMaster( "casting intimidation." ); // if pet has aggro :)
+        return;
+
+    // racial traits
+    if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY))
+        ai->CastSpell(BLOOD_FURY, *m_bot);
+    //ai->TellMaster( "Blood Fury." );
+    else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING))
+        ai->CastSpell(BERSERKING, *m_bot);
+    //ai->TellMaster( "Berserking." );
+
+    // check if ranged combat is possible (set m_rangedCombat and switch auras
+    float dist = m_bot->GetDistance(pTarget);
+    if ((dist <= ATTACK_DISTANCE || !m_bot->GetUInt32Value(PLAYER_AMMO_ID)) && m_rangedCombat)
+    {
+        // switch to melee combat (target in melee range, out of ammo)
+        m_rangedCombat = false;
+        if (!m_bot->GetUInt32Value(PLAYER_AMMO_ID))
+            ai->TellMaster("Out of ammo!");
+        // become monkey (increases dodge chance)...
+        (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY) && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+    }
+    else if (dist > ATTACK_DISTANCE && !m_rangedCombat)
+    {
+        // switch to ranged combat
+        m_rangedCombat = true;
+        // increase ranged attack power...
+        (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK) && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    }
+    else if (m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_HAWK))
+        // check if we have hawk aspect in ranged combat
+        (ASPECT_OF_THE_HAWK > 0 && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    else if (!m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_MONKEY))
+        // check if we have monkey aspect in melee combat
+        (ASPECT_OF_THE_MONKEY > 0 && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+
+    // activate auto shot
+    if (AUTO_SHOT > 0 && m_rangedCombat && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        ai->CastSpell(AUTO_SHOT, *pTarget);
+    //ai->TellMaster( "started auto shot." );
+    else if (AUTO_SHOT > 0 && m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        m_bot->InterruptNonMeleeSpells(true, AUTO_SHOT);
+    //ai->TellMaster( "stopped auto shot." );
+
+    // damage spells
+    std::ostringstream out;
+    if (m_rangedCombat)
+    {
+        out << "Case Ranged";
+        if (HUNTERS_MARK > 0 && ai->GetManaPercent() >= 3 && !pTarget->HasAura(HUNTERS_MARK) && ai->CastSpell(HUNTERS_MARK, *pTarget))
+            out << " > Hunter's Mark";
+        else if (RAPID_FIRE > 0 && ai->GetManaPercent() >= 3 && !m_bot->HasAura(RAPID_FIRE) && ai->CastSpell(RAPID_FIRE, *m_bot))
+            out << " > Rapid Fire";
+        else if (MULTI_SHOT > 0 && ai->GetManaPercent() >= 13 && ai->GetAttackerCount() >= 3 && ai->CastSpell(MULTI_SHOT, *pTarget))
+            out << " > Multi-Shot";
+        else if (ARCANE_SHOT > 0 && ai->GetManaPercent() >= 7 && ai->CastSpell(ARCANE_SHOT, *pTarget))
+            out << " > Arcane Shot";
+        else if (CONCUSSIVE_SHOT > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(CONCUSSIVE_SHOT) && ai->CastSpell(CONCUSSIVE_SHOT, *pTarget))
+            out << " > Concussive Shot";
+        else if (EXPLOSIVE_SHOT > 0 && ai->GetManaPercent() >= 10 && !pTarget->HasAura(EXPLOSIVE_SHOT) && ai->CastSpell(EXPLOSIVE_SHOT, *pTarget))
+            out << " > Explosive Shot";
+        else if (VIPER_STING > 0 && ai->GetManaPercent() >= 8 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && !pTarget->HasAura(VIPER_STING) && ai->CastSpell(VIPER_STING, *pTarget))
+            out << " > Viper Sting";
+        else if (SERPENT_STING > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(SERPENT_STING) && !pTarget->HasAura(SCORPID_STING) &&  !pTarget->HasAura(VIPER_STING) && ai->CastSpell(SERPENT_STING, *pTarget))
+            out << " > Serpent Sting";
+        else if (SCORPID_STING > 0 && ai->GetManaPercent() >= 11 && !pTarget->HasAura(WYVERN_STING) && !pTarget->HasAura(SCORPID_STING) && !pTarget->HasAura(SERPENT_STING) && !pTarget->HasAura(VIPER_STING) && ai->CastSpell(SCORPID_STING, *pTarget))
+            out << " > Scorpid Sting";
+        else if (CHIMERA_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(CHIMERA_SHOT, *pTarget))
+            out << " > Chimera Shot";
+        else if (VOLLEY > 0 && ai->GetManaPercent() >= 24 && ai->GetAttackerCount() >= 3 && ai->CastSpell(VOLLEY, *pTarget))
+            out << " > Volley";
+        else if (BLACK_ARROW > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(BLACK_ARROW) && ai->CastSpell(BLACK_ARROW, *pTarget))
+            out << " > Black Arrow";
+        else if (AIMED_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(AIMED_SHOT, *pTarget))
+            out << " > Aimed Shot";
+        else if (STEADY_SHOT > 0 && ai->GetManaPercent() >= 5 && ai->CastSpell(STEADY_SHOT, *pTarget))
+            out << " > Steady Shot";
+        else if (KILL_SHOT > 0 && ai->GetManaPercent() >= 7 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(KILL_SHOT, *pTarget))
+            out << " > Kill Shot!";
+        else
+            out << " NONE!";
+    }
+    else
+    {
+        out << "Case Melee";
+        if (RAPTOR_STRIKE > 0 && ai->GetManaPercent() >= 6 && ai->CastSpell(RAPTOR_STRIKE, *pTarget))
+            out << " > Raptor Strike";
+        else if (EXPLOSIVE_TRAP > 0 && ai->GetManaPercent() >= 27 && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(FROST_TRAP) && !pTarget->HasAura(BEAR_TRAP) && ai->CastSpell(EXPLOSIVE_TRAP, *pTarget))
+            out << " > Explosive Trap";
+        else if (WING_CLIP > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(WING_CLIP) && ai->CastSpell(WING_CLIP, *pTarget))
+            out << " > Wing Clip";
+        else if (IMMOLATION_TRAP > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(FROST_TRAP) && !pTarget->HasAura(BEAR_TRAP) && ai->CastSpell(IMMOLATION_TRAP, *pTarget))
+            out << " > Immolation Trap";
+        else if (MONGOOSE_BITE > 0 && ai->GetManaPercent() >= 4 && ai->CastSpell(MONGOOSE_BITE, *pTarget))
+            out << " > Mongoose Bite";
+        else if (FROST_TRAP > 0 && ai->GetManaPercent() >= 2 && !pTarget->HasAura(FROST_TRAP) && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(BEAR_TRAP) && ai->CastSpell(FROST_TRAP, *pTarget))
+            out << " > Frost Trap";
+        else if (ARCANE_TRAP > 0 && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(BEAR_TRAP) && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(FROST_TRAP) && ai->CastSpell(ARCANE_TRAP, *pTarget))
+            out << " > Arcane Trap";
+        else if (DETERRENCE > 0 && pVictim == m_bot && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && !m_bot->HasAura(DETERRENCE) && ai->CastSpell(DETERRENCE, *m_bot))
+            out << " > Deterrence";
+        else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP) && ai->CastSpell(WAR_STOMP, *pTarget))
+            out << " > War Stomp";
+        else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+            out << " > Arcane Torrent";
+        else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+            out << " > Stoneform";
+        else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD) && ai->CastSpell(SHADOWMELD, *m_bot))
+            out << " > Shadowmeld";
+        else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+            out << " > Gift of the Naaru";
+        else if ((pet && !pet->getDeathState() != ALIVE)
+                 && (MISDIRECTION > 0 && pVictim == m_bot && !m_bot->HasAura(MISDIRECTION) && ai->GetManaPercent() >= 9 && ai->CastSpell(MISDIRECTION, *pet)))
+            out << " > Misdirection";  // give threat to pet
+        /*else if( FREEZING_TRAP>0 && ai->GetManaPercent()>=5 && !pTarget->HasAura(FREEZING_TRAP) && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(BEAR_TRAP) && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(FROST_TRAP) && ai->CastSpell(FREEZING_TRAP,*pTarget) )
+            out << " > Freezing Trap"; // this can trap your bots too
+           else if( BEAR_TRAP>0 && !pTarget->HasAura(BEAR_TRAP) && !pTarget->HasAura(ARCANE_TRAP) && !pTarget->HasAura(EXPLOSIVE_TRAP) && !pTarget->HasAura(IMMOLATION_TRAP) && !pTarget->HasAura(FROST_TRAP) && ai->CastSpell(BEAR_TRAP,*pTarget) )
+            out << " > Bear Trap"; // this was just too annoying :)
+           else if( DISENGAGE>0 && pVictim && ai->GetManaPercent()>=5 && ai->CastSpell(DISENGAGE,*pTarget) )
+            out << " > Disengage!"; // attempt to return to ranged combat*/
+        else
+            out << " NONE!";
+    }
+    if (ai->GetManager()->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // reset ranged combat state
+    if (!m_rangedCombat)
+        m_rangedCombat = true;
+
+    // buff group
+    if (TRUESHOT_AURA > 0)
+        (!m_bot->HasAura(TRUESHOT_AURA) && ai->CastSpell (TRUESHOT_AURA, *m_bot));
+
+    // buff myself
+    if (ASPECT_OF_THE_HAWK > 0)
+        (!m_bot->HasAura(ASPECT_OF_THE_HAWK) && ai->CastSpell (ASPECT_OF_THE_HAWK, *m_bot));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+
+    // check for pet
+    if (PET_SUMMON > 0 && !m_petSummonFailed && HasPet(m_bot))
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if (!pet)
+        {
+            // summon pet
+            if (PET_SUMMON > 0 && ai->CastSpell(PET_SUMMON, *m_bot))
+                ai->TellMaster("summoning pet.");
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster("summon pet failed!");
+            }
+        }
+        else if (pet->getDeathState() != ALIVE)
+        {
+            // revive pet
+            if (PET_REVIVE > 0 && ai->GetManaPercent() >= 80 && ai->CastSpell(PET_REVIVE, *m_bot))
+                ai->TellMaster("reviving pet.");
+        }
+        else if (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        {
+            // heal pet when health lower 50%
+            if (PET_MEND > 0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot))
+                ai->TellMaster("healing pet.");
+        }
+        else if (pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit *) m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster, 51284, true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                        ai->TellMaster("feeding pet.");
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                            if (!pItemProto)
+                                continue;
+
+                            if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster, 51284, true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                                ai->TellMaster("feeding pet.");
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+            }
+            if (pet->HasAura(PET_MEND) && !pet->HasAura(PET_FEED))
+                ai->TellMaster("..no pet food!");
+            ai->SetIgnoreUpdateTime(7);
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..cf2c764
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
@@ -0,0 +1,121 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HUNTER
+};
+
+enum HunterSpells
+{
+    ARCANE_SHOT_1                   = 3044,
+    ASPECT_OF_THE_BEAST_1           = 13161,
+    ASPECT_OF_THE_CHEETAH_1         = 5118,
+    ASPECT_OF_THE_DRAGONHAWK_1      = 61846,
+    ASPECT_OF_THE_HAWK_1            = 13165,
+    ASPECT_OF_THE_MONKEY_1          = 13163,
+    ASPECT_OF_THE_PACK_1            = 13159,
+    ASPECT_OF_THE_VIPER_1           = 34074,
+    ASPECT_OF_THE_WILD_1            = 20043,
+    AUTO_SHOT_1                     = 75,
+    BEAST_LORE_1                    = 1462,
+    CALL_PET_1                      = 883,
+    CALL_STABLED_PET_1              = 62757,
+    CONCUSSIVE_SHOT_1               = 5116,
+    DETERRENCE_1                    = 19263,
+    DISENGAGE_1                     = 781,
+    DISMISS_PET_1                   = 2641,
+    DISTRACTING_SHOT_1              = 20736,
+    EAGLE_EYE_1                     = 6197,
+    EXPLOSIVE_TRAP_1                = 13813,
+    EYES_OF_THE_BEAST_1             = 1002,
+    FEED_PET_1                      = 6991,
+    FEIGN_DEATH_1                   = 5384,
+    FLARE_1                         = 1543,
+    FREEZING_ARROW_1                = 60192,
+    FREEZING_TRAP_1                 = 1499,
+    FROST_TRAP_1                    = 13809,
+    HUNTERS_MARK_1                  = 1130,
+    IMMOLATION_TRAP_1               = 13795,
+    KILL_COMMAND_1                  = 34026,
+    KILL_SHOT_1                     = 53351,
+    MASTERS_CALL_1                  = 53271,
+    MEND_PET_1                      = 136,
+    MISDIRECTION_1                  = 34477,
+    MONGOOSE_BITE_1                 = 1495,
+    MULTISHOT_1                     = 2643,
+    RAPID_FIRE_1                    = 3045,
+    RAPTOR_STRIKE_1                 = 2973,
+    REVIVE_PET_1                    = 982,
+    SCARE_BEAST_1                   = 1513,
+    SCORPID_STING_1                 = 3043,
+    SERPENT_STING_1                 = 1978,
+    SNAKE_TRAP_1                    = 34600,
+    STEADY_SHOT_1                   = 56641,
+    TAME_BEAST_1                    = 1515,
+    TRACK_BEASTS_1                  = 1494,
+    TRACK_DEMONS_1                  = 19878,
+    TRACK_DRAGONKIN_1               = 19879,
+    TRACK_ELEMENTALS_1              = 19880,
+    TRACK_GIANTS_1                  = 19882,
+    TRACK_HIDDEN_1                  = 19885,
+    TRACK_HUMANOIDS_1               = 19883,
+    TRACK_UNDEAD_1                  = 19884,
+    TRANQUILIZING_SHOT_1            = 19801,
+    VIPER_STING_1                   = 3034,
+    VOLLEY_1                        = 1510,
+    WING_CLIP_1                     = 2974,
+    AIMED_SHOT_1                    = 19434,
+    BESTIAL_WRATH_1                 = 19574,
+    BLACK_ARROW_1                   = 3674,
+    CHIMERA_SHOT_1                  = 53209,
+    COUNTERATTACK_1                 = 19306,
+    EXPLOSIVE_SHOT_1                = 53301,
+    INTIMIDATION_1                  = 19577,
+    READINESS_1                     = 23989,
+    SCATTER_SHOT_1                  = 19503,
+    SILENCING_SHOT_1                = 34490,
+    TRUESHOT_AURA_1                 = 19506,
+    WYVERN_STING_1                  = 19386
+};
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+public:
+    PlayerbotHunterAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotHunterAI();
+    bool HasPet(Player* bot);
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+    // Hunter
+    bool m_petSummonFailed;
+    bool m_rangedCombat;
+
+    uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH, INTIMIDATION;
+    uint32 AUTO_SHOT, HUNTERS_MARK, ARCANE_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, MULTI_SHOT, EXPLOSIVE_SHOT, SERPENT_STING, SCORPID_STING, VIPER_STING, WYVERN_STING, AIMED_SHOT, STEADY_SHOT, CHIMERA_SHOT, VOLLEY, BLACK_ARROW, KILL_SHOT;
+    uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, DISENGAGE, DETERRENCE;
+    uint32 BEAR_TRAP, FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, ARCANE_TRAP, SNAKE_TRAP;
+    uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, RAPID_FIRE, TRUESHOT_AURA, MISDIRECTION;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..5ef0ad4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
@@ -0,0 +1,468 @@
+
+#include "PlayerbotMageAI.h"
+
+class PlayerbotAI;
+
+PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    ARCANE_MISSILES         = ai->initSpell(ARCANE_MISSILES_1);
+    ARCANE_EXPLOSION        = ai->initSpell(ARCANE_EXPLOSION_1);
+    COUNTERSPELL            = ai->initSpell(COUNTERSPELL_1);
+    SLOW                    = ai->initSpell(SLOW_1);
+    ARCANE_BARRAGE          = ai->initSpell(ARCANE_BARRAGE_1);
+    ARCANE_BLAST            = ai->initSpell(ARCANE_BLAST_1);
+    ARCANE_POWER            = ai->initSpell(ARCANE_POWER_1);
+    DAMPEN_MAGIC            = ai->initSpell(DAMPEN_MAGIC_1);
+    AMPLIFY_MAGIC           = ai->initSpell(AMPLIFY_MAGIC_1);
+    MAGE_ARMOR              = ai->initSpell(MAGE_ARMOR_1);
+    MIRROR_IMAGE            = ai->initSpell(MIRROR_IMAGE_1);
+    ARCANE_INTELLECT        = ai->initSpell(ARCANE_INTELLECT_1);
+    ARCANE_BRILLIANCE       = ai->initSpell(ARCANE_BRILLIANCE_1);
+    DALARAN_INTELLECT       = ai->initSpell(DALARAN_INTELLECT_1);
+    DALARAN_BRILLIANCE      = ai->initSpell(DALARAN_BRILLIANCE_1);
+    MANA_SHIELD             = ai->initSpell(MANA_SHIELD_1);
+    CONJURE_WATER           = ai->initSpell(CONJURE_WATER_1);
+    CONJURE_FOOD            = ai->initSpell(CONJURE_FOOD_1);
+    FIREBALL                = ai->initSpell(FIREBALL_1);
+    FIRE_BLAST              = ai->initSpell(FIRE_BLAST_1);
+    FLAMESTRIKE             = ai->initSpell(FLAMESTRIKE_1);
+    SCORCH                  = ai->initSpell(SCORCH_1);
+    PYROBLAST               = ai->initSpell(PYROBLAST_1);
+    BLAST_WAVE              = ai->initSpell(BLAST_WAVE_1);
+    COMBUSTION              = ai->initSpell(COMBUSTION_1);
+    DRAGONS_BREATH          = ai->initSpell(DRAGONS_BREATH_1);
+    LIVING_BOMB             = ai->initSpell(LIVING_BOMB_1);
+    FROSTFIRE_BOLT          = ai->initSpell(FROSTFIRE_BOLT_1);
+    FIRE_WARD               = ai->initSpell(FIRE_WARD_1);
+    MOLTEN_ARMOR            = ai->initSpell(MOLTEN_ARMOR_1);
+    ICY_VEINS               = ai->initSpell(ICY_VEINS_1);
+    DEEP_FREEZE             = ai->initSpell(DEEP_FREEZE_1);
+    FROSTBOLT               = ai->initSpell(FROSTBOLT_1);
+    FROST_NOVA              = ai->initSpell(FROST_NOVA_1);
+    BLIZZARD                = ai->initSpell(BLIZZARD_1);
+    CONE_OF_COLD            = ai->initSpell(CONE_OF_COLD_1);
+    ICE_BARRIER             = ai->initSpell(ICE_BARRIER_1);
+    SUMMON_WATER_ELEMENTAL  = ai->initSpell(SUMMON_WATER_ELEMENTAL_1);
+    FROST_WARD              = ai->initSpell(FROST_WARD_1);
+    ICE_LANCE               = ai->initSpell(ICE_LANCE_1);
+    FROST_ARMOR             = ai->initSpell(FROST_ARMOR_1);
+    ICE_ARMOR               = ai->initSpell(ICE_ARMOR_1);
+    ICE_BLOCK               = ai->initSpell(ICE_BLOCK_1);
+    COLD_SNAP               = ai->initSpell(COLD_SNAP_1);
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_MAGE); // draenei
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotMageAI::~PlayerbotMageAI() {}
+
+bool PlayerbotMageAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (FIREBALL > 0)
+                ai->CastSpell(FIREBALL);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Damage Spells (primitive example)
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float dist = m_bot->GetDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_FROST:
+            if (ICY_VEINS > 0 && !m_bot->HasAura(ICY_VEINS) && LastSpellFrost < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(ICY_VEINS, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROSTBOLT > 0 && LastSpellFrost < 2 && !pTarget->HasAura(FROSTBOLT) && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(FROSTBOLT, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_WARD > 0 && LastSpellFrost < 3 && !m_bot->HasAura(FROST_WARD) && ai->GetManaPercent() >= 19)
+            {
+                ai->CastSpell(FROST_WARD, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_NOVA > 0 && LastSpellFrost < 4 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(FROST_NOVA) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_NOVA, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_LANCE > 0 && LastSpellFrost < 5 && ai->GetManaPercent() >= 7)
+            {
+                ai->CastSpell(ICE_LANCE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (BLIZZARD > 0 && LastSpellFrost < 6 && ai->GetAttackerCount() >= 5 && ai->GetManaPercent() >= 89)
+            {
+                ai->CastSpell(BLIZZARD, *pTarget);
+                ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (CONE_OF_COLD > 0 && LastSpellFrost < 7 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(CONE_OF_COLD) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(CONE_OF_COLD, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (DEEP_FREEZE > 0 && LastSpellFrost < 8 && pTarget->HasAura(AURA_STATE_FROZEN) && !pTarget->HasAura(DEEP_FREEZE) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(DEEP_FREEZE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BARRIER > 0 && LastSpellFrost < 9 && pVictim == m_bot && !m_bot->HasAura(ICE_BARRIER) && ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 30)
+            {
+                ai->CastSpell(ICE_BARRIER, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (SUMMON_WATER_ELEMENTAL > 0 && LastSpellFrost < 10 && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(SUMMON_WATER_ELEMENTAL);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BLOCK > 0 && LastSpellFrost < 11 && pVictim == m_bot && !m_bot->HasAura(ICE_BLOCK) && ai->GetHealthPercent() < 30)
+            {
+                ai->CastSpell(ICE_BLOCK, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (COLD_SNAP > 0 && LastSpellFrost < 12)
+            {
+                ai->CastSpell(COLD_SNAP, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            LastSpellFrost = 0;
+        //SpellSequence = SPELL_FIRE;
+        //break;
+
+        case SPELL_FIRE:
+            if (FIRE_WARD > 0 && !m_bot->HasAura(FIRE_WARD) && LastSpellFire < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(FIRE_WARD, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (COMBUSTION > 0 && !m_bot->HasAura(COMBUSTION) && LastSpellFire < 2)
+            {
+                ai->CastSpell(COMBUSTION, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIREBALL > 0 && LastSpellFire < 3 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIREBALL, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIRE_BLAST > 0 && LastSpellFire < 4 && ai->GetManaPercent() >= 25)
+            {
+                ai->CastSpell(FIRE_BLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FLAMESTRIKE > 0 && LastSpellFire < 5 && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(FLAMESTRIKE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (SCORCH > 0 && LastSpellFire < 6 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(SCORCH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (PYROBLAST > 0 && LastSpellFire < 7 && !pTarget->HasAura(PYROBLAST) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(PYROBLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (BLAST_WAVE > 0 && LastSpellFire < 8 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 34)
+            {
+                ai->CastSpell(BLAST_WAVE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (DRAGONS_BREATH > 0 && LastSpellFire < 9 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(DRAGONS_BREATH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (LIVING_BOMB > 0 && LastSpellFire < 10 && !pTarget->HasAura(LIVING_BOMB) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(LIVING_BOMB, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FROSTFIRE_BOLT > 0 && LastSpellFire < 11 && !pTarget->HasAura(FROSTFIRE_BOLT) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FROSTFIRE_BOLT, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            LastSpellFire = 0;
+        //SpellSequence = SPELL_ARCANE;
+        //break;
+
+        case SPELL_ARCANE:
+            if (ARCANE_POWER > 0 && LastSpellArcane < 1 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_POWER, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_MISSILES > 0 && LastSpellArcane < 2 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_MISSILES, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_EXPLOSION > 0 && LastSpellArcane < 3 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_EXPLOSION, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (COUNTERSPELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && LastSpellArcane < 4 && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(COUNTERSPELL, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (SLOW > 0 && LastSpellArcane < 5 && !pTarget->HasAura(SLOW) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(SLOW, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BARRAGE > 0 && LastSpellArcane < 6 && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_BARRAGE, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BLAST > 0 && LastSpellArcane < 7 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ARCANE_BLAST, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MIRROR_IMAGE > 0 && LastSpellArcane < 8 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(MIRROR_IMAGE);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MANA_SHIELD > 0 && LastSpellArcane < 9 && ai->GetHealthPercent() < 70 && pVictim == m_bot && !m_bot->HasAura(MANA_SHIELD) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(MANA_SHIELD, *m_bot);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else
+            {
+                LastSpellArcane = 0;
+                SpellSequence = SPELL_FROST;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_FROST;
+    PlayerbotAI* ai = GetAI();
+
+    // Buff armor
+    if (MOLTEN_ARMOR)
+    {
+        if (ai->SelfBuff(MOLTEN_ARMOR))
+            return;
+    }
+    else if (MAGE_ARMOR)
+    {
+        if (ai->SelfBuff(MAGE_ARMOR))
+            return;
+    }
+    else if (ICE_ARMOR)
+    {
+        if (ai->SelfBuff(ICE_ARMOR))
+            return;
+    }
+    else if (FROST_ARMOR)
+        if (ai->SelfBuff(FROST_ARMOR))
+            return;
+
+    // buff master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff...
+        if (!master->IsInDuel(master))
+            if (ARCANE_BRILLIANCE && ai->HasSpellReagents(ARCANE_BRILLIANCE))
+                if (ai->Buff(ARCANE_BRILLIANCE, master))
+                    return;
+
+        // ...and check group for new members joined or resurrected, or just buff everyone if no group buff available
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->isAlive() || tPlayer == m_bot)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == master && tPlayer->duel->startTime != 0)
+                continue;
+
+            // buff
+            if (BuffPlayer(tPlayer))
+                return;
+        }
+
+    }
+    // There is no group, buff master
+    else if (master->isAlive() && !master->IsInDuel(master))
+        if (BuffPlayer(master))
+            return;
+
+    // Buff self finally
+    if (BuffPlayer(m_bot))
+        return;
+
+    // conjure food & water
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem == NULL && CONJURE_WATER && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some water.");
+        ai->CastSpell(CONJURE_WATER, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+    else if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    pItem = ai->FindFood();
+
+    if (pItem == NULL && CONJURE_FOOD && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some food.");
+        ai->CastSpell(CONJURE_FOOD, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+} // end DoNonCombatActions
+
+bool PlayerbotMageAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if (pet && pet->getPowerType() == POWER_MANA && ai->Buff(ARCANE_INTELLECT, pet))
+        return true;
+
+    if (ARCANE_INTELLECT)
+        return ai->Buff(ARCANE_INTELLECT, target);
+    else
+        return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.h b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
new file mode 100644
index 0000000..a161524
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
@@ -0,0 +1,163 @@
+#ifndef _PlayerbotMageAI_H
+#define _PlayerbotMageAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_FROST,
+    SPELL_FIRE,
+    SPELL_ARCANE
+};
+
+enum MageSpells
+{
+    AMPLIFY_MAGIC_1                 = 1008,
+    ARCANE_BARRAGE_1                = 44425,
+    ARCANE_BLAST_1                  = 30451,
+    ARCANE_BRILLIANCE_1             = 23028,
+    ARCANE_EXPLOSION_1              = 1449,
+    ARCANE_INTELLECT_1              = 1459,
+    ARCANE_MISSILES_1               = 5143,
+    ARCANE_POWER_1                  = 12042,
+    BLAST_WAVE_1                    = 11113,
+    BLINK_1                         = 1953,
+    BLIZZARD_1                      = 10,
+    COLD_SNAP_1                     = 11958,
+    COMBUSTION_1                    = 11129,
+    CONE_OF_COLD_1                  = 120,
+    CONJURE_FOOD_1                  = 587,
+    CONJURE_MANA_GEM_1              = 759,
+    CONJURE_REFRESHMENT_1           = 42955,
+    CONJURE_WATER_1                 = 5504,
+    COUNTERSPELL_1                  = 2139,
+    DALARAN_BRILLIANCE_1            = 61316,
+    DALARAN_INTELLECT_1             = 61024,
+    DAMPEN_MAGIC_1                  = 604,
+    DEEP_FREEZE_1                   = 44572,
+    DRAGONS_BREATH_1                = 31661,
+    EVOCATION_1                     = 12051,
+    FIRE_BLAST_1                    = 2136,
+    FIRE_WARD_1                     = 543,
+    FIREBALL_1                      = 133,
+    FLAMESTRIKE_1                   = 2120,
+    FOCUS_MAGIC_1                   = 54646,
+    FROST_ARMOR_1                   = 168,
+    FROST_NOVA_1                    = 122,
+    FROST_WARD_1                    = 6143,
+    FROSTBOLT_1                     = 116,
+    FROSTFIRE_BOLT_1                = 44614,
+    ICE_ARMOR_1                     = 7302,
+    ICE_BARRIER_1                   = 11426,
+    ICE_BLOCK_1                     = 45438,
+    ICE_LANCE_1                     = 30455,
+    ICY_VEINS_1                     = 12472,
+    INVISIBILITY_1                  = 66,
+    LIVING_BOMB_1                   = 44457,
+    MAGE_ARMOR_1                    = 6117,
+    MANA_SHIELD_1                   = 1463,
+    MIRROR_IMAGE_1                  = 55342,
+    MOLTEN_ARMOR_1                  = 30482,
+    PRESENCE_OF_MIND_1              = 12043,
+    PYROBLAST_1                     = 11366,
+    REMOVE_CURSE_MAGE_1             = 475,
+    RITUAL_OF_REFRESHMENT_1         = 43987,
+    SCORCH_1                        = 2948,
+    SLOW_1                          = 31589,
+    SLOW_FALL_1                     = 130,
+    SPELLSTEAL_1                    = 30449,
+    SUMMON_WATER_ELEMENTAL_1        = 31687
+};
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+public:
+    PlayerbotMageAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotMageAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // ARCANE
+    uint32 ARCANE_MISSILES,
+           ARCANE_EXPLOSION,
+           COUNTERSPELL,
+           SLOW,
+           ARCANE_BARRAGE,
+           ARCANE_BLAST,
+           MIRROR_IMAGE,
+           ARCANE_POWER;
+
+    // FIRE
+    uint32 FIREBALL,
+           FIRE_BLAST,
+           FLAMESTRIKE,
+           SCORCH,
+           PYROBLAST,
+           BLAST_WAVE,
+           COMBUSTION,
+           DRAGONS_BREATH,
+           LIVING_BOMB,
+           FROSTFIRE_BOLT,
+           FIRE_WARD;
+
+    // FROST
+    uint32 DEEP_FREEZE,
+           FROSTBOLT,
+           FROST_NOVA,
+           BLIZZARD,
+           ICY_VEINS,
+           CONE_OF_COLD,
+           ICE_BARRIER,
+           SUMMON_WATER_ELEMENTAL,
+           ICE_LANCE,
+           FROST_WARD,
+           ICE_BLOCK,
+           COLD_SNAP;
+
+    // buffs
+    uint32 FROST_ARMOR,
+           ICE_ARMOR,
+           MAGE_ARMOR,
+           MOLTEN_ARMOR,
+           ARCANE_INTELLECT,
+           ARCANE_BRILLIANCE,
+           DALARAN_INTELLECT,
+           DALARAN_BRILLIANCE,
+           MANA_SHIELD,
+           DAMPEN_MAGIC,
+           AMPLIFY_MAGIC;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellArcane,
+           LastSpellFire,
+           LastSpellFrost,
+           CONJURE_WATER,
+           CONJURE_FOOD;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMgr.cpp b/src/server/game/AI/PlayerBots/PlayerbotMgr.cpp
new file mode 100644
index 0000000..a60dc91
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMgr.cpp
@@ -0,0 +1,1172 @@
+#include "Config.h"
+#include "Player.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "WorldPacket.h"
+#include "Chat.h"
+#include "ObjectMgr.h"
+#include "GossipDef.h"
+#include "Chat.h"
+#include "Language.h"
+#include "WaypointMovementGenerator.h"
+#include "Group.h"
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : m_master(master)
+{
+    // load config variables
+    m_confMaxNumBots = ConfigMgr::GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+    m_confDebugWhisper = ConfigMgr::GetBoolDefault("PlayerbotAI.DebugWhisper", false);
+    m_confFollowDistance[0] = ConfigMgr::GetFloatDefault("PlayerbotAI.FollowDistanceMin", 0.5f);
+    m_confFollowDistance[1] = ConfigMgr::GetFloatDefault("PlayerbotAI.FollowDistanceMax", 1.0f);
+    m_confCollectCombat = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Combat", true);
+    m_confCollectQuest = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Quest", true);
+    m_confCollectProfession = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Profession", true);
+    m_confCollectLoot = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Loot", true);
+    m_confCollectSkin = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Skin", true);
+    m_confCollectObjects = ConfigMgr::GetBoolDefault("PlayerbotAI.Collect.Objects", true);
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+    LogoutAllBots();
+}
+
+void PlayerbotMgr::UpdateAI(const uint32 /*p_time*/) {}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            uint64 guid;
+            std::vector<uint32> nodes;
+            nodes.resize(2);
+            uint8 delay = 9;
+
+            p >> guid >> nodes[0] >> nodes[1];
+
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXI from %d to %d", nodes[0], nodes[1]);
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = ObjectAccessor::GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            uint64 guid;
+            uint32 node_count;
+            uint8 delay = 9;
+
+            p >> guid >> node_count;
+
+            std::vector<uint32> nodes;
+
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                nodes.push_back(node);
+            }
+
+            if (nodes.empty())
+                return;
+
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXIEXPRESS from %d to %d", nodes.front(), nodes.back());
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = ObjectAccessor::GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        case CMSG_MOVE_SPLINE_DONE:
+        {
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE");
+
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            uint64 guid;                                            // guid - unused
+            p.readPackGUID(guid);
+
+            MovementInfo movementInfo;
+            // ReadMovementInfo(p, &movementInfo);
+            p.read_skip<uint32>();                          // unk
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                // in taxi flight packet received in 2 case:
+                // 1) end taxi path in far (multi-node) flight
+                // 2) switch from one map to other in case multi-map taxi path
+                // we need process only (1)
+                uint32 curDest = bot->m_taxi.GetTaxiDestination();
+                if (!curDest)
+                    return;
+
+                TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+
+                // far teleport case
+                if (curDestNode && curDestNode->map_id != bot->GetMapId())
+                {
+                    if (bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+                    {
+                        // short preparations to continue flight
+                        FlightPathMovementGenerator* flight = (FlightPathMovementGenerator *) (bot->GetMotionMaster()->top());
+
+                        flight->Reset(*bot);                // will reset at map landing
+
+                        flight->SetCurrentNodeAfterTeleport();
+                        TaxiPathNodeEntry const& node = flight->GetPath()[flight->GetCurrentNode()];
+                        flight->SkipCurrentNode();
+
+                        bot->TeleportTo(curDestNode->map_id, node.x, node.y, node.z, bot->GetOrientation());
+                    }
+                    return;
+                }
+
+                uint32 destinationnode = bot->m_taxi.NextTaxiDestination();
+                if (destinationnode > 0)                                // if more destinations to go
+                {
+                    // current source node for next destination
+                    uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+
+                    // Add to taximask middle hubs in taxicheat mode (to prevent having player with disabled taxicheat and not having back flight path)
+                    if (bot->isTaxiCheater())
+                        if (bot->m_taxi.SetTaximaskNode(sourcenode))
+                        {
+                            WorldPacket data(SMSG_NEW_TAXI_PATH, 0);
+                            bot->GetSession()->SendPacket(&data);
+                        }
+
+                    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE Taxi has to go from %u to %u", sourcenode, destinationnode);
+
+                    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                    uint32 path, cost;
+                    sObjectMgr->GetTaxiPath(sourcenode, destinationnode, path, cost);
+
+                    if (path && mountDisplayId)
+                        bot->GetSession()->SendDoFlight(mountDisplayId, path, 1);          // skip start fly node
+                    else
+                        bot->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+                }
+                else
+                    /* std::ostringstream out;
+                       out << "Destination reached" << bot->GetName();
+                       ChatHandler ch(m_master);
+                       ch.SendSysMessage(out.str().c_str()); */
+                    bot->m_taxi.ClearTaxiDestinations();        // Destination, clear source node
+            }
+            return;
+        }
+
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+
+        // If master inspects one of his bots, give the master useful info in chat window
+        // such as inventory that can be equipped
+        case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint64 guid;
+            p >> guid;
+            Player* const bot = GetPlayerBot(guid);
+            if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+            return;
+        }
+
+        // handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint32 emoteNum;
+            p >> emoteNum;
+
+            /* std::ostringstream out;
+               out << "emote is: " << emoteNum;
+               ChatHandler ch(m_master);
+               ch.SendSysMessage(out.str().c_str()); */
+
+            switch (emoteNum)
+            {
+                case TEXT_EMOTE_BOW:
+                {
+                    // Buff anyone who bows before me. Useful for players not in bot's group
+                    // How do I get correct target???
+                    //Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
+                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    return;
+                }
+                /*
+                   case TEXT_EMOTE_BONK:
+                   {
+                    Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    if (!pPlayer || !pPlayer->GetPlayerbotAI())
+                        return;
+                    PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(m_master);
+                    {
+                        std::ostringstream out;
+                        out << "time(0): " << time(0)
+                            << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                            << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
+                        out << "tradeActive: " << tradeActive;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsCharmed() " << pBot->getPlayer()->isCharmed();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                   }
+                 */
+
+                case TEXT_EMOTE_EAT:
+                case TEXT_EMOTE_DRINK:
+                {
+                    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        bot->GetPlayerbotAI()->Feast();
+                    }
+                    return;
+                }
+
+                // emote to attack selected target
+                case TEXT_EMOTE_POINT:
+                {
+                    uint64 attackOnGuid = m_master->GetSelection();
+                    if (!attackOnGuid)
+                        return;
+
+                    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_master, attackOnGuid);
+                    if (!thingToAttack) return;
+
+                    Player *bot = 0;
+                    for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+                    {
+                        bot = itr->second;
+                        if (!bot->IsFriendlyTo(thingToAttack) && bot->IsWithinLOSInMap(thingToAttack))
+                            bot->GetPlayerbotAI()->GetCombatTarget(thingToAttack);
+                    }
+                    return;
+                }
+
+                // emote to stay
+                case TEXT_EMOTE_STAND:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
+                    else
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
+                        }
+                    return;
+                }
+
+                // 324 is the followme emote (not defined in enum)
+                // if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXT_EMOTE_WAVE:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
+                    else
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
+                        }
+                    return;
+                }
+            }
+            return;
+        } /* EMOTE ends here */
+
+        case CMSG_GAMEOBJ_USE: // not sure if we still need this one
+        case CMSG_GAMEOBJ_REPORT_USE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);     // reset reader
+            uint64 objGUID;
+            p >> objGUID;
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+                if (!obj)
+                    return;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    bot->GetPlayerbotAI()->TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    bot->PrepareQuestMenu(objGUID);
+                    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.QuestId;
+                        if (!bot->GetPlayerbotAI()->AddQuest(questID, obj))
+                            sLog->outDebug(LOG_FILTER_NETWORKIO, "Couldn't take quest");
+                    }
+                }
+            }
+        }
+        break;
+
+        case CMSG_QUESTGIVER_HELLO:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            WorldObject* pNpc = ObjectAccessor::GetWorldObject( *m_master, npcGUID );
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+
+            return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint64 guid;
+            uint32 quest;
+            uint32 unk1;
+            p >> guid >> quest >> unk1;
+
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_ACCEPT_QUEST npc = %s, quest = %u, unk1 = %u", GUID_LOPART(guid), quest, unk1);
+
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+                for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (!bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (!bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (!bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (!bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0);         // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+
+                        // build needed items if quest contains any
+                        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+                            if (qInfo->RequiredItemCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedItems();
+                                break;
+                            }
+
+                        // build needed creatures if quest contains any
+                        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedCreatures();
+                                break;
+                            }
+                    }
+                }
+            return;
+        }
+
+        case CMSG_AREATRIGGER:
+        {
+            WorldPacket p(packet);
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                p.rpos(0);         // reset reader
+                bot->GetSession()->HandleAreaTriggerOpcode(p);
+            }
+            return;
+        }
+
+        case CMSG_QUESTGIVER_COMPLETE_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint32 quest;
+            uint64 npcGUID;
+            p >> npcGUID >> quest;
+
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %s, quest = %u", uint32(GUID_LOPART(npcGUID)), quest);
+
+            WorldObject* pNpc = ObjectAccessor::GetWorldObject( *m_master, npcGUID );
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+            return;
+        }
+
+        case CMSG_LOOT_ROLL:
+        {
+
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+            uint64 Guid;
+            uint32 NumberOfPlayers;
+            uint8 rollType;
+            p.rpos(0);    //reset packet pointer
+            p >> Guid;    //guid of the item rolled
+            p >> NumberOfPlayers;    //number of players invited to roll
+            p >> rollType;    //need,greed or pass on roll
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+
+                uint32 choice;
+
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    return;
+
+                (bot->GetPlayerbotAI()->CanStore()) ? choice = urand(0, 3) : choice = 0;  // pass = 0, need = 1, greed = 2, disenchant = 3
+
+                group->CountRollVote(bot->GetGUID(), Guid, NumberOfPlayers-1, MAX_ROLL_TYPE);
+
+                switch (choice)
+                {
+                    case ROLL_NEED:
+                        bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
+                        break;
+                    case ROLL_GREED:
+                        bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
+                        break;
+                }
+            }
+            return;
+        }
+
+        // Handle GOSSIP activate actions, prior to GOSSIP select menu actions
+        case CMSG_GOSSIP_HELLO:
+        {
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_GOSSIP_HELLO");
+
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_GOSSIP_HELLO, (8)
+            uint64 guid;
+            p.rpos(0);                //reset packet pointer
+            p >> guid;
+
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+                if (!pCreature)
+                {
+                    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %s not found or you can't interact with him.", GUID_LOPART(guid));
+                    return;
+                }
+
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureInfo()->GossipMenuId);
+                for (GossipMenuItemsMap::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
+                {
+                    uint32 npcflags = pCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+                    if (!(itr->second.OptionNpcflag & npcflags))
+                        continue;
+
+                    switch (itr->second.OptionType)
+                    {
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_TAXIVENDOR");
+                            bot->GetSession()->SendLearnNewTaxiNode(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_QUESTGIVER");
+                            bot->GetPlayerbotAI()->TurnInQuests(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_VENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_VENDOR");
+                            break;
+                        }
+                        case GOSSIP_OPTION_STABLEPET:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_STABLEPET");
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_AUCTIONEER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_BANKER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_INNKEEPER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_INNKEEPER");
+                            break;
+                        }
+                    }
+                }
+            }
+            return;
+        }
+
+        case CMSG_SPIRIT_HEALER_ACTIVATE:
+        {
+            // sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_SPIRIT_HEALER_ACTIVATE SpiritHealer is resurrecting the Player %s",m_master->GetName());
+            for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+            {
+                Player* const bot = itr->second;
+                Group *grp = bot->GetGroup();
+                if (grp)
+                    grp->RemoveMember(bot->GetGUID());
+            }
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+        {
+            if (!ConfigMgr::GetBoolDefault("PlayerbotAI.SellGarbage", true))
+                return;
+
+            WorldPacket p(packet);
+            p.rpos(0);  // reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            Object* const pNpc = (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*m_master, npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot->IsInMap(static_cast<WorldObject *>(pNpc)))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                    continue;
+                }
+                else
+                    bot->GetPlayerbotAI()->SellGarbage();
+            }
+            return;
+        }
+
+            /*
+               case CMSG_NAME_QUERY:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_BACKWARD:
+               case MSG_MOVE_HEARTBEAT:
+               case CMSG_STANDSTATECHANGE:
+               case CMSG_QUERY_TIME:
+               case CMSG_CREATURE_QUERY:
+               case CMSG_GAMEOBJECT_QUERY:
+               case MSG_MOVE_JUMP:
+               case MSG_MOVE_FALL_LAND:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+                // ChatHandler ch(m_master);
+                // ch.SendSysMessage(oc);
+
+                std::ostringstream out;
+                out << "masterin: " << oc;
+                sLog.outError(out.str().c_str());
+               }
+             */
+    }
+}
+
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    
+       switch (packet.GetOpcode())
+       {
+        // maybe our bots should only start looting after the master loots?
+        //case SMSG_LOOT_RELEASE_RESPONSE: {}
+        case SMSG_NAME_QUERY_RESPONSE:
+        case SMSG_MONSTER_MOVE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case SMSG_DESTROY_OBJECT:
+        case SMSG_UPDATE_OBJECT:
+        case SMSG_STANDSTATE_UPDATE:
+        case MSG_MOVE_HEARTBEAT:
+        case SMSG_QUERY_TIME_RESPONSE:
+        case SMSG_AURA_UPDATE_ALL:
+        case SMSG_CREATURE_QUERY_RESPONSE:
+        case SMSG_GAMEOBJECT_QUERY_RESPONSE:
+            return;
+        default:
+        {
+            const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+            std::ostringstream out;
+            out << "masterout: " << oc;
+            sLog->outError(out.str().c_str());
+        }
+       }
+     
+}
+
+void PlayerbotMgr::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot = itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+void PlayerbotMgr::Stay()
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* bot = itr->second;
+        bot->GetMotionMaster()->Clear();
+    }
+}
+
+// Playerbot mod: logs out a Playerbot.
+void PlayerbotMgr::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+// Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* PlayerbotMgr::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return (it == m_playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotMgr::OnBotLogin(Player * const bot)
+{
+    // give the bot some AI, object is owned by the player class
+    PlayerbotAI* ai = new PlayerbotAI(this, bot);
+    bot->SetPlayerbotAI(ai);
+
+    // tell the world session that they now manage this new bot
+    m_playerBots[bot->GetGUID()] = bot;
+
+    // if bot is in a group and master is not in group then
+    // have bot leave their group
+    if (bot->GetGroup() &&
+        (m_master->GetGroup() == NULL ||
+         m_master->GetGroup()->IsMember(bot->GetGUID()) == false))
+        bot->RemoveFromGroup();
+
+    // sometimes master can lose leadership, pass leadership to master check
+    const uint64 masterGuid = m_master->GetGUID();
+    if (m_master->GetGroup() &&
+        !m_master->GetGroup()->IsLeader(masterGuid))
+        {
+                // But only do so if one of the master's bots is leader
+                for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); itr++)
+                {
+                        Player* bot = itr->second;
+                        if ( m_master->GetGroup()->IsLeader(bot->GetGUID()) )
+                        {
+                                m_master->GetGroup()->ChangeLeader(masterGuid);
+                                break;
+                        }
+                }
+        }
+}
+
+void PlayerbotMgr::RemoveAllBotsFromGroup()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); m_master->GetGroup() && it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->IsInSameGroupWith(m_master))
+            m_master->GetGroup()->RemoveMember(bot->GetGUID());
+    }
+}
+
+void Creature::LoadBotMenu(Player *pPlayer)
+{
+
+    if (pPlayer->GetPlayerbotAI()) return;
+    uint64 guid = pPlayer->GetGUID();
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    QueryResult result = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account='%d'", accountId);
+    do
+    {
+        Field *fields = result->Fetch();
+        uint64 guidlo = uint64(fields[0].GetUInt32());
+        std::string name = fields[1].GetString();
+        std::string word = "";
+
+        if ((guid == uint64()) || (guid == guidlo))
+        {
+            //not found or himself
+        }
+        else
+        {
+            // if(sConfig.GetBoolDefault("PlayerbotAI.DisableBots", false)) return;
+            // create the manager if it doesn't already exist
+            if (!pPlayer->GetPlayerbotMgr())
+                pPlayer->SetPlayerbotMgr(new PlayerbotMgr(pPlayer));
+            if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) == NULL) // add (if not already in game)
+            {
+                word += "Recruit ";
+                word += name;
+                word += " as a Bot.";
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(0, (uint8) 9, word, guidlo, GOSSIP_OPTION_BOT, word, false);
+            }
+            else if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) != NULL) // remove (if in game)
+            {
+                word += "Dismiss ";
+                word += name;
+                word += " from duty.";
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(0, (uint8) 0, word, guidlo, GOSSIP_OPTION_BOT, word, false);
+            }
+        }
+    }
+    while (result->NextRow());
+}
+
+void Player::skill(std::list<uint32>& m_spellsToLearn)
+{
+    for (SkillStatusMap::const_iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+    {
+        if (itr->second.uState == SKILL_DELETED)
+            continue;
+
+        uint32 pskill = itr->first;
+
+        m_spellsToLearn.push_back(pskill);
+    }
+}
+
+void Player::MakeTalentGlyphLink(std::ostringstream &out)
+{
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+    // |cff66bbff|Hglyph:23:460|h[Glyph of Fortitude]|h|r
+
+    if (m_specsCount)
+        // loop through all specs (only 1 for now)
+        for (uint32 specIdx = 0; specIdx < m_specsCount; ++specIdx)
+        {
+            // find class talent tabs (all players have 3 talent tabs)
+            uint32 const* talentTabIds = GetTalentTabPages(getClass());
+
+            out << "\n" << "Active Talents ";
+
+            for (uint32 i = 0; i < 3; ++i)
+            {
+                uint32 talentTabId = talentTabIds[i];
+                for (PlayerTalentMap::iterator iter = m_talents[i]->begin(); iter != m_talents[i]->end(); ++iter)
+                {
+                    PlayerTalent* talent = (iter)->second;
+
+                    if (talent->state == PLAYERSPELL_REMOVED)
+                        continue;
+
+                    // skip another tab talents
+                    if (talent->talentEntry->TalentTab != talentTabId)
+                        continue;
+
+                    TalentEntry const* talentInfo = sTalentStore.LookupEntry( talent->talentEntry->TalentID );
+
+                    SpellEntry const* spell_entry = sSpellStore.LookupEntry(talentInfo->RankID[talent->spec]);
+
+                    out << "|cff4e96f7|Htalent:" << talent->talentEntry->TalentID << ":" << talent->spec
+                        << " |h[" << spell_entry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+                }
+            }
+
+            uint32 freepoints = 0;
+
+            out << " Unspent points : ";
+
+            if ((freepoints = GetFreeTalentPoints()) > 0)
+                out << "|h|cff00ff00" << freepoints << "|h|r";
+            else
+                out << "|h|cffff0000" << freepoints << "|h|r";
+
+            out << "\n" << "Active Glyphs ";
+            // GlyphProperties.dbc
+            for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            {
+                GlyphPropertiesEntry const* glyph = sGlyphPropertiesStore.LookupEntry(GetGlyphSlot(i));
+                if (!glyph)
+                    continue;
+
+                SpellEntry const* spell_entry = sSpellStore.LookupEntry(glyph->SpellId);
+
+                out << "|cff66bbff|Hglyph:" << GetGlyphSlot(i) << ":" << GetGlyphSlot(i)
+                    << " |h[" << spell_entry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+
+            }
+        }
+}
+
+void Player::chompAndTrim(std::string& str)
+{
+    while (str.length() > 0)
+    {
+        char lc = str[str.length() - 1];
+        if (lc == '\r' || lc == '\n' || lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(0, str.length() - 1);
+        else
+            break;
+    }
+
+    while (str.length() > 0)
+    {
+        char lc = str[0];
+        if (lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(1, str.length() - 1);
+        else
+            break;
+    }
+}
+
+bool Player::getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId)
+{
+    bool result = false;
+    unsigned int i;
+    for (i = pStartPos; i < pString.size(); ++i)
+    {
+        if (pString[i] == ',')
+            break;
+    }
+    if (i > pStartPos)
+    {
+        std::string idString = pString.substr(pStartPos, i - pStartPos);
+        pStartPos = i + 1;
+        chompAndTrim(idString);
+        pId = atoi(idString.c_str());
+        result = true;
+    }
+    return(result);
+}
+
+bool Player::requiredQuests(const char* pQuestIdString)
+{
+    if (pQuestIdString != NULL)
+    {
+        unsigned int pos = 0;
+        unsigned int id;
+        std::string confString(pQuestIdString);
+        chompAndTrim(confString);
+        while (getNextQuestId(confString, pos, id))
+        {
+            QuestStatus status = GetQuestStatus(id);
+            if (status == QUEST_STATUS_COMPLETE)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool ChatHandler::HandlePlayerbotCommand(const char* args)
+{
+    if (!(m_session->GetSecurity() > SEC_PLAYER))
+        if (ConfigMgr::GetBoolDefault("PlayerbotAI.DisableBots", false))
+        {
+            PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+    if (!m_session)
+    {
+        PSendSysMessage("|cffff0000You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!*args)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char *) args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    if (!normalizePlayerName(charnameStr))
+        return false;
+
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+    if (guid == uint64() || (guid == m_session->GetPlayer()->GetGUID()))
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    if (accountId != m_session->GetAccountId())
+    {
+        PSendSysMessage("|cffff0000You may only add bots from the same account.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // create the playerbot manager if it doesn't already exist
+    PlayerbotMgr* mgr = m_session->GetPlayer()->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        mgr = new PlayerbotMgr(m_session->GetPlayer());
+        m_session->GetPlayer()->SetPlayerbotMgr(mgr);
+    }
+
+    QueryResult resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
+    if (resultchar)
+    {
+        Field *fields = resultchar->Fetch();
+        int acctcharcount = fields[0].GetUInt32();
+        int maxnum = ConfigMgr::GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+        if (!(m_session->GetSecurity() > SEC_PLAYER))
+            if (acctcharcount > maxnum && (cmdStr == "add" || cmdStr == "login"))
+            {
+                PSendSysMessage("|cffff0000You cannot summon anymore bots.(Current Max: |cffffffff%u)", maxnum);
+                SetSentErrorMessage(true);
+                return false;
+            }
+    }
+
+    QueryResult resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    if (resultlvl)
+    {
+        Field *fields = resultlvl->Fetch();
+        int charlvl = fields[0].GetUInt32();
+        int maxlvl = ConfigMgr::GetIntDefault("PlayerbotAI.RestrictBotLevel", 80);
+        if (!(m_session->GetSecurity() > SEC_PLAYER))
+            if (charlvl > maxlvl)
+            {
+                PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.(Current Max:lvl |cffffffff%u)", fields[1].GetString(), maxlvl);
+                SetSentErrorMessage(true);
+                return false;
+            }
+    }
+    // end of gmconfig patch
+    if (cmdStr == "add" || cmdStr == "login")
+    {
+        if (mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("Bot already exists in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 1 WHERE guid = '%u'", GUID_LOPART(guid));
+        mgr->AddPlayerBot(guid);
+        PSendSysMessage("Bot added successfully.");
+    }
+    else if (cmdStr == "remove" || cmdStr == "logout")
+    {
+        if (!mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("|cffff0000Bot can not be removed because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", GUID_LOPART(guid));
+        mgr->LogoutPlayerBot(guid);
+        PSendSysMessage("Bot removed successfully.");
+    }
+    else if (cmdStr == "co" || cmdStr == "combatorder")
+    {
+        Unit *target = NULL;
+        char *orderChar = strtok(NULL, " ");
+        if (!orderChar)
+        {
+            PSendSysMessage("|cffff0000Syntax error:|cffffffff .bot co <botName> <order=reset|tank|assist|heal|protect> [targetPlayer]");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        std::string orderStr = orderChar;
+        if (orderStr == "protect" || orderStr == "assist")
+        {
+            char *targetChar = strtok(NULL, " ");
+            uint64 targetGUID = m_session->GetPlayer()->GetSelection();
+            if (!targetChar && !targetGUID)
+            {
+                PSendSysMessage("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            if (targetChar)
+            {
+                std::string targetStr = targetChar;
+                uint64 targ_guid = sObjectMgr->GetPlayerGUIDByName(targetStr.c_str());
+
+                //targetGUID.Set(targ_guid.GetRawValue());
+            }
+            target = ObjectAccessor::GetUnit(*m_session->GetPlayer(), targetGUID);
+            if (!target)
+            {
+                PSendSysMessage("|cffff0000Invalid target for combat order protect or assist!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+        }
+        if (mgr->GetPlayerBot(guid) == NULL)
+        {
+            PSendSysMessage("|cffff0000Bot can not receive combat order because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        mgr->GetPlayerBot(guid)->GetPlayerbotAI()->SetCombatOrderByStr(orderStr, target);
+    }
+    return true;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMgr.h b/src/server/game/AI/PlayerBots/PlayerbotMgr.h
new file mode 100644
index 0000000..7df0442
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMgr.h
@@ -0,0 +1,64 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+
+class PlayerbotMgr
+{
+public:
+    PlayerbotMgr(Player * const master);
+    virtual ~PlayerbotMgr();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called whenever the master sends a packet to the server.
+    // These packets can be viewed, but not edited.
+    // It allows bot creators to craft AI in response to a master's actions.
+    // For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    // Notice: this is static - it is called once for all bots of the master.
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+
+    void AddPlayerBot(uint64 guid);
+    void LogoutPlayerBot(uint64 guid);
+    Player* GetPlayerBot(uint64 guid) const;
+    Player* GetMaster() const { return m_master; };
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
+    void LogoutAllBots();
+    void RemoveAllBotsFromGroup();
+    void OnBotLogin(Player * const bot);
+    void Stay();
+
+public:
+    // config variables
+    uint32 m_confRestrictBotLevel;
+    uint32 m_confDisableBotsInRealm;
+    uint32 m_confMaxNumBots;
+    bool m_confDisableBots;
+    bool m_confDebugWhisper;
+    float m_confFollowDistance[2];
+    bool m_confCollectCombat;
+    bool m_confCollectQuest;
+    bool m_confCollectProfession;
+    bool m_confCollectLoot;
+    bool m_confCollectSkin;
+    bool m_confCollectObjects;
+
+private:
+    Player* const m_master;
+    PlayerBotMap m_playerBots;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..10bcf13
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,538 @@
+/*
+   Name    : PlayerbotPaladinAI.cpp
+   Complete: maybe around 27% :D
+   Author  : Natsukawa
+   Version : 0.35
+ */
+
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RETRIBUTION_AURA              = ai->initSpell(RETRIBUTION_AURA_1);
+    CRUSADER_AURA                 = ai->initSpell(CRUSADER_AURA_1);
+    CRUSADER_STRIKE               = ai->initSpell(CRUSADER_STRIKE_1);
+    SEAL_OF_COMMAND               = ai->initSpell(SEAL_OF_COMMAND_1);
+    SEAL_OF_RIGHTEOUSNESS         = ai->initSpell(SEAL_OF_RIGHTEOUSNESS_1);
+    SEAL_OF_CORRUPTION            = ai->initSpell(SEAL_OF_CORRUPTION_1);
+    SEAL_OF_JUSTICE               = ai->initSpell(SEAL_OF_JUSTICE_1);
+    SEAL_OF_LIGHT                 = ai->initSpell(SEAL_OF_LIGHT_1);
+    SEAL_OF_VENGEANCE             = ai->initSpell(SEAL_OF_VENGEANCE_1);
+    SEAL_OF_WISDOM                = ai->initSpell(SEAL_OF_WISDOM_1);
+    JUDGEMENT_OF_LIGHT            = ai->initSpell(JUDGEMENT_OF_LIGHT_1);
+    JUDGEMENT_OF_WISDOM           = ai->initSpell(JUDGEMENT_OF_WISDOM_1);
+    JUDGEMENT_OF_JUSTICE          = ai->initSpell(JUDGEMENT_OF_JUSTICE_1);
+    DIVINE_STORM                  = ai->initSpell(DIVINE_STORM_1);
+    BLESSING_OF_MIGHT             = ai->initSpell(BLESSING_OF_MIGHT_1);
+    GREATER_BLESSING_OF_MIGHT     = ai->initSpell(GREATER_BLESSING_OF_MIGHT_1);
+    HAMMER_OF_WRATH               = ai->initSpell(HAMMER_OF_WRATH_1);
+    FLASH_OF_LIGHT                = ai->initSpell(FLASH_OF_LIGHT_1); // Holy
+    HOLY_LIGHT                    = ai->initSpell(HOLY_LIGHT_1);
+    HOLY_SHOCK                    = ai->initSpell(HOLY_SHOCK_1);
+    HOLY_WRATH                    = ai->initSpell(HOLY_WRATH_1);
+    DIVINE_FAVOR                  = ai->initSpell(DIVINE_FAVOR_1);
+    CONCENTRATION_AURA            = ai->initSpell(CONCENTRATION_AURA_1);
+    BLESSING_OF_WISDOM            = ai->initSpell(BLESSING_OF_WISDOM_1);
+    GREATER_BLESSING_OF_WISDOM    = ai->initSpell(GREATER_BLESSING_OF_WISDOM_1);
+    CONSECRATION                  = ai->initSpell(CONSECRATION_1);
+    AVENGING_WRATH                = ai->initSpell(AVENGING_WRATH_1);
+    LAY_ON_HANDS                  = ai->initSpell(LAY_ON_HANDS_1);
+    EXORCISM                      = ai->initSpell(EXORCISM_1);
+    SACRED_SHIELD                 = ai->initSpell(SACRED_SHIELD_1);
+    DIVINE_PLEA                   = ai->initSpell(DIVINE_PLEA_1);
+    BLESSING_OF_KINGS             = ai->initSpell(BLESSING_OF_KINGS_1);
+    GREATER_BLESSING_OF_KINGS     = ai->initSpell(GREATER_BLESSING_OF_KINGS_1);
+    BLESSING_OF_SANCTUARY         = ai->initSpell(BLESSING_OF_SANCTUARY_1);
+    GREATER_BLESSING_OF_SANCTUARY = ai->initSpell(GREATER_BLESSING_OF_SANCTUARY_1);
+    HAMMER_OF_JUSTICE             = ai->initSpell(HAMMER_OF_JUSTICE_1);
+    RIGHTEOUS_FURY                = ai->initSpell(RIGHTEOUS_FURY_1);
+    RIGHTEOUS_DEFENSE             = ai->initSpell(RIGHTEOUS_DEFENSE_1);
+    SHADOW_RESISTANCE_AURA        = ai->initSpell(SHADOW_RESISTANCE_AURA_1);
+    DEVOTION_AURA                 = ai->initSpell(DEVOTION_AURA_1);
+    FIRE_RESISTANCE_AURA          = ai->initSpell(FIRE_RESISTANCE_AURA_1);
+    FROST_RESISTANCE_AURA         = ai->initSpell(FROST_RESISTANCE_AURA_1);
+    HAND_OF_PROTECTION            = ai->initSpell(HAND_OF_PROTECTION_1);
+    DIVINE_PROTECTION             = ai->initSpell(DIVINE_PROTECTION_1);
+    DIVINE_INTERVENTION           = ai->initSpell(DIVINE_INTERVENTION_1);
+    DIVINE_SACRIFICE              = ai->initSpell(DIVINE_SACRIFICE_1);
+    DIVINE_SHIELD                 = ai->initSpell(DIVINE_SHIELD_1);
+    HOLY_SHIELD                   = ai->initSpell(HOLY_SHIELD_1);
+    AVENGERS_SHIELD               = ai->initSpell(AVENGERS_SHIELD_1);
+    HAND_OF_SACRIFICE             = ai->initSpell(HAND_OF_SACRIFICE_1);
+    SHIELD_OF_RIGHTEOUSNESS       = ai->initSpell(SHIELD_OF_RIGHTEOUSNESS_1);
+    REDEMPTION                    = ai->initSpell(REDEMPTION_1);
+
+    // Warrior auras
+    DEFENSIVE_STANCE              = 71;   //Def Stance
+    BERSERKER_STANCE              = 2458; //Ber Stance
+    BATTLE_STANCE                 = 2457; //Bat Stance
+
+    FORBEARANCE                   = 25771; // cannot be protected
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PALADIN); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+}
+
+PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
+
+bool PlayerbotPaladinAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    if (hp < 25 && ai->CastSpell(LAY_ON_HANDS, *target))
+        return true;
+
+    if (hp < 30 && ai->CastSpell(FLASH_OF_LIGHT, *target))
+        return true;
+
+    if (hp < 35 && ai->CastSpell(HOLY_SHOCK, *target))
+        return true;
+
+    if (hp < 40 && ai->CastSpell(HOLY_LIGHT, *target))
+        return true;
+
+    return false;
+} // end HealTarget
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HAMMER_OF_JUSTICE > 0)
+                ai->CastSpell(HAMMER_OF_JUSTICE);
+            return;
+    }
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+    float dist = m_bot->GetDistance(pTarget);
+    std::ostringstream out;
+
+    //Shield master if low hp.
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    if (GetMaster()->isAlive())
+        if (masterHP < 25 && HAND_OF_PROTECTION > 0 && !GetMaster()->HasAura(FORBEARANCE) && !GetMaster()->HasAura(HAND_OF_PROTECTION) && !GetMaster()->HasAura(DIVINE_PROTECTION) && !GetMaster()->HasAura(DIVINE_SHIELD))
+            ai->CastSpell(HAND_OF_PROTECTION, *GetMaster());
+
+    // heal group inside combat, but do not heal if tank
+    if (m_group && pVictim != m_bot)  // possible tank
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 40 && ai->GetManaPercent() >= 40)  // do not heal bots without plenty of mana for master & self
+                if (HealTarget(m_groupMember))
+                    return;
+        }
+    }
+
+    if (RIGHTEOUS_FURY > 0 && !m_bot->HasAura(RIGHTEOUS_FURY))
+        ai->CastSpell (RIGHTEOUS_FURY, *m_bot);
+
+    if (SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA) && pTarget->getClass() == CLASS_WARLOCK)
+        ai->CastSpell (SHADOW_RESISTANCE_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA) && pTarget->getClass() == CLASS_WARRIOR)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA) && pTarget->getClass() == CLASS_MAGE)
+        ai->CastSpell (FIRE_RESISTANCE_AURA, *m_bot);
+
+    if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA) && pTarget->getClass() == CLASS_PRIEST)
+        ai->CastSpell (RETRIBUTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA) && pTarget->getClass() == CLASS_SHAMAN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA) && pTarget->getClass() == CLASS_ROGUE)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA) && pTarget->getClass() == CLASS_PALADIN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (ai->GetHealthPercent() <= 40 || GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.4)
+        SpellSequence = Healing;
+    else
+        SpellSequence = Combat;
+
+    switch (SpellSequence)
+    {
+        case Combat:
+            if (JUDGEMENT_OF_LIGHT > 0 && !pTarget->HasAura(JUDGEMENT_OF_LIGHT) && CombatCounter < 1 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (JUDGEMENT_OF_LIGHT, *pTarget);
+                out << " Judgement of Light";
+                CombatCounter++;
+                break;
+            }
+            else if (SEAL_OF_COMMAND > 0 && !m_bot->HasAura(SEAL_OF_COMMAND) && CombatCounter < 2 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (SEAL_OF_COMMAND, *m_bot);
+                out << " Seal of Command";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE) && CombatCounter < 3 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget);
+                out << " Hammer of Justice";
+                CombatCounter++;
+                break;
+            }
+            else if (CRUSADER_STRIKE > 0 && CombatCounter < 4 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (CRUSADER_STRIKE, *pTarget);
+                out << " Crusader Strike";
+                CombatCounter++;
+                break;
+            }
+            else if (AVENGING_WRATH > 0 && CombatCounter < 5 && !m_bot->HasAura(AVENGING_WRATH) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell (AVENGING_WRATH, *m_bot);
+                out << " Avenging Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (SACRED_SHIELD > 0 && CombatCounter < 6 && pVictim == m_bot && ai->GetHealthPercent() < 70 && !m_bot->HasAura(SACRED_SHIELD) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (SACRED_SHIELD, *m_bot);
+                out << " Sacred Shield";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_STORM > 0 && CombatCounter < 7 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (DIVINE_STORM, *pTarget);
+                out << " Divine Storm";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_WRATH > 0 && CombatCounter < 8 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (HAMMER_OF_WRATH, *pTarget);
+                out << " Hammer of Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HOLY_WRATH > 0 && CombatCounter < 9 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell (HOLY_WRATH, *pTarget);
+                out << " Holy Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HAND_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(HAND_OF_SACRIFICE) && CombatCounter < 10 && ai->GetManaPercent() >= 6)
+            {
+                ai->CastSpell (HAND_OF_SACRIFICE, *GetMaster());
+                out << " Hand of Sacrifice";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PROTECTION > 0 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE) && ai->GetHealthPercent() < 30 && CombatCounter < 11 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (DIVINE_PROTECTION, *m_bot);
+                out << " Divine Protection";
+                CombatCounter++;
+                break;
+            }
+            else if (RIGHTEOUS_DEFENSE > 0 && pVictim != m_bot && ai->GetHealthPercent() > 70 && CombatCounter < 12)
+            {
+                ai->CastSpell (RIGHTEOUS_DEFENSE, *pTarget);
+                out << " Righteous Defense";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PLEA > 0 && !m_bot->HasAura(DIVINE_PLEA) && ai->GetManaPercent() < 50 && CombatCounter < 13)
+            {
+                ai->CastSpell (DIVINE_PLEA, *m_bot);
+                out << " Divine Plea";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR) && CombatCounter < 14)
+            {
+                ai->CastSpell (DIVINE_FAVOR, *m_bot);
+                out << " Divine Favor";
+                CombatCounter++;
+                break;
+            }
+            else if (CombatCounter > 15)
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("CombatCounter Reset");
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+
+        case Healing:
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (m_bot);
+                out << " ...healing bot";
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (GetMaster());
+                out << " ...healing master";
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+    }
+    if (ai->GetManager()->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+    if (AVENGING_WRATH > 0 && !m_bot->HasAura(AVENGING_WRATH) && ai->GetManaPercent() >= 8)
+        ai->CastSpell(AVENGING_WRATH, *m_bot);
+
+    if (DIVINE_SHIELD > 0 && ai->GetHealthPercent() < 30 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE) && !m_bot->HasAura(DIVINE_SHIELD) && ai->GetManaPercent() >= 3)
+        ai->CastSpell(DIVINE_SHIELD, *m_bot);
+
+    if (DIVINE_SACRIFICE > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !m_bot->HasAura(DIVINE_SACRIFICE))
+        ai->CastSpell(DIVINE_SACRIFICE, *m_bot);
+}
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // Buff myself
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK) ai->SelfBuff(RIGHTEOUS_FURY);
+    if (SEAL_OF_WISDOM > 0 && !m_bot->HasAura(SEAL_OF_WISDOM) && ai->GetManaPercent() <= 30)
+        ai->CastSpell(SEAL_OF_WISDOM, *m_bot);
+    else if (m_bot->HasAura(SEAL_OF_WISDOM) && ai->GetManaPercent() < 85)
+    { }
+    else if (SEAL_OF_LIGHT > 0 && !m_bot->HasAura(SEAL_OF_LIGHT) && ai->GetHealthPercent() < 40)
+        ai->CastSpell(SEAL_OF_LIGHT, *m_bot);
+    else if (SEAL_OF_RIGHTEOUSNESS > 0 && !m_bot->HasAura(SEAL_OF_RIGHTEOUSNESS))
+        ai->CastSpell(SEAL_OF_RIGHTEOUSNESS, *m_bot);
+    BuffPlayer(m_bot);
+
+    // Buff master
+    if(!GetMaster()->IsInDuel(GetMaster()))
+        BuffPlayer(GetMaster());
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 40)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check original
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 40)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal and buff group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster() && tPlayer->duel->startTime != 0)
+                continue;
+
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(REDEMPTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+
+            if (HealTarget(tPlayer))
+                return;
+
+            if (tPlayer != m_bot && tPlayer != GetMaster())
+                if (BuffPlayer(tPlayer))
+                    return;
+        }
+    }
+}
+
+bool PlayerbotPaladinAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    uint8 SPELL_BLESSING = 2; // See SpellSpecific enum in SpellMgr.h
+
+    Pet * pet = target->GetPet();
+    bool petCanBeBlessed = false;
+    if (pet)
+        petCanBeBlessed = ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet);
+
+    if (!ai->CanReceiveSpecificSpell(SPELL_BLESSING, target) && !petCanBeBlessed)
+        return false;
+
+    switch (target->getClass())
+    {
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (Bless(BLESSING_OF_MIGHT, target))
+                return true;
+            if (Bless(BLESSING_OF_KINGS, target))
+                return true;
+            if (Bless(BLESSING_OF_WISDOM, target))
+                return true;
+            if (Bless(BLESSING_OF_SANCTUARY, target))
+                return true;
+            else
+                return false;
+        case CLASS_DEATH_KNIGHT:
+        case CLASS_HUNTER:
+            if (petCanBeBlessed)
+                if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+            if (Bless(BLESSING_OF_KINGS, pet))
+                return true;
+            if (Bless(BLESSING_OF_SANCTUARY, pet))
+                return true;
+        case CLASS_ROGUE:
+        case CLASS_WARRIOR:
+            if (Bless(BLESSING_OF_MIGHT, target))
+                return true;
+            if (Bless(BLESSING_OF_KINGS, target))
+                return true;
+            if (Bless(BLESSING_OF_SANCTUARY, target))
+                return true;
+            else
+                return false;
+        case CLASS_WARLOCK:
+            if (petCanBeBlessed)
+            {
+                if (pet->getPowerType() == POWER_MANA)
+                {
+                    if (Bless(BLESSING_OF_WISDOM, pet))
+                        return true;
+                }
+                else if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, pet))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, pet))
+                    return true;
+            }
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+            if (Bless(BLESSING_OF_WISDOM, target))
+                return true;
+            if (Bless(BLESSING_OF_KINGS, target))
+                return true;
+            if (Bless(BLESSING_OF_SANCTUARY, target))
+                return true;
+            else
+                return false;
+    }
+    return false;
+}
+
+bool PlayerbotPaladinAI::Bless(uint32 spellId, Unit *target)
+{
+    if (spellId == 0)
+        return false;
+
+    PlayerbotAI * ai = GetAI();
+
+    if (spellId == BLESSING_OF_MIGHT)
+    {
+        if (GREATER_BLESSING_OF_MIGHT && ai->HasSpellReagents(GREATER_BLESSING_OF_MIGHT) && ai->Buff(GREATER_BLESSING_OF_MIGHT, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_WISDOM)
+    {
+        if (GREATER_BLESSING_OF_WISDOM && ai->HasSpellReagents(GREATER_BLESSING_OF_WISDOM) && ai->Buff(GREATER_BLESSING_OF_WISDOM, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_KINGS)
+    {
+        if (GREATER_BLESSING_OF_KINGS && ai->HasSpellReagents(GREATER_BLESSING_OF_KINGS) && ai->Buff(GREATER_BLESSING_OF_KINGS, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_SANCTUARY)
+    {
+        if (GREATER_BLESSING_OF_SANCTUARY && ai->HasSpellReagents(GREATER_BLESSING_OF_SANCTUARY) && ai->Buff(GREATER_BLESSING_OF_SANCTUARY, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+
+    // Should not happen, but let it be here
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..3de2eb4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
@@ -0,0 +1,185 @@
+#ifndef _PlayerbotPaladinAI_H
+#define _PlayerbotPaladinAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    Combat,
+    Healing
+};
+
+enum PaladinSpells
+{
+    AURA_MASTERY_1                  = 31821,
+    AVENGERS_SHIELD_1               = 31935,
+    AVENGING_WRATH_1                = 31884,
+    BEACON_OF_LIGHT_1               = 53563,
+    BLESSING_OF_KINGS_1             = 20217,
+    BLESSING_OF_MIGHT_1             = 19740,
+    BLESSING_OF_SANCTUARY_1         = 20911,
+    BLESSING_OF_WISDOM_1            = 19742,
+    CLEANSE_1                       = 4987,
+    CONCENTRATION_AURA_1            = 19746,
+    CONSECRATION_1                  = 26573,
+    CRUSADER_AURA_1                 = 32223,
+    CRUSADER_STRIKE_1               = 35395,
+    DEVOTION_AURA_1                 = 465,
+    DIVINE_FAVOR_1                  = 20216,
+    DIVINE_ILLUMINATION_1           = 31842,
+    DIVINE_INTERVENTION_1           = 19752,
+    DIVINE_PLEA_1                   = 54428,
+    DIVINE_PROTECTION_1             = 498,
+    DIVINE_SACRIFICE_1              = 64205,
+    DIVINE_SHIELD_1                 = 642,
+    DIVINE_STORM_1                  = 53385,
+    EXORCISM_1                      = 879,
+    FIRE_RESISTANCE_AURA_1          = 19891,
+    FLASH_OF_LIGHT_1                = 19750,
+    FROST_RESISTANCE_AURA_1         = 19888,
+    GREATER_BLESSING_OF_KINGS_1     = 25898,
+    GREATER_BLESSING_OF_MIGHT_1     = 25782,
+    GREATER_BLESSING_OF_SANCTUARY_1 = 25899,
+    GREATER_BLESSING_OF_WISDOM_1    = 25894,
+    HAMMER_OF_JUSTICE_1             = 853,
+    HAMMER_OF_THE_RIGHTEOUS_1       = 53595,
+    HAMMER_OF_WRATH_1               = 24275,
+    HAND_OF_FREEDOM_1               = 1044,
+    HAND_OF_PROTECTION_1            = 1022,
+    HAND_OF_RECKONING_1             = 62124,
+    HAND_OF_SACRIFICE_1             = 6940,
+    HAND_OF_SALVATION_1             = 1038,
+    HOLY_LIGHT_1                    = 635,
+    HOLY_SHIELD_1                   = 20925,
+    HOLY_SHOCK_1                    = 20473,
+    HOLY_WRATH_1                    = 2812,
+    JUDGEMENT_OF_JUSTICE_1          = 53407,
+    JUDGEMENT_OF_LIGHT_1            = 20271,
+    JUDGEMENT_OF_WISDOM_1           = 53408,
+    LAY_ON_HANDS_1                  = 633,
+    PURIFY_1                        = 1152,
+    REDEMPTION_1                    = 7328,
+    REPENTANCE_1                    = 20066,
+    RETRIBUTION_AURA_1              = 7294,
+    RIGHTEOUS_DEFENSE_1             = 31789,
+    RIGHTEOUS_FURY_1                = 25780,
+    SACRED_SHIELD_1                 = 53601,
+    SEAL_OF_COMMAND_1               = 20375,
+    SEAL_OF_CORRUPTION_1            = 53736,
+    SEAL_OF_JUSTICE_1               = 20164,
+    SEAL_OF_LIGHT_1                 = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1         = 21084,
+    SEAL_OF_VENGEANCE_1             = 31801,
+    SEAL_OF_WISDOM_1                = 20166,
+    SENSE_UNDEAD_1                  = 5502,
+    SHADOW_RESISTANCE_AURA_1        = 19876,
+    SHIELD_OF_RIGHTEOUSNESS_1       = 53600,
+    TURN_EVIL_1                     = 10326
+};
+//class Player;
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPaladinAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPaladinAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Bless target using greater blessing if possible
+    bool Bless(uint32 spellId, Unit *target);
+
+    // Retribution
+    uint32 RETRIBUTION_AURA,
+           SEAL_OF_COMMAND,
+           JUDGEMENT_OF_LIGHT,
+           JUDGEMENT_OF_WISDOM,
+           GREATER_BLESSING_OF_WISDOM,
+           GREATER_BLESSING_OF_MIGHT,
+           BLESSING_OF_WISDOM,
+           BLESSING_OF_MIGHT,
+           HAMMER_OF_JUSTICE,
+           RIGHTEOUS_FURY,
+           CRUSADER_AURA,
+           CRUSADER_STRIKE,
+           AVENGING_WRATH,
+           DIVINE_STORM,
+           JUDGEMENT_OF_JUSTICE;
+
+    // Holy
+    uint32 FLASH_OF_LIGHT,
+           HOLY_LIGHT,
+           DIVINE_SHIELD,
+           HAMMER_OF_WRATH,
+           CONSECRATION,
+           CONCENTRATION_AURA,
+           DIVINE_FAVOR,
+           SACRED_SHIELD,
+           HOLY_SHOCK,
+           HOLY_WRATH,
+           LAY_ON_HANDS,
+           EXORCISM,
+           REDEMPTION,
+           DIVINE_PLEA,
+           SEAL_OF_CORRUPTION,
+           SEAL_OF_JUSTICE,
+           SEAL_OF_LIGHT,
+           SEAL_OF_RIGHTEOUSNESS,
+           SEAL_OF_VENGEANCE,
+           SEAL_OF_WISDOM;
+
+    // Protection
+    uint32 GREATER_BLESSING_OF_KINGS,
+           BLESSING_OF_KINGS,
+           HAND_OF_PROTECTION,
+           SHADOW_RESISTANCE_AURA,
+           DEVOTION_AURA,
+           FIRE_RESISTANCE_AURA,
+           FROST_RESISTANCE_AURA,
+           DEFENSIVE_STANCE,
+           BERSERKER_STANCE,
+           BATTLE_STANCE,
+           DIVINE_SACRIFICE,
+           DIVINE_PROTECTION,
+           DIVINE_INTERVENTION,
+           HOLY_SHIELD,
+           AVENGERS_SHIELD,
+           RIGHTEOUS_DEFENSE,
+           BLESSING_OF_SANCTUARY,
+           GREATER_BLESSING_OF_SANCTUARY,
+           HAND_OF_SACRIFICE,
+           SHIELD_OF_RIGHTEOUSNESS;
+
+    // cannot be protected
+    uint32 FORBEARANCE;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, CombatCounter, HealCounter;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..1f1cf46
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
@@ -0,0 +1,446 @@
+
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+
+PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RENEW                         = ai->initSpell(RENEW_1);
+    LESSER_HEAL                   = ai->initSpell(LESSER_HEAL_1);
+    FLASH_HEAL                    = ai->initSpell(FLASH_HEAL_1);
+    (FLASH_HEAL > 0) ? FLASH_HEAL : FLASH_HEAL = LESSER_HEAL;
+    HEAL                          = ai->initSpell(HEAL_1);
+    (HEAL > 0) ? HEAL : HEAL = FLASH_HEAL;
+    GREATER_HEAL                  = ai->initSpell(GREATER_HEAL_1);
+    (GREATER_HEAL > 0) ? GREATER_HEAL : GREATER_HEAL = HEAL;
+    RESURRECTION                  = ai->initSpell(RESURRECTION_1);
+    SMITE                         = ai->initSpell(SMITE_1);
+    MANA_BURN                     = ai->initSpell(MANA_BURN_1);
+    HOLY_NOVA                     = ai->initSpell(HOLY_NOVA_1);
+    HOLY_FIRE                     = ai->initSpell(HOLY_FIRE_1);
+    DESPERATE_PRAYER              = ai->initSpell(DESPERATE_PRAYER_1);
+    PRAYER_OF_HEALING             = ai->initSpell(PRAYER_OF_HEALING_1);
+    CIRCLE_OF_HEALING             = ai->initSpell(CIRCLE_OF_HEALING_1);
+    BINDING_HEAL                  = ai->initSpell(BINDING_HEAL_1);
+    PRAYER_OF_MENDING             = ai->initSpell(PRAYER_OF_MENDING_1);
+
+    // SHADOW
+    FADE                          = ai->initSpell(FADE_1);
+    SHADOW_WORD_PAIN              = ai->initSpell(SHADOW_WORD_PAIN_1);
+    MIND_BLAST                    = ai->initSpell(MIND_BLAST_1);
+    SCREAM                        = ai->initSpell(PSYCHIC_SCREAM_1);
+    MIND_FLAY                     = ai->initSpell(MIND_FLAY_1);
+    DEVOURING_PLAGUE              = ai->initSpell(DEVOURING_PLAGUE_1);
+    SHADOW_PROTECTION             = ai->initSpell(SHADOW_PROTECTION_1);
+    VAMPIRIC_TOUCH                = ai->initSpell(VAMPIRIC_TOUCH_1);
+    PRAYER_OF_SHADOW_PROTECTION   = ai->initSpell(PRAYER_OF_SHADOW_PROTECTION_1);
+    SHADOWFIEND                   = ai->initSpell(SHADOWFIEND_1);
+    MIND_SEAR                     = ai->initSpell(MIND_SEAR_1);
+
+    // DISCIPLINE
+    PENANCE                       = ai->initSpell(PENANCE_1);
+    INNER_FIRE                    = ai->initSpell(INNER_FIRE_1);
+    POWER_WORD_SHIELD             = ai->initSpell(POWER_WORD_SHIELD_1);
+    POWER_WORD_FORTITUDE          = ai->initSpell(POWER_WORD_FORTITUDE_1);
+    PRAYER_OF_FORTITUDE           = ai->initSpell(PRAYER_OF_FORTITUDE_1);
+    FEAR_WARD                     = ai->initSpell(FEAR_WARD_1);
+    DIVINE_SPIRIT                 = ai->initSpell(DIVINE_SPIRIT_1);
+    PRAYER_OF_SPIRIT              = ai->initSpell(PRAYER_OF_SPIRIT_1);
+    MASS_DISPEL                   = ai->initSpell(MASS_DISPEL_1);
+    POWER_INFUSION                = ai->initSpell(POWER_INFUSION_1);
+    INNER_FOCUS                   = ai->initSpell(INNER_FOCUS_1);
+
+    RECENTLY_BANDAGED  = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PRIEST); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN          = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotPriestAI::~PlayerbotPriestAI() {}
+
+bool PlayerbotPriestAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotPriestAI::HealTarget(Unit* target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    if (hp >= 80)
+        return false;
+
+    if (hp < 25 && FLASH_HEAL > 0 && ai->CastSpell(FLASH_HEAL, *target))
+        return true;
+    else if (hp < 30 && GREATER_HEAL > 0 && ai->CastSpell(GREATER_HEAL, *target))
+        return true;
+    else if (hp < 33 && BINDING_HEAL > 0 && ai->CastSpell(BINDING_HEAL, *target))
+        return true;
+    else if (hp < 40 && PRAYER_OF_HEALING > 0 && ai->CastSpell(PRAYER_OF_HEALING, *target))
+        return true;
+    else if (hp < 50 && CIRCLE_OF_HEALING > 0 && ai->CastSpell(CIRCLE_OF_HEALING, *target))
+        return true;
+    else if (hp < 60 && HEAL > 0 && ai->CastSpell(HEAL, *target))
+        return true;
+    else if (hp < 80 && RENEW > 0 && ai->CastSpell(RENEW, *target))
+        return true;
+    else
+        return false;
+} // end HealTarget
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, *pTarget) && ai->GetHealthPercent() < 60 && ai->CastSpell(HEAL)) ||
+            ai->CastSpell(SHADOW_WORD_PAIN) ||
+            (ai->GetHealthPercent() < 80 && ai->CastSpell(RENEW)) ||
+            (ai->GetPlayerBot()->GetDistance(pTarget) <= 5 && ai->CastSpell(SCREAM)) ||
+            ai->CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && ai->CastSpell(GREATER_HEAL)) ||
+            ai->CastSpell(SMITE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 15 && FADE > 0 && !m_bot->HasAura(FADE))
+    {
+        ai->TellMaster("I'm casting fade.");
+        ai->CastSpell(FADE, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 25 && POWER_WORD_SHIELD > 0 && !m_bot->HasAura(POWER_WORD_SHIELD))
+    {
+        ai->TellMaster("I'm casting pws on myself.");
+        ai->CastSpell(POWER_WORD_SHIELD);
+    }
+    else if (ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0)
+    {
+        ai->TellMaster("I'm casting desperate prayer.");
+        ai->CastSpell(DESPERATE_PRAYER, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 80)
+        HealTarget (m_bot);
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 25 && POWER_WORD_SHIELD > 0 && !GetMaster()->HasAura(POWER_WORD_SHIELD))
+            ai->CastSpell(POWER_WORD_SHIELD, *(GetMaster()));
+        else if (masterHP < 80)
+            HealTarget (GetMaster());
+    }
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 25)
+                HealTarget(m_groupMember);
+        }
+    }
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL)  // && ai->GetMovementOrder() == PlayerbotAI::MOVEMENT_STAY)
+        SpellSequence = SPELL_HOLY;
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)  // && ai->GetMovementOrder() == PlayerbotAI::MOVEMENT_STAY)
+        SpellSequence = SPELL_SHADOWMAGIC;
+    else
+        SpellSequence = SPELL_HOLY;
+
+    // Damage Spells
+    float dist = m_bot->GetDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_HOLY:
+            if (SMITE > 0 && LastSpellHoly < 1 && !pTarget->HasAura(SMITE) && ai->GetManaPercent() >= 17)
+            {
+                ai->CastSpell(SMITE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (MANA_BURN > 0 && LastSpellHoly < 2 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && ai->GetManaPercent() >= 14)
+            {
+                //ai->TellMaster("I'm casting mana burn.");
+                ai->CastSpell(MANA_BURN, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_NOVA > 0 && LastSpellHoly < 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 22)
+            {
+                //ai->TellMaster("I'm casting holy nova.");
+                ai->CastSpell(HOLY_NOVA);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_FIRE > 0 && LastSpellHoly < 4 && !pTarget->HasAura(HOLY_FIRE) && ai->GetManaPercent() >= 13)
+            {
+                //ai->TellMaster("I'm casting holy fire.");
+                ai->CastSpell(HOLY_FIRE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (PRAYER_OF_MENDING > 0 && LastSpellHoly < 5 && pVictim == GetMaster() && GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.7 && !GetMaster()->HasAura(PRAYER_OF_MENDING) && ai->GetManaPercent() >= 15)
+            {
+                //ai->TellMaster("I'm casting prayer of mending on master.");
+                ai->CastSpell(PRAYER_OF_MENDING, *GetMaster());
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else
+                LastSpellHoly = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+
+        case SPELL_SHADOWMAGIC:
+            if (SHADOW_WORD_PAIN > 0 && LastSpellShadowMagic < 1 && !pTarget->HasAura(SHADOW_WORD_PAIN) && ai->GetManaPercent() >= 25)
+            {
+                //ai->TellMaster("I'm casting pain.");
+                ai->CastSpell(SHADOW_WORD_PAIN, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_BLAST > 0 && LastSpellShadowMagic < 2 && ai->GetManaPercent() >= 19)
+            {
+                //ai->TellMaster("I'm casting mind blast.");
+                ai->CastSpell(MIND_BLAST, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SCREAM > 0 && LastSpellShadowMagic < 3 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 15)
+            {
+                ai->TellMaster("I'm casting scream.");
+                ai->CastSpell(SCREAM);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_FLAY > 0 && LastSpellShadowMagic < 4 && !pTarget->HasAura(MIND_FLAY) && ai->GetManaPercent() >= 10)
+            {
+                //ai->TellMaster("I'm casting mind flay.");
+                ai->CastSpell(MIND_FLAY, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (DEVOURING_PLAGUE > 0 && LastSpellShadowMagic < 5 && !pTarget->HasAura(DEVOURING_PLAGUE) && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(DEVOURING_PLAGUE, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOW_PROTECTION > 0 && LastSpellShadowMagic < 6 && ai->GetManaPercent() >= 60)
+            {
+                ai->CastSpell(SHADOW_PROTECTION, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (VAMPIRIC_TOUCH > 0 && LastSpellShadowMagic < 7 && !pTarget->HasAura(VAMPIRIC_TOUCH) && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(VAMPIRIC_TOUCH, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOWFIEND > 0 && LastSpellShadowMagic < 8)
+            {
+                ai->CastSpell(SHADOWFIEND);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_SEAR > 0 && LastSpellShadowMagic < 9 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(MIND_SEAR, *pTarget);
+                ai->SetIgnoreUpdateTime(5);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else
+                LastSpellShadowMagic = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE || ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_DISCIPLINE;
+            break;
+
+        case SPELL_DISCIPLINE:
+            if (FEAR_WARD > 0 && LastSpellDiscipline < 1 && ai->GetManaPercent() >= 3)
+            {
+                //ai->TellMaster("I'm casting fear ward");
+                ai->CastSpell(FEAR_WARD, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (POWER_INFUSION > 0 && LastSpellDiscipline < 2 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting power infusion");
+                ai->CastSpell(POWER_INFUSION, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (MASS_DISPEL > 0 && LastSpellDiscipline < 3 && ai->GetManaPercent() >= 33)
+            {
+                //ai->TellMaster("I'm casting mass dispel");
+                ai->CastSpell(MASS_DISPEL);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (INNER_FOCUS > 0 && !m_bot->HasAura(INNER_FOCUS) && LastSpellDiscipline < 4)
+            {
+                //ai->TellMaster("I'm casting inner focus");
+                ai->CastSpell(INNER_FOCUS, *m_bot);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (PENANCE > 0 && LastSpellDiscipline < 5 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting PENANCE");
+                ai->CastSpell(PENANCE);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else
+                LastSpellDiscipline = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_HOLY;
+            else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_HOLY;
+
+    // selfbuff goes first
+    if (ai->SelfBuff(INNER_FIRE))
+        return;
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buffs
+        if (!master->IsInDuel(master))
+            if (master->isAlive())
+            {
+                if (PRAYER_OF_FORTITUDE && ai->HasSpellReagents(PRAYER_OF_FORTITUDE) && ai->Buff(PRAYER_OF_FORTITUDE, master))
+                    return;
+
+                if (PRAYER_OF_SPIRIT && ai->HasSpellReagents(PRAYER_OF_SPIRIT) && ai->Buff(PRAYER_OF_SPIRIT, master))
+                    return;
+            }
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || tPlayer == m_bot)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == master && tPlayer->duel->startTime != 0)
+                continue;
+
+            // first rezz em
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(RESURRECTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->isAlive() && !master->IsInDuel(master))
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else
+        if (ai->CastSpell(RESURRECTION, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotPriestAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if (pet && ai->Buff(POWER_WORD_FORTITUDE, pet))
+        return true;
+
+    if (ai->Buff(POWER_WORD_FORTITUDE, target))
+        return true;
+
+    if ((target->getClass() == CLASS_DRUID || target->getPowerType() == POWER_MANA) && ai->Buff(DIVINE_SPIRIT, target))
+        return true;
+
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..d6404dd
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
@@ -0,0 +1,156 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HOLY,
+    SPELL_SHADOWMAGIC,
+    SPELL_DISCIPLINE
+};
+
+enum PriestSpells
+{
+    ABOLISH_DISEASE_1               = 552,
+    BINDING_HEAL_1                  = 32546,
+    BLESSED_HEALING_1               = 70772,
+    CIRCLE_OF_HEALING_1             = 34861,
+    CURE_DISEASE_1                  = 528,
+    DESPERATE_PRAYER_1              = 19236,
+    DEVOURING_PLAGUE_1              = 2944,
+    DISPEL_MAGIC_1                  = 527,
+    DISPERSION_1                    = 47585,
+    DIVINE_HYMN_1                   = 64843,
+    DIVINE_SPIRIT_1                 = 14752,
+    FADE_1                          = 586,
+    FEAR_WARD_1                     = 6346,
+    FLASH_HEAL_1                    = 2061,
+    GREATER_HEAL_1                  = 2060,
+    GUARDIAN_SPIRIT_1               = 47788,
+    HEAL_1                          = 2054,
+    HOLY_FIRE_1                     = 14914,
+    HOLY_NOVA_1                     = 15237,
+    HYMN_OF_HOPE_1                  = 64901,
+    INNER_FIRE_1                    = 588,
+    INNER_FOCUS_1                   = 14751,
+    LESSER_HEAL_1                   = 2050,
+    LEVITATE_1                      = 1706,
+    LIGHTWELL_1                     = 724,
+    MANA_BURN_1                     = 8129,
+    MASS_DISPEL_1                   = 32375,
+    MIND_BLAST_1                    = 8092,
+    MIND_CONTROL_1                  = 605,
+    MIND_FLAY_1                     = 15407,
+    MIND_SEAR_1                     = 48045,
+    MIND_SOOTHE_1                   = 453,
+    MIND_VISION_1                   = 2096,
+    PAIN_SUPPRESSION_1              = 33206,
+    PENANCE_1                       = 47540,
+    POWER_INFUSION_1                = 10060,
+    POWER_WORD_FORTITUDE_1          = 1243,
+    POWER_WORD_SHIELD_1             = 17,
+    PRAYER_OF_FORTITUDE_1           = 21562,
+    PRAYER_OF_HEALING_1             = 596,
+    PRAYER_OF_MENDING_1             = 33076,
+    PRAYER_OF_SHADOW_PROTECTION_1   = 27683,
+    PRAYER_OF_SPIRIT_1              = 27681,
+    PSYCHIC_HORROR_1                = 64044,
+    PSYCHIC_SCREAM_1                = 8122,
+    RENEW_1                         = 139,
+    RESURRECTION_1                  = 2006,
+    SHACKLE_UNDEAD_1                = 9484,
+    SHADOW_PROTECTION_1             = 976,
+    SHADOW_WORD_DEATH_1             = 32379,
+    SHADOW_WORD_PAIN_1              = 589,
+    SHADOWFIEND_1                   = 34433,
+    SHADOWFORM_1                    = 15473,
+    SILENCE_1                       = 15487,
+    SMITE_1                         = 585,
+    VAMPIRIC_EMBRACE_1              = 15286,
+    VAMPIRIC_TOUCH_1                = 34914
+};
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPriestAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit* target);
+
+    // holy
+    uint32 BINDING_HEAL,
+           CIRCLE_OF_HEALING,
+           CLEARCASTING,
+           DESPERATE_PRAYER,
+           FLASH_HEAL,
+           GREATER_HEAL,
+           HEAL,
+           HOLY_FIRE,
+           HOLY_NOVA,
+           LESSER_HEAL,
+           MANA_BURN,
+           PRAYER_OF_HEALING,
+           PRAYER_OF_MENDING,
+           RENEW,
+           RESURRECTION,
+           SMITE;
+
+    // shadowmagic
+    uint32 FADE,
+           SHADOW_WORD_PAIN,
+           MIND_BLAST,
+           SCREAM,
+           MIND_FLAY,
+           DEVOURING_PLAGUE,
+           SHADOW_PROTECTION,
+           VAMPIRIC_TOUCH,
+           PRAYER_OF_SHADOW_PROTECTION,
+           SHADOWFIEND,
+           MIND_SEAR;
+
+    // discipline
+    uint32 POWER_WORD_SHIELD,
+           INNER_FIRE,
+           POWER_WORD_FORTITUDE,
+           PRAYER_OF_FORTITUDE,
+           FEAR_WARD,
+           POWER_INFUSION,
+           MASS_DISPEL,
+           PENANCE,
+           DIVINE_SPIRIT,
+           PRAYER_OF_SPIRIT,
+           INNER_FOCUS;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellHoly, LastSpellShadowMagic, LastSpellDiscipline;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..df574ae
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
@@ -0,0 +1,346 @@
+/*
+   Name    : PlayerbotRogueAI.cpp
+   Complete: maybe around 28%
+   Author    : Natsukawa
+   Version : 0.37
+ */
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    SINISTER_STRIKE          = ai->initSpell(SINISTER_STRIKE_1);
+    BACKSTAB                 = ai->initSpell(BACKSTAB_1);
+    KICK                     = ai->initSpell(KICK_1);
+    FEINT                    = ai->initSpell(FEINT_1);
+    FAN_OF_KNIVES            = ai->initSpell(FAN_OF_KNIVES_1);
+    GOUGE                    = ai->initSpell(GOUGE_1);
+    SPRINT                   = ai->initSpell(SPRINT_1);
+
+    SHADOWSTEP               = ai->initSpell(SHADOWSTEP_1);
+    STEALTH                  = ai->initSpell(STEALTH_1);
+    VANISH                   = ai->initSpell(VANISH_1);
+    EVASION                  = ai->initSpell(EVASION_1);
+    CLOAK_OF_SHADOWS         = ai->initSpell(CLOAK_OF_SHADOWS_1);
+    HEMORRHAGE               = ai->initSpell(HEMORRHAGE_1);
+    GHOSTLY_STRIKE           = ai->initSpell(GHOSTLY_STRIKE_1);
+    SHADOW_DANCE             = ai->initSpell(SHADOW_DANCE_1);
+    BLIND                    = ai->initSpell(BLIND_1);
+    DISTRACT                 = ai->initSpell(DISTRACT_1);
+    PREPARATION              = ai->initSpell(PREPARATION_1);
+    PREMEDITATION            = ai->initSpell(PREMEDITATION_1);
+    PICK_POCKET              = ai->initSpell(PICK_POCKET_1);
+
+    EVISCERATE               = ai->initSpell(EVISCERATE_1);
+    KIDNEY_SHOT              = ai->initSpell(KIDNEY_SHOT_1);
+    SLICE_DICE               = ai->initSpell(SLICE_AND_DICE_1);
+    GARROTE                  = ai->initSpell(GARROTE_1);
+    EXPOSE_ARMOR             = ai->initSpell(EXPOSE_ARMOR_1);
+    RUPTURE                  = ai->initSpell(RUPTURE_1);
+    DISMANTLE                = ai->initSpell(DISMANTLE_1);
+    CHEAP_SHOT               = ai->initSpell(CHEAP_SHOT_1);
+    AMBUSH                   = ai->initSpell(AMBUSH_1);
+    MUTILATE                 = ai->initSpell(MUTILATE_1);
+
+    RECENTLY_BANDAGED   = 11196; // first aid check
+    // racial
+    ARCANE_TORRENT           = ai->initSpell(ARCANE_TORRENT_ROGUE);
+    STONEFORM                = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST            = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF    = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD               = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN     = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotRogueAI::~PlayerbotRogueAI() {}
+
+bool PlayerbotRogueAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+
+    if (STEALTH > 0 && !m_bot->HasAura(STEALTH) && ai->CastSpell(STEALTH, *m_bot))
+    {
+
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("First > Stealth (%d)", STEALTH);
+
+        m_bot->AddUnitState(UNIT_STAT_CHASE); // ensure that the bot does not use MoveChase(), as this doesn't seem to work with STEALTH
+
+        return true;
+    }
+    else if (m_bot->HasAura(STEALTH))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation());
+        return false;
+    }
+    return false;
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SINISTER_STRIKE > 0)
+                ai->CastSpell(SINISTER_STRIKE);
+            return;
+        }
+        default:
+            break;
+    }
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = m_bot->GetDistance(pTarget);
+
+    // TODO: make this work better...
+    /*if (pVictim)
+       {
+        if( pVictim!=m_bot && !m_bot->HasUnitState(UNIT_STAT_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
+            GetAI()->TellMaster( "getting behind target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
+        }
+        else if( pVictim==m_bot && m_bot->HasUnitState(UNIT_STAT_FOLLOW) )
+        {
+            GetAI()->TellMaster( "chasing attacking target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveChase( pTarget );
+        }
+       }*/
+
+    //Rouge like behaviour. ^^
+/*    if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
+        m_bot->AttackStop();
+        m_bot->RemoveAllAttackers();
+        ai->CastSpell(VANISH);
+   //        m_bot->RemoveAllSpellCooldown();
+        GetAI()->TellMaster("AttackStop, CombatStop, Vanish");
+    }*/
+
+    // decide what to do:
+    if (pVictim == m_bot && CLOAK_OF_SHADOWS > 0 && pVictim->HasAura(SPELL_AURA_PERIODIC_DAMAGE) && !m_bot->HasAura(CLOAK_OF_SHADOWS) && ai->CastSpell(CLOAK_OF_SHADOWS))
+    {
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("CoS!");
+        return;
+    }
+    else if (m_bot->HasAura(STEALTH))
+        SpellSequence = RogueStealth;
+    else if (pTarget->IsNonMeleeSpellCasted(true))
+        SpellSequence = RogueSpellPreventing;
+    else if (pVictim == m_bot && ai->GetHealthPercent() < 40)
+        SpellSequence = RogueThreat;
+    else
+        SpellSequence = RogueCombat;
+
+    // we fight in melee, target is not in range, skip the next part!
+    if (fTargetDist > ATTACK_DISTANCE)
+        return;
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case RogueStealth:
+            out << "Case Stealth";
+            if (PICK_POCKET > 0 && (pTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0 &&
+                !((Creature*)pTarget)->lootForPickPocketed && ai->CastSpell(PICK_POCKET, *pTarget))
+                out << " > Pick Pocket";
+            else if (PREMEDITATION > 0 && ai->CastSpell(PREMEDITATION, *pTarget))
+                out << " > Premeditation";
+            else if (AMBUSH > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                out << " > Ambush";
+            else if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                out << " > Cheap Shot";
+            else if (GARROTE > 0 && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                out << " > Garrote";
+            else
+                m_bot->RemoveAurasDueToSpell(SPELL_AURA_MOD_STEALTH);
+            break;
+        case RogueThreat:
+            out << "Case Threat";
+            if (GOUGE > 0 && ai->GetEnergyAmount() >= 45 && !pTarget->HasAura(GOUGE) && ai->CastSpell(GOUGE, *pTarget))
+                out << " > Gouge";
+            else if (EVASION > 0 && ai->GetHealthPercent() <= 35 && !m_bot->HasAura(EVASION) && ai->CastSpell(EVASION))
+                out << " > Evasion";
+            else if (BLIND > 0 && ai->GetHealthPercent() <= 30 && !pTarget->HasAura(BLIND) && ai->GetEnergyAmount() >= 30 && ai->CastSpell(BLIND, *pTarget))
+                out << " > Blind";
+            else if (FEINT > 0 && ai->GetHealthPercent() <= 25 && ai->GetEnergyAmount() >= 20 && ai->CastSpell(FEINT))
+                out << " > Feint";
+            else if (VANISH > 0 && ai->GetHealthPercent() <= 20 && !m_bot->HasAura(FEINT) && ai->CastSpell(VANISH))
+                out << " > Vanish";
+            else if (PREPARATION > 0 && ai->CastSpell(PREPARATION))
+                out << " > Preparation";
+            else if (m_bot->getRace() == RACE_NIGHTELF && ai->GetHealthPercent() <= 15 && !m_bot->HasAura(SHADOWMELD) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else
+                out << " NONE!";
+            break;
+        case RogueSpellPreventing:
+            out << "Case Prevent";
+            if (KIDNEY_SHOT > 0 && ai->GetEnergyAmount() >= 25 && m_bot->GetComboPoints() >= 2 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                out << " > Kidney Shot";
+            else if (KICK > 0 && ai->GetEnergyAmount() >= 25  && ai->CastSpell(KICK, *pTarget))
+                out << " > Kick";
+            else
+                out << " NONE!";
+            break;
+        case RogueCombat:
+        default:
+            out << "Case Combat";
+            if (m_bot->GetComboPoints() <= 4)
+            {
+                if (SHADOW_DANCE > 0 && !m_bot->HasAura(SHADOW_DANCE) && ai->CastSpell(SHADOW_DANCE, *m_bot))
+                    out << " > Shadow Dance";
+                else if (CHEAP_SHOT > 0 && m_bot->HasAura(SHADOW_DANCE) && !pTarget->HasAura(CHEAP_SHOT) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                    out << " > Cheap Shot";
+                else if (AMBUSH > 0 && m_bot->HasAura(SHADOW_DANCE) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                    out << " > Ambush";
+                else if (GARROTE > 0 && m_bot->HasAura(SHADOW_DANCE) && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                    out << " > Garrote";
+                else if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 1) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(BACKSTAB, *pTarget))
+                    out << " > Backstab";
+                else if (MUTILATE > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(MUTILATE, *pTarget))
+                    out << " > Mutilate";
+                else if (SINISTER_STRIKE > 0 && ai->GetEnergyAmount() >= 45 && ai->CastSpell(SINISTER_STRIKE, *pTarget))
+                    out << " > Sinister Strike";
+                else if (GHOSTLY_STRIKE > 0 && ai->GetEnergyAmount() >= 40 && ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
+                    out << " > Ghostly Strike";
+                else if (HEMORRHAGE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(HEMORRHAGE, *pTarget))
+                    out << " > Hemorrhage";
+                else if (DISMANTLE > 0 && !pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(DISMANTLE, *pTarget))
+                    out << " > Dismantle";
+                else if (SHADOWSTEP > 0 && ai->GetEnergyAmount() >= 10 && ai->CastSpell(SHADOWSTEP, *pTarget))
+                    out << " > Shadowstep";
+                else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+                    out << " > Arcane Torrent";
+                else if ((m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STAT_STUNNED)) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot)))
+                    out << " > Every Man for Himself";
+                else if ((m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR)) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot)))
+                    out << " > Will of the Forsaken";
+                else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                    out << " > Stoneform";
+                else if ((m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STAT_STUNNED)) || (m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot)))
+                    out << " > Escape Artist";
+                else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                    out << " > Blood Fury";
+                else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING) && ai->CastSpell(BERSERKING, *m_bot))
+                    out << " > Berserking";
+                else
+                    out << " NONE!";
+            }
+            else
+            {
+                if (EVISCERATE > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Rogue Eviscerate";
+                else if (EVISCERATE > 0 && pTarget->getClass() == CLASS_DRUID && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Druid Eviscerate";
+                else if (KIDNEY_SHOT > 0 && pTarget->getClass() == CLASS_SHAMAN && ai->GetEnergyAmount() >= 25 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                    out << " > Shaman Kidney";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_WARLOCK && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Warlock Slice & Dice";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_HUNTER && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Hunter Slice & Dice";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_WARRIOR && !pTarget->HasAura(EXPOSE_ARMOR) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Warrior Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_PALADIN && !pTarget->HasAura(EXPOSE_ARMOR) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Paladin Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_DEATH_KNIGHT && !pTarget->HasAura(EXPOSE_ARMOR) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > DK Expose Armor";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_MAGE && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Mage Rupture";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_PRIEST && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Priest Rupture";
+                else if (EVISCERATE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Eviscerate";
+                else
+                    out << " NONE!";
+            }
+            break;
+    }
+    if (ai->GetManager()->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+// end DoNextCombatManeuver
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // remove stealth
+    if (m_bot->HasAura(STEALTH))
+        m_bot->RemoveAurasDueToSpell(SPELL_AURA_MOD_STEALTH);
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // Search and apply poisons to weapons
+    // Mainhand ...
+    Item * poison, * weapon;
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_MAINHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+    //... and offhand
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_OFFHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..c4328b5
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
@@ -0,0 +1,102 @@
+
+#ifndef _PlayerbotRogueAI_H
+#define _PlayerbotRogueAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    RogueCombat,
+    RogueSpellPreventing,
+    RogueThreat,
+    RogueStealth
+};
+
+enum RoguePoisonDisplayId
+{
+    DEADLY_POISON_DISPLAYID  = 13707,
+    INSTANT_POISON_DISPLAYID = 13710,
+    WOUND_POISON_DISPLAYID   = 37278
+};
+
+enum RogueSpells
+{
+    ADRENALINE_RUSH_1               = 13750,
+    AMBUSH_1                        = 8676,
+    BACKSTAB_1                      = 53,
+    BLADE_FLURRY_1                  = 13877,
+    BLIND_1                         = 2094,
+    CHEAP_SHOT_1                    = 1833,
+    CLOAK_OF_SHADOWS_1              = 31224,
+    COLD_BLOOD_1                    = 14177,
+    DEADLY_THROW_1                  = 26679,
+    DISARM_TRAP_1                   = 1842,
+    DISMANTLE_1                     = 51722,
+    DISTRACT_1                      = 1725,
+    ENVENOM_1                       = 32645,
+    EVASION_1                       = 5277,
+    EVISCERATE_1                    = 2098,
+    EXPOSE_ARMOR_1                  = 8647,
+    FAN_OF_KNIVES_1                 = 51723,
+    FEINT_1                         = 1966,
+    GARROTE_1                       = 703,
+    GHOSTLY_STRIKE_1                = 14278,
+    GOUGE_1                         = 1776,
+    HEMORRHAGE_1                    = 16511,
+    HUNGER_FOR_BLOOD_1              = 51662,
+    KICK_1                          = 1766,
+    KIDNEY_SHOT_1                   = 408,
+    KILLING_SPREE_1                 = 51690,
+    MUTILATE_1                      = 1329,
+    PICK_LOCK_1                     = 1804,
+    PICK_POCKET_1                   = 921,
+    PREMEDITATION_1                 = 14183,
+    PREPARATION_1                   = 14185,
+    RIPOSTE_1                       = 14251,
+    RUPTURE_1                       = 1943,
+    SAP_1                           = 6770,
+    SHADOW_DANCE_1                  = 51713,
+    SHADOWSTEP_1                    = 36554,
+    SHIV_1                          = 5938,
+    SINISTER_STRIKE_1               = 1752,
+    SLICE_AND_DICE_1                = 5171,
+    SPRINT_1                        = 2983,
+    STEALTH_1                       = 1784,
+    TRICKS_OF_THE_TRADE_1           = 57934,
+    VANISH_1                        = 1856
+};
+//class Player;
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+public:
+    PlayerbotRogueAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotRogueAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // COMBAT
+    uint32 SINISTER_STRIKE, BACKSTAB, GOUGE, EVASION, SPRINT, KICK, FEINT, SHIV, FAN_OF_KNIVES;
+
+    // SUBTLETY
+    uint32 SHADOWSTEP, STEALTH, VANISH, HEMORRHAGE, BLIND, SHADOW_DANCE, PICK_POCKET, CLOAK_OF_SHADOWS, TRICK_TRADE, CRIPPLING_POISON, DEADLY_POISON, MIND_NUMBING_POISON, GHOSTLY_STRIKE, DISTRACT, PREPARATION, PREMEDITATION;
+
+    // ASSASSINATION
+    uint32 EVISCERATE, SLICE_DICE, GARROTE, EXPOSE_ARMOR, AMBUSH, RUPTURE, DISMANTLE, CHEAP_SHOT, KIDNEY_SHOT, MUTILATE, ENVENOM, DEADLY_THROW;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..39b1d7c
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
@@ -0,0 +1,527 @@
+
+#include "PlayerbotShamanAI.h"
+
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // restoration
+    CHAIN_HEAL               = ai->initSpell(CHAIN_HEAL_1);
+    HEALING_WAVE             = ai->initSpell(HEALING_WAVE_1);
+    LESSER_HEALING_WAVE      = ai->initSpell(LESSER_HEALING_WAVE_1);
+    RIPTIDE                  = ai->initSpell(RIPTIDE_1);
+    ANCESTRAL_SPIRIT         = ai->initSpell(ANCESTRAL_SPIRIT_1);
+    EARTH_SHIELD             = ai->initSpell(EARTH_SHIELD_1);
+    WATER_SHIELD             = ai->initSpell(WATER_SHIELD_1);
+    EARTHLIVING_WEAPON       = ai->initSpell(EARTHLIVING_WEAPON_1);
+    TREMOR_TOTEM             = ai->initSpell(TREMOR_TOTEM_1); // totems
+    HEALING_STREAM_TOTEM     = ai->initSpell(HEALING_STREAM_TOTEM_1);
+    MANA_SPRING_TOTEM        = ai->initSpell(MANA_SPRING_TOTEM_1);
+    MANA_TIDE_TOTEM          = ai->initSpell(MANA_TIDE_TOTEM_1);
+    // enhancement
+    FOCUSED                  = 0; // Focused what?
+    STORMSTRIKE              = ai->initSpell(STORMSTRIKE_1);
+    LAVA_LASH                = ai->initSpell(LAVA_LASH_1);
+    SHAMANISTIC_RAGE         = ai->initSpell(SHAMANISTIC_RAGE_1);
+    BLOODLUST                = ai->initSpell(BLOODLUST_1);
+    HEROISM                  = ai->initSpell(HEROISM_1);
+    FERAL_SPIRIT             = ai->initSpell(FERAL_SPIRIT_1);
+    LIGHTNING_SHIELD         = ai->initSpell(LIGHTNING_SHIELD_1);
+    ROCKBITER_WEAPON         = ai->initSpell(ROCKBITER_WEAPON_1);
+    FLAMETONGUE_WEAPON       = ai->initSpell(FLAMETONGUE_WEAPON_1);
+    FROSTBRAND_WEAPON        = ai->initSpell(FROSTBRAND_WEAPON_1);
+    WINDFURY_WEAPON          = ai->initSpell(WINDFURY_WEAPON_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1); // totems
+    STRENGTH_OF_EARTH_TOTEM  = ai->initSpell(STRENGTH_OF_EARTH_TOTEM_1);
+    FROST_RESISTANCE_TOTEM   = ai->initSpell(FROST_RESISTANCE_TOTEM_1);
+    FLAMETONGUE_TOTEM        = ai->initSpell(FLAMETONGUE_TOTEM_1);
+    FIRE_RESISTANCE_TOTEM    = ai->initSpell(FIRE_RESISTANCE_TOTEM_1);
+    GROUNDING_TOTEM          = ai->initSpell(GROUNDING_TOTEM_1);
+    NATURE_RESISTANCE_TOTEM  = ai->initSpell(NATURE_RESISTANCE_TOTEM_1);
+    WIND_FURY_TOTEM          = ai->initSpell(WINDFURY_TOTEM_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1);
+    WRATH_OF_AIR_TOTEM       = ai->initSpell(WRATH_OF_AIR_TOTEM_1);
+    EARTH_ELEMENTAL_TOTEM    = ai->initSpell(EARTH_ELEMENTAL_TOTEM_1);
+    // elemental
+    LIGHTNING_BOLT           = ai->initSpell(LIGHTNING_BOLT_1);
+    EARTH_SHOCK              = ai->initSpell(EARTH_SHOCK_1);
+    FLAME_SHOCK              = ai->initSpell(FLAME_SHOCK_1);
+    PURGE                    = ai->initSpell(PURGE_1);
+    WIND_SHOCK               = 0; //NPC spell
+    FROST_SHOCK              = ai->initSpell(FROST_SHOCK_1);
+    CHAIN_LIGHTNING          = ai->initSpell(CHAIN_LIGHTNING_1);
+    LAVA_BURST               = ai->initSpell(LAVA_BURST_1);
+    HEX                      = ai->initSpell(HEX_1);
+    STONECLAW_TOTEM          = ai->initSpell(STONECLAW_TOTEM_1); // totems
+    SEARING_TOTEM            = ai->initSpell(SEARING_TOTEM_1);
+    FIRE_NOVA_TOTEM          = 0; // NPC only spell, check FIRE_NOVA_1
+    MAGMA_TOTEM              = ai->initSpell(MAGMA_TOTEM_1);
+    EARTHBIND_TOTEM          = ai->initSpell(EARTHBIND_TOTEM_1);
+    TOTEM_OF_WRATH           = ai->initSpell(TOTEM_OF_WRATH_1);
+    FIRE_ELEMENTAL_TOTEM     = ai->initSpell(FIRE_ELEMENTAL_TOTEM_1);
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU        = ai->initSpell(GIFT_OF_THE_NAARU_SHAMAN); // draenei
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_SHAMAN); // orc
+    WAR_STOMP                = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+}
+
+PlayerbotShamanAI::~PlayerbotShamanAI() {}
+
+bool PlayerbotShamanAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotShamanAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && HEALING_WAVE > 0 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE, target);
+    else if (hp < 45 && LESSER_HEALING_WAVE > 0 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE, target);
+    else if (hp < 55 && RIPTIDE > 0 && !target.HasAura(RIPTIDE) && ai->GetManaPercent() >= 21)
+        ai->CastSpell(RIPTIDE, target);
+    else if (hp < 70 && CHAIN_HEAL > 0 && ai->GetManaPercent() >= 24)
+        ai->CastSpell(CHAIN_HEAL, target);
+    // end HealTarget
+}
+
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(LIGHTNING_BOLT);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 30 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 70)
+        HealTarget (*m_bot, ai->GetHealthPercent());
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 30 && ai->GetManaPercent() >= 32)
+            ai->CastSpell(HEALING_WAVE, *(GetMaster()));
+        else if (masterHP < 70)
+            HealTarget (*GetMaster(), masterHP);
+    }
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 30)
+                HealTarget(*m_groupMember, memberHP);
+        }
+    }
+
+    // Damage Spells
+
+    switch (SpellSequence)
+    {
+        case SPELL_ENHANCEMENT:
+            if (STRENGTH_OF_EARTH_TOTEM > 0 && LastSpellEnhancement == 1 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STRENGTH_OF_EARTH_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STONESKIN_TOTEM > 0 && LastSpellEnhancement == 5 && (!m_bot->HasAura(STONESKIN_TOTEM)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STONESKIN_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FOCUSED > 0 && LastSpellEnhancement == 2)
+            {
+                ai->CastSpell(FOCUSED, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FROST_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 10 && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM)) && (!m_bot->HasAura(TOTEM_OF_WRATH)) && (!m_bot->HasAura(FLAMETONGUE_TOTEM)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FLAMETONGUE_TOTEM > 0 && LastSpellEnhancement == 15 && (!m_bot->HasAura(FLAMETONGUE_TOTEM)) && (!m_bot->HasAura(TOTEM_OF_WRATH)) && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM)) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FLAMETONGUE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FIRE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 20 && (!m_bot->HasAura(FIRE_RESISTANCE_TOTEM)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM)) && (!m_bot->HasAura(MANA_SPRING_TOTEM)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FIRE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (GROUNDING_TOTEM > 0 && LastSpellEnhancement == 25 && (!m_bot->HasAura(GROUNDING_TOTEM)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM)) && (!m_bot->HasAura(WIND_FURY_TOTEM)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(GROUNDING_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (NATURE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 30 && (!m_bot->HasAura(NATURE_RESISTANCE_TOTEM)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM)) && (!m_bot->HasAura(GROUNDING_TOTEM)) && (!m_bot->HasAura(WIND_FURY_TOTEM)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(NATURE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WIND_FURY_TOTEM > 0 && LastSpellEnhancement == 35 && (!m_bot->HasAura(WIND_FURY_TOTEM)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM)) && (!m_bot->HasAura(GROUNDING_TOTEM)) && ai->GetManaPercent() >= 11)
+            {
+                ai->CastSpell(WIND_FURY_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STORMSTRIKE > 0 && LastSpellEnhancement == 4 && (!pTarget->HasAura(STORMSTRIKE)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STORMSTRIKE, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LAVA_LASH > 0 && LastSpellEnhancement == 6 && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(LAVA_LASH, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FERAL_SPIRIT > 0 && LastSpellEnhancement == 7 && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(FERAL_SPIRIT);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WRATH_OF_AIR_TOTEM > 0 && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM)) && (!m_bot->HasAura(GROUNDING_TOTEM)) && LastSpellEnhancement == 40)
+            {
+                ai->CastSpell(WRATH_OF_AIR_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (EARTH_ELEMENTAL_TOTEM > 0 && LastSpellEnhancement == 45 && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(EARTH_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (BLOODLUST > 0 && LastSpellEnhancement == 8 && (!GetMaster()->HasAura(BLOODLUST)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(BLOODLUST);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (HEROISM > 0 && LastSpellEnhancement == 10 && (!GetMaster()->HasAura(HEROISM)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(HEROISM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (SHAMANISTIC_RAGE > 0 && (!m_bot->HasAura(SHAMANISTIC_RAGE)) && LastSpellEnhancement == 11)
+            {
+                ai->CastSpell(SHAMANISTIC_RAGE, *m_bot);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LastSpellEnhancement > 50)
+            {
+                LastSpellEnhancement = 1;
+                SpellSequence = SPELL_RESTORATION;
+                break;
+            }
+            LastSpellEnhancement = LastSpellEnhancement + 1;
+        //SpellSequence = SPELL_RESTORATION;
+        //break;
+
+        case SPELL_RESTORATION:
+            if (HEALING_STREAM_TOTEM > 0 && LastSpellRestoration < 3 && ai->GetHealthPercent() < 50 && (!m_bot->HasAura(HEALING_STREAM_TOTEM)) && (!m_bot->HasAura(MANA_SPRING_TOTEM)) && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(HEALING_STREAM_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_SPRING_TOTEM > 0 && LastSpellRestoration < 4 && (!m_bot->HasAura(MANA_SPRING_TOTEM)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(MANA_SPRING_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_TIDE_TOTEM > 0 && LastSpellRestoration < 5 && ai->GetManaPercent() < 50 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(MANA_TIDE_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            /*else if (TREMOR_TOTEM > 0 && LastSpellRestoration < 6 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM)) && ai->GetManaPercent() >= 2)
+               {
+                ai->CastSpell(TREMOR_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+               }*/
+            else if (LastSpellRestoration > 6)
+            {
+                LastSpellRestoration = 0;
+                SpellSequence = SPELL_ELEMENTAL;
+                break;
+            }
+            LastSpellRestoration = LastSpellRestoration + 1;
+        //SpellSequence = SPELL_ELEMENTAL;
+        //break;
+
+        case SPELL_ELEMENTAL:
+            if (LIGHTNING_BOLT > 0 && LastSpellElemental == 1 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(LIGHTNING_BOLT, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (SEARING_TOTEM > 0 && LastSpellElemental == 2 && (!pTarget->HasAura(SEARING_TOTEM)) && (!m_bot->HasAura(TOTEM_OF_WRATH)) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(SEARING_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (STONECLAW_TOTEM > 0 && ai->GetHealthPercent() < 51 && LastSpellElemental == 3 && (!pTarget->HasAura(STONECLAW_TOTEM)) && (!pTarget->HasAura(EARTHBIND_TOTEM)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STONECLAW_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FLAME_SHOCK > 0 && LastSpellElemental == 4 && (!pTarget->HasAura(FLAME_SHOCK)) && ai->GetManaPercent() >= 22)
+            {
+                ai->CastSpell(FLAME_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (LAVA_BURST > 0 && LastSpellElemental == 5 && (pTarget->HasAura(FLAME_SHOCK)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(LAVA_BURST, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (MAGMA_TOTEM > 0 && LastSpellElemental == 6 && (!m_bot->HasAura(TOTEM_OF_WRATH)) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(MAGMA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTHBIND_TOTEM > 0 && LastSpellElemental == 7 && (!pTarget->HasAura(EARTHBIND_TOTEM)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(EARTHBIND_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTH_SHOCK > 0 && LastSpellElemental == 8 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(EARTH_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (PURGE > 0 && LastSpellElemental == 9 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(PURGE, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (WIND_SHOCK > 0 && LastSpellElemental == 10 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(WIND_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_NOVA_TOTEM > 0 && LastSpellElemental == 11 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(FIRE_NOVA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FROST_SHOCK > 0 && LastSpellElemental == 12 && (!pTarget->HasAura(FROST_SHOCK)) && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FROST_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (CHAIN_LIGHTNING > 0 && LastSpellElemental == 13 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(CHAIN_LIGHTNING, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (TOTEM_OF_WRATH > 0 && LastSpellElemental == 14 && (!m_bot->HasAura(TOTEM_OF_WRATH)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(TOTEM_OF_WRATH);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_ELEMENTAL_TOTEM > 0 && LastSpellElemental == 15 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIRE_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            /*else if (HEX > 0 && LastSpellElemental == 16 && (!pTarget->HasAura(HEX)) && ai->GetManaPercent() >= 3)
+               {
+                ai->CastSpell(HEX);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+               }*/
+            else if (LastSpellElemental > 16)
+            {
+                LastSpellElemental = 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+                break;
+            }
+            else
+            {
+                LastSpellElemental = LastSpellElemental + 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_ENHANCEMENT;
+
+    // buff master with EARTH_SHIELD
+    if (EARTH_SHIELD > 0)
+        (!GetMaster()->HasAura(EARTH_SHIELD) && ai->CastSpell(EARTH_SHIELD, *(GetMaster())));
+
+    // buff myself with WATER_SHIELD, LIGHTNING_SHIELD
+    if (WATER_SHIELD > 0)
+        (!m_bot->HasAura(WATER_SHIELD) && !m_bot->HasAura(LIGHTNING_SHIELD) && ai->CastSpell(WATER_SHIELD, *m_bot));
+    else if (LIGHTNING_SHIELD > 0)
+        (!m_bot->HasAura(LIGHTNING_SHIELD) && !m_bot->HasAura(WATER_SHIELD) && ai->CastSpell(LIGHTNING_SHIELD, *m_bot));
+/*
+       // buff myself weapon
+       if (ROCKBITER_WEAPON > 0)
+            (!m_bot->HasAura(ROCKBITER_WEAPON) && !m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(WINDFURY_WEAPON) && !m_bot->HasAura(FLAMETONGUE_WEAPON) && !m_bot->HasAura(FROSTBRAND_WEAPON) && ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
+       else if (EARTHLIVING_WEAPON > 0)
+            (!m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(FLAMETONGUE_WEAPON) && !m_bot->HasAura(FROSTBRAND_WEAPON) && !m_bot->HasAura(ROCKBITER_WEAPON) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (WINDFURY_WEAPON > 0)
+            (!m_bot->HasAura(WINDFURY_WEAPON) && !m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(FLAMETONGUE_WEAPON) && !m_bot->HasAura(FROSTBRAND_WEAPON) && !m_bot->HasAura(ROCKBITER_WEAPON) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (FLAMETONGUE_WEAPON > 0)
+            (!m_bot->HasAura(FLAMETONGUE_WEAPON) && !m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(WINDFURY_WEAPON) && !m_bot->HasAura(FROSTBRAND_WEAPON) && !m_bot->HasAura(ROCKBITER_WEAPON) && ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
+       else if (FROSTBRAND_WEAPON > 0)
+            (!m_bot->HasAura(FROSTBRAND_WEAPON) && !m_bot->HasAura(EARTHLIVING_WEAPON) && !m_bot->HasAura(WINDFURY_WEAPON) && !m_bot->HasAura(FLAMETONGUE_WEAPON) && !m_bot->HasAura(ROCKBITER_WEAPON) && ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
+ */
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->isAlive())
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster() && tPlayer->duel->startTime != 0)
+                continue;
+
+            // heal
+            (HealTarget(*tPlayer, tPlayer->GetHealth() * 100 / tPlayer->GetMaxHealth()));
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..8155293
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
@@ -0,0 +1,119 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_ENHANCEMENT,
+    SPELL_RESTORATION,
+    SPELL_ELEMENTAL
+};
+
+enum
+{
+    ANCESTRAL_SPIRIT_1              = 2008,
+    ASTRAL_RECALL_1                 = 556,
+    BLOODLUST_1                     = 2825,
+    CALL_OF_THE_ANCESTORS_1         = 66843,
+    CALL_OF_THE_ELEMENTS_1          = 66842,
+    CALL_OF_THE_SPIRITS_1           = 66844,
+    CHAIN_HEAL_1                    = 1064,
+    CHAIN_LIGHTNING_1               = 421,
+    CHAINED_HEAL_1                  = 70809,
+    CLEANSE_SPIRIT_1                = 51886,
+    CLEANSING_TOTEM_1               = 8170,
+    CURE_TOXINS_1                   = 526,
+    EARTH_ELEMENTAL_TOTEM_1         = 2062,
+    EARTH_SHIELD_1                  = 974,
+    EARTH_SHOCK_1                   = 8042,
+    EARTHBIND_TOTEM_1               = 2484,
+    EARTHLIVING_WEAPON_1            = 51730,
+    ELEMENTAL_MASTERY_1             = 16166,
+    FERAL_SPIRIT_1                  = 51533,
+    FIRE_ELEMENTAL_TOTEM_1          = 2894,
+    FIRE_NOVA_1                     = 1535,
+    FIRE_RESISTANCE_TOTEM_1         = 8184,
+    FLAME_SHOCK_1                   = 8050,
+    FLAMETONGUE_TOTEM_1             = 8227,
+    FLAMETONGUE_WEAPON_1            = 8024,
+    FROST_RESISTANCE_TOTEM_1        = 8181,
+    FROST_SHOCK_1                   = 8056,
+    FROSTBRAND_WEAPON_1             = 8033,
+    GHOST_WOLF_1                    = 2645,
+    GROUNDING_TOTEM_1               = 8177,
+    HEALING_STREAM_TOTEM_1          = 5394,
+    HEALING_WAVE_1                  = 331,
+    HEROISM_1                       = 32182,
+    HEX_1                           = 51514,
+    LAVA_BURST_1                    = 51505,
+    LAVA_LASH_1                     = 60103,
+    LESSER_HEALING_WAVE_1           = 8004,
+    LIGHTNING_BOLT_1                = 403,
+    LIGHTNING_SHIELD_1              = 324,
+    MAGMA_TOTEM_1                   = 8190,
+    MANA_SPRING_TOTEM_1             = 5675,
+    MANA_TIDE_TOTEM_1               = 16190,
+    NATURE_RESISTANCE_TOTEM_1       = 10595,
+    NATURES_SWIFTNESS_SHAMAN_1      = 16188,
+    PURGE_1                         = 370,
+    RIPTIDE_1                       = 61295,
+    ROCKBITER_WEAPON_1              = 8017,
+    SEARING_TOTEM_1                 = 3599,
+    SENTRY_TOTEM_1                  = 6495,
+    SHAMANISTIC_RAGE_1              = 30823,
+    STONECLAW_TOTEM_1               = 5730,
+    STONESKIN_TOTEM_1               = 8071,
+    STORMSTRIKE_1                   = 17364,
+    STRENGTH_OF_EARTH_TOTEM_1       = 8075,
+    THUNDERSTORM_1                  = 51490,
+    TIDAL_FORCE_1                   = 55198,
+    TOTEM_OF_WRATH_1                = 30706,
+    TOTEMIC_RECALL_1                = 36936,
+    TREMOR_TOTEM_1                  = 8143,
+    WATER_BREATHING_1               = 131,
+    WATER_SHIELD_1                  = 52127,
+    WATER_WALKING_1                 = 546,
+    WIND_SHEAR_1                    = 57994,
+    WINDFURY_TOTEM_1                = 8512,
+    WINDFURY_WEAPON_1               = 8232,
+    WRATH_OF_AIR_TOTEM_1            = 3738
+};
+//class Player;
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+public:
+    PlayerbotShamanAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotShamanAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // Heals the target based off its hps
+    void HealTarget (Unit& target, uint8 hp);
+
+    // ENHANCEMENT
+    uint32 ROCKBITER_WEAPON, STONESKIN_TOTEM, LIGHTNING_SHIELD, FLAMETONGUE_WEAPON, STRENGTH_OF_EARTH_TOTEM, FOCUSED, FROSTBRAND_WEAPON, FROST_RESISTANCE_TOTEM, FLAMETONGUE_TOTEM, FIRE_RESISTANCE_TOTEM, WINDFURY_WEAPON, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM, WIND_FURY_TOTEM, STORMSTRIKE, LAVA_LASH, SHAMANISTIC_RAGE, WRATH_OF_AIR_TOTEM, EARTH_ELEMENTAL_TOTEM, BLOODLUST, HEROISM, FERAL_SPIRIT;
+
+    // RESTORATION
+    uint32 HEALING_WAVE, LESSER_HEALING_WAVE, ANCESTRAL_SPIRIT, TREMOR_TOTEM, HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, CHAIN_HEAL, MANA_TIDE_TOTEM, EARTH_SHIELD, WATER_SHIELD, EARTHLIVING_WEAPON, RIPTIDE;
+
+    // ELEMENTAL
+    uint32 LIGHTNING_BOLT, EARTH_SHOCK, STONECLAW_TOTEM, FLAME_SHOCK, SEARING_TOTEM, PURGE, FIRE_NOVA_TOTEM, WIND_SHOCK, FROST_SHOCK, MAGMA_TOTEM, CHAIN_LIGHTNING, TOTEM_OF_WRATH, FIRE_ELEMENTAL_TOTEM, LAVA_BURST, EARTHBIND_TOTEM, HEX;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..c449ca3
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,570 @@
+
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // DESTRUCTION
+    SHADOW_BOLT           = ai->initSpell(SHADOW_BOLT_1);
+    IMMOLATE              = ai->initSpell(IMMOLATE_1);
+    INCINERATE            = ai->initSpell(INCINERATE_1);
+    SEARING_PAIN          = ai->initSpell(SEARING_PAIN_1);
+    CONFLAGRATE           = ai->initSpell(CONFLAGRATE_1);
+    SHADOWFURY            = ai->initSpell(SHADOWFURY_1);
+    CHAOS_BOLT            = ai->initSpell(CHAOS_BOLT_1);
+    SHADOWFLAME           = ai->initSpell(SHADOWFLAME_1);
+    HELLFIRE              = ai->initSpell(HELLFIRE_1);
+    RAIN_OF_FIRE          = ai->initSpell(RAIN_OF_FIRE_1);
+    SOUL_FIRE             = ai->initSpell(SOUL_FIRE_1); // soul shard spells
+    SHADOWBURN            = ai->initSpell(SHADOWBURN_1);
+    // CURSE
+    CURSE_OF_WEAKNESS     = ai->initSpell(CURSE_OF_WEAKNESS_1);
+    CURSE_OF_THE_ELEMENTS = ai->initSpell(CURSE_OF_THE_ELEMENTS_1);
+    CURSE_OF_AGONY        = ai->initSpell(CURSE_OF_AGONY_1);
+    CURSE_OF_EXHAUSTION   = ai->initSpell(CURSE_OF_EXHAUSTION_1);
+    CURSE_OF_TONGUES      = ai->initSpell(CURSE_OF_TONGUES_1);
+    CURSE_OF_DOOM         = ai->initSpell(CURSE_OF_DOOM_1);
+    // AFFLICTION
+    CORRUPTION            = ai->initSpell(CORRUPTION_1);
+    DRAIN_SOUL            = ai->initSpell(DRAIN_SOUL_1);
+    DRAIN_LIFE            = ai->initSpell(DRAIN_LIFE_1);
+    DRAIN_MANA            = ai->initSpell(DRAIN_MANA_1);
+    LIFE_TAP              = ai->initSpell(LIFE_TAP_1);
+    UNSTABLE_AFFLICTION   = ai->initSpell(UNSTABLE_AFFLICTION_1);
+    HAUNT                 = ai->initSpell(HAUNT_1);
+    SEED_OF_CORRUPTION    = ai->initSpell(SEED_OF_CORRUPTION_1);
+    DARK_PACT             = ai->initSpell(DARK_PACT_1);
+    HOWL_OF_TERROR        = ai->initSpell(HOWL_OF_TERROR_1);
+    FEAR                  = ai->initSpell(FEAR_1);
+    // DEMONOLOGY
+    DEMON_SKIN            = ai->initSpell(DEMON_SKIN_1);
+    DEMON_ARMOR           = ai->initSpell(DEMON_ARMOR_1);
+    DEMONIC_EMPOWERMENT   = ai->initSpell(DEMONIC_EMPOWERMENT_1);
+    FEL_ARMOR             = ai->initSpell(FEL_ARMOR_1);
+    SHADOW_WARD           = ai->initSpell(SHADOW_WARD_1);
+    SOULSHATTER           = ai->initSpell(SOULSHATTER_1);
+    SOUL_LINK             = ai->initSpell(SOUL_LINK_1);
+    SOUL_LINK_AURA        = 25228; // dummy aura applied, after spell SOUL_LINK
+    HEALTH_FUNNEL         = ai->initSpell(HEALTH_FUNNEL_1);
+    DETECT_INVISIBILITY   = ai->initSpell(DETECT_INVISIBILITY_1);
+    CREATE_FIRESTONE      = ai->initSpell(CREATE_FIRESTONE_1);
+    CREATE_HEALTHSTONE    = ai->initSpell(CREATE_HEALTHSTONE_1);
+    CREATE_SOULSTONE      = ai->initSpell(CREATE_SOULSTONE_1);
+    // demon summon
+    SUMMON_IMP            = ai->initSpell(SUMMON_IMP_1);
+    SUMMON_VOIDWALKER     = ai->initSpell(SUMMON_VOIDWALKER_1);
+    SUMMON_SUCCUBUS       = ai->initSpell(SUMMON_SUCCUBUS_1);
+    SUMMON_FELHUNTER      = ai->initSpell(SUMMON_FELHUNTER_1);
+    SUMMON_FELGUARD       = ai->initSpell(SUMMON_FELGUARD_1);
+    // demon skills should be initialized on demons
+    BLOOD_PACT            = 0; // imp skill
+    CONSUME_SHADOWS       = 0; // voidwalker skill
+    FEL_INTELLIGENCE      = 0; // felhunter skill
+
+    RECENTLY_BANDAGED     = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT        = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    ESCAPE_ARTIST         = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY            = ai->initSpell(BLOOD_FURY_WARLOCK); // orc
+    WILL_OF_THE_FORSAKEN  = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+
+    m_lastDemon = 0;
+    m_demonOfChoice = DEMON_IMP;
+    m_isTempImp = false;
+}
+
+PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
+
+bool PlayerbotWarlockAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SHADOW_BOLT > 0)
+                ai->CastSpell(SHADOW_BOLT);
+            return;
+        }
+        default:
+            break;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+
+    // Empower demon
+    if (pet && DEMONIC_EMPOWERMENT && !m_bot->HasSpellCooldown(DEMONIC_EMPOWERMENT))
+        ai->CastSpell(DEMONIC_EMPOWERMENT);
+
+    // Use voidwalker sacrifice on low health if possible
+    if (ai->GetHealthPercent() < 50)
+        if (pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE))
+            ai->CastPetSpell(SACRIFICE);
+
+    // Use healthstone
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (healthStone)
+            ai->UseItem(healthStone);
+    }
+
+    // Damage Spells
+    switch (SpellSequence)
+    {
+        case SPELL_CURSES:
+            if (CURSE_OF_AGONY && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(SHADOWFLAME) && LastSpellCurse < 1)
+            {
+                ai->CastSpell(CURSE_OF_AGONY, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_THE_ELEMENTS && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && LastSpellCurse < 2)
+            {
+                ai->CastSpell(CURSE_OF_THE_ELEMENTS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_WEAKNESS && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 3)
+            {
+                ai->CastSpell(CURSE_OF_WEAKNESS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_TONGUES && !pTarget->HasAura(CURSE_OF_TONGUES) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 4)
+            {
+                ai->CastSpell(CURSE_OF_TONGUES, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            LastSpellCurse = 0;
+        //SpellSequence = SPELL_AFFLICTION;
+        //break;
+
+        case SPELL_AFFLICTION:
+            if (LIFE_TAP && LastSpellAffliction < 1 && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+            {
+                ai->CastSpell(LIFE_TAP, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (CORRUPTION && !pTarget->HasAura(CORRUPTION) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 2)
+            {
+                ai->CastSpell(CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_SOUL && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.40 && !pTarget->HasAura(DRAIN_SOUL) && LastSpellAffliction < 3)
+            {
+                ai->CastSpell(DRAIN_SOUL, *pTarget);
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_LIFE && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(SEED_OF_CORRUPTION) && !pTarget->HasAura(DRAIN_LIFE) && !pTarget->HasAura(DRAIN_MANA) && ai->GetHealthPercent() <= 70)
+            {
+                ai->CastSpell(DRAIN_LIFE, *pTarget);
+                //ai->SetIgnoreUpdateTime(5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (UNSTABLE_AFFLICTION && LastSpellAffliction < 5 && !pTarget->HasAura(UNSTABLE_AFFLICTION) && !pTarget->HasAura(SHADOWFLAME))
+            {
+                ai->CastSpell(UNSTABLE_AFFLICTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HAUNT && LastSpellAffliction < 6 && !pTarget->HasAura(HAUNT))
+            {
+                ai->CastSpell(HAUNT, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (SEED_OF_CORRUPTION && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 7)
+            {
+                ai->CastSpell(SEED_OF_CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HOWL_OF_TERROR && !pTarget->HasAura(HOWL_OF_TERROR) && ai->GetAttackerCount() > 3 && LastSpellAffliction < 8)
+            {
+                ai->CastSpell(HOWL_OF_TERROR, *pTarget);
+                ai->TellMaster("casting howl of terror!");
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (FEAR && !pTarget->HasAura(FEAR) && pVictim == m_bot && ai->GetAttackerCount() >= 2 && LastSpellAffliction < 9)
+            {
+                ai->CastSpell(FEAR, *pTarget);
+                //ai->TellMaster("casting fear!");
+                //ai->SetIgnoreUpdateTime(1.5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if ((pet)
+                     && (DARK_PACT > 0 && ai->GetManaPercent() <= 50 && LastSpellAffliction < 10 && pet->GetPower(POWER_MANA) > 0))
+            {
+                ai->CastSpell(DARK_PACT, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            LastSpellAffliction = 0;
+        //SpellSequence = SPELL_DESTRUCTION;
+        //break;
+
+        case SPELL_DESTRUCTION:
+            if (SHADOWFURY && LastSpellDestruction < 1 && !pTarget->HasAura(SHADOWFURY))
+            {
+                ai->CastSpell(SHADOWFURY, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOW_BOLT && LastSpellDestruction < 2)
+            {
+                ai->CastSpell(SHADOW_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (RAIN_OF_FIRE && LastSpellDestruction < 3 && ai->GetAttackerCount() >= 3)
+            {
+                ai->CastSpell(RAIN_OF_FIRE, *pTarget);
+                //ai->TellMaster("casting rain of fire!");
+                //ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWFLAME && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 4)
+            {
+                ai->CastSpell(SHADOWFLAME, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (IMMOLATE && !pTarget->HasAura(IMMOLATE) && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 5)
+            {
+                ai->CastSpell(IMMOLATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CONFLAGRATE && LastSpellDestruction < 6)
+            {
+                ai->CastSpell(CONFLAGRATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (INCINERATE && LastSpellDestruction < 7)
+            {
+                ai->CastSpell(INCINERATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SEARING_PAIN && LastSpellDestruction < 8)
+            {
+                ai->CastSpell(SEARING_PAIN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SOUL_FIRE && LastSpellDestruction < 9)
+            {
+                ai->CastSpell(SOUL_FIRE, *pTarget);
+                //ai->SetIgnoreUpdateTime(6);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CHAOS_BOLT && LastSpellDestruction < 10)
+            {
+                ai->CastSpell(CHAOS_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWBURN && LastSpellDestruction < 11 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && !pTarget->HasAura(SHADOWBURN))
+            {
+                ai->CastSpell(SHADOWBURN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (HELLFIRE && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE) && ai->GetAttackerCount() >= 5 && ai->GetHealthPercent() >= 50)
+            {
+                ai->CastSpell(HELLFIRE);
+                ai->TellMaster("casting hellfire!");
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else
+            {
+                LastSpellDestruction = 0;
+                SpellSequence = SPELL_CURSES;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    SpellSequence = SPELL_CURSES;
+
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!ai || !m_bot)
+        return;
+
+    Pet *pet = m_bot->GetPet();
+
+    // Initialize pet spells
+    if (pet && pet->GetEntry() != m_lastDemon)
+    {
+        switch (pet->GetEntry())
+        {
+            case DEMON_IMP:
+            {
+                BLOOD_PACT       = ai->initPetSpell(BLOOD_PACT_ICON);
+                FIREBOLT         = ai->initPetSpell(FIREBOLT_ICON);
+                FIRE_SHIELD      = ai->initPetSpell(FIRE_SHIELD_ICON);
+                break;
+            }
+            case DEMON_VOIDWALKER:
+            {
+                CONSUME_SHADOWS  = ai->initPetSpell(CONSUME_SHADOWS_ICON);
+                SACRIFICE        = ai->initPetSpell(SACRIFICE_ICON);
+                SUFFERING        = ai->initPetSpell(SUFFERING_ICON);
+                TORMENT          = ai->initPetSpell(TORMENT_ICON);
+                break;
+            }
+            case DEMON_SUCCUBUS:
+            {
+                LASH_OF_PAIN     = ai->initPetSpell(LASH_OF_PAIN_ICON);
+                SEDUCTION        = ai->initPetSpell(SEDUCTION_ICON);
+                SOOTHING_KISS    = ai->initPetSpell(SOOTHING_KISS_ICON);
+                break;
+            }
+            case DEMON_FELHUNTER:
+            {
+                DEVOUR_MAGIC     = ai->initPetSpell(DEVOUR_MAGIC_ICON);
+                FEL_INTELLIGENCE = ai->initPetSpell(FEL_INTELLIGENCE_ICON);
+                SHADOW_BITE      = ai->initPetSpell(SHADOW_BITE_ICON);
+                SPELL_LOCK       = ai->initPetSpell(SPELL_LOCK_ICON);
+                break;
+            }
+            case DEMON_FELGUARD:
+            {
+                ANGUISH          = ai->initPetSpell(ANGUISH_ICON);
+                CLEAVE           = ai->initPetSpell(CLEAVE_ICON);
+                INTERCEPT        = ai->initPetSpell(INTERCEPT_ICON);
+                break;
+            }
+        }
+
+        m_lastDemon = pet->GetEntry();
+
+        if (!m_isTempImp)
+            m_demonOfChoice = pet->GetEntry();
+    }
+
+    // Destroy extra soul shards
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, NULL);
+    uint8 freeSpace = ai->GetFreeBagSpace();
+    if (shardCount > MAX_SHARD_COUNT || (freeSpace == 0 && shardCount > 1))
+        m_bot->DestroyItemCount(SOUL_SHARD, shardCount > MAX_SHARD_COUNT ? shardCount - MAX_SHARD_COUNT : 1, true, false);
+
+    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR
+    if (FEL_ARMOR)
+    {
+        if (ai->SelfBuff(FEL_ARMOR))
+            return;
+    }
+    else if (DEMON_ARMOR)
+    {
+        if (ai->SelfBuff(DEMON_ARMOR))
+            return;
+    }
+    else if (DEMON_SKIN)
+        if (ai->SelfBuff(DEMON_SKIN))
+            return;
+
+    // healthstone creation
+    if (CREATE_HEALTHSTONE && shardCount > 0)
+    {
+        Item* const healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (!healthStone && ai->CastSpell(CREATE_HEALTHSTONE))
+            return;
+    }
+
+    // soulstone creation and use
+    if (CREATE_SOULSTONE)
+    {
+        Item* soulStone = ai->FindConsumable(SOULSTONE_DISPLAYID);
+        if (!soulStone)
+        {
+            if (shardCount > 0 && !m_bot->HasSpellCooldown(CREATE_SOULSTONE) && ai->CastSpell(CREATE_SOULSTONE))
+                return;
+        }
+        else
+        {
+            uint32 soulStoneSpell = soulStone->GetTemplate()->Spells[0].SpellId;
+            Player * master = GetMaster();
+            if (!master->HasAura(soulStoneSpell) && !m_bot->HasSpellCooldown(soulStoneSpell))
+            {
+                ai->UseItem(soulStone, master);
+                return;
+            }
+        }
+    }
+
+    // firestone creation and use
+    Item* const weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        Item* const stone = ai->FindConsumable(FIRESTONE_DISPLAYID);
+        if (!stone)
+        {
+            if (CREATE_FIRESTONE && shardCount > 0 && ai->CastSpell(CREATE_FIRESTONE))
+                return;
+        }
+        else
+        {
+            ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
+            return;
+        }
+    }
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    // mana check
+    if (pet && DARK_PACT && pet->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() <= 50)
+        if (ai->CastSpell(DARK_PACT, *m_bot))
+            return;
+
+    if (LIFE_TAP && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+        if (ai->CastSpell(LIFE_TAP, *m_bot))
+            return;
+
+    if (ai->GetManaPercent() < 25)
+    {
+        Item* pItem = ai->FindDrink();
+        if (pItem)
+        {
+            ai->TellMaster("I could use a drink.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    // hp check
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* pItem = ai->FindFood();
+        if (pItem)
+        {
+            ai->TellMaster("I could use some food.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    if (ai->GetHealthPercent() < 50 && !m_bot->HasAura(RECENTLY_BANDAGED))
+    {
+        Item* fItem = ai->FindBandage();
+        if (fItem)
+        {
+            ai->TellMaster("I could use first aid.");
+            ai->UseItem(fItem);
+            return;
+        }
+    }
+
+    //Heal Voidwalker
+    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && CONSUME_SHADOWS && pet->GetHealthPercent() < 75 && !pet->HasAura(CONSUME_SHADOWS))
+        ai->CastPetSpell(CONSUME_SHADOWS);
+
+    // Summon demon
+    if (!pet || m_isTempImp)
+    {
+        uint32 summonSpellId;
+        if (m_demonOfChoice != DEMON_IMP && shardCount > 0)
+        {
+            switch (m_demonOfChoice)
+            {
+                case DEMON_VOIDWALKER:
+                    summonSpellId = SUMMON_VOIDWALKER;
+                    break;
+                case DEMON_FELGUARD:
+                    summonSpellId = SUMMON_FELGUARD;
+                    break;
+                case DEMON_FELHUNTER:
+                    summonSpellId = SUMMON_FELHUNTER;
+                    break;
+                case DEMON_SUCCUBUS:
+                    summonSpellId = SUMMON_SUCCUBUS;
+                    break;
+                default:
+                    summonSpellId = 0;
+            }
+            if (ai->CastSpell(summonSpellId))
+            {
+                ai->TellMaster("Summoning favorite demon...");
+                m_isTempImp = false;
+                return;
+            }
+        }
+        else if (!pet && SUMMON_IMP && ai->CastSpell(SUMMON_IMP))
+        {
+            if (m_demonOfChoice != DEMON_IMP)
+                m_isTempImp = true;
+
+            ai->TellMaster("Summoning Imp...");
+            return;
+        }
+    }
+
+    // Soul link demon
+    if (pet && SOUL_LINK && !m_bot->HasAura(SOUL_LINK_AURA) && ai->CastSpell(SOUL_LINK, *m_bot))
+        return;
+
+    // Check demon buffs
+    if (pet && pet->GetEntry() == DEMON_IMP && BLOOD_PACT && !m_bot->HasAura(BLOOD_PACT) && ai->CastPetSpell(BLOOD_PACT))
+        return;
+
+    if (pet && pet->GetEntry() == DEMON_FELHUNTER && FEL_INTELLIGENCE && !m_bot->HasAura(FEL_INTELLIGENCE) && ai->CastPetSpell(FEL_INTELLIGENCE))
+        return;
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..98dbc55
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
@@ -0,0 +1,250 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+#define SOUL_SHARD 6265
+#define MAX_SHARD_COUNT 4 // Maximum soul shard count bot should keep
+
+enum
+{
+    SPELL_CURSES,
+    SPELL_AFFLICTION,
+    SPELL_DESTRUCTION,
+    SPELL_DEMONOLOGY
+};
+
+enum StoneDisplayId
+{
+    FIRESTONE_DISPLAYID   = 7409,
+    SPELLSTONE_DISPLAYID  = 13291,
+    SOULSTONE_DISPLAYID   = 6009,
+    HEALTHSTONE_DISPLAYID = 8026
+};
+
+enum DemonEntry
+{
+    DEMON_IMP        = 416,
+    DEMON_VOIDWALKER = 1860,
+    DEMON_SUCCUBUS   = 1863,
+    DEMON_FELHUNTER  = 417,
+    DEMON_FELGUARD   = 17252
+};
+
+enum DemonSpellIconIds
+{
+    // Imp
+    BLOOD_PACT_ICON       = 541,
+    FIREBOLT_ICON         = 18,
+    FIRE_SHIELD_ICON      = 16,
+    // Felguard
+    ANGUISH_ICON          = 173,
+    CLEAVE_ICON           = 277,
+    INTERCEPT_ICON        = 516,
+    // Felhunter
+    DEVOUR_MAGIC_ICON     = 47,
+    FEL_INTELLIGENCE_ICON = 1940,
+    SHADOW_BITE_ICON      = 2027,
+    SPELL_LOCK_ICON       = 77,
+    // Succubus
+    LASH_OF_PAIN_ICON     = 596,
+    SEDUCTION_ICON        = 48,
+    SOOTHING_KISS_ICON    = 694,
+    // Voidwalker
+    CONSUME_SHADOWS_ICON  = 207,
+    SACRIFICE_ICON        = 693,
+    SUFFERING_ICON        = 9,
+    TORMENT_ICON          = 173
+};
+
+enum WarlockSpells
+{
+    BANISH_1                        = 710,
+    CHALLENGING_HOWL_1              = 59671,
+    CHAOS_BOLT_1                    = 50796,
+    CONFLAGRATE_1                   = 17962,
+    CORRUPTION_1                    = 172,
+    CREATE_FIRESTONE_1              = 6366,
+    CREATE_HEALTHSTONE_1            = 6201,
+    CREATE_SOULSTONE_1              = 693,
+    CREATE_SPELLSTONE_1             = 2362,
+    CURSE_OF_AGONY_1                = 980,
+    CURSE_OF_DOOM_1                 = 603,
+    CURSE_OF_EXHAUSTION_1           = 18223,
+    CURSE_OF_THE_ELEMENTS_1         = 1490,
+    CURSE_OF_TONGUES_1              = 1714,
+    CURSE_OF_WEAKNESS_1             = 702,
+    DARK_PACT_1                     = 18220,
+    DEATH_COIL_WARLOCK_1            = 6789,
+    DEMON_ARMOR_1                   = 706,
+    DEMON_CHARGE_1                  = 54785,
+    DEMON_SKIN_1                    = 687,
+    DEMONIC_CIRCLE_SUMMON_1         = 48018,
+    DEMONIC_CIRCLE_TELEPORT_1       = 48020,
+    DEMONIC_EMPOWERMENT_1           = 47193,
+    DEMONIC_IMMOLATE_1              = 75445,
+    DETECT_INVISIBILITY_1           = 132,
+    DRAIN_LIFE_1                    = 689,
+    DRAIN_MANA_1                    = 5138,
+    DRAIN_SOUL_1                    = 1120,
+    ENSLAVE_DEMON_1                 = 1098,
+    EYE_OF_KILROGG_1                = 126,
+    FEAR_1                          = 5782,
+    FEL_ARMOR_1                     = 28176,
+    FEL_DOMINATION_1                = 18708,
+    HAUNT_1                         = 48181,
+    HEALTH_FUNNEL_1                 = 755,
+    HELLFIRE_1                      = 1949,
+    HOWL_OF_TERROR_1                = 5484,
+    IMMOLATE_1                      = 348,
+    IMMOLATION_AURA_1               = 50589,
+    INCINERATE_1                    = 29722,
+    INFERNO_1                       = 1122,
+    LIFE_TAP_1                      = 1454,
+    METAMORPHOSIS_1                 = 59672,
+    RAIN_OF_FIRE_1                  = 5740,
+    RITUAL_OF_DOOM_1                = 18540,
+    RITUAL_OF_SOULS_1               = 29893,
+    RITUAL_OF_SUMMONING_1           = 698,
+    SEARING_PAIN_1                  = 5676,
+    SEED_OF_CORRUPTION_1            = 27243,
+    SENSE_DEMONS_1                  = 5500,
+    SHADOW_BOLT_1                   = 686,
+    SHADOW_CLEAVE_1                 = 50581,
+    SHADOW_WARD_1                   = 6229,
+    SHADOWBURN_1                    = 17877,
+    SHADOWFLAME_1                   = 47897,
+    SHADOWFURY_1                    = 30283,
+    SOUL_FIRE_1                     = 6353,
+    SOUL_LINK_1                     = 19028,
+    SOULSHATTER_1                   = 29858,
+    SUMMON_FELGUARD_1               = 30146,
+    SUMMON_FELHUNTER_1              = 691,
+    SUMMON_IMP_1                    = 688,
+    SUMMON_SUCCUBUS_1               = 712,
+    SUMMON_VOIDWALKER_1             = 697,
+    UNENDING_BREATH_1               = 5697,
+    UNSTABLE_AFFLICTION_1           = 30108
+};
+
+//class Player;
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarlockAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarlockAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // CURSES
+    uint32 CURSE_OF_WEAKNESS,
+           CURSE_OF_AGONY,
+           CURSE_OF_EXHAUSTION,
+           CURSE_OF_TONGUES,
+           CURSE_OF_THE_ELEMENTS,
+           CURSE_OF_DOOM;
+
+    // AFFLICTION
+    uint32 CORRUPTION,
+           DRAIN_SOUL,
+           DRAIN_LIFE,
+           DRAIN_MANA,
+           LIFE_TAP,
+           UNSTABLE_AFFLICTION,
+           HAUNT,
+           SEED_OF_CORRUPTION,
+           DARK_PACT,
+           HOWL_OF_TERROR,
+           FEAR;
+
+    // DESTRUCTION
+    uint32 SHADOW_BOLT,
+           IMMOLATE,
+           INCINERATE,
+           SEARING_PAIN,
+           CONFLAGRATE,
+           SOUL_FIRE,
+           SHADOWFURY,
+           CHAOS_BOLT,
+           SHADOWFLAME,
+           HELLFIRE,
+           RAIN_OF_FIRE,
+           SHADOWBURN;
+
+    // DEMONOLOGY
+    uint32 DEMON_SKIN,
+           DEMON_ARMOR,
+           DEMONIC_EMPOWERMENT,
+           SHADOW_WARD,
+           FEL_ARMOR,
+           SOULSHATTER,
+           SOUL_LINK,
+           SOUL_LINK_AURA,
+           HEALTH_FUNNEL,
+           DETECT_INVISIBILITY,
+           CREATE_FIRESTONE,
+           CREATE_SOULSTONE,
+           CREATE_HEALTHSTONE;
+
+    // DEMON SUMMON
+    uint32 SUMMON_IMP,
+           SUMMON_VOIDWALKER,
+           SUMMON_SUCCUBUS,
+           SUMMON_FELHUNTER,
+           SUMMON_FELGUARD;
+
+    // DEMON SKILLS
+    uint32 BLOOD_PACT,
+           FIREBOLT,
+           FIRE_SHIELD,
+           ANGUISH,
+           CLEAVE,
+           INTERCEPT,
+           DEVOUR_MAGIC,
+           FEL_INTELLIGENCE,
+           SHADOW_BITE,
+           SPELL_LOCK,
+           LASH_OF_PAIN,
+           SEDUCTION,
+           SOOTHING_KISS,
+           CONSUME_SHADOWS,
+           SACRIFICE,
+           SUFFERING,
+           TORMENT;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellCurse,
+           LastSpellAffliction,
+           LastSpellDestruction;
+
+    uint32 m_lastDemon;      // Last demon entry used for spell initialization
+    uint32 m_demonOfChoice;  // Preferred demon entry
+    bool m_isTempImp;        // True if imp summoned temporarily until soul shard acquired for demon of choice.
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..da3f026
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,351 @@
+/*
+   Name    : PlayerbotWarriorAI.cpp
+   Complete: maybe around 37%
+   Author  : Natsukawa
+   Version : 0.39
+ */
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    BATTLE_STANCE           = ai->initSpell(BATTLE_STANCE_1); //ARMS
+    CHARGE                  = ai->initSpell(CHARGE_1); //ARMS
+    OVERPOWER               = ai->initSpell(OVERPOWER_1); // ARMS
+    HEROIC_STRIKE           = ai->initSpell(HEROIC_STRIKE_1); //ARMS
+    REND                    = ai->initSpell(REND_1); //ARMS
+    THUNDER_CLAP            = ai->initSpell(THUNDER_CLAP_1);  //ARMS
+    HAMSTRING               = ai->initSpell(HAMSTRING_1);  //ARMS
+    MOCKING_BLOW            = ai->initSpell(MOCKING_BLOW_1);  //ARMS
+    RETALIATION             = ai->initSpell(RETALIATION_1);  //ARMS
+    SWEEPING_STRIKES        = ai->initSpell(SWEEPING_STRIKES_1); //ARMS
+    MORTAL_STRIKE           = ai->initSpell(MORTAL_STRIKE_1);  //ARMS
+    BLADESTORM              = ai->initSpell(BLADESTORM_1);  //ARMS
+    HEROIC_THROW            = ai->initSpell(HEROIC_THROW_1);  //ARMS
+    SHATTERING_THROW        = ai->initSpell(SHATTERING_THROW_1);  //ARMS
+    BLOODRAGE               = ai->initSpell(BLOODRAGE_1); //PROTECTION
+    DEFENSIVE_STANCE        = ai->initSpell(DEFENSIVE_STANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SUNDER_ARMOR            = ai->initSpell(SUNDER_ARMOR_1); //PROTECTION
+    TAUNT                   = ai->initSpell(TAUNT_1); //PROTECTION
+    SHIELD_BASH             = ai->initSpell(SHIELD_BASH_1); //PROTECTION
+    REVENGE                 = ai->initSpell(REVENGE_1); //PROTECTION
+    SHIELD_BLOCK            = ai->initSpell(SHIELD_BLOCK_1); //PROTECTION
+    DISARM                  = ai->initSpell(DISARM_1); //PROTECTION
+    SHIELD_WALL             = ai->initSpell(SHIELD_WALL_1); //PROTECTION
+    SHIELD_SLAM             = ai->initSpell(SHIELD_SLAM_1); //PROTECTION
+    VIGILANCE               = ai->initSpell(VIGILANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SHOCKWAVE               = ai->initSpell(SHOCKWAVE_1); //PROTECTION
+    CONCUSSION_BLOW         = ai->initSpell(CONCUSSION_BLOW_1); //PROTECTION
+    SPELL_REFLECTION        = ai->initSpell(SPELL_REFLECTION_1); //PROTECTION
+    LAST_STAND              = ai->initSpell(LAST_STAND_1); //PROTECTION
+    BATTLE_SHOUT            = ai->initSpell(BATTLE_SHOUT_1); //FURY
+    DEMORALIZING_SHOUT      = ai->initSpell(DEMORALIZING_SHOUT_1); //FURY
+    CLEAVE                  = ai->initSpell(CLEAVE_1); //FURY
+    INTIMIDATING_SHOUT      = ai->initSpell(INTIMIDATING_SHOUT_1); //FURY
+    EXECUTE                 = ai->initSpell(EXECUTE_1); //FURY
+    CHALLENGING_SHOUT       = ai->initSpell(CHALLENGING_SHOUT_1); //FURY
+    SLAM                    = ai->initSpell(SLAM_1); //FURY
+    BERSERKER_STANCE        = ai->initSpell(BERSERKER_STANCE_1); //FURY
+    INTERCEPT               = ai->initSpell(INTERCEPT_1); //FURY
+    DEATH_WISH              = ai->initSpell(DEATH_WISH_1); //FURY
+    BERSERKER_RAGE          = ai->initSpell(BERSERKER_RAGE_1); //FURY
+    WHIRLWIND               = ai->initSpell(WHIRLWIND_1); //FURY
+    PUMMEL                  = ai->initSpell(PUMMEL_1); //FURY
+    BLOODTHIRST             = ai->initSpell(BLOODTHIRST_1); //FURY
+    RECKLESSNESS            = ai->initSpell(RECKLESSNESS_1); //FURY
+    RAMPAGE                 = 0; // passive
+    HEROIC_FURY             = ai->initSpell(HEROIC_FURY_1); //FURY
+    COMMANDING_SHOUT        = ai->initSpell(COMMANDING_SHOUT_1); //FURY
+    ENRAGED_REGENERATION    = ai->initSpell(ENRAGED_REGENERATION_1); //FURY
+    PIERCING_HOWL           = ai->initSpell(PIERCING_HOWL_1); //FURY
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_WARRIOR); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD              = ai->initSpell(SHADOWMELD_ALL); // night elf
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
+
+bool PlayerbotWarriorAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    Player *m_bot = GetPlayerBot();
+    PlayerbotAI *ai = GetAI();
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+    float fTargetDist = m_bot->GetDistance(pTarget);
+
+    if ((co & PlayerbotAI::ORDERS_TANK) && DEFENSIVE_STANCE > 0 && !m_bot->HasAura(DEFENSIVE_STANCE) && ai->CastSpell(DEFENSIVE_STANCE))
+    {
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("First > Defensive Stance (%d)", DEFENSIVE_STANCE);
+        return true;
+    }
+    else if ((co & PlayerbotAI::ORDERS_TANK) && TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE) && ai->CastSpell(TAUNT, *pTarget))
+    {
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("First > Taunt (%d)", TAUNT);
+        return false;
+    }
+    else if (BATTLE_STANCE > 0 && !m_bot->HasAura(BATTLE_STANCE) && ai->CastSpell(BATTLE_STANCE))
+    {
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("First > Battle Stance (%d)", BATTLE_STANCE);
+        return true;
+    }
+    else if (BATTLE_STANCE > 0 && CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE))
+    {
+        if (fTargetDist < 8.0f)
+            return false;
+        else if (fTargetDist > 25.0f)
+            return true;
+        else if (CHARGE > 0 && ai->CastSpell(CHARGE, *pTarget))
+        {
+            float x, y, z;
+            pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+            m_bot->Relocate(x, y, z);
+
+            if (ai->GetManager()->m_confDebugWhisper)
+                ai->TellMaster("First > Charge (%d)", CHARGE);
+            return false;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HEROIC_STRIKE > 0)
+                ai->CastSpell(HEROIC_STRIKE);
+            return;
+    }
+    // ------- Non Duel combat ----------
+
+    // Damage Attacks
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = m_bot->GetDistance(pTarget);
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+
+    // decide what stance to use
+    if ((co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(DEFENSIVE_STANCE) && ai->CastSpell(DEFENSIVE_STANCE))
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("Stance > Defensive");
+        else if (!(co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(BATTLE_STANCE) && ai->CastSpell(BATTLE_STANCE))
+            if (ai->GetManager()->m_confDebugWhisper)
+                ai->TellMaster("Stance > Battle");
+
+    // get spell sequence
+    if (pTarget->IsNonMeleeSpellCasted(true))
+        SpellSequence = WarriorSpellPreventing;
+    else if (m_bot->HasAura(BATTLE_STANCE))
+        SpellSequence = WarriorBattle;
+    else if (m_bot->HasAura(DEFENSIVE_STANCE))
+        SpellSequence = WarriorDefensive;
+    else if (m_bot->HasAura(BERSERKER_STANCE))
+        SpellSequence = WarriorBerserker;
+
+    // do shouts, berserker rage, etc...
+    if (BERSERKER_RAGE > 0 && !m_bot->HasAura(BERSERKER_RAGE) && ai->CastSpell(BERSERKER_RAGE))
+        if (ai->GetManager()->m_confDebugWhisper)
+            ai->TellMaster("Pre > Berseker Rage");
+        else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT) && ai->CastSpell(DEMORALIZING_SHOUT))
+            if (ai->GetManager()->m_confDebugWhisper)
+                ai->TellMaster("Pre > Demoralizing Shout");
+            else if (BATTLE_SHOUT > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(BATTLE_SHOUT) && ai->CastSpell(BATTLE_SHOUT))
+                if (ai->GetManager()->m_confDebugWhisper)
+                    ai->TellMaster("Pre > Battle Shout");
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case WarriorSpellPreventing:
+            out << "Case Prevent";
+            if (SHIELD_BASH > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(SHIELD_BASH, *pTarget))
+                out << " > Shield Bash";
+            else if (PUMMEL > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(PUMMEL, *pTarget))
+                out << " > Pummel";
+            else if (SPELL_REFLECTION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(SPELL_REFLECTION) && ai->CastSpell(SPELL_REFLECTION, *m_bot))
+                out << " > Spell Reflection";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBattle:
+            out << "Case Battle";
+            if (EXECUTE > 0 && ai->GetRageAmount() >= 15 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(EXECUTE, *pTarget))
+                out << " > Execute!";
+            else if (LAST_STAND > 0 && !m_bot->HasAura(LAST_STAND) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(LAST_STAND, *m_bot))
+                out << " > Last Stand!";
+            else if (BLOODRAGE > 0 && ai->GetRageAmount() < 50 && !m_bot->HasAura(BLOODRAGE) && ai->CastSpell(BLOODRAGE, *m_bot))
+                out << " > Bloodrage";
+            else if (DEATH_WISH > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(DEATH_WISH) && ai->CastSpell(DEATH_WISH, *m_bot))
+                out << " > Death Wish";
+            else if (RETALIATION > 0 && pVictim == m_bot && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(RETALIATION) && ai->CastSpell(RETALIATION, *m_bot))
+                out << " > Retaliation";
+            else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT) && ai->CastSpell(DEMORALIZING_SHOUT, *pTarget))
+                out << " > Demoralizing Shout";
+            else if (SWEEPING_STRIKES > 0 && ai->GetRageAmount() >= 30 && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(SWEEPING_STRIKES) && ai->CastSpell(SWEEPING_STRIKES, *m_bot))
+                out << " > Sweeping Strikes!";
+            else if (BLADESTORM > 0 && ai->GetRageAmount() >= 25 && pVictim == m_bot && !m_bot->HasAura(BLADESTORM) && ai->GetAttackerCount() >= 3 && ai->CastSpell(BLADESTORM, *pTarget))
+                out << " > Bladestorm!";
+            else if (MORTAL_STRIKE > 0 && ai->GetRageAmount() >= 30 && !pTarget->HasAura(MORTAL_STRIKE) && ai->CastSpell(MORTAL_STRIKE, *pTarget))
+                out << " > Mortal Strike";
+            else if (INTIMIDATING_SHOUT > 0 && ai->GetRageAmount() >= 25 && ai->GetAttackerCount() > 5 && ai->CastSpell(INTIMIDATING_SHOUT, *pTarget))
+                out << " > Intimidating Shout";
+            else if (THUNDER_CLAP > 0 && ai->GetRageAmount() >= 20 && pVictim == m_bot && !pTarget->HasAura(THUNDER_CLAP) && ai->CastSpell(THUNDER_CLAP, *pTarget))
+                out << " > Thunder Clap";
+            else if (ENRAGED_REGENERATION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(BERSERKER_RAGE) && !m_bot->HasAura(ENRAGED_REGENERATION) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(ENRAGED_REGENERATION, *m_bot))
+                out << " > Enraged Regeneration";
+            else if (SHOCKWAVE > 0 && ai->GetRageAmount() >= 15 && pVictim == m_bot && !pTarget->HasAura(WAR_STOMP) && !pTarget->HasAura(PIERCING_HOWL) && !pTarget->HasAura(SHOCKWAVE) && !pTarget->HasAura(CONCUSSION_BLOW) && ai->CastSpell(SHOCKWAVE, *pTarget))
+                out << " > Shockwave";
+            else if (REND > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(REND) && ai->CastSpell(REND, *pTarget))
+                out << " > Rend";
+            else if (HAMSTRING > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(HAMSTRING) && ai->CastSpell(HAMSTRING, *pTarget))
+                out << " > Hamstring";
+            else if (CHALLENGING_SHOUT > 0 && ai->GetRageAmount() >= 5 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW) && !pTarget->HasAura(CHALLENGING_SHOUT) && ai->CastSpell(CHALLENGING_SHOUT, *pTarget))
+                out << " > Challenging Shout";
+            else if (BLOODTHIRST > 0 && ai->GetRageAmount() >= 20 && !m_bot->HasAura(BLOODTHIRST) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.7 && ai->CastSpell(BLOODTHIRST, *pTarget))
+                out << " > Bloodthrist";
+            else if (CLEAVE > 0 && ai->GetRageAmount() >= 20 && ai->CastSpell(CLEAVE, *pTarget))
+                out << " > Cleave";
+            else if (HEROIC_STRIKE > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                out << " > Heroic Strike";
+            else if (CONCUSSION_BLOW > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(WAR_STOMP) && !pTarget->HasAura(PIERCING_HOWL) && !pTarget->HasAura(SHOCKWAVE) && !pTarget->HasAura(CONCUSSION_BLOW) && ai->CastSpell(CONCUSSION_BLOW, *pTarget))
+                out << " > Concussion Blow";
+            else if (SLAM > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SLAM, *pTarget))
+                out << " > Slam";
+            else if (PIERCING_HOWL > 0 && ai->GetRageAmount() >= 10 && ai->GetAttackerCount() >= 3 && !pTarget->HasAura(WAR_STOMP) && !pTarget->HasAura(PIERCING_HOWL) && !pTarget->HasAura(SHOCKWAVE) && !pTarget->HasAura(CONCUSSION_BLOW) && ai->CastSpell(PIERCING_HOWL, *pTarget))
+                out << " > Piercing Howl";
+            else if (MOCKING_BLOW > 0 && ai->GetRageAmount() >= 10 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW) && !pTarget->HasAura(CHALLENGING_SHOUT) && ai->CastSpell(MOCKING_BLOW, *pTarget))
+                out << " > Mocking Blow";
+            else if (OVERPOWER > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(OVERPOWER, *pTarget))
+                out << " > Overpower";
+            else if (SUNDER_ARMOR > 0 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (SHATTERING_THROW > 0 && !pTarget->HasAura(SHATTERING_THROW) && ai->CastSpell(SHATTERING_THROW, *pTarget))
+                out << " > Shattering Throw";
+            else if (HEROIC_THROW > 0 && ai->CastSpell(HEROIC_THROW, *pTarget))
+                out << " > Heroic Throw";
+            else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP) && !pTarget->HasAura(PIERCING_HOWL) && !pTarget->HasAura(SHOCKWAVE) && !pTarget->HasAura(CONCUSSION_BLOW) && ai->CastSpell(WAR_STOMP, *pTarget))
+                out << " > War Stomp";
+            else if (m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot))
+                out << " > Every Man for Himself";
+            else if (m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
+                out << " > Will of the Forsaken";
+            else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                out << " > Stoneform";
+            else if (m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot))
+                out << " > Escape Artist";
+            else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                out << " > Blood Fury";
+            else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING) && ai->CastSpell(BERSERKING, *m_bot))
+                out << " > Berserking";
+            else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+                out << " > Gift of the Naaru";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorDefensive:
+            out << "Case Defensive";
+            if (DISARM > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(DISARM) && ai->CastSpell(DISARM, *pTarget))
+                out << " > Disarm";
+            else if (SUNDER_ARMOR > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (REVENGE > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(REVENGE, *pTarget))
+                out << " > Revenge";
+            else if (SHIELD_BLOCK > 0 && !m_bot->HasAura(SHIELD_BLOCK) && ai->CastSpell(SHIELD_BLOCK, *m_bot))
+                out << " > Shield Block";
+            else if (SHIELD_WALL > 0 && !m_bot->HasAura(SHIELD_WALL) && ai->CastSpell(SHIELD_WALL, *m_bot))
+                out << " > Shield Wall";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBerserker:
+            out << "Case Berserker";
+            if (WHIRLWIND > 0 && ai->GetRageAmount() >= 25 && ai->CastSpell(WHIRLWIND, *pTarget))
+                out << " > Whirlwind";
+            out << " > NONE";
+            break;
+    }
+    if (ai->GetManager()->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // TODO (by Runsttren): check if shout aura bot has is casted by this bot,
+    // otherwise cast other useful shout
+    // If the bot is protect talented, she/he needs stamina not attack power.
+    // With stance change can the shout change to.
+    // Inserted line to battle shout m_bot->HasAura( COMMANDING_SHOUT)
+    // Natsukawa
+    if (((COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT)) ||
+         (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT))) &&
+        ai->GetRageAmount() < 10 && BLOODRAGE > 0 && !m_bot->HasAura(BLOODRAGE))
+        // we do have a useful shout, no rage coming but can cast bloodrage... do it
+        ai->CastSpell(BLOODRAGE, *m_bot);
+    else if (COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT))
+        // use commanding shout now
+        ai->CastSpell(COMMANDING_SHOUT, *m_bot);
+    else if (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT) && !m_bot->HasAura(COMMANDING_SHOUT))
+        // use battle shout
+        ai->CastSpell(BATTLE_SHOUT, *m_bot);
+
+    // buff master with VIGILANCE
+    if (VIGILANCE > 0)
+        (!GetMaster()->HasAura(VIGILANCE) && ai->CastSpell(VIGILANCE, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..bb5a025
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
@@ -0,0 +1,103 @@
+#ifndef _PlayerbotWarriorAI_H
+#define _PlayerbotWarriorAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    WarriorSpellPreventing,
+    WarriorBattle,
+    WarriorDefensive,
+    WarriorBerserker
+};
+
+enum WarriorSpells
+{
+    BATTLE_SHOUT_1                  = 6673,
+    BATTLE_STANCE_1                 = 2457,
+    BERSERKER_RAGE_1                = 18499,
+    BERSERKER_STANCE_1              = 2458,
+    BLADESTORM_1                    = 46924,
+    BLOODRAGE_1                     = 2687,
+    BLOODTHIRST_1                   = 23881,
+    CHALLENGING_SHOUT_1             = 1161,
+    CHARGE_1                        = 100,
+    CLEAVE_1                        = 845,
+    COMMANDING_SHOUT_1              = 469,
+    CONCUSSION_BLOW_1               = 12809,
+    DEATH_WISH_1                    = 12292,
+    DEFENSIVE_STANCE_1              = 71,
+    DEMORALIZING_SHOUT_1            = 1160,
+    DEVASTATE_1                     = 20243,
+    DISARM_1                        = 676,
+    ENRAGED_REGENERATION_1          = 55694,
+    EXECUTE_1                       = 5308,
+    HAMSTRING_1                     = 1715,
+    HEROIC_FURY_1                   = 60970,
+    HEROIC_STRIKE_1                 = 78,
+    HEROIC_THROW_1                  = 57755,
+    INTERCEPT_1                     = 20252,
+    INTERVENE_1                     = 3411,
+    INTIMIDATING_SHOUT_1            = 5246,
+    LAST_STAND_1                    = 12975,
+    MOCKING_BLOW_1                  = 694,
+    MORTAL_STRIKE_1                 = 12294,
+    OVERPOWER_1                     = 7384,
+    PIERCING_HOWL_1                 = 12323,
+    PUMMEL_1                        = 6552,
+    RECKLESSNESS_1                  = 1719,
+    REND_1                          = 772,
+    RETALIATION_1                   = 20230,
+    REVENGE_1                       = 6572,
+    SHATTERING_THROW_1              = 64382,
+    SHIELD_BASH_1                   = 72,
+    SHIELD_BLOCK_1                  = 2565,
+    SHIELD_SLAM_1                   = 23922,
+    SHIELD_WALL_1                   = 871,
+    SHOCKWAVE_1                     = 46968,
+    SLAM_1                          = 1464,
+    SPELL_REFLECTION_1              = 23920,
+    SUNDER_ARMOR_1                  = 7386,
+    SWEEPING_STRIKES_1              = 12328,
+    TAUNT_1                         = 355,
+    THUNDER_CLAP_1                  = 6343,
+    VICTORY_RUSH_1                  = 34428,
+    VIGILANCE_1                     = 50720,
+    WHIRLWIND_1                     = 1680
+};
+
+//class Player;
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarriorAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarriorAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // ARMS
+    uint32 BATTLE_STANCE, CHARGE, HEROIC_STRIKE, REND, THUNDER_CLAP, HAMSTRING, MOCKING_BLOW, RETALIATION, SWEEPING_STRIKES, MORTAL_STRIKE, BLADESTORM, HEROIC_THROW, SHATTERING_THROW;
+
+    // PROTECTION
+    uint32 DEFENSIVE_STANCE, BLOODRAGE, SUNDER_ARMOR, TAUNT, SHIELD_BASH, REVENGE, SHIELD_BLOCK, DISARM, SHIELD_WALL, SHIELD_SLAM, VIGILANCE, DEVASTATE, SHOCKWAVE, CONCUSSION_BLOW, SPELL_REFLECTION, LAST_STAND;
+
+    // FURY
+    uint32 BERSERKER_STANCE, BATTLE_SHOUT, DEMORALIZING_SHOUT, OVERPOWER, CLEAVE, INTIMIDATING_SHOUT, EXECUTE, CHALLENGING_SHOUT, SLAM, INTERCEPT, DEATH_WISH, BERSERKER_RAGE, WHIRLWIND, PUMMEL, BLOODTHIRST, RECKLESSNESS, RAMPAGE, HEROIC_FURY, COMMANDING_SHOUT, ENRAGED_REGENERATION, PIERCING_HOWL;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence;
+};
+
+#endif
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..68565db
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,373 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+    }
+
+    sLog->outError("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        sLog->outError("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            sLog->outError("Invalid data0 (category: %u).", cat);
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        sLog->outError("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        sLog->outError("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        sLog->outError("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        sLog->outError("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        sLog->outError("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        sLog->outError("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    sLog->outError("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+	    sLog->outString( "TSCR: Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        sLog->outString("");
+        sLog->outString("TSCR: >> Loaded %u npc_teleport.", nbDest);
+    } else sLog->outString("TSCR: WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
new file mode 100644
index 0000000..e4dafa9
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
@@ -0,0 +1,1980 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
+#include <vector>
+
+using namespace std;
+vector<uint32> npcItems;
+vector<uint32> glyphItemsBin;
+vector<uint32> lootItems;
+vector<uint32> greyTradeGoodsBin;
+vector<uint32> whiteTradeGoodsBin;
+vector<uint32> greenTradeGoodsBin;
+vector<uint32> blueTradeGoodsBin;
+vector<uint32> purpleTradeGoodsBin;
+vector<uint32> orangeTradeGoodsBin;
+vector<uint32> yellowTradeGoodsBin;
+vector<uint32> greyItemsBin;
+vector<uint32> whiteItemsBin;
+vector<uint32> greenItemsBin;
+vector<uint32> blueItemsBin;
+vector<uint32> purpleItemsBin;
+vector<uint32> orangeItemsBin;
+vector<uint32> yellowItemsBin;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    debug_Out = false;
+    debug_Out_Filters = false;
+    AHBSeller = false;
+    AHBBuyer = false;
+
+    //Begin Filters
+
+    Vendor_Items = false;
+    Loot_Items = false;
+    Other_Items = false;
+    Vendor_TGs = false;
+    Loot_TGs = false;
+    Other_TGs = false;
+
+    No_Bind = false;
+    Bind_When_Picked_Up = false;
+    Bind_When_Equipped = false;
+    Bind_When_Use = false;
+    Bind_Quest_Item = false;
+
+    DisableBeta_PTR_Unused = false;
+    DisablePermEnchant = false;
+    DisableConjured = false;
+    DisableGems = false;
+    DisableMoney = false;
+    DisableMoneyLoot = false;
+    DisableLootable = false;
+    DisableKeys = false;
+    DisableDuration = false;
+    DisableBOP_Or_Quest_NoReqLevel = false;
+
+    DisableWarriorItems = false;
+    DisablePaladinItems = false;
+    DisableHunterItems = false;
+    DisableRogueItems = false;
+    DisablePriestItems = false;
+    DisableDKItems = false;
+    DisableShamanItems = false;
+    DisableMageItems = false;
+    DisableWarlockItems = false;
+    DisableUnusedClassItems = false;
+    DisableDruidItems = false;
+
+    DisableItemsBelowLevel = 0;
+    DisableItemsAboveLevel = 0;
+    DisableTGsBelowLevel = 0;
+    DisableTGsAboveLevel = 0;
+    DisableItemsBelowGUID = 0;
+    DisableItemsAboveGUID = 0;
+    DisableTGsBelowGUID = 0;
+    DisableTGsAboveGUID = 0;
+    DisableItemsBelowReqLevel = 0;
+    DisableItemsAboveReqLevel = 0;
+    DisableTGsBelowReqLevel = 0;
+    DisableTGsAboveReqLevel = 0;
+    DisableItemsBelowReqSkillRank = 0;
+    DisableItemsAboveReqSkillRank = 0;
+    DisableTGsBelowReqSkillRank = 0;
+    DisableTGsAboveReqSkillRank = 0;
+	//glyphs patch
+	SellGlyphs = false;
+	GlyphsCount = 0;
+	DisableGlyphBelowLevel = 0;
+	DisableGlyphAboveLevel = 0;
+	GlyphBuyOutPriceMin = 0;
+	GlyphBuyOutPriceMax = 0;
+	GlyphBidPriceMin = 0;
+	GlyphBidPriceMax = 0;
+	// <- end glyphs patch
+
+    //End Filters
+
+    _lastrun_a = time(NULL);
+    _lastrun_h = time(NULL);
+    _lastrun_n = time(NULL);
+
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+	bool glyphMode = false;
+
+    if (!AHBSeller)
+    {
+        if (debug_Out) sLog->outError("AHSeller: Disabled");
+        return;
+    }
+
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+
+    if (maxItems == 0)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions disabled");
+        return;
+    }
+
+    AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+    if (!ahEntry)
+    {
+        return;
+    }
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    if (!auctionHouse)
+    {
+        return;
+    }
+
+    uint32 auctions = auctionHouse->Getcount();
+
+    uint32 items = 0;
+
+	if(SellGlyphs)
+	{
+		if(GlyphsCount <= 0)
+			GlyphsCount = 400;
+
+		if(auctions >= minItems)
+			glyphMode = true;
+
+		if(auctions >= (maxItems + GlyphsCount))
+			return;
+
+		if (((maxItems + GlyphsCount) - auctions) >= ItemsPerCycle)
+			items = ItemsPerCycle;
+		else
+			items = ((maxItems + GlyphsCount) - auctions);
+	}
+	else
+	{
+		if (auctions >= minItems)
+		{
+			//if (debug_Out) sLog.outString("AHSeller: Auctions above minimum");
+			return;
+		}
+
+		if (auctions >= maxItems)
+		{
+			//if (debug_Out) sLog.outString("AHSeller: Auctions at or above maximum");
+			return;
+		}
+
+		if ((maxItems - auctions) >= ItemsPerCycle)
+			items = ItemsPerCycle;
+		else
+			items = (maxItems - auctions);
+	}
+
+    if (debug_Out) sLog->outString("AHSeller: Adding %u Auctions", items);
+
+    uint32 AuctioneerGUID = 0;
+
+    switch (config->GetAHID())
+    {
+    case 2:
+        AuctioneerGUID = 79707; //Human in stormwind.
+        break;
+    case 6:
+        AuctioneerGUID = 4656; //orc in Orgrimmar
+        break;
+    case 7:
+        AuctioneerGUID = 23442; //goblin in GZ
+        break;
+    default:
+        if (debug_Out) sLog->outError("AHSeller: GetAHID() - Default switch reached");
+        AuctioneerGUID = 23442; //default to neutral 7
+        break;
+    }
+
+    if (debug_Out) sLog->outString("AHSeller: Current Auctineer GUID is %u", AuctioneerGUID);
+
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+/*    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+*/
+    uint32 greyTGoods = config->GetItemCounts(AHB_GREY_TG);
+    uint32 whiteTGoods = config->GetItemCounts(AHB_WHITE_TG);
+    uint32 greenTGoods = config->GetItemCounts(AHB_GREEN_TG);
+    uint32 blueTGoods = config->GetItemCounts(AHB_BLUE_TG);
+    uint32 purpleTGoods = config->GetItemCounts(AHB_PURPLE_TG);
+    uint32 orangeTGoods = config->GetItemCounts(AHB_ORANGE_TG);
+    uint32 yellowTGoods = config->GetItemCounts(AHB_YELLOW_TG);
+
+    uint32 greyItems = config->GetItemCounts(AHB_GREY_I);
+    uint32 whiteItems = config->GetItemCounts(AHB_WHITE_I);
+    uint32 greenItems = config->GetItemCounts(AHB_GREEN_I);
+    uint32 blueItems = config->GetItemCounts(AHB_BLUE_I);
+    uint32 purpleItems = config->GetItemCounts(AHB_PURPLE_I);
+    uint32 orangeItems = config->GetItemCounts(AHB_ORANGE_I);
+    uint32 yellowItems = config->GetItemCounts(AHB_YELLOW_I);
+
+    if (debug_Out) sLog->outString("AHSeller: %u items", items);
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1; cnt <= items; cnt++)
+    {
+    if (debug_Out) sLog->outString("AHSeller: %u count", cnt);
+        uint32 itemID = 0;
+        uint32 itemColor = 99;
+        uint32 loopbreaker = 0;
+        while (itemID == 0 && loopbreaker <= 50)
+        {
+            ++loopbreaker;
+            uint32 choice = urand(0, 13);
+			if(glyphMode)
+				choice = 14;
+            itemColor = choice;
+            switch (choice)
+            {
+            case 0:
+                {
+                    if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                        itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 1:
+                {
+                    if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                        itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 2:
+                {
+                    if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                        itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 3:
+                {
+                    if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                        itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 4:
+                {
+                    if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                        itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 5:
+                {
+                    if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                        itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 6:
+                {
+                    if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                        itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 7:
+                {
+                    if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                        itemID = greyTradeGoodsBin[urand(0, greyTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 8:
+                {
+                    if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                        itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 9:
+                {
+                    if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                        itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 10:
+                {
+                    if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                        itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 11:
+                {
+                    if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                        itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 12:
+                {
+                    if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                        itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 13:
+                {
+                    if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                        itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+			case 14:
+                {
+					if (glyphItemsBin.size() > 0)
+						itemID = glyphItemsBin[urand(0, glyphItemsBin.size() - 1)];
+					else continue;
+                    break;
+                }
+            default:
+                {
+                    if (debug_Out) sLog->outError("AHSeller: itemID Switch - Default Reached");
+                    break;
+                }
+            }
+
+            if (itemID == 0)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() - ItemID is 0");
+                continue;
+            }
+
+            ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(itemID);
+            if (prototype == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Huh?!?! prototype == NULL");
+                continue;
+            }
+
+            Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+            if (item == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() returned NULL");
+                break;
+            }
+            item->AddToUpdateQueueOf(AHBplayer);
+
+            uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+            if (randomPropertyId != 0)
+                item->SetItemRandomProperties(randomPropertyId);
+
+            uint64 buyoutPrice = 0;
+            uint64 bidPrice = 0;
+            uint32 stackCount = 1;
+
+            switch (SellMethod)
+            {
+            case 0:
+                buyoutPrice  = prototype->SellPrice;
+                break;
+            case 1:
+                buyoutPrice  = prototype->BuyPrice;
+                break;
+            }
+
+            if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+            {
+				if(!glyphMode)
+				{
+					if (config->GetMaxStack(prototype->Quality) > 1 && item->GetMaxStackCount() > 1)
+						stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(prototype->Quality)));
+					else if (config->GetMaxStack(prototype->Quality) == 0 && item->GetMaxStackCount() > 1)
+						stackCount = urand(1, item->GetMaxStackCount());
+					else
+						stackCount = 1;
+					buyoutPrice *= urand(config->GetMinPrice(prototype->Quality), config->GetMaxPrice(prototype->Quality));
+					buyoutPrice /= 100;
+					bidPrice = buyoutPrice * urand(config->GetMinBidPrice(prototype->Quality), config->GetMaxBidPrice(prototype->Quality));
+					bidPrice /= 100;
+				}
+				else
+				{
+					buyoutPrice = urand(GlyphBuyOutPriceMin, GlyphBuyOutPriceMax);
+					bidPrice = urand(GlyphBidPriceMin, GlyphBidPriceMax);
+					if(buyoutPrice<bidPrice)
+						bidPrice = buyoutPrice - 1;
+					stackCount = 1;
+				}
+            }
+            else
+            {
+                // quality is something it shouldn't be, let's get out of here
+                if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                item->RemoveFromUpdateQueueOf(AHBplayer);
+                continue;
+            }
+
+            uint32 etime = urand(1,3);
+            switch(etime)
+            {
+            case 1:
+                etime = 43200;
+                break;
+            case 2:
+                etime = 86400;
+                break;
+            case 3:
+                etime = 172800;
+                break;
+            default:
+                etime = 86400;
+                break;
+            }
+            item->SetCount(stackCount);
+
+            uint32 dep =  sAuctionMgr->GetAuctionDeposit(ahEntry, etime, item, stackCount);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            AuctionEntry* auctionEntry = new AuctionEntry;
+            auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+            auctionEntry->auctioneer = AuctioneerGUID;
+            auctionEntry->item_guidlow = item->GetGUIDLow();
+            auctionEntry->item_template = item->GetEntry();
+            auctionEntry->owner = AHBplayer->GetGUIDLow();
+            auctionEntry->startbid = bidPrice * stackCount;
+            auctionEntry->buyout = buyoutPrice * stackCount;
+            auctionEntry->bidder = 0;
+            auctionEntry->bid = 0;
+            auctionEntry->deposit = dep;
+            auctionEntry->expire_time = (time_t) etime + time(NULL);
+            auctionEntry->auctionHouseEntry = ahEntry;
+            item->SaveToDB(trans);
+            item->RemoveFromUpdateQueueOf(AHBplayer);
+            sAuctionMgr->AddAItem(item);
+            auctionHouse->AddAuction(auctionEntry);
+            auctionEntry->SaveToDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+
+            switch(itemColor)
+            {
+            case 0:
+                ++greyItems;
+                break;
+            case 1:
+                ++whiteItems;
+                break;
+            case 2:
+                ++greenItems;
+                break;
+            case 3:
+                ++blueItems;
+                break;
+            case 4:
+                ++purpleItems;
+                break;
+            case 5:
+                ++orangeItems;
+                break;
+            case 6:
+                ++yellowItems;
+                break;
+            case 7:
+                ++greyTGoods;
+                break;
+            case 8:
+                ++whiteTGoods;
+                break;
+            case 9:
+                ++greenTGoods;
+                break;
+            case 10:
+                ++blueTGoods;
+                break;
+            case 11:
+                ++purpleTGoods;
+                break;
+            case 12:
+                ++orangeTGoods;
+                break;
+            case 13:
+                ++yellowTGoods;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!AHBBuyer)
+    {
+        if (debug_Out) sLog->outError("AHBuyer: Disabled");
+        return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE itemowner<>%u AND buyguid<>%u", AHBplayerGUID, AHBplayerGUID);
+
+    if (!result)
+        return;
+
+    if (result->GetRowCount() == 0)
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    do
+    {
+        uint32 tmpdata = result->Fetch()->GetUInt32();
+        possibleBids.push_back(tmpdata);
+    }while (result->NextRow());
+
+    for (uint32 count = 1; count <= config->GetBidsPerInterval(); ++count)
+    {
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: I have no items to bid on.");
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(*iter);
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        possibleBids.erase(iter);
+
+        if (!auction)
+            continue;
+
+        // get exact item information
+        Item *pItem =  sAuctionMgr->GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            if (debug_Out) sLog->outError("AHBuyer: Item %u doesn't exist, perhaps bought already?", auction->item_guidlow);
+            continue;
+        }
+
+        // get item prototype
+        ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(auction->item_template);
+
+        // check which price we have to use, startbid or if it is bidded already
+        uint32 currentprice;
+        if (auction->bid)
+            currentprice = auction->bid;
+        else
+            currentprice = auction->startbid;
+
+        // Prepare portion from maximum bid
+        double bidrate = static_cast<double>(urand(1, 100)) / 100;
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        switch (BuyMethod)
+        {
+        case 0:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        case 1:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        }
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+        case 6:
+            bidMax = 0;
+            break;
+        default:
+            break;
+        }
+
+        if (bidMax == 0)
+        {
+            // quality check failed to get bidmax, let's get out of here
+            continue;
+        }
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        // Convert to uint32
+        uint32 bidprice = static_cast<uint32>(bidvalue);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+            bidprice = currentprice + auction->GetAuctionOutBid();
+
+        if (debug_Out)
+        {
+            sLog->outString("-------------------------------------------------");
+            sLog->outString("AHBuyer: Info for Auction #%u:", auction->Id);
+            sLog->outString("AHBuyer: AuctionHouse: %u", auction->GetHouseId());
+            sLog->outString("AHBuyer: Auctioneer: %u", auction->auctioneer);
+            sLog->outString("AHBuyer: Owner: %u", auction->owner);
+            sLog->outString("AHBuyer: Bidder: %u", auction->bidder);
+            sLog->outString("AHBuyer: Starting Bid: %u", auction->startbid);
+            sLog->outString("AHBuyer: Current Bid: %u", currentprice);
+            sLog->outString("AHBuyer: Buyout: %u", auction->buyout);
+            sLog->outString("AHBuyer: Deposit: %u", auction->deposit);
+            sLog->outString("AHBuyer: Expire Time: %u", auction->expire_time);
+            sLog->outString("AHBuyer: Bid Rate: %f", bidrate);
+            sLog->outString("AHBuyer: Bid Max: %f", bidMax);
+            sLog->outString("AHBuyer: Bid Value: %f", bidvalue);
+            sLog->outString("AHBuyer: Bid Price: %u", bidprice);
+            sLog->outString("AHBuyer: Item GUID: %u", auction->item_guidlow);
+            sLog->outString("AHBuyer: Item Template: %u", auction->item_template);
+            sLog->outString("AHBuyer: Item Info:");
+            sLog->outString("AHBuyer: Item ID: %u", prototype->ItemId);
+            sLog->outString("AHBuyer: Buy Price: %u", prototype->BuyPrice);
+            sLog->outString("AHBuyer: Sell Price: %u", prototype->SellPrice);
+            sLog->outString("AHBuyer: Bonding: %u", prototype->Bonding);
+            sLog->outString("AHBuyer: Quality: %u", prototype->Quality);
+            sLog->outString("AHBuyer: Item Level: %u", prototype->ItemLevel);
+            sLog->outString("AHBuyer: Ammo Type: %u", prototype->AmmoType);
+            sLog->outString("-------------------------------------------------");
+        }
+
+        // Check whether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    sAuctionMgr->SendAuctionOutbiddedMail(auction , bidprice, session->GetPlayer(), trans);
+                    CharacterDatabase.CommitTransaction(trans);
+                    //pl->ModifyMoney(-int32(price));
+                }
+           }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            //buyout
+            if ((auction->bidder) && (AHBplayer->GetGUIDLow() != auction->bidder))
+            {
+                sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, session->GetPlayer(), trans);
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+            sAuctionMgr->SendAuctionWonMail(auction, trans);
+            auction->DeleteFromDB( trans);
+            uint32 item_template = auction->item_template;
+            sAuctionMgr->RemoveAItem(auction->item_guidlow);
+            auctionHouse->RemoveAuction(auction, item_template);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!AHBSeller) && (!AHBBuyer))
+        return;
+
+	WorldSession _session(AHBplayerAccount, NULL, SEC_PLAYER, false, true, 0, LOCALE_enUS, 0, 0);
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(AHBplayerGUID);
+    sObjectAccessor->AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) >= (AllianceConfig.GetBiddingInterval() * MINUTE)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_a));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Alliance Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) >= (HordeConfig.GetBiddingInterval() * MINUTE)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_h));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Horde Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) >= (NeutralConfig.GetBiddingInterval() * MINUTE)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_n));
+        //if (debug_Out) sLog->outString("AHBuyer: Bidding on Neutral Auctions");
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+    sObjectAccessor->RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    debug_Out = ConfigMgr::GetBoolDefault("AuctionHouseBot.DEBUG", false);
+    debug_Out_Filters = ConfigMgr::GetBoolDefault("AuctionHouseBot.DEBUG_FILTERS", false);
+
+    AHBSeller = ConfigMgr::GetBoolDefault("AuctionHouseBot.EnableSeller", false);
+    AHBBuyer = ConfigMgr::GetBoolDefault("AuctionHouseBot.EnableBuyer", false);
+    SellMethod = ConfigMgr::GetBoolDefault("AuctionHouseBot.UseBuyPriceForSeller", false);
+    BuyMethod = ConfigMgr::GetBoolDefault("AuctionHouseBot.UseBuyPriceForBuyer", false);
+
+    AHBplayerAccount = ConfigMgr::GetIntDefault("AuctionHouseBot.Account", 0);
+    AHBplayerGUID = ConfigMgr::GetIntDefault("AuctionHouseBot.GUID", 0);
+    ItemsPerCycle = ConfigMgr::GetIntDefault("AuctionHouseBot.ItemsPerCycle", 200);
+
+    //Begin Filters
+
+    Vendor_Items = ConfigMgr::GetBoolDefault("AuctionHouseBot.VendorItems", false);
+    Loot_Items = ConfigMgr::GetBoolDefault("AuctionHouseBot.LootItems", true);
+    Other_Items = ConfigMgr::GetBoolDefault("AuctionHouseBot.OtherItems", false);
+    Vendor_TGs = ConfigMgr::GetBoolDefault("AuctionHouseBot.VendorTradeGoods", false);
+    Loot_TGs = ConfigMgr::GetBoolDefault("AuctionHouseBot.LootTradeGoods", true);
+    Other_TGs = ConfigMgr::GetBoolDefault("AuctionHouseBot.OtherTradeGoods", false);
+
+    No_Bind = ConfigMgr::GetBoolDefault("AuctionHouseBot.No_Bind", true);
+    Bind_When_Picked_Up = ConfigMgr::GetBoolDefault("AuctionHouseBot.Bind_When_Picked_Up", false);
+    Bind_When_Equipped = ConfigMgr::GetBoolDefault("AuctionHouseBot.Bind_When_Equipped", true);
+    Bind_When_Use = ConfigMgr::GetBoolDefault("AuctionHouseBot.Bind_When_Use", true);
+    Bind_Quest_Item = ConfigMgr::GetBoolDefault("AuctionHouseBot.Bind_Quest_Item", false);
+
+    DisableBeta_PTR_Unused = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableBeta_PTR_Unused", false);
+    DisablePermEnchant = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisablePermEnchant", false);
+    DisableConjured = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableConjured", false);
+    DisableGems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableGems", false);
+    DisableMoney = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableMoney", false);
+    DisableMoneyLoot = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableMoneyLoot", false);
+    DisableLootable = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableLootable", false);
+    DisableKeys = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableKeys", false);
+    DisableDuration = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableDuration", false);
+    DisableBOP_Or_Quest_NoReqLevel = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel", false);
+
+    DisableWarriorItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableWarriorItems", false);
+    DisablePaladinItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisablePaladinItems", false);
+    DisableHunterItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableHunterItems", false);
+    DisableRogueItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableRogueItems", false);
+    DisablePriestItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisablePriestItems", false);
+    DisableDKItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableDKItems", false);
+    DisableShamanItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableShamanItems", false);
+    DisableMageItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableMageItems", false);
+    DisableWarlockItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableWarlockItems", false);
+    DisableUnusedClassItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableUnusedClassItems", false);
+    DisableDruidItems = ConfigMgr::GetBoolDefault("AuctionHouseBot.DisableDruidItems", false);
+
+    DisableItemsBelowLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsBelowLevel", 0);
+    DisableItemsAboveLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsAboveLevel", 0);
+    DisableTGsBelowLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsBelowLevel", 0);
+    DisableTGsAboveLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsAboveLevel", 0);
+    DisableItemsBelowGUID = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsBelowGUID", 0);
+    DisableItemsAboveGUID = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsAboveGUID", 0);
+    DisableTGsBelowGUID = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsBelowGUID", 0);
+    DisableTGsAboveGUID = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsAboveGUID", 0);
+    DisableItemsBelowReqLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsBelowReqLevel", 0);
+    DisableItemsAboveReqLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsAboveReqLevel", 0);
+    DisableTGsBelowReqLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsBelowReqLevel", 0);
+    DisableTGsAboveReqLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsAboveReqLevel", 0);
+    DisableItemsBelowReqSkillRank = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsBelowReqSkillRank", 0);
+    DisableItemsAboveReqSkillRank = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableItemsAboveReqSkillRank", 0);
+    DisableTGsBelowReqSkillRank = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsBelowReqSkillRank", 0);
+    DisableTGsAboveReqSkillRank = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableTGsAboveReqSkillRank", 0);
+	SellGlyphs = ConfigMgr::GetBoolDefault("AuctionHouseBot.SellGlyphs", false);
+	GlyphsCount = ConfigMgr::GetIntDefault("AuctionHouseBot.GlyphsCount", 0);
+	DisableGlyphBelowLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableGlyphBelowLevel", 0);
+	DisableGlyphAboveLevel = ConfigMgr::GetIntDefault("AuctionHouseBot.DisableGlyphAboveLevel", 0);
+	GlyphBuyOutPriceMin = ConfigMgr::GetIntDefault("AuctionHouseBot.GlyphBuyOutPriceMin", 0);
+	GlyphBuyOutPriceMax = ConfigMgr::GetIntDefault("AuctionHouseBot.GlyphBuyOutPriceMax", 0);
+	GlyphBidPriceMin = ConfigMgr::GetIntDefault("AuctionHouseBot.GlyphBidPriceMin", 0);
+	GlyphBidPriceMax = ConfigMgr::GetIntDefault("AuctionHouseBot.GlyphBidPriceMax", 0);
+
+    //End Filters
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+
+    //
+    // check if the AHBot account/GUID in the config actually exists
+    //
+
+    if ((AHBplayerAccount != 0) || (AHBplayerGUID != 0))
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE account = %u AND guid = %u", AHBplayerAccount, AHBplayerGUID);
+        if (!result)
+       {
+           sLog->outError("AuctionHouseBot: The account/GUID-information set for your AHBot is incorrect (account: %u guid: %u)", AHBplayerAccount, AHBplayerGUID);
+           return;
+        }
+    }
+
+    if (AHBSeller)
+    {
+        QueryResult results = QueryResult(NULL);
+        char npcQuery[] = "SELECT distinct item FROM npc_vendor";
+        results = WorldDatabase.Query(npcQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+        }
+
+		if(SellGlyphs)
+		{
+			if(DisableGlyphBelowLevel > 80)
+				DisableGlyphBelowLevel = 0;
+			if(DisableGlyphAboveLevel < DisableGlyphBelowLevel)
+				DisableGlyphAboveLevel = DisableGlyphBelowLevel;
+			if(DisableGlyphAboveLevel == 0)
+				DisableGlyphAboveLevel = 85;
+
+			if(GlyphBidPriceMin <= 0)
+				GlyphBidPriceMin = 8000;
+			if(GlyphBidPriceMin > GlyphBidPriceMax)
+				GlyphBidPriceMax = GlyphBidPriceMin;
+			if(GlyphBuyOutPriceMin <= 0)
+				GlyphBuyOutPriceMin = 10000;
+			if(GlyphBuyOutPriceMin > GlyphBuyOutPriceMax)
+				GlyphBuyOutPriceMax = GlyphBuyOutPriceMin;
+
+
+			results = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE class = 16 AND RequiredLevel >= %u AND RequiredLevel <= %u", DisableGlyphBelowLevel, DisableGlyphAboveLevel);
+			if (results != NULL)
+			{
+				do
+				{
+					Field* fields = results->Fetch();
+					glyphItemsBin.push_back(fields[0].GetUInt32());
+
+				} while (results->NextRow());
+			}
+			else
+			{
+				if (debug_Out) sLog->outString("AuctionHouseBot: query glyphs failed");
+			}
+		}
+
+        char lootQuery[] = "SELECT item FROM creature_loot_template UNION "
+            "SELECT item FROM reference_loot_template UNION "
+            "SELECT item FROM disenchant_loot_template UNION "
+            "SELECT item FROM fishing_loot_template UNION "
+            "SELECT item FROM gameobject_loot_template UNION "
+            "SELECT item FROM item_loot_template UNION "
+            "SELECT item FROM milling_loot_template UNION "
+            "SELECT item FROM pickpocketing_loot_template UNION "
+            "SELECT item FROM prospecting_loot_template UNION "
+            "SELECT item FROM skinning_loot_template";
+
+        results = WorldDatabase.Query(lootQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+        }
+
+        ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+        {
+
+            switch (itr->second.Bonding)
+            {
+            case NO_BIND:
+                if (!No_Bind)
+                    continue;
+                break;
+            case BIND_WHEN_PICKED_UP:
+                if (!Bind_When_Picked_Up)
+                    continue;
+                break;
+            case BIND_WHEN_EQUIPED:
+                if (!Bind_When_Equipped)
+                    continue;
+                break;
+            case BIND_WHEN_USE:
+                if (!Bind_When_Use)
+                    continue;
+                break;
+            case BIND_QUEST_ITEM:
+                if (!Bind_Quest_Item)
+                    continue;
+                break;
+            default:
+                continue;
+                break;
+            }
+
+            switch (SellMethod)
+            {
+            case 0:
+                if (itr->second.SellPrice == 0)
+                    continue;
+                break;
+            case 1:
+                if (itr->second.BuyPrice == 0)
+                    continue;
+                break;
+            }
+
+            if ((itr->second.Quality < 0) || (itr->second.Quality > 6))
+                continue;
+
+            if ((Vendor_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if ((Vendor_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+
+                if (isVendorTG)
+                    continue;
+            }
+
+            if ((Loot_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if ((Loot_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+
+                if (isLootTG)
+                    continue;
+            }
+
+            if ((Other_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            if ((Other_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+                if ((!isLootTG) && (!isVendorTG))
+                    continue;
+            }
+
+             //TODO:Make list of items and create a vector
+            // Disable PTR/Beta/Unused items
+            if ((DisableBeta_PTR_Unused) && ((itr->second.ItemId == 21878) || (itr->second.ItemId == 27774) || (itr->second.ItemId == 27811) || (itr->second.ItemId == 28117) || (itr->second.ItemId == 28112)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (PTR/Beta/Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable permanent enchants items
+            if ((DisablePermEnchant) && (itr->second.Class == ITEM_CLASS_PERMANENT))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Permanent Enchant Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable conjured items
+            if ((DisableConjured) && (itr->second.IsConjuredConsumable()))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Conjured Consumable)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable gems
+            if ((DisableGems) && (itr->second.Class == ITEM_CLASS_GEM))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Gem)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable money
+            if ((DisableMoney) && (itr->second.Class == ITEM_CLASS_MONEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Money)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable moneyloot
+            if ((DisableMoneyLoot) && (itr->second.MinMoneyLoot > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (MoneyLoot)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable lootable items
+            if ((DisableLootable) && (itr->second.Flags & 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Lootable Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable Keys
+            if ((DisableKeys) && (itr->second.Class == ITEM_CLASS_KEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Quest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items with duration
+            if ((DisableDuration) && (itr->second.Duration > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Has a Duration)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items which are BOP or Quest Items and have a required level lower than the item level
+            if ((DisableBOP_Or_Quest_NoReqLevel) && ((itr->second.Bonding == BIND_WHEN_PICKED_UP || itr->second.Bonding == BIND_QUEST_ITEM) && (itr->second.RequiredLevel < itr->second.ItemLevel)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (BOP or BQI and Required Level is less than Item Level)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warrior
+            if ((DisableWarriorItems) && (itr->second.AllowableClass == 1))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warrior Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Paladin
+            if ((DisablePaladinItems) && (itr->second.AllowableClass == 2))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Paladin Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Hunter
+            if ((DisableHunterItems) && (itr->second.AllowableClass == 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Hunter Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Rogue
+            if ((DisableRogueItems) && (itr->second.AllowableClass == 8))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Rogue Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Priest
+            if ((DisablePriestItems) && (itr->second.AllowableClass == 16))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Priest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for DK
+            if ((DisableDKItems) && (itr->second.AllowableClass == 32))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (DK Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Shaman
+            if ((DisableShamanItems) && (itr->second.AllowableClass == 64))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Shaman Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Mage
+            if ((DisableMageItems) && (itr->second.AllowableClass == 128))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Mage Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warlock
+            if ((DisableWarlockItems) && (itr->second.AllowableClass == 256))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warlock Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Unused Class
+            if ((DisableUnusedClassItems) && (itr->second.AllowableClass == 512))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Druid
+            if ((DisableDruidItems) && (itr->second.AllowableClass == 1024))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Druid Item)", itr->second.ItemId);
+                continue;
+            }
+
+             // Disable Items below level X
+            if ((DisableItemsBelowLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableItemsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above level X
+            if ((DisableItemsAboveLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableItemsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods below level X
+            if ((DisableTGsBelowLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableTGsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods above level X
+            if ((DisableTGsAboveLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableTGsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items below GUID X
+            if ((DisableItemsBelowGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableItemsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above GUID X
+            if ((DisableItemsAboveGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableItemsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods below GUID X
+            if ((DisableTGsBelowGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableTGsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods above GUID X
+            if ((DisableTGsAboveGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableTGsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items for level lower than X
+            if ((DisableItemsBelowReqLevel) && (itr->second.RequiredLevel < DisableItemsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items for level higher than X
+            if ((DisableItemsAboveReqLevel) && (itr->second.RequiredLevel > DisableItemsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level lower than X
+            if ((DisableTGsBelowReqLevel) && (itr->second.RequiredLevel < DisableTGsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level higher than X
+            if ((DisableTGsAboveReqLevel) && (itr->second.RequiredLevel > DisableTGsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items that require skill lower than X
+            if ((DisableItemsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableItemsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Items that require skill higher than X
+            if ((DisableItemsAboveReqSkillRank) && (itr->second.RequiredSkillRank > DisableItemsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill lower than X
+            if ((DisableTGsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableTGsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill higher than X
+            if ((DisableTGsAboveReqSkillRank) && (itr->second.RequiredSkillRank > DisableTGsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+                continue;
+            }
+
+            switch (itr->second.Quality)
+            {
+            case AHB_GREY:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greyTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greyItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_WHITE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    whiteTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    whiteItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_GREEN:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greenTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greenItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_BLUE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    blueTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    blueItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_PURPLE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    purpleTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    purpleItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_ORANGE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    orangeTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    orangeItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_YELLOW:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    yellowTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    yellowItemsBin.push_back(itr->second.ItemId);
+                break;
+            }
+        }
+
+        if ((greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0))
+        {
+            sLog->outError("AuctionHouseBot: No items");
+            AHBSeller = 0;
+        }
+
+        sLog->outString("AuctionHouseBot:");
+        sLog->outString("loaded %u grey trade goods", greyTradeGoodsBin.size());
+        sLog->outString("loaded %u white trade goods", whiteTradeGoodsBin.size());
+        sLog->outString("loaded %u green trade goods", greenTradeGoodsBin.size());
+        sLog->outString("loaded %u blue trade goods", blueTradeGoodsBin.size());
+        sLog->outString("loaded %u purple trade goods", purpleTradeGoodsBin.size());
+        sLog->outString("loaded %u orange trade goods", orangeTradeGoodsBin.size());
+        sLog->outString("loaded %u yellow trade goods", yellowTradeGoodsBin.size());
+        sLog->outString("loaded %u grey items", greyItemsBin.size());
+        sLog->outString("loaded %u white items", whiteItemsBin.size());
+        sLog->outString("loaded %u green items", greenItemsBin.size());
+        sLog->outString("loaded %u blue items", blueItemsBin.size());
+        sLog->outString("loaded %u purple items", purpleItemsBin.size());
+        sLog->outString("loaded %u orange items", orangeItemsBin.size());
+        sLog->outString("loaded %u yellow items", yellowItemsBin.size());
+		sLog->outString("loaded %u glyph items", glyphItemsBin.size());
+
+    }
+    sLog->outString("AuctionHouseBot and AuctionHouseBuyer have been loaded.");
+}
+
+void AuctionHouseBot::IncrementItemCounts(AuctionEntry* ah)
+{
+    // from auctionhousehandler.cpp, creates auction pointer & player pointer
+
+    // get exact item information
+    Item *pItem =  sAuctionMgr->GetAItem(ah->item_guidlow);
+    if (!pItem)
+    {
+        if (debug_Out) sLog->outError("AHBot: Item %u doesn't exist, perhaps bought already?", ah->item_guidlow);
+        return;
+    }
+
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(ah->item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->IncItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::DecrementItemCounts(AuctionEntry* ah, uint32 item_template)
+{
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->DecItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config = NULL;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == AHBplayerGUID)
+                {
+                    itr->second->expire_time = sWorld->GetGameTime();
+                    uint32 id = itr->second->Id;
+                    uint32 expire_time = itr->second->expire_time;
+                    CharacterDatabase.PExecute("UPDATE auctionhouse SET time = '%u' WHERE id = '%u'", expire_time, id);
+                }
+                ++itr;
+            }
+        }
+        break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }
+        break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+            config->CalculatePercents();
+        }
+        break;
+    case 3:     //min time Deprecated (Place holder for future commands)
+        break;
+    case 4:     //max time Deprecated (Place holder for future commands)
+        break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction( trans);
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }
+        break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }
+        break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }
+        break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }
+        break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }
+        break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }
+        break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }
+        break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }
+        break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (debug_Out) sLog->outString(((std::string)("Start Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+    if (AHBSeller)
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("minItems                = %u", config->GetMinItems());
+            sLog->outString("maxItems                = %u", config->GetMaxItems());
+            sLog->outString("percentGreyTradeGoods   = %u", config->GetPercentages(AHB_GREY_TG));
+            sLog->outString("percentWhiteTradeGoods  = %u", config->GetPercentages(AHB_WHITE_TG));
+            sLog->outString("percentGreenTradeGoods  = %u", config->GetPercentages(AHB_GREEN_TG));
+            sLog->outString("percentBlueTradeGoods   = %u", config->GetPercentages(AHB_BLUE_TG));
+            sLog->outString("percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            sLog->outString("percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            sLog->outString("percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            sLog->outString("percentGreyItems        = %u", config->GetPercentages(AHB_GREY_I));
+            sLog->outString("percentWhiteItems       = %u", config->GetPercentages(AHB_WHITE_I));
+            sLog->outString("percentGreenItems       = %u", config->GetPercentages(AHB_GREEN_I));
+            sLog->outString("percentBlueItems        = %u", config->GetPercentages(AHB_BLUE_I));
+            sLog->outString("percentPurpleItems      = %u", config->GetPercentages(AHB_PURPLE_I));
+            sLog->outString("percentOrangeItems      = %u", config->GetPercentages(AHB_ORANGE_I));
+            sLog->outString("percentYellowItems      = %u", config->GetPercentages(AHB_YELLOW_I));
+            sLog->outString("minPriceGrey            = %u", config->GetMinPrice(AHB_GREY));
+            sLog->outString("maxPriceGrey            = %u", config->GetMaxPrice(AHB_GREY));
+            sLog->outString("minPriceWhite           = %u", config->GetMinPrice(AHB_WHITE));
+            sLog->outString("maxPriceWhite           = %u", config->GetMaxPrice(AHB_WHITE));
+            sLog->outString("minPriceGreen           = %u", config->GetMinPrice(AHB_GREEN));
+            sLog->outString("maxPriceGreen           = %u", config->GetMaxPrice(AHB_GREEN));
+            sLog->outString("minPriceBlue            = %u", config->GetMinPrice(AHB_BLUE));
+            sLog->outString("maxPriceBlue            = %u", config->GetMaxPrice(AHB_BLUE));
+            sLog->outString("minPricePurple          = %u", config->GetMinPrice(AHB_PURPLE));
+            sLog->outString("maxPricePurple          = %u", config->GetMaxPrice(AHB_PURPLE));
+            sLog->outString("minPriceOrange          = %u", config->GetMinPrice(AHB_ORANGE));
+            sLog->outString("maxPriceOrange          = %u", config->GetMaxPrice(AHB_ORANGE));
+            sLog->outString("minPriceYellow          = %u", config->GetMinPrice(AHB_YELLOW));
+            sLog->outString("maxPriceYellow          = %u", config->GetMaxPrice(AHB_YELLOW));
+            sLog->outString("minBidPriceGrey         = %u", config->GetMinBidPrice(AHB_GREY));
+            sLog->outString("maxBidPriceGrey         = %u", config->GetMaxBidPrice(AHB_GREY));
+            sLog->outString("minBidPriceWhite        = %u", config->GetMinBidPrice(AHB_WHITE));
+            sLog->outString("maxBidPriceWhite        = %u", config->GetMaxBidPrice(AHB_WHITE));
+            sLog->outString("minBidPriceGreen        = %u", config->GetMinBidPrice(AHB_GREEN));
+            sLog->outString("maxBidPriceGreen        = %u", config->GetMaxBidPrice(AHB_GREEN));
+            sLog->outString("minBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("maxBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("minBidPricePurple       = %u", config->GetMinBidPrice(AHB_PURPLE));
+            sLog->outString("maxBidPricePurple       = %u", config->GetMaxBidPrice(AHB_PURPLE));
+            sLog->outString("minBidPriceOrange       = %u", config->GetMinBidPrice(AHB_ORANGE));
+            sLog->outString("maxBidPriceOrange       = %u", config->GetMaxBidPrice(AHB_ORANGE));
+            sLog->outString("minBidPriceYellow       = %u", config->GetMinBidPrice(AHB_YELLOW));
+            sLog->outString("maxBidPriceYellow       = %u", config->GetMaxBidPrice(AHB_YELLOW));
+            sLog->outString("maxStackGrey            = %u", config->GetMaxStack(AHB_GREY));
+            sLog->outString("maxStackWhite           = %u", config->GetMaxStack(AHB_WHITE));
+            sLog->outString("maxStackGreen           = %u", config->GetMaxStack(AHB_GREEN));
+            sLog->outString("maxStackBlue            = %u", config->GetMaxStack(AHB_BLUE));
+            sLog->outString("maxStackPurple          = %u", config->GetMaxStack(AHB_PURPLE));
+            sLog->outString("maxStackOrange          = %u", config->GetMaxStack(AHB_ORANGE));
+            sLog->outString("maxStackYellow          = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+        //AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+        AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+        config->ResetItemCounts();
+        uint32 auctions = auctionHouse->Getcount();
+
+        if (auctions)
+        {
+            for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+            {
+                AuctionEntry *Aentry = itr->second;
+                Item *item =  sAuctionMgr->GetAItem(Aentry->item_guidlow);
+                if (item)
+                {
+                    ItemTemplate const *prototype = item->GetTemplate();
+                    if (prototype)
+                    {
+                        switch (prototype->Quality)
+                        {
+                        case 0:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREY_TG);
+                            else
+                                config->IncItemCounts(AHB_GREY_I);
+                            break;
+                        case 1:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_WHITE_TG);
+                            else
+                                config->IncItemCounts(AHB_WHITE_I);
+                            break;
+                        case 2:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREEN_TG);
+                            else
+                                config->IncItemCounts(AHB_GREEN_I);
+                            break;
+                        case 3:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_BLUE_TG);
+                            else
+                                config->IncItemCounts(AHB_BLUE_I);
+                            break;
+                        case 4:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_PURPLE_TG);
+                            else
+                                config->IncItemCounts(AHB_PURPLE_I);
+                            break;
+                        case 5:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_ORANGE_TG);
+                            else
+                                config->IncItemCounts(AHB_ORANGE_I);
+                            break;
+                        case 6:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_YELLOW_TG);
+                            else
+                                config->IncItemCounts(AHB_YELLOW_I);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (debug_Out)
+        {
+            sLog->outString(((std::string)("Current Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+            sLog->outString("Grey Trade Goods\t%u\tGrey Items\t%u", config->GetItemCounts(AHB_GREY_TG), config->GetItemCounts(AHB_GREY_I));
+            sLog->outString("White Trade Goods\t%u\tWhite Items\t%u", config->GetItemCounts(AHB_WHITE_TG), config->GetItemCounts(AHB_WHITE_I));
+            sLog->outString("Green Trade Goods\t%u\tGreen Items\t%u", config->GetItemCounts(AHB_GREEN_TG), config->GetItemCounts(AHB_GREEN_I));
+            sLog->outString("Blue Trade Goods\t%u\tBlue Items\t%u", config->GetItemCounts(AHB_BLUE_TG), config->GetItemCounts(AHB_BLUE_I));
+            sLog->outString("Purple Trade Goods\t%u\tPurple Items\t%u", config->GetItemCounts(AHB_PURPLE_TG), config->GetItemCounts(AHB_PURPLE_I));
+            sLog->outString("Orange Trade Goods\t%u\tOrange Items\t%u", config->GetItemCounts(AHB_ORANGE_TG), config->GetItemCounts(AHB_ORANGE_I));
+            sLog->outString("Yellow Trade Goods\t%u\tYellow Items\t%u", config->GetItemCounts(AHB_YELLOW_TG), config->GetItemCounts(AHB_YELLOW_I));
+        }
+    }
+    if (AHBBuyer)
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("buyerPriceGrey          = %u", config->GetBuyerPrice(AHB_GREY));
+            sLog->outString("buyerPriceWhite         = %u", config->GetBuyerPrice(AHB_WHITE));
+            sLog->outString("buyerPriceGreen         = %u", config->GetBuyerPrice(AHB_GREEN));
+            sLog->outString("buyerPriceBlue          = %u", config->GetBuyerPrice(AHB_BLUE));
+            sLog->outString("buyerPricePurple        = %u", config->GetBuyerPrice(AHB_PURPLE));
+            sLog->outString("buyerPriceOrange        = %u", config->GetBuyerPrice(AHB_ORANGE));
+            sLog->outString("buyerPriceYellow        = %u", config->GetBuyerPrice(AHB_YELLOW));
+            sLog->outString("buyerBiddingInterval    = %u", config->GetBiddingInterval());
+            sLog->outString("buyerBidsPerInterval    = %u", config->GetBidsPerInterval());
+        }
+    }
+    if (debug_Out) sLog->outString(((std::string)("End Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
new file mode 100644
index 0000000..a7da388
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
@@ -0,0 +1,1257 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Config.h"
+#include "ItemPrototype.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_MAX_QUALITY 6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+#define AHB_GLYPH		14
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+    uint32 greyTGoods;
+    uint32 whiteTGoods;
+    uint32 greenTGoods;
+    uint32 blueTGoods;
+    uint32 purpleTGoods;
+    uint32 orangeTGoods;
+    uint32 yellowTGoods;
+
+    uint32 greyItems;
+    uint32 whiteItems;
+    uint32 greenItems;
+    uint32 blueItems;
+    uint32 purpleItems;
+    uint32 orangeItems;
+    uint32 yellowItems;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+    // CalculatePercents() needs to be called, but only if
+    // SetPercentages() has been called at least once already.
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            DecItemCounts(Quality);
+            break;
+        default:
+            DecItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            --greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            --whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            --greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            --blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            --purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            --orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            --yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            --greyItems;
+            break;
+        case AHB_WHITE_I:
+            --whiteItems;
+            break;
+        case AHB_GREEN_I:
+            --greenItems;
+            break;
+        case AHB_BLUE_I:
+            --blueItems;
+            break;
+        case AHB_PURPLE_I:
+            --purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            --orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            --yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            IncItemCounts(Quality);
+            break;
+        default:
+            IncItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            ++greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            ++whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            ++greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            ++blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            ++purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            ++orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            ++yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            ++greyItems;
+            break;
+        case AHB_WHITE_I:
+            ++whiteItems;
+            break;
+        case AHB_GREEN_I:
+            ++greenItems;
+            break;
+        case AHB_BLUE_I:
+            ++blueItems;
+            break;
+        case AHB_PURPLE_I:
+            ++purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            ++orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            ++yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void ResetItemCounts()
+    {
+        greyTGoods = 0;
+        whiteTGoods = 0;
+        greenTGoods = 0;
+        blueTGoods = 0;
+        purpleTGoods = 0;
+        orangeTGoods = 0;
+        yellowTGoods = 0;
+
+        greyItems = 0;
+        whiteItems = 0;
+        greenItems = 0;
+        blueItems = 0;
+        purpleItems = 0;
+        orangeItems = 0;
+        yellowItems = 0;
+    }
+
+    uint32 TotalItemCounts()
+    {
+        return(
+        greyTGoods +
+        whiteTGoods +
+        greenTGoods +
+        blueTGoods +
+        purpleTGoods +
+        orangeTGoods +
+        yellowTGoods +
+
+        greyItems +
+        whiteItems +
+        greenItems +
+        blueItems +
+        purpleItems +
+        orangeItems +
+        yellowItems);
+    }
+
+    uint32 GetItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            return whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            return greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            return blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            return greyItems;
+            break;
+        case AHB_WHITE_I:
+            return whiteItems;
+            break;
+        case AHB_GREEN_I:
+            return greenItems;
+            break;
+        case AHB_BLUE_I:
+            return blueItems;
+            break;
+        case AHB_PURPLE_I:
+            return purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return yellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+class AuctionHouseBot
+{
+private:
+
+    bool debug_Out;
+    bool debug_Out_Filters;
+
+    bool AHBSeller;
+    bool AHBBuyer;
+    bool BuyMethod;
+    bool SellMethod;
+
+    uint32 AHBplayerAccount;
+    uint32 AHBplayerGUID;
+    uint32 ItemsPerCycle;
+
+    //Begin Filters
+
+    bool Vendor_Items;
+    bool Loot_Items;
+    bool Other_Items;
+    bool Vendor_TGs;
+    bool Loot_TGs;
+    bool Other_TGs;
+
+    bool No_Bind;
+    bool Bind_When_Picked_Up;
+    bool Bind_When_Equipped;
+    bool Bind_When_Use;
+    bool Bind_Quest_Item;
+
+    bool DisableBeta_PTR_Unused;
+    bool DisablePermEnchant;
+    bool DisableConjured;
+    bool DisableGems;
+    bool DisableMoney;
+    bool DisableMoneyLoot;
+    bool DisableLootable;
+    bool DisableKeys;
+    bool DisableDuration;
+    bool DisableBOP_Or_Quest_NoReqLevel;
+
+    bool DisableWarriorItems;
+    bool DisablePaladinItems;
+    bool DisableHunterItems;
+    bool DisableRogueItems;
+    bool DisablePriestItems;
+    bool DisableDKItems;
+    bool DisableShamanItems;
+    bool DisableMageItems;
+    bool DisableWarlockItems;
+    bool DisableUnusedClassItems;
+    bool DisableDruidItems;
+
+    uint32 DisableItemsBelowLevel;
+    uint32 DisableItemsAboveLevel;
+    uint32 DisableTGsBelowLevel;
+    uint32 DisableTGsAboveLevel;
+    uint32 DisableItemsBelowGUID;
+    uint32 DisableItemsAboveGUID;
+    uint32 DisableTGsBelowGUID;
+    uint32 DisableTGsAboveGUID;
+    uint32 DisableItemsBelowReqLevel;
+    uint32 DisableItemsAboveReqLevel;
+    uint32 DisableTGsBelowReqLevel;
+    uint32 DisableTGsAboveReqLevel;
+    uint32 DisableItemsBelowReqSkillRank;
+    uint32 DisableItemsAboveReqSkillRank;
+    uint32 DisableTGsBelowReqSkillRank;
+    uint32 DisableTGsAboveReqSkillRank;
+
+	bool SellGlyphs;
+	uint32 GlyphsCount;
+	uint32 DisableGlyphBelowLevel;
+	uint32 DisableGlyphAboveLevel;
+	uint32 GlyphBuyOutPriceMin;
+	uint32 GlyphBuyOutPriceMax;
+	uint32 GlyphBidPriceMin;
+	uint32 GlyphBidPriceMax;
+
+    //End Filters
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+    friend class ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>;
+    AuctionHouseBot();
+
+public:
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void LoadValues(AHBConfig*);
+    void DecrementItemCounts(AuctionEntry* ah, uint32 item_template);
+    void IncrementItemCounts(AuctionEntry* ah);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return AHBplayerGUID; };
+};
+
+#define auctionbot (*ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index e7504b4..4044d04 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -217,7 +217,7 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         uint32 profit = auction->bid + auction->deposit - auctionCut;
 
         //FIXME: what do if owner offline
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
         {
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
@@ -247,7 +247,7 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
         std::ostringstream subject;
         subject << auction->item_template << ":0:" << AUCTION_EXPIRED << ":0:0";
 
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
             owner->GetSession()->SendAuctionOwnerNotification(auction);
 
         MailDraft(subject.str(), "")                        // TODO: fix body
@@ -272,6 +272,9 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry* auction, uint32 new
         std::ostringstream msgAuctionOutbiddedSubject;
         msgAuctionOutbiddedSubject << auction->item_template << ":0:" << AUCTION_OUTBIDDED << ":0:0";
 
+        if (oldBidder && !newBidder)
+            oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
+
         if (oldBidder && newBidder)
             oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, newBidder->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
 
@@ -462,8 +465,10 @@ void AuctionHouseObject::AddAuction(AuctionEntry* auction)
     sScriptMgr->OnAuctionAdd(this, auction);
 }
 
-bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 /*item_template*/)
+bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 item_template)
 {
+    auctionbot.DecrementItemCounts(auction, item_template);
+
     bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
 
     sScriptMgr->OnAuctionRemove(this, auction);
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.h b/src/server/game/AuctionHouse/AuctionHouseMgr.h
index f81393b..21d880a 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.h
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.h
@@ -25,6 +25,8 @@
 #include "DatabaseEnv.h"
 #include "DBCStructure.h"
 
+#include "AuctionHouseBot/AuctionHouseBot.h"
+
 class Item;
 class Player;
 class WorldPacket;
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 117a8f6..2dd45de 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -17,9 +17,11 @@ file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
 file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
+file(GLOB_RECURSE sources_CityConquest CityConquest/*.cpp CityConquest/*.h)
 file(GLOB_RECURSE sources_Combat Combat/*.cpp Combat/*.h)
 file(GLOB_RECURSE sources_Conditions Conditions/*.cpp Conditions/*.h)
 file(GLOB_RECURSE sources_DataStores DataStores/*.cpp DataStores/*.h)
@@ -47,6 +49,7 @@ file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
 file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
 file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
 file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
+file(GLOB_RECURSE sources_TriniChat TriniChat/*.cpp TriniChat/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
 
@@ -66,9 +69,11 @@ set(game_STAT_SRCS
   ${sources_Addons}
   ${sources_AI}
   ${sources_AuctionHouse}
+  ${sources_AuctionHouseBot}
   ${sources_Battlegrounds}
   ${sources_Calendar}
   ${sources_Chat}
+  ${sources_CityConquest}
   ${sources_Combat}
   ${sources_Conditions}
   ${sources_DataStores}
@@ -87,6 +92,7 @@ set(game_STAT_SRCS
   ${sources_Movement}
   ${sources_OutdoorPvP}
   ${sources_Pools}
+  ${sources_PlayerBots}
   ${sources_Quests}
   ${sources_Reputation}
   ${sources_Scripting}
@@ -96,6 +102,7 @@ set(game_STAT_SRCS
   ${sources_Texts}
   ${sources_Tools}
   ${sources_Tickets}
+  ${sources_TriniChat}
   ${sources_Weather}
   ${sources_World}
 )
@@ -129,13 +136,16 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/PlayerBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
   ${CMAKE_CURRENT_SOURCE_DIR}/Chat
+  ${CMAKE_CURRENT_SOURCE_DIR}/CityConquest
   ${CMAKE_CURRENT_SOURCE_DIR}/Chat/Channels
   ${CMAKE_CURRENT_SOURCE_DIR}/Chat/Commands
   ${CMAKE_CURRENT_SOURCE_DIR}/Combat
@@ -187,9 +197,11 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Texts
   ${CMAKE_CURRENT_SOURCE_DIR}/Tools
   ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
+  ${CMAKE_CURRENT_SOURCE_DIR}/TriniChat
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
   ${CMAKE_CURRENT_SOURCE_DIR}/World
   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
@@ -207,3 +219,4 @@ if( USE_COREPCH )
     add_native_precompiled_header(game ${CMAKE_CURRENT_SOURCE_DIR}/PrecompiledHeaders/gamePCH)
   endif()
 endif()
+
diff --git a/src/server/game/Chat/Channels/Channel.cpp b/src/server/game/Chat/Channels/Channel.cpp
index b6e9dd3..157b8c7 100755
--- a/src/server/game/Chat/Channels/Channel.cpp
+++ b/src/server/game/Chat/Channels/Channel.cpp
@@ -23,6 +23,7 @@
 #include "World.h"
 #include "DatabaseEnv.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 Channel::Channel(const std::string& name, uint32 channel_id, uint32 Team)
  : m_announce(true), m_ownership(true), m_name(name), m_password(""), m_flags(0), m_channelId(channel_id), m_ownerGUID(0), m_Team(Team)
@@ -202,6 +203,8 @@ void Channel::Join(uint64 p, const char *pass)
 
     JoinNotify(p);
 
+	sIRC.Handle_WoW_Channel(m_name, ObjectAccessor::FindPlayer(p), CHANNEL_JOIN);
+
     // Custom channel handling
     if (!IsConstant())
     {
@@ -253,6 +256,7 @@ void Channel::Leave(uint64 p, bool send)
             SendToAll(&data);
         }
 
+		sIRC.Handle_WoW_Channel(m_name, ObjectAccessor::FindPlayer(p), CHANNEL_LEAVE);
         LeaveNotify(p);
 
         if (!IsConstant())
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 91ccb42..a52ce60 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -216,7 +216,15 @@ ChatCommand* ChatHandler::getCommandTable()
         { "write",          SEC_ADMINISTRATOR,  true,  OldHandler<&ChatHandler::HandlePDumpWriteCommand>,          "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
-
+    // Playerbot mod start:
+    static ChatCommand questCommandTable[] =
+    {
+        { "add",            SEC_ADMINISTRATOR,  false, NULL,                                                       "", NULL },
+        { "complete",       SEC_ADMINISTRATOR,  false, NULL,                                                       "", NULL },
+        { "remove",         SEC_ADMINISTRATOR,  false, NULL,                                                       "", NULL },
+        { NULL,             0,                  false, NULL,                                           "", NULL }
+    };
+    // Playerbot mod end.
     static ChatCommand resetCommandTable[] =
     {
         { "achievements",   SEC_ADMINISTRATOR,  true,  OldHandler<&ChatHandler::HandleResetAchievementsCommand>,   "", NULL },
@@ -329,6 +337,17 @@ ChatCommand* ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                                "", NULL }
     };
 
+    static ChatCommand wintergraspCommandTable[] =
+    {
+        { "status",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStatusCommand>,       "", NULL },
+        { "enable",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspEnableCommand>,       "", NULL },
+        { "start",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStartCommand>,        "", NULL },
+        { "stop",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStopCommand>,         "", NULL },
+        { "switch",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspSwitchTeamCommand>,   "", NULL },
+        { "timer",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspTimerCommand>,        "", NULL },
+        { NULL,             0,                  false, NULL,                                               "", NULL }
+    };
+
     static ChatCommand commandTable[] =
     {
         { "character",      SEC_GAMEMASTER,     true,  NULL,                                           "", characterCommandTable},
@@ -345,7 +364,13 @@ ChatCommand* ChatHandler::getCommandTable()
 
         { "pet",            SEC_GAMEMASTER,     false, NULL,                                           "", petCommandTable },
         { "ticket",         SEC_MODERATOR,      false,  NULL,                                          "", ticketCommandTable },
-
+        { "ahbotoptions",   SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleAHBotOptionsCommand>,        "", NULL },
+	     // Jail by WarHead Edited by LordPsyan
+        { "jail",           SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleJailCommand>,                "", NULL },
+        { "jailinfo",       SEC_PLAYER,         false, OldHandler<&ChatHandler::HandleJailInfoCommand>,            "", NULL },
+        { "unjail",         SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleUnJailCommand>,              "", NULL },
+        { "jailreload",     SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleJailReloadCommand>,          "", NULL },
+        
         { "aura",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleAuraCommand>,                "", NULL },
         { "unaura",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnAuraCommand>,              "", NULL },
         { "nameannounce",   SEC_MODERATOR,      true,  OldHandler<&ChatHandler::HandleNameAnnounceCommand>,        "", NULL },
@@ -404,7 +429,9 @@ ChatCommand* ChatHandler::getCommandTable()
         { "flusharenapoints", SEC_ADMINISTRATOR, false, OldHandler<&ChatHandler::HandleFlushArenaPointsCommand>,    "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleRepairitemsCommand>,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, OldHandler<&ChatHandler::HandleWaterwalkCommand>,           "", NULL },
-
+        // Playerbot mod start:
+        { "bot",            SEC_PLAYER,         false, OldHandler<&ChatHandler::HandlePlayerbotCommand>,           "", NULL },
+        // Playerbot mod end.
         { "freeze",         SEC_MODERATOR,  false, OldHandler<&ChatHandler::HandleFreezeCommand>,              "", NULL },
         { "unfreeze",       SEC_MODERATOR,  false, OldHandler<&ChatHandler::HandleUnFreezeCommand>,            "", NULL },
         { "listfreeze",     SEC_MODERATOR,  false, OldHandler<&ChatHandler::HandleListFreezeCommand>,          "", NULL },
@@ -414,6 +441,8 @@ ChatCommand* ChatHandler::getCommandTable()
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+        { "wg",             SEC_ADMINISTRATOR,  false, NULL,                                 "", wintergraspCommandTable },
+		{ "tcrecon",        SEC_MODERATOR,      true,  OldHandler<&ChatHandler::HandleIRCRelogCommand>,            "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -707,6 +736,15 @@ bool ChatHandler::ExecuteCommandInTable(ChatCommand* table, const char* text, co
                     sLog->outCommand(m_session->GetAccountId(), "Command: %s [Player: %s (Account: %u) X: %f Y: %f Z: %f Map: %u Selected %s: %s (GUID: %u)]",
                         fullcmd.c_str(), p->GetName(), m_session->GetAccountId(), p->GetPositionX(), p->GetPositionY(), p->GetPositionZ(), p->GetMapId(),
                         GetLogNameForGuid(sel_guid), (p->GetSelectedUnit()) ? p->GetSelectedUnit()->GetName() : "", GUID_LOPART(sel_guid));
+
+					if ((sIRC.logmask & 2) != 0)
+                    {
+                        std::string logchan = "#";
+                        logchan += sIRC.logchan;
+                        std::stringstream ss;
+                        ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << p->GetName() << "(" << p->GetSession()->GetSecurity() << ") ] Used Command: [ " << fullcmd << " ] Target: [" << GUID_LOPART(sel_guid) << "]";
+                        sIRC.Send_IRC_Channel(logchan,ss.str().c_str(), true, "LOG");
+                    }
                 }
             }
         }
@@ -1215,6 +1253,381 @@ char* ChatHandler::extractKeyFromLink(char* text, char const* const* linkTypes,
     return NULL;
 }
 
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+// Playerbot mod start:
+/**
+ * Function extract name-like string (from non-numeric or special symbol until whitespace)
+ *
+ * @param args variable pointer to non parsed args string, updated at function call to new position (with skipped white spaces)
+ * @param lit  optional explicit literal requirement. function fail if literal is not starting substring of lit.
+ *             Note: function in same way fail if no any literal or literal not fit in this case. Need additional check for select specific fail case
+ * @return     name/number-like string without whitespaces, or NULL if args empty or not appropriate content.
+ */
+char* ChatHandler::ExtractLiteralArg(char** args, char const* lit /*= NULL*/)
+{
+    if (!*args || !**args)
+        return NULL;
+
+    char* head = *args;
+
+    // reject quoted string or link (|-started text)
+    switch (head[0])
+    {
+        // reject quoted string
+        case '[': case '\'': case '"':
+            return NULL;
+        // reject link (|-started text)
+        case '|':
+            // client replace all | by || in raw text
+            if (head[1] != '|')
+                return NULL;
+            ++head;                                         // skip one |
+            break;
+        default: break;
+    }
+
+    if (lit)
+    {
+        int l = strlen(lit);
+
+        int largs = 0;
+        while(head[largs] && !isWhiteSpace(head[largs]))
+            ++largs;
+
+        if (largs < l)
+            l = largs;
+
+        int diff = strncmp(head, lit, l);
+
+        if (diff != 0)
+            return NULL;
+
+        if (head[l] && !isWhiteSpace(head[l]))
+            return NULL;
+
+        char* arg = head;
+
+        if (head[l])
+        {
+            head[l] = '\0';
+
+            head += l + 1;
+
+            *args = head;
+        }
+        else
+            *args = head + l;
+
+        SkipWhiteSpaces(args);
+        return arg;
+    }
+
+    char* name = strtok(head, " ");
+
+    char* tail = strtok(NULL, "");
+
+    *args = tail ? tail : (char*)"";                        // *args don't must be NULL
+
+    SkipWhiteSpaces(args);
+
+    return name;
+}
+
+void ChatHandler::SkipWhiteSpaces(char** args)
+{
+    if(!*args)
+        return;
+
+    while(isWhiteSpace(**args))
+        ++(*args);
+}
+
+char* ChatHandler::ExtractQuotedOrLiteralArg(char** args, bool asis /*= false*/)
+{
+    char *arg = ExtractQuotedArg(args, asis);
+    if (!arg)
+        arg = ExtractLiteralArg(args);
+    return arg;
+}
+
+char* ChatHandler::ExtractLinkArg(char** args, char const* const* linkTypes /*= NULL*/, int* foundIdx /*= NULL*/, char** keyPair /*= NULL*/, char** somethingPair /*= NULL*/)
+{
+    if (!*args || !**args)
+        return NULL;
+
+    // skip if not linked started or encoded single | (doubled by client)
+    if ((*args)[0] != '|' || (*args)[1] == '|')
+        return NULL;
+
+    // |color|Hlinktype:key:data...|h[name]|h|r
+
+    char* head = *args;
+
+    // [name] Shift-click form |color|linkType:key|h[name]|h|r
+    // or
+    // [name] Shift-click form |color|linkType:key:something1:...:somethingN|h[name]|h|r
+    // or
+    // [name] Shift-click form |linkType:key|h[name]|h|r
+
+    // |color|Hlinktype:key:data...|h[name]|h|r
+
+    char* tail = (*args)+1;                                 // skip |
+
+    if (*tail != 'H')                                       // skip color part, some links can not have color part
+    {
+        while (*tail && *tail != '|')
+            ++tail;
+
+        if (!*tail)
+            return NULL;
+
+        // |Hlinktype:key:data...|h[name]|h|r
+
+        ++tail;                                             // skip |
+    }
+
+    // Hlinktype:key:data...|h[name]|h|r
+
+    if (*tail != 'H')
+        return NULL;
+
+    int linktype_idx = 0;
+
+    if (linkTypes)                                          // check link type if provided
+    {
+        // check linktypes (its include H in name)
+        for (; linkTypes[linktype_idx]; ++linktype_idx)
+        {
+            // exactly string with follow : or |
+            int l = strlen(linkTypes[linktype_idx]);
+            if (strncmp(tail, linkTypes[linktype_idx], l) == 0 &&
+                (tail[l] == ':' || tail[l] == '|'))
+                break;
+        }
+
+        // is search fail?
+        if (!linkTypes[linktype_idx])                       // NULL terminator in last element
+            return NULL;
+
+        tail += strlen(linkTypes[linktype_idx]);            // skip linktype string
+
+        // :key:data...|h[name]|h|r
+
+        if (*tail != ':')
+            return NULL;
+    }
+    else
+    {
+        while (*tail && *tail != ':')                       // skip linktype string
+            ++tail;
+
+        if (!*tail)
+            return NULL;
+    }
+
+    ++tail;
+
+    // key:data...|h[name]|h|r
+    char* keyStart = tail;                                  // remember key start for return
+    char* keyEnd   = tail;                                  // key end for truncate, will updated
+
+    while (*tail && *tail != '|' && *tail != ':')
+        ++tail;
+
+    if (!*tail)
+        return NULL;
+
+    keyEnd = tail;                                          // remember key end for truncate
+
+    // |h[name]|h|r or :something...|h[name]|h|r
+
+    char* somethingStart = tail+1;
+    char* somethingEnd   = tail+1;                          // will updated later if need
+
+    if (*tail == ':' && somethingPair)                      // optional data extraction
+    {
+        // :something...|h[name]|h|r
+
+        if (*tail == ':')
+            ++tail;
+
+        // something|h[name]|h|r or something:something2...|h[name]|h|r
+
+        while (*tail && *tail != '|' && *tail != ':')
+            ++tail;
+
+        if (!*tail)
+            return NULL;
+
+        somethingEnd = tail;                                // remember data end for truncate
+    }
+
+    // |h[name]|h|r or :something2...|h[name]|h|r
+
+    while (*tail && (*tail != '|' || *(tail+1) != 'h'))     // skip ... part if exist
+        ++tail;
+
+    if (!*tail)
+        return NULL;
+
+    // |h[name]|h|r
+
+    tail += 2;                                              // skip |h
+
+    // [name]|h|r
+    if (!*tail || *tail != '[')
+        return NULL;
+
+    while (*tail && (*tail != ']' || *(tail+1) != '|'))     // skip name part
+        ++tail;
+
+    tail += 2;                                              // skip ]|
+
+    // h|r
+    if (!*tail || *tail != 'h'  || *(tail+1) != '|')
+        return NULL;
+
+    tail += 2;                                              // skip h|
+
+    // r
+    if (!*tail || *tail != 'r' || (*(tail+1) && !isWhiteSpace(*(tail+1))))
+        return NULL;
+
+    ++tail;                                                 // skip r
+
+    // success
+
+    if (*tail)                                              // truncate all link string
+        *(tail++) = '\0';
+
+    if (foundIdx)
+        *foundIdx = linktype_idx;
+
+    if (keyPair)
+    {
+        keyPair[0] = keyStart;
+        keyPair[1] = keyEnd;
+    }
+
+    if (somethingPair)
+    {
+        somethingPair[0] = somethingStart;
+        somethingPair[1] = somethingEnd;
+    }
+
+    *args = tail;
+
+    SkipWhiteSpaces(args);
+
+    return head;
+}
+
+char* ChatHandler::ExtractQuotedArg(char** args, bool asis /*= false*/ )
+{
+    if (!*args || !**args)
+        return NULL;
+
+    if (**args != '\'' && **args != '"' && **args != '[')
+        return NULL;
+
+    char guard = (*args)[0];
+
+    if (guard == '[')
+        guard = ']';
+
+    char* tail = (*args)+1;                                 // start scan after first quote symbol
+    char* head = asis ? *args : tail;                       // start arg
+
+    while (*tail && *tail != guard)
+        ++tail;
+
+    if (!*tail || (tail[1] && !isWhiteSpace(tail[1])))      // fail
+        return NULL;
+
+    if (!tail[1])                                           // quote is last char in string
+    {
+        if (!asis)
+            *tail = '\0';
+    }
+    else                                                    // quote isn't last char
+    {
+        if (asis)
+            ++tail;
+
+        *tail = '\0';
+    }
+
+    *args = tail+1;
+
+    SkipWhiteSpaces(args);
+
+    return head;
+}
+
+bool  ChatHandler::ExtractUInt32Base(char** args, uint32& val, uint32 base)
+{
+    if (!*args || !**args)
+        return false;
+
+    char* tail = *args;
+
+    unsigned long valRaw = strtoul(*args, &tail, base);
+
+    if (tail != *args && isWhiteSpace(*tail))
+        *(tail++) = '\0';
+    else if (tail && *tail)                                 // some not whitespace symbol
+        return false;                                       // args not modified and can be re-parsed
+
+    if (valRaw > std::numeric_limits<uint32>::max())
+        return false;
+
+    // value successfully extracted
+    val = uint32(valRaw);
+    *args = tail;
+
+    SkipWhiteSpaces(args);
+    return true;
+}
+
+bool ChatHandler::ExtractUint32KeyFromLink(char** text, char const* linkType, uint32& value)
+{
+    char* arg = extractKeyFromLink((char*)text, linkType);
+    if (!arg)
+        return false;
+
+    return ExtractUInt32(&arg, value);
+}
+// Playerbot mod end.
 GameObject* ChatHandler::GetNearbyGameObject()
 {
     if (!m_session)
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 2311f4b..e74ddcc 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -21,6 +21,7 @@
 
 #include "SharedDefines.h"
 #include "Player.h"
+#include "../TriniChat/IRCClient.h"
 
 #include <vector>
 
@@ -101,7 +102,18 @@ class ChatHandler
 
         char*     extractKeyFromLink(char* text, char const* linkType, char** something1 = NULL);
         char*     extractKeyFromLink(char* text, char const* const* linkTypes, int* found_idx, char** something1 = NULL);
-
+        // Playerbot mod start:
+        void  SkipWhiteSpaces(char** args);
+        char* ExtractQuotedOrLiteralArg(char** args, bool asis = false);
+        char* ExtractLinkArg(char** args, char const* const* linkTypes = NULL, int* foundIdx = NULL, char** keyPair = NULL, char** somethingPair = NULL);
+        bool  ExtractUint32KeyFromLink(char** text, char const* linkType, uint32& value);
+        bool  ExtractUInt32Base(char** args, uint32& val, uint32 base);
+        bool  ExtractUInt32(char** args, uint32& val) { return ExtractUInt32Base(args,val, 10); }
+        char* ExtractQuotedArg(char** args, bool asis = false);
+                                                            // string with " or [] or ' around
+        char* ExtractLiteralArg(char** args, char const* lit = NULL);
+                                                            // literal string (until whitespace and not started from "['|), any or 'lit' if provided
+        // Playerbot mod end.
         // if args have single value then it return in arg2 and arg1 == NULL
         void      extractOptFirstArg(char* args, char** arg1, char** arg2);
         char*     extractQuotedArg(char* args);
@@ -131,6 +143,7 @@ class ChatHandler
         bool ShowHelpForCommand(ChatCommand* table, const char* cmd);
         bool ShowHelpForSubCommands(ChatCommand* table, char const* cmd, char const* subcmd);
 
+        bool HandleAHBotOptionsCommand(const char * args);
         bool HandleNameAnnounceCommand(const char* args);
         bool HandleGMNameAnnounceCommand(const char* args);
         bool HandleGMAnnounceCommand(const char* args);
@@ -210,7 +223,11 @@ class ChatHandler
 
         bool HandlePDumpLoadCommand(const char *args);
         bool HandlePDumpWriteCommand(const char *args);
-
+        // Playerbot mod start
+        bool HandleQuestAddCommand(char* args);
+        bool HandleQuestRemoveCommand(char* args);
+        bool HandleQuestCompleteCommand(char* args);
+        // Playerbot mod end.
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
         bool HandleResetHonorCommand(const char * args);
@@ -223,6 +240,7 @@ class ChatHandler
         bool HandleSendMailCommand(const char* args);
         bool HandleSendMessageCommand(const char * args);
         bool HandleSendMoneyCommand(const char* args);
+		bool HandleIRCpmCommand(const char* args);
 
         bool HandleServerCorpsesCommand(const char* args);
         bool HandleServerExitCommand(const char* args);
@@ -288,6 +306,7 @@ class ChatHandler
         bool HandleExploreCheatCommand(const char* args);
         bool HandleHoverCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
+        bool HandlePlayerbotCommand(const char* args);
         bool HandleLevelUpCommand(const char* args);
         bool HandleShowAreaCommand(const char* args);
         bool HandleHideAreaCommand(const char* args);
@@ -335,8 +354,15 @@ class ChatHandler
         bool HandleSendMessageCommand(const char * args);*/
 
         bool HandleFlushArenaPointsCommand(const char *args);
+        // Jail by WarHead Edited by spgm
+        bool HandleJailCommand(const char* args);
+		bool HandleJailInfoCommand(const char* args);
+		bool HandleUnJailCommand(const char* args);
+		bool HandleJailReloadCommand(const char* args);
+		
         bool HandlePlayAllCommand(const char* args);
         bool HandleRepairitemsCommand(const char* args);
+		bool HandleIRCRelogCommand(const char *args);
 
         bool HandleTempGameObjectCommand(const char* args);
 
@@ -358,6 +384,14 @@ class ChatHandler
         void HandleCharacterLevel(Player* player, uint64 playerGuid, uint32 oldLevel, uint32 newLevel);
         void HandleLearnSkillRecipesHelper(Player* player, uint32 skill_id);
 
+        //Wintergrasp
+        bool HandleWintergraspStatusCommand(const char *args);
+        bool HandleWintergraspStartCommand(const char *args);
+        bool HandleWintergraspStopCommand(const char *args);
+        bool HandleWintergraspEnableCommand(const char *args);
+        bool HandleWintergraspSwitchTeamCommand(const char *args);
+        bool HandleWintergraspTimerCommand(const char *args);
+
         // Stores informations about a deleted character
         struct DeletedInfo
         {
@@ -404,4 +438,8 @@ class CliHandler : public ChatHandler
         Print* m_print;
 };
 
+char const *fmtstring(char const *format, ...);
+
+char const *fmtstring(char const *format, ...);
+
 #endif
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 6d33a57..3e91d9a 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -28,6 +28,7 @@
 #include "SystemConfig.h"
 #include "revision.h"
 #include "Util.h"
+#include "math.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -54,6 +55,13 @@ bool ChatHandler::HandleCommandsCommand(const char* /*args*/)
 
 bool ChatHandler::HandleStartCommand(const char* /*args*/)
 {
+    // Jail mod start:
+    if (m_session->GetPlayer()->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+    // Jail mod end.  
     Player* chr = m_session->GetPlayer();
 
     if (chr->isInFlight())
@@ -78,7 +86,7 @@ bool ChatHandler::HandleStartCommand(const char* /*args*/)
     }
 
     // cast spell Stuck
-    chr->CastSpell(chr, 7355, false);
+    chr->CastSpell(chr, 8690, false);
     return true;
 }
 
@@ -130,7 +138,14 @@ bool ChatHandler::HandleDismountCommand(const char* /*args*/)
 bool ChatHandler::HandleSaveCommand(const char* /*args*/)
 {
     Player* player = m_session->GetPlayer();
-
+    
+		// Jail by WarHead edited by LordPsyan
+    if (player->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+  
     // save GM account without delay and output message
     if (!AccountMgr::IsPlayerAccount(m_session->GetSecurity()))
     {
@@ -156,4 +171,38 @@ bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
     PSendSysMessage(LANG_MOTD_CURRENT, sWorld->GetMotd());
     return true;
 }
+	//Trinity Jail Edited by spgm
+bool ChatHandler::HandleJailInfoCommand(const char* args)
+{
+    time_t localtime;
+    localtime = time(NULL);
+    Player *chr = m_session->GetPlayer();
+
+    if (chr->m_jail_release > 0)
+    {
+        uint32 min_left = (uint32)floor(float(chr->m_jail_release - localtime) / 60);
+
+        if (min_left <= 0)
+        {
+            chr->m_jail_release = 0;
+            chr->_SaveJail();
+            SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+            return true;
+        }
+        else
+        {
+            if (min_left >= 60) PSendSysMessage(LANG_JAIL_JAILED_H_INFO, (uint32)floor(float(chr->m_jail_release - localtime) / 60 / 60));
+            else PSendSysMessage(LANG_JAIL_JAILED_M_INFO, min_left);
+            PSendSysMessage(LANG_JAIL_REASON, chr->m_jail_gmchar.c_str(), chr->m_jail_reason.c_str());
+
+            return true;
+        }
+    }
+    else
+    {
+        SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+        return true;
+    }
+    return false;
+}
 
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index 57d5e8c..24af1e8 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -35,6 +35,7 @@
 #include "InstanceSaveMgr.h"
 #include "Util.h"
 #include "Group.h"
+#include "IRCClient.h"
 
 #ifdef _DEBUG_VMAPS
 #include "VMapFactory.h"
@@ -74,6 +75,13 @@ bool ChatHandler::HandleAnnounceCommand(const char* args)
     if (!*args)
         return false;
 
+  if ((sIRC.BOTMASK & 256) != 0)
+    {
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+        sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s", "%s", args), true);
+    }
+
     char buff[2048];
     sprintf(buff, GetTrinityString(LANG_SYSTEMMESSAGE), args);
     sWorld->SendServerMessage(SERVER_MSG_STRING, buff);
@@ -103,6 +111,13 @@ bool ChatHandler::HandleNotifyCommand(const char* args)
     data << str;
     sWorld->SendGlobalMessage(&data);
 
+  if ((sIRC.BOTMASK & 256) != 0)
+    {
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+        sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s", "%s", args), true);
+    }
+
     return true;
 }
 
@@ -630,6 +645,292 @@ bool ChatHandler::HandleSaveAllCommand(const char* /*args*/)
     return true;
 }
 
+// Jail by WarHead edited by spgm
+bool ChatHandler::HandleJailCommand(const char *args)
+{
+    std::string cname, announce, ban_reason, ban_by;
+    time_t localtime;
+    localtime = time(NULL);
+
+    char *charname = strtok((char*)args, " ");
+    if (charname == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NONAME);
+        return true;
+    } else cname = charname;
+
+    char *timetojail = strtok(NULL, " ");
+    if (timetojail == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NOTIME);
+        return true;
+    }
+
+    uint32 jailtime = (uint32) atoi((char*)timetojail);
+    if (jailtime < 1 || jailtime > sObjectMgr->m_jailconf_max_duration)
+    {
+        PSendSysMessage(LANG_JAIL_VALUE, sObjectMgr->m_jailconf_max_duration);
+        return true;
+    }
+
+    char *reason = strtok(NULL, "\0");
+    std::string jailreason;
+    if (reason == NULL || strlen((const char*)reason) < sObjectMgr->m_jailconf_min_reason)
+    {
+        PSendSysMessage(LANG_JAIL_NOREASON, sObjectMgr->m_jailconf_min_reason);
+        return true;
+    } else jailreason = reason;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    if (GUID == 0)
+    {
+        SendSysMessage(LANG_JAIL_WRONG_NAME);
+        return true;
+    }
+
+    Player *chr = ObjectAccessor::FindPlayer(GUID);
+    if (!chr)
+    {
+		uint32 jail_guid = GUID_LOPART(GUID);
+		std::string jail_char = cname;
+		bool jail_isjailed = true;
+		uint32 jail_release = localtime + (jailtime * 60 * 60);
+		uint32 jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		std::string jail_reason = jailreason;
+		uint32 jail_times = 0;
+
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", jail_guid);
+		CharacterDatabase.CommitTransaction(trans);
+
+        if (!result)
+        {
+            jail_times = 1;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            jail_times = fields[5].GetUInt32()+1;
+        }
+
+        uint32 jail_gmacc = m_session->GetAccountId();
+        std::string jail_gmchar = m_session->GetPlayerName();
+
+        SQLTransaction trans2 = CharacterDatabase.BeginTransaction();
+		if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u','%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", jail_guid, jail_char.c_str(), jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime);
+        else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime, jail_guid);
+        CharacterDatabase.CommitTransaction(trans2);
+
+        PSendSysMessage(LANG_JAIL_WAS_JAILED, cname.c_str(), jailtime);
+
+        announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+        announce += cname;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+        announce += m_session->GetPlayerName();
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+        announce += jail_reason;
+
+        HandleAnnounceCommand(announce.c_str());
+
+        if ((sObjectMgr->m_jailconf_max_jails == jail_times) && !sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+
+            Field *fields = result->Fetch();
+
+            Player::DeleteFromDB(GUID, fields[1].GetUInt32());
+        }
+        else if ((sObjectMgr->m_jailconf_max_jails == jail_times) && sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            Field *fields = result->Fetch();
+            uint32 acc_id = fields[1].GetUInt32();
+
+            SQLTransaction trans2 = LoginDatabase.BeginTransaction();
+            result = LoginDatabase.PQuery("SELECT * FROM `account` WHERE `id`='%u' LIMIT 1", acc_id);
+            LoginDatabase.CommitTransaction(trans2);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+            ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+            SQLTransaction trans3 = LoginDatabase.BeginTransaction();
+            LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+            LoginDatabase.CommitTransaction(trans3);
+
+        }
+        return true;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+
+    if (chr->GetName() == m_session->GetPlayerName())
+    {
+        SendSysMessage(LANG_JAIL_NO_JAIL);
+        return true;
+    }
+
+		chr->SaveToDB();
+
+		chr->m_jail_guid = fields[0].GetUInt32();
+		chr->m_jail_char = fields[3].GetString();
+		chr->m_jail_isjailed = true;
+		chr->m_jail_release = localtime + (jailtime * 60 * 60);
+		chr->m_jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		chr->m_jail_reason = jailreason;
+		chr->m_jail_times = chr->m_jail_times+1;
+		chr->m_jail_gmacc = m_session->GetAccountId();
+		chr->m_jail_gmchar = m_session->GetPlayerName();
+		chr->m_jail_duration = jailtime;
+
+		chr->_SaveJail();
+
+		PSendSysMessage(LANG_JAIL_WAS_JAILED, fields[3].GetString().c_str(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_JAILED, m_session->GetPlayerName(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_REASON, m_session->GetPlayerName(), jailreason.c_str());
+
+		announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+		announce += fields[3].GetString();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+		announce += timetojail;
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+		announce += m_session->GetPlayerName();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+		announce += chr->m_jail_reason;
+
+		HandleAnnounceCommand(announce.c_str());
+
+    if (sObjectMgr->m_jailconf_max_jails == chr->m_jail_times)
+    {
+        chr->GetSession()->KickPlayer();
+        chr->DeleteFromDB(fields[0].GetUInt64(), fields[1].GetUInt32());
+    }
+    else if ((sObjectMgr->m_jailconf_max_jails == chr->m_jail_times) && sObjectMgr->m_jailconf_ban)
+    {
+        uint32 acc_id = chr->GetSession()->GetAccountId();
+        ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+        ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+		SQLTransaction trans = LoginDatabase.BeginTransaction();
+        LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+        LoginDatabase.CommitTransaction(trans);
+
+        chr->GetSession()->LogoutPlayer(false);
+    }
+    else chr->GetSession()->LogoutPlayer(false);
+    return true;
+}
+
+bool ChatHandler::HandleUnJailCommand(const char *args)
+{
+    char *charname = strtok((char*)args, " ");
+    std::string cname;
+
+    if (charname == NULL) return false;
+    else cname = charname;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    Player *chr = ObjectAccessor::FindPlayer(GUID);
+
+    if (chr)
+    {
+        if (chr->GetName() == m_session->GetPlayerName())
+        {
+            SendSysMessage(LANG_JAIL_NO_UNJAIL);
+            return true;
+        }
+
+        if (chr->m_jail_isjailed)
+        {
+            chr->m_jail_isjailed = false;
+            chr->m_jail_release = 0;
+            chr->m_jail_times = chr->m_jail_times-1;
+
+            chr->_SaveJail();
+
+            if (chr->m_jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_UNJAILED, m_session->GetPlayerName());    
+            chr->CastSpell(chr,8690,false);
+            //chr->GetSession()->LogoutPlayer(false);
+        } else PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+        return true;
+    }
+    else
+    {
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        QueryResult jresult = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+        CharacterDatabase.CommitTransaction(trans);
+
+        if (!jresult)
+        {
+            PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+            return true;
+        }
+        else
+        {
+            Field *fields = jresult->Fetch();
+            uint32 jail_times = fields[4].GetUInt32()-1;
+
+            if (jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+            else
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("UPDATE `jail` SET `release`='0',`times`='%u' WHERE `guid`='%u' LIMIT 1", jail_times, fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            return true;
+        }
+
+    }
+    return true;
+}
+
 //Send mail by command
 bool ChatHandler::HandleSendMailCommand(const char* args)
 {
@@ -766,3 +1067,21 @@ bool ChatHandler::HandleGroupSummonCommand(const char* args)
 
     return true;
 }
+
+bool ChatHandler::HandleIRCpmCommand(const char* args)
+{
+    std::string Msg = args;
+    if (Msg.find(" ") == std::string::npos)
+        return false;
+    std::string To = Msg.substr(0, Msg.find(" "));
+    Msg = Msg.substr(Msg.find(" ") + 1);
+    std::size_t pos;
+    while ((pos = To.find("||")) != std::string::npos)
+    {
+        std::size_t find1 = To.find("||", pos);
+        To.replace(pos, find1 - pos + 2, "|");
+    }    
+    sIRC.SendIRC("PRIVMSG "+To+" : <WoW>["+m_session->GetPlayerName()+"] : " + Msg);
+    sIRC.Send_WoW_Player(m_session->GetPlayer(), "|cffCC4ACCTo ["+To+"]: "+Msg);
+    return true;
+}
diff --git a/src/server/game/Chat/Commands/Level2.cpp b/src/server/game/Chat/Commands/Level2.cpp
index 144a1f8..3288aa4 100755
--- a/src/server/game/Chat/Commands/Level2.cpp
+++ b/src/server/game/Chat/Commands/Level2.cpp
@@ -33,6 +33,8 @@
 #include "PoolMgr.h"
 #include "AccountMgr.h"
 #include "WaypointManager.h"
+#include "WaypointMovementGenerator.h"
+#include "math.h"
 #include "Util.h"
 #include <cctype>
 #include <iostream>
@@ -42,6 +44,7 @@
 #include "Transport.h"
 #include "TargetedMovementGenerator.h"                      // for HandleNpcUnFollowCommand
 #include "CreatureGroups.h"
+#include "OutdoorPvPWG.h"
 
 //mute player for some times
 bool ChatHandler::HandleMuteCommand(const char* args)
@@ -278,7 +281,18 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 mapId;
     uint32 areaId;
     uint32 phase = 0;
-
+    bool p_jail_isjailed;
+    uint32 p_jail_guid;
+    std::string p_jail_char;
+    uint32 p_jail_release;
+    bool p_jail_amnestietime;
+    std::string p_jail_reason;
+    uint32 p_jail_times;
+    uint32 p_jail_gmacc;
+    std::string p_jail_gmchar;
+    std::string p_jail_lasttime;
+    uint32 p_jail_duration;
+    std::string gmname;
 
     // get additional information from Player object
     if (target)
@@ -298,6 +312,18 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         mapId = target->GetMapId();
         areaId = target->GetAreaId();
         phase = target->GetPhaseMask();
+        p_jail_isjailed = target->m_jail_isjailed;
+        p_jail_guid = target->m_jail_guid;
+        p_jail_char = target->m_jail_char;
+        p_jail_release = target->m_jail_release;
+        p_jail_amnestietime = target->m_jail_amnestietime;
+        p_jail_reason = target->m_jail_reason;
+        p_jail_times =  target->m_jail_times;
+        p_jail_gmacc =  target->m_jail_gmacc;
+        p_jail_gmchar = target->m_jail_gmchar;
+        p_jail_lasttime = target->m_jail_lasttime;
+        p_jail_duration = target->m_jail_duration;
+        gmname = target->GetName();
     }
     // get additional information from DB
     else
@@ -310,8 +336,11 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         QueryResult result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account, race, class, map, zone FROM characters "
                                                       "WHERE guid = '%u'", GUID_LOPART(target_guid));
         if (!result)
-            return false;
-
+          {
+              return false;
+        }
+        else
+        {
         Field* fields = result->Fetch();
         total_player_time = fields[0].GetUInt32();
         level = fields[1].GetUInt32();
@@ -321,6 +350,31 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         Class = fields[5].GetUInt8();
         mapId = fields[6].GetUInt16();
         areaId = fields[7].GetUInt16();
+        }
+		
+        QueryResult row = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(target_guid));
+	    
+        if (!row)
+        {
+             p_jail_isjailed = false;
+        }
+        else
+        {
+
+            Field *data = row->Fetch();
+            p_jail_isjailed = true;
+            p_jail_guid = data[0].GetUInt32();
+            p_jail_char = data[1].GetString();
+            p_jail_release = data[2].GetUInt32();
+            p_jail_amnestietime = data[3].GetUInt32();
+            p_jail_reason = data[4].GetString();
+            p_jail_times = data[5].GetUInt32();
+            p_jail_gmacc = data[6].GetUInt32();
+            p_jail_gmchar = data[7].GetString();
+            p_jail_lasttime = data[8].GetString();
+            p_jail_duration = data[9].GetUInt32();
+            gmname = "";
+        }
     }
 
     std::string username = GetTrinityString(LANG_ERROR);
@@ -448,6 +502,39 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     else
         PSendSysMessage(LANG_PINFO_MAP_OFFLINE, map->name[locale], areaName.c_str());
 
+	if (p_jail_times > 0)
+        {
+            if (p_jail_release > 0)
+            {
+                time_t localtime;
+                localtime = time(NULL);
+                uint32 min_left = (uint32)floor(float(p_jail_release - localtime) / 60);
+
+                if (min_left <= 0)
+                {
+                    p_jail_release = 0;
+                    CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u' WHERE `guid`='%u' LIMIT 1", p_jail_release, p_jail_guid);
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+                else
+                {
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, min_left, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+            }
+            else
+            {
+                PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                return true;
+            }
+        }
+        else
+        {
+            PSendSysMessage(LANG_JAIL_GM_NOINFO, gmname.c_str());
+            return true;
+        }
+        
     return true;
 }
 
@@ -1025,6 +1112,151 @@ bool ChatHandler::HandlePetUnlearnCommand(const char *args)
     return true;
 }
 
+bool ChatHandler::HandleWintergraspStatusCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+   if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    PSendSysMessage(LANG_BG_WG_STATUS, sObjectMgr->GetTrinityStringForDBCLocale(
+        pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE),
+        secsToTimeString(pvpWG->GetTimer(), true).c_str(),
+        pvpWG->isWarTime() ? "Yes" : "No",
+        pvpWG->GetNumPlayersH(),
+        pvpWG->GetNumPlayersA());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStartCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStartBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_START);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStopCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStopBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_STOP);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspEnableCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!strncmp(args, "on", 3))
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, true);
+        }
+        PSendSysMessage(LANG_BG_WG_ENABLE);
+        return true;
+    }
+    else if (!strncmp(args, "off", 4))
+    {
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, false);
+        }
+        PSendSysMessage(LANG_BG_WG_DISABLE);
+        return true;
+    }
+    else
+    {
+        SendSysMessage(LANG_USE_BOL);
+        SetSentErrorMessage(true);
+        return false;
+    }
+}
+
+bool ChatHandler::HandleWintergraspTimerCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    int32 time = atoi (args);
+
+    // Min value 1 min
+    if (1 > time)
+        time = 1;
+    // Max value during wartime = 60. No wartime = 1440 (day)
+    if (pvpWG->isWarTime())
+    {
+        if (60 < time)
+            return false;
+    }
+    else
+        if (1440 < time)
+            return false;
+    time *= MINUTE * IN_MILLISECONDS;
+
+    pvpWG->setTimer((uint32)time);
+
+    PSendSysMessage(LANG_BG_WG_CHANGE_TIMER, secsToTimeString(pvpWG->GetTimer(), true).c_str());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspSwitchTeamCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    uint32 timer = pvpWG->GetTimer();
+    pvpWG->forceChangeTeam();
+    pvpWG->setTimer(timer);
+    PSendSysMessage(LANG_BG_WG_SWITCH_FACTION, GetTrinityString(pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+    return true;
+}
+
 bool ChatHandler::HandleLookupTitleCommand(const char* args)
 {
     if (!*args)
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index d23a429..dda3e35 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -64,6 +64,505 @@
 #include "Group.h"
 #include "ChannelMgr.h"
 
+//TrinityJail reload commands Edited by LordPsyan
+	bool ChatHandler::HandleJailReloadCommand(const char* arg)
+{
+    sObjectMgr->LoadJailConf();
+    SendSysMessage(LANG_JAIL_RELOAD);
+    return true;
+}
+
+
+#include "AuctionHouseBot.h"
+
+bool ChatHandler::HandleAHBotOptionsCommand(const char *args)
+{
+    uint32 ahMapID = 0;
+    char * opt = strtok((char*)args, " ");
+    char * ahMapIdStr = strtok(NULL, " ");
+    if (ahMapIdStr)
+    {
+        ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+        switch (ahMapID)
+        {
+        case 2:
+        case 6:
+        case 7:
+            break;
+        default:
+            opt = NULL;
+            break;
+        }
+    }
+    if (!opt)
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    int l = strlen(opt);
+
+    if (strncmp(opt,"help",l) == 0)
+    {
+        PSendSysMessage("AHBot commands:");
+        PSendSysMessage("ahexpire");
+        PSendSysMessage("minitems");
+        PSendSysMessage("maxitems");
+        //PSendSysMessage("");
+        //PSendSysMessage("");
+        PSendSysMessage("percentages");
+        PSendSysMessage("minprice");
+        PSendSysMessage("maxprice");
+        PSendSysMessage("minbidprice");
+        PSendSysMessage("maxbidprice");
+        PSendSysMessage("maxstack");
+        PSendSysMessage("buyerprice");
+        PSendSysMessage("bidinterval");
+        PSendSysMessage("bidsperinterval");
+        return true;
+    }
+    else if (strncmp(opt,"ahexpire",l) == 0)
+    {
+        if (!ahMapIdStr)
+        {
+            PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+            return false;
+        }
+        auctionbot.Commands(0, ahMapID, NULL, NULL);
+    }
+    else if (strncmp(opt,"minitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+            return false;
+        }
+        auctionbot.Commands(1, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"maxitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+            return false;
+        }
+        auctionbot.Commands(2, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"mintime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions mintime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+            return false;
+        }
+        auctionbot.Commands(3, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"maxtime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions maxtime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+            return false;
+        }
+        auctionbot.Commands(4, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"percentages",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        char * param3 = strtok(NULL, " ");
+        char * param4 = strtok(NULL, " ");
+        char * param5 = strtok(NULL, " ");
+        char * param6 = strtok(NULL, " ");
+        char * param7 = strtok(NULL, " ");
+        char * param8 = strtok(NULL, " ");
+        char * param9 = strtok(NULL, " ");
+        char * param10 = strtok(NULL, " ");
+        char * param11 = strtok(NULL, " ");
+        char * param12 = strtok(NULL, " ");
+        char * param13 = strtok(NULL, " ");
+        char * param14 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param14))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+        uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+        uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+        uint32 bluetg = (uint32) strtoul(param3, NULL, 0);
+        uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+        uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+        uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+        uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+        uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+        uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+        uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+        uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+        uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+        uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+        if ((totalPercent == 0) || (totalPercent != 100))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        char param[100];
+        param[0] = '\0';
+        strcat(param, param1);
+        strcat(param, " ");
+        strcat(param, param2);
+        strcat(param, " ");
+        strcat(param, param3);
+        strcat(param, " ");
+        strcat(param, param4);
+        strcat(param, " ");
+        strcat(param, param5);
+        strcat(param, " ");
+        strcat(param, param6);
+        strcat(param, " ");
+        strcat(param, param7);
+        strcat(param, " ");
+        strcat(param, param8);
+        strcat(param, " ");
+        strcat(param, param9);
+        strcat(param, " ");
+        strcat(param, param10);
+        strcat(param, " ");
+        strcat(param, param11);
+        strcat(param, " ");
+        strcat(param, param12);
+        strcat(param, " ");
+        strcat(param, param13);
+        strcat(param, " ");
+        strcat(param, param14);
+        auctionbot.Commands(5, ahMapID, NULL, param);
+    }
+    else if (strncmp(opt,"minprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"minbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 minBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((minBidPrice < 1) || (minBidPrice > 100))
+        {
+            PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 maxBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((maxBidPrice < 1) || (maxBidPrice > 100))
+        {
+            PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxstack",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+        uint32 maxStack = (uint32) strtoul(param2, NULL, 0);
+        if (maxStack < 0)
+        {
+            PSendSysMessage("maxstack can't be a negative number.");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"buyerprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"bidinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+            return false;
+        }
+        auctionbot.Commands(12, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"bidsperinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+            return false;
+        }
+        auctionbot.Commands(13, ahMapID, NULL, param1);
+    }
+    else
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    return true;
+}
+
 bool ChatHandler::HandleMaxSkillCommand(const char* /*args*/)
 {
     Player* SelectedPlayer = getSelectedPlayer();
@@ -2850,7 +3349,194 @@ bool ChatHandler::HandleServerIdleShutDownCommand(const char *args)
         sWorld->ShutdownServ(time, SHUTDOWN_MASK_IDLE, SHUTDOWN_EXIT_CODE);
     return true;
 }
+// Playerbot Mod Start:
+bool ChatHandler::HandleQuestRemoveCommand(char* args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    uint32 entry;
+    if (!ExtractUint32KeyFromLink(&args, "Hquest", entry))
+        return false;
 
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for(uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot )
+    {
+        uint32 quest = player->GetQuestSlotQuestId(slot);
+        if (quest==entry)
+        {
+            player->SetQuestSlot(slot,0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem( quest, false );
+        }
+    }
+
+    // set quest status to not started (will updated in DB at next save)
+    player->SetQuestStatus( entry, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+    player->getQuestStatusMap()[entry].m_rewarded = false;
+
+    SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
+bool ChatHandler::HandleQuestAddCommand(char* args)
+{
+    Player* player = getSelectedPlayer();
+    if(!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .addquest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    uint32 entry;
+    if (!ExtractUint32KeyFromLink(&args, "Hquest", entry))
+        return false;
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+    if(!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND,entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // check item starting quest (it can work incorrectly if added without item in inventory)
+    for (uint32 id = 0; id < sItemStore.GetNumRows(); ++id)
+    {
+        ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(id);
+        if (!pProto)
+            continue;
+
+        if (pProto->StartQuest == entry)
+        {
+            PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, entry, pProto->ItemId);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    // ok, normal (creature/GO starting) quest
+    if (player->CanAddQuest(pQuest, true))
+    {
+        player->AddQuest(pQuest, NULL);
+
+        if (player->CanCompleteQuest(entry))
+            player->CompleteQuest(entry);
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleQuestCompleteCommand(char* args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .quest complete #entry
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    uint32 entry;
+    if (!ExtractUint32KeyFromLink(&args, "Hquest", entry))
+        return false;
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    // If player doesn't have the quest
+    if (!pQuest || player->GetQuestStatus(entry) == QUEST_STATUS_NONE)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // Add quest items for quests that require items
+    for(uint8 x = 0; x < QUEST_ITEM_OBJECTIVES_COUNT; ++x)
+    {
+        uint32 id = pQuest->RequiredItemId[x];
+        uint32 count = pQuest->RequiredItemCount[x];
+        if (!id || !count)
+            continue;
+
+        uint32 curItemCount = player->GetItemCount(id,true);
+
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, id, count - curItemCount );
+        if (msg == EQUIP_ERR_OK)
+        {
+            Item* item = player->StoreNewItem( dest, id, true);
+            player->SendNewItem(item,count-curItemCount, true, false);
+        }
+    }
+
+    // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+    for(uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+    {
+        int32 creature = pQuest->RewardChoiceItemId[i];
+        uint32 creaturecount = pQuest->RewardChoiceItemCount[i];
+
+        if (uint32 spell_id = pQuest->RequiredSpellCast[i])
+        {
+            for(uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature, uint64(), spell_id);
+        }
+        else if (creature > 0)
+        {
+            if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                for(uint16 z = 0; z < creaturecount; ++z)
+                    player->KilledMonster(cInfo, uint64());
+        }
+        else if (creature < 0)
+        {
+            for(uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(-creature, uint64(), 0);
+        }
+    }
+
+    // If the quest requires reputation to complete
+    if(uint32 repFaction = pQuest->GetRepObjectiveFaction())
+    {
+        uint32 repValue = pQuest->GetRepObjectiveValue();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue);
+    }
+
+    // If the quest requires money
+    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+    if (ReqOrRewMoney < 0)
+        player->ModifyMoney(-ReqOrRewMoney);
+
+    player->CompleteQuest(entry);
+    return true;
+}
+// Playerbot mod end.
 bool ChatHandler::HandleBanAccountCommand(const char *args)
 {
     return HandleBanHelper(BAN_ACCOUNT, args);
diff --git a/src/server/game/CityConquest/CityConquestMgr.cpp b/src/server/game/CityConquest/CityConquestMgr.cpp
new file mode 100644
index 0000000..fbc936d
--- /dev/null
+++ b/src/server/game/CityConquest/CityConquestMgr.cpp
@@ -0,0 +1,321 @@
+#include "ScriptPCH.h"
+#include "Creature.h"
+#include <stdio.h>
+#include <time.h>
+#include <list>
+#include "CityConquestMgr.h"
+#include "World.h"
+
+CityConquestMgr CityConquest;
+
+CityConquestMgr::CityConquestMgr(){}
+
+City::City(){}
+
+Coords::Coords(){}
+
+Spawn::Spawn(){}
+
+void CityConquestMgr::StartSiege(int id, int faction)
+{
+	if (CanStartSiege(id, faction))
+	{
+		City * city = GetCityFromId(id);
+		if (city->summonerSet)
+			SpawnBoss(id, faction);
+		else
+		{
+			int t = time (NULL) + 1800;
+			WorldDatabase.PExecute("UPDATE city_capture_bosses SET spawn_timer = %u WHERE city_id = %u", t, id);
+		}
+
+		city->active = true;
+
+		char * fname;
+		if (faction == 0)
+			fname = "Aliance";
+		else
+			fname = "Horde";
+
+		char * nm;
+		nm = new char[city->name.size()+1];
+		nm[city->name.size()] = 0;
+		memcpy(nm, city->name.c_str(), city->name.size());
+
+		char msg[500];
+		sprintf(msg, "City Conquest: %s declared war to %s. Opposite team has got 30 minutes to engage commander of %s!", fname, nm, nm);
+		sWorld->SendWorldText(LANG_SYSTEMMESSAGE, msg);
+
+		WorldDatabase.PExecute("REPLACE INTO city_capture_progress (city_id, time) VALUES (%u, %u)",
+			id, time (NULL));
+
+		//OpenPortal(id);
+	}
+}
+
+void CityConquestMgr::EndSiege(int id)
+{
+	City *city = GetCityFromId(id);
+	if (!city->active)
+		return;
+	city->active = false;
+	WorldDatabase.PExecute("REPLACE INTO city_capture_progress (city_id, time) VALUES (%u, %u, %u)",
+			id, time (NULL));
+
+	WorldDatabase.PExecute("UPDATE city_capture_bosses SET spawn_timer =  1 WHERE city_id = %u", id);
+
+	char * fname;
+	if (city->controlled == 0)
+		fname = "Aliance";
+	else
+		fname = "Horde";
+
+	char * nm;
+	nm = new char[city->name.size()+1];
+	nm[city->name.size()] = 0;
+	memcpy(nm, city->name.c_str(), city->name.size());
+
+	char msg[255];
+	sprintf(msg, "City Conquest: Battle for %s is over! %s is controlled by %s", nm, nm, fname);
+	sWorld->SendWorldText(LANG_SYSTEMMESSAGE, msg);
+}
+
+
+void CityConquestMgr::SwitchFaction(int id)
+{
+	City * city = GetCityFromId(id);
+
+	if (city->active)
+	{
+		Spawns::iterator l;
+		for (l = city->spawns.begin(); l != city->spawns.end(); ++l)
+		{
+			Spawn *spawn = *l;
+			if (city->controlled == 1)
+			{
+				spawn->creature->setFaction(spawn->faction_A);
+
+				if(CreatureTemplate const *cinfo = spawn->creature->GetCreatureInfo())
+				{
+					const_cast<CreatureTemplate*>(cinfo)->faction_A = spawn->faction_A;
+					const_cast<CreatureTemplate*>(cinfo)->faction_H = spawn->faction_A;
+				}
+				WorldDatabase.PExecute("UPDATE creature_template SET faction_A = '%u', faction_H = '%u' WHERE entry = '%u'", spawn->faction_A, spawn->faction_A, spawn->creature->GetEntry());
+			}
+			else if (city->controlled == 0)
+			{
+				spawn->creature->setFaction(spawn->faction_H);
+
+				if(CreatureTemplate const *cinfo = spawn->creature->GetCreatureInfo())
+				{
+					const_cast<CreatureTemplate*>(cinfo)->faction_A = spawn->faction_H;
+					const_cast<CreatureTemplate*>(cinfo)->faction_H = spawn->faction_H;
+				}
+				WorldDatabase.PExecute("UPDATE creature_template SET faction_A = '%u', faction_H = '%u' WHERE entry = '%u'", spawn->faction_H, spawn->faction_H, spawn->creature->GetEntry());
+			}
+		}
+		if (city->controlled == 0)
+			city->controlled = 1;
+		else
+			city->controlled = 0;
+		WorldDatabase.PExecute("UPDATE city_capture_cities SET controlled = %u WHERE id = %u", city->controlled, city->id);
+		EndSiege(id);
+	}
+}
+
+void CityConquestMgr::SpawnBoss(int id, int faction)
+{
+	City * city = GetCityFromId(id);
+	if (faction == 0)
+		city->summoner->SummonCreature(city->boss_H, city->summoner->GetPositionX(), city->summoner->GetPositionY(), city->summoner->GetPositionZ(),
+		city->summoner->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 1800000);
+	else if (faction == 1)
+		city->summoner->SummonCreature(city->boss_A, city->summoner->GetPositionX(), city->summoner->GetPositionY(), city->summoner->GetPositionZ(),
+		city->summoner->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 1800000);
+
+	WorldDatabase.PExecute("UPDATE city_capture_bosses SET spawn_timer =  1 WHERE city_id = %u", id);
+}
+
+City * CityConquestMgr::GetCityFromId(int id)
+{
+	Cities::iterator l;
+	for (l = cities.begin(); l != cities.end(); ++l)
+	{
+		City *ct = *l;
+		if (ct->id == id)
+			return ct;
+	}
+	return new City();
+}
+
+bool CityConquestMgr::CanStartSiege(int id, int faction)
+{
+	City *city = GetCityFromId(id);
+	if (city->active == true)
+		return false;
+	if (city->controlled == faction)
+		return false;
+
+	QueryResult result = WorldDatabase.PQuery("SELECT time FROM city_capture_progress WHERE city_id = %u", id);
+	//														  0
+	if (result)
+	{
+		Field *fields = result->Fetch();
+		// 60 = 1 min, will be increased in release
+		if (fields[0].GetInt32() + 3600 > time (NULL))
+			return false;
+	}
+
+	return true;
+}
+
+void CityConquestMgr::LoadCities()
+{
+	QueryResult result = WorldDatabase.Query("SELECT id, minlevel, maxlevel, name, controlled, boss_entry_A, boss_entry_H FROM city_capture_cities LEFT JOIN city_capture_bosses ON id = city_id ORDER BY id ASC");
+	//														  0   1         2         3     4           5             6
+	if (result)
+	{
+		do
+		{
+			City *city = new City();
+			Field *fields = result->Fetch();
+			city->id = fields[0].GetInt32();
+			city->minlevel = fields[1].GetInt32();
+			city->maxlevel = fields[2].GetInt32();
+			city->name = fields[3].GetString();
+			city->controlled = fields[4].GetInt32();
+			city->summonerSet = false;
+			city->active = false; // todo activecheck
+			city->boss_A = fields[5].GetInt32();
+			city->boss_H = fields[6].GetInt32();
+			// sLog->outString("CQM: City Loaded - %s", fields[3].GetString()); -- causes crash during startup (LordPsyan)
+			cities.push_back(city);
+			city->LoadPorts();
+
+		}
+		while (result->NextRow());
+	}
+}
+
+void CityConquestMgr::RegisterCreature(Creature * creature, int type)
+{
+	QueryResult result;
+	if (type == 0)
+	{
+		sLog->outString("CQM: Creature Registered - %u", creature->GetEntry());
+		result
+			= WorldDatabase.PQuery("SELECT city_id, faction_A, faction_H FROM city_capture_creatures WHERE entry = %u",
+			//                             0        1          2
+			creature->GetEntry());
+		if (result)
+		{
+			Field *fields = result->Fetch();
+			Cities::iterator l;
+			for (l = cities.begin(); l != cities.end(); ++l)
+			{
+				City *ct = *l;
+				if (ct->id == fields[0].GetInt32())
+				{
+					Spawn *spawn = new Spawn();
+					spawn->creature = creature;
+					spawn->faction_A = fields[1].GetInt32();
+					spawn->faction_H = fields[2].GetInt32();
+
+					spawn->creature->setFaction(spawn->faction_A);
+
+					if (ct->controlled == 1)
+					{
+						spawn->creature->setFaction(spawn->faction_H);
+
+						if(CreatureTemplate const *cinfo = spawn->creature->GetCreatureInfo())
+						{
+							const_cast<CreatureTemplate*>(cinfo)->faction_A = spawn->faction_H;
+							const_cast<CreatureTemplate*>(cinfo)->faction_H = spawn->faction_H;
+						}
+						WorldDatabase.PExecute("UPDATE creature_template SET faction_A = '%u', faction_H = '%u' WHERE entry = '%u'", spawn->faction_H, spawn->faction_H, spawn->creature->GetEntry());
+					}
+					else if (ct->controlled == 0)
+					{
+						spawn->creature->setFaction(spawn->faction_A);
+
+						if(CreatureTemplate const *cinfo = spawn->creature->GetCreatureInfo())
+						{
+							const_cast<CreatureTemplate*>(cinfo)->faction_A = spawn->faction_A;
+							const_cast<CreatureTemplate*>(cinfo)->faction_H = spawn->faction_A;
+						}
+						WorldDatabase.PExecute("UPDATE creature_template SET faction_A = '%u', faction_H = '%u' WHERE entry = '%u'", spawn->faction_A, spawn->faction_A, spawn->creature->GetEntry());
+					}
+
+					ct->spawns.push_back(spawn);
+					return;
+				}
+			}
+		}
+	}
+	else if (type == 2)
+	{
+		sLog->outString("CQM: City Spawner attmpts to register - %u", creature->GetEntry());
+		result
+			= WorldDatabase.PQuery("SELECT city_id, spawner_entry, spawn_timer FROM city_capture_bosses WHERE spawner_entry = %u", creature->GetEntry());
+
+		if (result)
+		{
+			sLog->outString("CQM: City Spawner passed first check - %u", creature->GetEntry());
+			Field *fields = result->Fetch();
+			Cities::iterator l;
+			for (l = cities.begin(); l != cities.end(); ++l)
+			{
+				City *ct = *l;
+				sLog->outString("CQM: City Spawner browses through cities - %u", creature->GetEntry());
+				if (ct->id == fields[0].GetInt32())
+				{
+					if (creature->GetEntry() == fields[1].GetInt32())
+					{
+						sLog->outString("CQM: City Spawner Registered - %u", creature->GetEntry());
+						if (!ct->summonerSet)
+						{
+							ct->summoner = creature;
+							ct->summonerSet = true;
+							if (fields[2].GetInt32() > time(NULL))
+							{
+								if (ct->controlled == 1)
+									SpawnBoss(ct->id, 0);
+								else
+									SpawnBoss(ct->id, 1);
+							}
+							else
+								EndSiege(ct->id);
+
+						}
+					}
+					return;
+				}
+			}
+		}
+
+	}
+}
+
+void City::LoadPorts()
+{
+	QueryResult result = WorldDatabase.PQuery("SELECT x, y, z, o, map, side FROM city_capture_ports WHERE city_id = %u", id);
+	//														  0  1  2  3  4    5
+	if (result)
+	{
+		do
+		{
+			Field *fields = result->Fetch();
+			Coords *coords = new Coords();
+			coords->x = fields[0].GetFloat();
+			coords->y = fields[1].GetFloat();
+			coords->z = fields[2].GetFloat();
+			coords->o = fields[3].GetFloat();
+			coords->map = fields[4].GetInt32();
+			if (fields[5].GetInt32() == 0)
+				port_defense = coords;
+			else if (fields[5].GetInt32() == 1)
+				port_attack = coords;
+		}
+		while (result->NextRow());
+	}
+}
diff --git a/src/server/game/CityConquest/CityConquestMgr.h b/src/server/game/CityConquest/CityConquestMgr.h
new file mode 100644
index 0000000..cc4735e
--- /dev/null
+++ b/src/server/game/CityConquest/CityConquestMgr.h
@@ -0,0 +1,84 @@
+#ifndef CITYCONQUESTMGR_H
+#define CITYCONQUESTMGR_H
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+class Coords
+{
+public:
+	float x;
+	float y;
+	float z;
+	float o;
+	int map;
+	Coords(void);
+};
+
+class Spawn
+{
+public:
+	Creature *creature;
+	int faction_A;
+	int faction_H;
+	Spawn(void);
+private:
+	void GetCreatureData(int entry);
+};
+
+typedef std::list<Spawn *> Spawns;
+
+class City
+{
+public:
+	int id;
+	Spawns spawns;
+	int boss_A;
+	int boss_H;
+	bool summonerSet;
+	Creature * summoner;
+	Coords * port_defense;
+	Coords * port_attack;
+	int controlled;
+	//	0 aliance
+	//  1 horde
+	int minlevel;
+	int maxlevel;
+	std::string name;
+	bool active;
+	//   true - siege in progress
+	//   false - not under siege
+	City(void);
+	void LoadPorts(void);									// done
+
+
+};
+
+typedef std::list<City *> Cities;
+
+class CityConquestMgr
+{
+public:
+	Cities cities;
+	CityConquestMgr(void);
+	void LoadCities(void); // done
+	void RegisterCreature(Creature *creature, int type);	// done
+	//                                            0 normal
+	//                                            1 boss
+	//                                            2 spawner
+	bool CanStartSiege(int id, int faction);				// done
+	//							   0 aliance
+	//                             1 horde
+	void StartSiege(int id, int faction);				    // done
+	void SpawnBoss(int id, int faction);					// done
+	//						   0 aliance
+	//                         1 horde
+	void EndSiege(int id);									// done
+	void OpenPortal(int id);								// todo
+	void SwitchFaction(int id);				                // done
+	//							   0 aliance
+	//                             1 horde
+	City * GetCityFromId(int id);							// done
+};
+
+extern CityConquestMgr CityConquest;
+
+#endif
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index 15408ad..00bc304 100755
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -663,7 +663,7 @@ struct ChrClassesEntry
                                                             // 1, unused
     uint32  powerType;                                      // 2
                                                             // 3-4, unused
-    //char*       name[16];                                 // 5-20 unused
+    char*       name[16];                                   // 5-20 Trinichat2
                                                             // 21 string flag, unused
     //char*       nameFemale[16];                           // 21-36 unused, if different from base (male) case
                                                             // 37 string flag, unused
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index c55fb79..8776e99 100755
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -35,7 +35,7 @@ const char CharStartOutfitEntryfmt[]="diiiiiiiiiiiiiiiiiiiiiiiiixxxxxxxxxxxxxxxx
 const char CharTitlesEntryfmt[]="nxssssssssssssssssxxxxxxxxxxxxxxxxxxi";
 const char ChatChannelsEntryfmt[]="nixssssssssssssssssxxxxxxxxxxxxxxxxxx";
                                                             // ChatChannelsEntryfmt, index not used (more compact store)
-const char ChrClassesEntryfmt[]="nxixxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxixii";
+const char ChrClassesEntryfmt[]="nxixssssssssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxixii";
 const char ChrRacesEntryfmt[]="nxixiixixxxxixssssssssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxi";
 const char CinematicSequencesEntryfmt[]="nxxxxxxxxx";
 const char CreatureDisplayInfofmt[]="nixxfxxxxxxxxxxx";
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index adad026..fe9015a 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -468,7 +468,9 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool canWalk() const { return GetCreatureInfo()->InhabitType & INHABIT_GROUND; }
         bool canSwim() const { return GetCreatureInfo()->InhabitType & INHABIT_WATER; }
         //bool canFly()  const { return GetCreatureInfo()->InhabitType & INHABIT_AIR; }
-
+        // Playerbot mod start - adds functionality to load/unload bots from NPC, also need to apply SQL scripts
+        void LoadBotMenu(Player *pPlayer);
+        // Playerbot mod end.
         void SetReactState(ReactStates st) { m_reactState = st; }
         ReactStates GetReactState() { return m_reactState; }
         bool HasReactState(ReactStates state) const { return (m_reactState == state); }
@@ -585,6 +587,11 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         Loot loot;
         bool lootForPickPocketed;
         bool lootForBody;
+
+        // Playerbot mod start:
+        bool lootForSkin;
+        // Playerbot mod end.
+
         Player* GetLootRecipient() const;
         Group* GetLootRecipientGroup() const;
         bool hasLootRecipient() const { return m_lootRecipient || m_lootRecipientGroup; }
diff --git a/src/server/game/Entities/Creature/GossipDef.h b/src/server/game/Entities/Creature/GossipDef.h
index 15766bb..ea62192 100755
--- a/src/server/game/Entities/Creature/GossipDef.h
+++ b/src/server/game/Entities/Creature/GossipDef.h
@@ -50,6 +50,8 @@ enum Gossip_Option
     GOSSIP_OPTION_UNLEARNPETTALENTS = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
+    // Playerbot mod
+    GOSSIP_OPTION_BOT               = 99,                   //UNIT_NPC_FLAG_GOSSIP              (1) UNUSED (just for bot system)
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index decbc49..29d96a1 100755
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -447,6 +447,11 @@ void GameObject::Update(uint32 diff)
                         if (goInfo->trap.spellId)
                             CastSpell(ok, goInfo->trap.spellId);
 
+						// allow to use scripts
+                        if (ok->GetTypeId() == TYPEID_PLAYER)
+                            if (sScriptMgr->OnGossipHello(ok->ToPlayer(), this))
+                                return;
+
                         m_cooldownTime = time(NULL) + (goInfo->trap.cooldown ? goInfo->trap.cooldown :  uint32(4));   // template or 4 seconds
 
                         if (goInfo->trap.type == 1)
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 10ec850..2c71366 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -72,8 +72,17 @@
 #include "LFGMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "InstanceScript.h"
+#include "IRCClient.h"
 #include <cmath>
 #include "AccountMgr.h"
+#include "Config.h"
+#include "OutdoorPvPWG.h"
+
+// Playerbot mod start:
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "Config.h"
+// Playerbot mod end.
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -89,6 +98,8 @@
 #define SKILL_PERM_BONUS(x)    int16(PAIR32_HIPART(x))
 #define MAKE_SKILL_BONUS(t, p) MAKE_PAIR32(t, p)
 
+extern Config botConfig;
+
 enum CharacterFlags
 {
     CHARACTER_FLAG_NONE                 = 0x00000000,
@@ -635,6 +646,25 @@ Player::Player(WorldSession* session): Unit(true), m_achievementMgr(this), m_rep
 #pragma warning(default:4355)
 #endif
 
+	m_jail_guid     = 0;
+    m_jail_char     = "";
+    m_jail_amnestie = false;
+    m_jail_warning  = false;
+    m_jail_isjailed = false;
+    m_jail_amnestietime =0;
+    m_jail_release  = 0;
+    m_jail_times    = 0;
+    m_jail_reason   = "";
+    m_jail_gmacc    = 0;
+    m_jail_gmchar   = "";
+    m_jail_lasttime = "";
+    m_jail_duration = 0;
+	// Jail end
+
+    // Playerbot mod:
+    m_playerbotAI = 0;
+    m_playerbotMgr = 0;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -888,6 +918,17 @@ Player::~Player ()
     delete m_declinedname;
     delete m_runes;
 
+    // Playerbot mod start:
+    if (m_playerbotAI) {
+        delete m_playerbotAI;
+        m_playerbotAI = 0;
+    }
+    if (m_playerbotMgr) {
+        delete m_playerbotMgr;
+        m_playerbotMgr = 0;
+    }
+    // Playerbot mod end.
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1301,9 +1342,12 @@ int32 Player::getMaxTimer(MirrorTimerType timer)
 {
     switch (timer)
     {
+	if(ConfigMgr::GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+		{
         case FATIGUE_TIMER:
             return MINUTE * IN_MILLISECONDS;
-        case BREATH_TIMER:
+		}
+		case BREATH_TIMER:
         {
             if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
                 return DISABLED_MIRROR_TIMER;
@@ -1373,6 +1417,9 @@ void Player::HandleDrowning(uint32 time_diff)
     }
 
     // In dark water
+if(ConfigMgr::GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+{
+
     if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
     {
         // Fatigue timer not activated - activate it
@@ -1409,7 +1456,7 @@ void Player::HandleDrowning(uint32 time_diff)
         else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
             SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
     }
-
+}
     if (m_MirrorTimerFlags & (UNDERWATER_INLAVA|UNDERWATER_INSLIME))
     {
         // Breath timer not activated - activate it
@@ -1532,6 +1579,79 @@ void Player::Update(uint32 p_time)
     Unit::Update(p_time);
     SetCanDelayTeleport(false);
 
+	if (m_jail_isjailed)
+    {
+        time_t localtime;
+        localtime = time(NULL);
+		
+        if (m_jail_release <= localtime)
+        {
+            m_jail_isjailed = false;
+            m_jail_release = 0;
+
+            _SaveJail();
+            
+            sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+            
+			CastSpell(this,8690,false);
+
+            return;
+        }
+
+        if (m_team == ALLIANCE)
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_ally_x, sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                    sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+                return;
+            }
+        }
+        else
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_horde_x, sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                    sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+                return;
+            }
+			
+        }
+    }
+	
+	if (m_jail_warning == true)
+	{
+		m_jail_warning  = false;
+		
+		if (sObjectMgr->m_jailconf_warn_player == m_jail_times || sObjectMgr->m_jailconf_warn_player <= m_jail_times)
+		{
+			if ((sObjectMgr->m_jailconf_max_jails-1 == m_jail_times-1) && sObjectMgr->m_jailconf_ban-1)
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING_BAN, m_jail_times , sObjectMgr->m_jailconf_max_jails-1);
+			}
+			else
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING, m_jail_times , sObjectMgr->m_jailconf_max_jails);
+			}
+		        
+		}
+				return;
+	}
+if (m_jail_amnestie == true && sObjectMgr->m_jailconf_amnestie > 0)
+{
+	m_jail_amnestie =false;
+	time_t localtime;
+    localtime    = time(NULL);
+	
+	if (localtime >  m_jail_amnestietime)
+	{   
+		CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
+		ChatHandler(this).PSendSysMessage(LANG_JAIL_AMNESTII);
+	}
+    return;
+}
+
+
     time_t now = time(NULL);
 
     UpdatePvPFlag(now);
@@ -1712,15 +1832,26 @@ void Player::Update(uint32 p_time)
     }
 
     if (m_deathState == JUST_DIED)
-        KillPlayer();
+        // Prevent death of jailed players
+        if (!m_jail_isjailed) KillPlayer();
+        else
+        {
+            m_deathState = ALIVE;
+            RegenerateAll();
+        }
 
-    if (m_nextSave > 0)
+    if (m_nextSave > 0 && !m_jail_isjailed)
     {
         if (p_time >= m_nextSave)
         {
             // m_nextSave reseted in SaveToDB call
             SaveToDB();
             sLog->outDetail("Player '%s' (GUID: %u) saved", GetName(), GetGUIDLow());
+            // If Fake WHO List system on then change player position with every SavePlayer Interval (usually 15min) 
+            if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST)) 
+                CharacterDatabase.PExecute("UPDATE characters SET zone = (FLOOR(50 * RAND()) + 1) WHERE online>1"); 
+                CharacterDatabase.PExecute("UPDATE characters SET level=level+1 WHERE online>1 AND level<5"); 
+
         }
         else
             m_nextSave -= p_time;
@@ -1798,6 +1929,12 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    // Playerbot mod
+    if (m_playerbotAI)
+        m_playerbotAI->UpdateAI(p_time);
+    else if (m_playerbotMgr)
+        m_playerbotMgr->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2070,6 +2207,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
+    // Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    if (GetPlayerbotMgr())
+        GetPlayerbotMgr()->Stay();
+
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
@@ -2418,6 +2560,15 @@ void Player::RemoveFromWorld()
             SetViewpoint(viewpoint, false);
         }
     }
+  //TODO: FIXME
+    if (sIRC.ajoin == 1)
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT `name` FROM `irc_inchan` WHERE `name` = '%s'", Unit::GetName());
+        if (!result)
+        {
+            sIRC.AutoJoinChannel(this);
+        }
+    }
 }
 
 void Player::RegenerateAll()
@@ -3032,6 +3183,17 @@ void Player::GiveLevel(uint8 level)
     InitTaxiNodesForLevel();
     InitGlyphsForLevel();
 
+  if ((sIRC.BOTMASK & 64) != 0)
+    {
+        char  temp [5];
+        sprintf(temp, "%u", level);
+        std::string plevel = temp;
+        std::string pname = GetName();
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.Status].c_str();
+        sIRC.Send_IRC_Channel(ircchan, "\00311["+pname+"] : Has Reached Level: "+plevel, true);
+    }
+
     UpdateAllStats();
 
     if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
@@ -6865,7 +7027,8 @@ void Player::CheckAreaExploreAndOutdoor()
                 {
                     XP = uint32(sObjectMgr->GetBaseXP(p->area_level)*sWorld->getRate(RATE_XP_EXPLORE));
                 }
-
+                if(GetSession()->IsPremium())
+                XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);
                 GiveXP(XP, NULL);
                 SendExplorationExperience(area, XP);
             }
@@ -9081,6 +9244,13 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
                                                             // 8 Arena season id
     data << uint32(0xF3D) << uint32(sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID));
 
+    // May be send timer to start Wintergrasp
+    if(sWorld->GetWintergrapsState()==4354)
+        data << uint32(0x1102) << sWorld->GetWintergrapsTimer();
+    else
+        data << uint32(0xEC5) << sWorld->GetWintergrapsTimer();
+    // ---
+
     if (mapid == 530)                                       // Outland
     {
         data << uint32(0x9bf) << uint32(0x0);               // 7
@@ -14070,6 +14240,22 @@ void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool
                     if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
                         canTalk = false;
                     break;
+                case GOSSIP_OPTION_BOT:
+                {
+                    if(ConfigMgr::GetBoolDefault("PlayerbotAI.DisableBots", false) && !creature->isInnkeeper())
+                    {
+                        ChatHandler(this).PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+                        canTalk = false;
+                        break;
+                    }
+
+                    std::string reqQuestIds = ConfigMgr::GetStringDefault("PlayerbotAI.BotguyQuests","");
+                    uint32 cost = ConfigMgr::GetIntDefault("PlayerbotAI.BotguyCost",0);
+                    if((reqQuestIds == "" || requiredQuests(reqQuestIds.c_str())) && !creature->isInnkeeper() && this->GetMoney() >= cost)
+                        creature->LoadBotMenu(this);
+                    canTalk = false;
+                    break;
+                }
                 default:
                     sLog->outErrorDb("Creature entry %u have unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuId);
                     canTalk = false;
@@ -14161,7 +14347,8 @@ void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 men
     // if not same, then something funky is going on
     if (menuId != gossipMenu.GetMenuId())
         return;
-
+    // Possible error
+    // GossipMenuItemData pMenuData = gossipmenu.GetItemData(gossipListId);
     GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
     if (!item)
         return;
@@ -14271,6 +14458,57 @@ void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 men
             PrepareGossipMenu(source);
             SendPreparedGossip(source);
             break;
+        // Playerbot mod start:
+        case GOSSIP_OPTION_BOT:
+        {
+            // DEBUG_LOG("GOSSIP_OPTION_BOT");
+            PlayerTalkClass->SendCloseGossip();
+            uint32 guidlo = PlayerTalkClass->GetGossipOptionSender(gossipListId);
+            uint32 cost = ConfigMgr::GetIntDefault("PlayerbotAI.BotguyCost",0);
+
+            if (!GetPlayerbotMgr())
+                SetPlayerbotMgr(new PlayerbotMgr(this));
+
+            if(GetPlayerbotMgr()->GetPlayerBot(guid) != NULL)
+            {
+                GetPlayerbotMgr()->LogoutPlayerBot(guid);
+            }
+            else if(GetPlayerbotMgr()->GetPlayerBot(guid) == NULL)
+            {
+                QueryResult resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
+                if(resultchar)
+                {
+                    Field *fields = resultchar->Fetch();
+                    int maxnum = ConfigMgr::GetIntDefault("PlayerbotAI.MaxNumBots", 9);
+                    int acctcharcount = fields[0].GetUInt32();
+                    if(!(m_session->GetSecurity() > SEC_PLAYER))
+                        if(acctcharcount > maxnum)
+                        {
+                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon anymore bots. (Current Max: |cffffffff%u|cffff0000)",maxnum);
+                            break;
+                        }
+                }
+
+                QueryResult resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guidlo);
+                if(resultlvl)
+                {
+                    Field *fields=resultlvl->Fetch();
+                    int maxlvl = ConfigMgr::GetIntDefault("PlayerbotAI.RestrictBotLevel", 80);
+                    int charlvl = fields[0].GetUInt32();
+                    if(!(m_session->GetSecurity() > SEC_PLAYER))
+                        if(charlvl > maxlvl)
+                        {
+                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high. (Current Max:lvl |cffffffff%u|cffff0000)",fields[1].GetString(),maxlvl);
+                            break;
+                        }
+                }
+
+                GetPlayerbotMgr()->AddPlayerBot(guid);
+                this->ModifyMoney(-(int32)cost);
+            }
+            break;
+        }
+        // Playerbot mod end.
         case GOSSIP_OPTION_BATTLEFIELD:
         {
             BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());
@@ -14920,6 +15158,9 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
         AddPctN(XP, (*i)->GetAmount());
 
+    if (GetSession()->IsPremium())
+        XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);
+
     int32 moneyRew = 0;
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
@@ -17099,10 +17340,77 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     m_achievementMgr.CheckAllAchievementCriteria();
 
     _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
+	// Loads the jail datas and if jailed it corrects the position to the corresponding jail
+    _LoadJail();
 
     return true;
 }
 
+void Player::_LoadJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+		Field *fields = result->Fetch();
+		m_jail_warning = true;
+		m_jail_isjailed = true;
+		m_jail_guid = fields[0].GetUInt32();
+		m_jail_char = fields[1].GetString();
+		m_jail_release = fields[2].GetUInt32();
+		m_jail_amnestietime = fields[3].GetUInt32();
+		m_jail_reason = fields[4].GetString();
+		m_jail_times = fields[5].GetUInt32();
+		m_jail_gmacc = fields[6].GetUInt32();
+		m_jail_gmchar = fields[7].GetString();
+		m_jail_lasttime = fields[8].GetString();
+		m_jail_duration = fields[9].GetUInt32();
+
+    if (m_jail_release == 0)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+    time_t localtime;
+    localtime = time(NULL);
+
+    if (m_jail_release <= localtime)
+    {
+        m_jail_isjailed = false;
+        m_jail_release = 0;
+
+        _SaveJail();
+
+        sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+
+        CastSpell(this,8690,false);
+        return;
+    }
+
+    if (m_jail_isjailed)
+    {
+        if (m_team == ALLIANCE)
+        {
+            TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+        }
+        else
+        {
+            TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+        }
+         
+        sWorld->SendWorldText(LANG_JAIL_CHAR_TELE, GetName());
+    }
+}
+
 bool Player::isAllowedToLoot(const Creature* creature)
 {
     if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
@@ -18322,9 +18630,21 @@ bool Player::_LoadHomeBind(PreparedQueryResult result)
 /*********************************************************/
 /***                   SAVE SYSTEM                     ***/
 /*********************************************************/
+// Saves the jail datas (added by WarHead) edited by LordPsyan.
+void Player::_SaveJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT `guid` FROM `jail` WHERE `guid`='%u' LIMIT 1", m_jail_guid);
+    if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u', '%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", m_jail_guid, m_jail_char.c_str(), m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration);
+    else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration, m_jail_guid);
+    CharacterDatabase.CommitTransaction(trans);
+}
 
 void Player::SaveToDB(bool create /*=false*/)
 {
+	// Jail: Prevent saving of jailed players
+    if (m_jail_isjailed) return;
+
     // delay auto save at any saves (manual, in code, or autosave)
     m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
 
@@ -23455,7 +23775,7 @@ void Player::_LoadSkills(PreparedQueryResult result)
                 stmt->setUInt16(1, skill);
 
                 CharacterDatabase.Execute(stmt);
-
+                CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
                 continue;
             }
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 7da008d..fca0f50 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -36,7 +36,10 @@
 #include "Unit.h"
 #include "Util.h"                                           // for Tokens typedef
 #include "WorldSession.h"
-
+// Playerbot mod start:
+#include "../../AI/PlayerBots/PlayerbotMgr.h"
+#include "../../AI/PlayerBots/PlayerbotAI.h"
+// Playerbot mod end.
 // for template
 #include "SpellMgr.h"
 
@@ -55,6 +58,8 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -107,6 +112,10 @@ struct PlayerSpell
 
 struct PlayerTalent
 {
+    // Playerbot mod start:
+    TalentEntry const *talentEntry;
+    uint32 currentRank;
+    // Playerbot mod end.
     PlayerSpellState state : 8;
     uint8 spec             : 8;
 };
@@ -1508,6 +1517,13 @@ class Player : public Unit, public GridObject<Player>
         void AddTimedQuest(uint32 quest_id) { m_timedquests.insert(quest_id); }
         void RemoveTimedQuest(uint32 quest_id) { m_timedquests.erase(quest_id); }
 
+        // Playerbot mod
+        void chompAndTrim(std::string& str);
+        bool getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId);
+        void skill(std::list<uint32>& m_spellsToLearn);
+        void MakeTalentGlyphLink(std::ostringstream &out);
+        bool requiredQuests(const char* pQuestIdString);
+
         /*********************************************************/
         /***                   LOAD SYSTEM                     ***/
         /*********************************************************/
@@ -2267,6 +2283,26 @@ class Player : public Unit, public GridObject<Player>
         bool IsImmuneToEnvironmentalDamage();
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
 
+	    // Jail by WarHead edited by spgm
+        // ---------------
+        // Char datas...
+		bool m_jail_warning;
+		bool m_jail_amnestie;
+		bool m_jail_isjailed;           // Is this player jailed?
+		std::string m_jail_char;        // Name of jailed char
+		uint32 m_jail_guid;             // guid of the jailed char
+		uint32 m_jail_release;          // When is the player a free man/woman?
+		std::string m_jail_reason;      // Why was the char jailed?
+		uint32 m_jail_times;			// How often was the player jailed?
+		uint32 m_jail_amnestietime;
+		uint32 m_jail_gmacc;            // Used GM acc
+		std::string m_jail_gmchar;      // Used GM char
+		std::string m_jail_lasttime;    // Last jail time
+		uint32 m_jail_duration;         // Duration of the jail
+		// Load / save functions...
+		void _LoadJail(void);           // Loads the jail datas
+		void _SaveJail(void);           // Saves the jail datas
+
         /*********************************************************/
         /***               FLOOD FILTER SYSTEM                 ***/
         /*********************************************************/
@@ -2320,6 +2356,10 @@ class Player : public Unit, public GridObject<Player>
 
         uint32 m_ConditionErrorMsgId;
 
+         // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
+
         // Homebind coordinates
         uint32 m_homebindMapId;
         uint16 m_homebindAreaId;
@@ -2527,6 +2567,17 @@ class Player : public Unit, public GridObject<Player>
             //! TODO: Need a proper calculation for collision height when mounted
         }
 
+        // Playerbot mod start:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        void SetPlayerbotAI(PlayerbotAI* ai) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        bool IsInDuel(Player const* player) const { return duel && (duel->opponent == player || duel->initiator == player) && duel->startTime != 0; }
+        // Playerbot mod end.
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2854,6 +2905,8 @@ class Player : public Unit, public GridObject<Player>
         InstanceTimeMap _instanceResetTimes;
         uint32 _pendingBindId;
         uint32 _pendingBindTimer;
+  public :
+    QuestStatusSaveMap m_RewardedQuestsSave2;
 };
 
 void AddItemsSetItem(Player*player, Item* item);
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 5a6b34b..1d6cde5 100755
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1133,7 +1133,10 @@ struct CharmInfo
         void SetCommandState(CommandStates st) { m_CommandState = st; }
         CommandStates GetCommandState() const { return m_CommandState; }
         bool HasCommandState(CommandStates state) const { return (m_CommandState == state); }
-
+        // Playerbot mod start:
+        void SetReactState(ReactStates st) { m_oldReactState = st; }
+        ReactStates GetReactState() { return m_oldReactState; }
+        // Playerbot mod end.
         void InitPossessCreateSpells();
         void InitCharmCreateSpells();
         void InitPetActionBar();
@@ -1352,6 +1355,10 @@ class Unit : public WorldObject
         uint32 GetHealth()    const { return GetUInt32Value(UNIT_FIELD_HEALTH); }
         uint32 GetMaxHealth() const { return GetUInt32Value(UNIT_FIELD_MAXHEALTH); }
 
+        // Playerbot mod start:
+        float GetHealthPercent() const { return (GetHealth()*100.0f) / GetMaxHealth(); }
+        // Playerbot mod end.
+
         bool IsFullHealth() const { return GetHealth() == GetMaxHealth(); }
         bool HealthBelowPct(int32 pct) const { return GetHealth() * uint64(100) < GetMaxHealth() * uint64(pct); }
         bool HealthBelowPctDamaged(int32 pct, uint32 damage) const { return (int32(GetHealth()) - damage) * int64(100) < GetMaxHealth() * int64(pct); }
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
index 7e4beba..6225d98 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
@@ -508,3 +508,29 @@ uint8 Vehicle::GetAvailableSeatCount() const
 
     return ret;
 }
+
+void Vehicle::Relocate(Position pos)
+{
+    sLog->outDebug(LOG_FILTER_VEHICLES, "Vehicle::Relocate %u", _me->GetEntry());
+
+    std::set<Unit*> vehiclePlayers;
+    for (int8 i = 0; i < 8; i++)
+        vehiclePlayers.insert(GetPassenger(i));
+
+    // passengers should be removed or they will have movement stuck
+    RemoveAllPassengers();
+
+    for (std::set<Unit*>::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
+    {
+        if (Unit* plr = (*itr))
+        {
+            // relocate/setposition doesn't work for player
+            plr->NearTeleportTo(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+            //plr->TeleportTo(pPlayer->GetMapId(), triggerPos.GetPositionX(), triggerPos.GetPositionY(), triggerPos.GetPositionZ(), triggerPos.GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT);
+        }
+    }
+
+    _me->UpdatePosition(pos, true);
+    // problems, and impossible to do delayed enter
+    //pPlayer->EnterVehicle(veh);
+}
diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
index 213be5a..796506f 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.h
+++ b/src/server/game/Entities/Vehicle/Vehicle.h
@@ -23,6 +23,7 @@
 #include "VehicleDefines.h"
 
 struct VehicleEntry;
+struct Position;
 class Unit;
 
 class Vehicle
@@ -53,6 +54,7 @@ class Vehicle
         void RelocatePassengers(float x, float y, float z, float ang);
         void RemoveAllPassengers();
         void Dismiss();
+        void Relocate(Position pos);
         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
 
         SeatMap Seats;
diff --git a/src/server/game/Events/GameEventMgr.cpp b/src/server/game/Events/GameEventMgr.cpp
index 8b9e2fe..eb3c0fc 100755
--- a/src/server/game/Events/GameEventMgr.cpp
+++ b/src/server/game/Events/GameEventMgr.cpp
@@ -29,6 +29,7 @@
 #include "BattlegroundMgr.h"
 #include "UnitAI.h"
 #include "GameObjectAI.h"
+#include "IRCClient.h"
 
 bool GameEventMgr::CheckOneGameEvent(uint16 entry) const
 {
@@ -1089,6 +1090,12 @@ void GameEventMgr::ApplyNewEvent(uint16 event_id)
             break;
         case 1:                                             // announce events
             sWorld->SendWorldText(LANG_EVENTMESSAGE, mGameEvent[event_id].description.c_str());
+      if ((sIRC.BOTMASK & 256) != 0)
+            {
+                std::string ircchan = "#";
+                ircchan += sIRC._irc_chan[sIRC.anchn].c_str();                
+                sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Game Event \00304,08\037/!\\\037\017 %s", "%s", mGameEvent[event_id].description.c_str()), true);
+            }
             break;
     }
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 086dd61..9351698 100755
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -6715,6 +6715,121 @@ uint32 ObjectMgr::GeneratePetNumber()
     return ++m_hiPetNumber;
 }
 
+// Loads the jail conf out of the database
+void ObjectMgr::LoadJailConf(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail_conf`");
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR1));
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR2));
+
+		m_jailconf_max_jails    = 3;
+		m_jailconf_max_duration = 672;
+		m_jailconf_min_reason   = 25;
+		m_jailconf_warn_player  = 1;
+		m_jailconf_amnestie     = 180;
+
+		m_jailconf_ally_x       = -8673.43;
+		m_jailconf_ally_y       = 631.795;
+		m_jailconf_ally_z       = 96.9406;
+		m_jailconf_ally_o       = 2.1785;
+		m_jailconf_ally_m       = 0;
+
+		m_jailconf_horde_x      = 2179.85;
+		m_jailconf_horde_y      = -4763.96;
+		m_jailconf_horde_z      = 54.911;
+		m_jailconf_horde_o      = 4.44216;
+		m_jailconf_horde_m      = 1;
+
+		m_jailconf_ban          = 0;
+		m_jailconf_radius       = 10;
+
+        return;
+    }
+do
+{
+    Field *fields = result->Fetch();
+    m_jail_obt = fields[1].GetString();
+	if (m_jail_obt == "m_jailconf_max_jails")
+	{
+      m_jailconf_max_jails    = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_max_duration")
+	{
+	  m_jailconf_max_duration = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_min_reason")
+	{
+      m_jailconf_min_reason   = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_warn_player")
+	{
+      m_jailconf_warn_player  = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_amnestie")
+	{
+	  m_jailconf_amnestie     = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ally_x")
+	{
+      m_jailconf_ally_x       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_y")
+	{
+      m_jailconf_ally_y       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_z")
+	{
+      m_jailconf_ally_z       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_o")
+	{
+      m_jailconf_ally_o       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_m")
+	{
+      m_jailconf_ally_m       = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_horde_x")
+	{
+      m_jailconf_horde_x      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_y")
+	{
+      m_jailconf_horde_y      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_z")
+	{
+      m_jailconf_horde_z      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_o")
+	{
+      m_jailconf_horde_o      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_m")
+	{
+      m_jailconf_horde_m      = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ban")
+	{
+      m_jailconf_ban = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_radius")
+	{
+      m_jailconf_radius = fields[2].GetUInt32();
+	}
+}
+while (result->NextRow());
+
+    sLog->outString("");
+    sLog->outString(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_LOADED));
+    sLog->outString("");
+}
+
 void ObjectMgr::LoadCorpses()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 57c6fe1..b482d4d 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -917,6 +917,29 @@ class ObjectMgr
         void LoadTrainerSpell();
         void AddSpellToTrainer(uint32 entry, uint32 spell, uint32 spellCost, uint32 reqSkill, uint32 reqSkillValue, uint32 reqLevel);
 
+		// Loads the jail conf out of the database
+		void LoadJailConf(void);
+
+		// Jail Config...
+		std::string m_jail_obt;
+		uint32 m_jailconf_max_jails;    // Jail times when the char will be deleted
+		uint32 m_jailconf_max_duration; // Max. jail duration in hours
+		uint32 m_jailconf_min_reason;   // Min. char length of the reason
+		uint32 m_jailconf_warn_player;  // Warn player every login if max_jails is nearly reached?
+		uint32 m_jailconf_amnestie;     // player amnestie
+		float m_jailconf_ally_x;        // Coords of the jail for the allies
+		float m_jailconf_ally_y;
+		float m_jailconf_ally_z;
+		float m_jailconf_ally_o;
+		uint32 m_jailconf_ally_m;
+		float m_jailconf_horde_x;       // Coords of the jail for the horde
+		float m_jailconf_horde_y;
+		float m_jailconf_horde_z;
+		float m_jailconf_horde_o;
+		uint32 m_jailconf_horde_m;
+		uint32 m_jailconf_ban;          // Ban acc if max. jailtimes is reached?
+		uint32 m_jailconf_radius;       // Radius in which a jailed char can walk
+
         std::string GeneratePetName(uint32 entry);
         uint32 GetBaseXP(uint8 level);
         uint32 GetXPForLevel(uint8 level);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 4947288..d4fe80c 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -33,6 +33,9 @@
 #include "InstanceSaveMgr.h"
 #include "MapInstanced.h"
 #include "Util.h"
+// Playerbot mod start:
+#include "PlayerbotMgr.h"
+// Playerbot mod end.
 #include "LFGMgr.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
@@ -432,6 +435,14 @@ bool Group::AddMember(Player* player)
 
 bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /*= 0*/, const char* reason /*= NULL*/)
 {
+    // Playerbot mod start - if master leaves group, all bots leave group
+    {
+        Player* const player = ObjectAccessor::FindPlayer(guid);
+        if (player && player->GetPlayerbotMgr())
+            player->GetPlayerbotMgr()->RemoveAllBotsFromGroup();
+    }
+    // Playerbot mod end.
+
     BroadcastGroupUpdate();
 
     sScriptMgr->OnGroupRemoveMember(this, guid, method, kicker, reason);
diff --git a/src/server/game/Guilds/Guild.h b/src/server/game/Guilds/Guild.h
index e18e62e..35c2b0a 100755
--- a/src/server/game/Guilds/Guild.h
+++ b/src/server/game/Guilds/Guild.h
@@ -745,7 +745,6 @@ private:
     uint32 _GetRankRights(uint8 rankId) const;
     uint32 _GetRankBankMoneyPerDay(uint8 rankId) const;
     uint32 _GetRankBankTabSlotsPerDay(uint8 rankId, uint8 tabId) const;
-    std::string _GetRankName(uint8 rankId) const;
 
     uint32 _GetMemberRemainingSlots(uint64 guid, uint8 tabId) const;
     uint32 _GetMemberRemainingMoney(uint64 guid) const;
@@ -764,6 +763,7 @@ private:
     void _SendBankMoneyUpdate(WorldSession* session) const;
     void _SendBankContentUpdate(MoveItemData* pSrc, MoveItemData* pDest) const;
     void _SendBankContentUpdate(uint8 tabId, SlotIds slots) const;
+    std::string _GetRankName(uint8 rankId) const;
 
     void _BroadcastEvent(GuildEvents guildEvent, uint64 guid, const char* param1 = NULL, const char* param2 = NULL, const char* param3 = NULL) const;
 };
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 3c3888e..e6b3c49 100755
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -26,6 +26,7 @@
 #include "BattlegroundMgr.h"
 #include "Item.h"
 #include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
 
 MailSender::MailSender(Object* sender, MailStationery stationery) : m_stationery(stationery)
 {
@@ -178,6 +179,13 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
 
     uint32 mailId = sObjectMgr->GenerateMailID();
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION)        // auction mail with items
+            deleteIncludedItems(trans, true);
+        return;
+    }
+
     time_t deliver_time = time(NULL) + deliver_delay;
 
     //expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index 4faacc1..c3b7d73 100755
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -178,7 +178,9 @@ namespace Trinity
                         gain *= 2;
                 }
 
-                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL));
+	    float premium_rate = player->GetSession()->IsPremium() ? sWorld->getRate(RATE_XP_KILL_PREMIUM) : 1.0f;
+
+            return uint32(gain*sWorld->getRate(RATE_XP_KILL)*premium_rate);
             }
 
             sScriptMgr->OnGainCalculation(gain, player, u);
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 66610ad..6fd73b9 100755
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -21,6 +21,42 @@
 
 enum TrinityStrings
 {
+		// Added by WarHead for the Jail edited by spgm
+	LANG_JAIL_YOURE_JAILED              = 950,  // "You are jailed by %s for %u hour(s)!"
+	LANG_JAIL_REASON                    = 951,  // "%s wrote this as reason: %s"
+	LANG_JAIL_WAS_JAILED                = 952,  // "%s was jailed by you for %u hour(s)!"
+	LANG_JAIL_YOURE_UNJAILED            = 953,  // "You was released out of the jail by %s."
+	LANG_JAIL_WAS_UNJAILED              = 954,  // "You have released %s out of the jail."
+	LANG_JAIL_NOREASON                  = 955,  // "No reason given or reason is < %u chars!"
+	LANG_JAIL_NONAME                    = 956,  // "No name given!"
+	LANG_JAIL_NOTIME                    = 957,  // "No time given!"
+	LANG_JAIL_VALUE                     = 958,  // "The jailtime must be between 1 and %u hours!"
+	LANG_JAIL_CHAR_NOTJAILED            = 959,  // "The character (%s) is not jailed!"
+	LANG_JAIL_DENIED                    = 960,  // "Command forbidden for jailed characters!"
+	LANG_JAIL_JAILED_H_INFO             = 961,  // "You have %u hour(s) left in the jail."
+	LANG_JAIL_JAILED_M_INFO             = 962,  // "You have %u minute(s) left in the jail."
+	LANG_JAIL_NOTJAILED_INFO            = 963,  // "You're a free woman / man. ;-)"
+	LANG_JAIL_GM_INFO                   = 964,  // "%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: '%s'"
+	LANG_JAIL_GM_NOINFO                 = 965,  // "%s was never jailed."
+	LANG_JAIL_NO_JAIL                   = 966,  // "You can't jail yourself!"
+	LANG_JAIL_NO_UNJAIL                 = 967,  // "You can't unjail yourself!"
+	LANG_JAIL_WARNING                   = 968,  // "Be carefull! Only one more jailtime and your current character will be deleted!"
+	LANG_JAIL_ANNOUNCE1                 = 969,  // "The character '"
+	LANG_JAIL_ANNOUNCE2                 = 970,  // "' was jailed for "
+	LANG_JAIL_ANNOUNCE3                 = 971,  // " hour(s) by the GM character '"
+	LANG_JAIL_ANNOUNCE4                 = 972,  // "'. The reason is: "
+	LANG_JAIL_RELOAD                    = 973,  // "The jail configuration was reloaded."
+	LANG_JAIL_CONF_LOADED               = 974,  // ">> Jail config loaded."
+	LANG_JAIL_CONF_ERR1                 = 975,  // "Can't load jail config! Table empty or missed! Use jail_conf.sql!"
+	LANG_JAIL_CONF_ERR2                 = 976,  // "Set all jail config settings to default..."
+	LANG_JAIL_CHAR_TELE                 = 977,  // "The Character '%s' (GUID %u) is jailed and teleportet into the jail."
+	LANG_JAIL_CHAR_FREE                 = 978,  // "The Character '%s' (GUID %u) was released out of the jail."
+	LANG_JAIL_WRONG_NAME                = 979,  // "A character with this name doesn't exists!"
+	LANG_JAIL_WARNING_BAN               = 980,  // "Be carefull! Only one more jailtime and your account will be banned!"
+	LANG_JAIL_BAN_REASON                = 981,  // "Max. jailtimes reached!"
+	LANG_JAIL_BAN_BY                    = 982,  // "Robotron"
+	LANG_JAIL_AMNESTII					= 983,  // "AMNESTII"
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
@@ -705,6 +741,29 @@ enum TrinityStrings
 //  LANG_BG_AB_START_TWO_MINUTES        = 754, - defined above
 //  LANG_BG_EY_START_TWO_MINUTES        = 755, - defined above
 
+    LANG_BG_WG_BATTLE_STARTS            = 756,
+    LANG_BG_WG_DEFENDED                 = 757,
+    LANG_BG_WG_CAPTURED                 = 758,
+    LANG_BG_WG_WORKSHOP_DAMAGED         = 759,
+    LANG_BG_WG_WORKSHOP_DESTROYED       = 760,
+    LANG_BG_WG_TOWER_DAMAGED            = 761,
+    LANG_BG_WG_TOWER_DESTROYED          = 762,
+    LANG_BG_WG_FORTRESS_UNDER_ATTACK    = 763,
+    LANG_BG_WG_SWITCH_FACTION           = 764,
+    LANG_BG_WG_CHANGE_TIMER             = 765,
+    LANG_BG_WG_BATTLE_FORCE_START       = 766,
+    LANG_BG_WG_BATTLE_FORCE_STOP        = 767,
+    LANG_BG_WG_STATUS                   = 768,
+    LANG_BG_WG_DISABLE                  = 769,
+    LANG_BG_WG_ENABLE                   = 770,
+    LANG_BG_WG_RANK1                    = 771,
+    LANG_BG_WG_RANK2                    = 772,
+
+    LANG_BG_WG_WORLD_ANNOUNCE_30        = 780,
+    LANG_BG_WG_WORLD_ANNOUNCE_10        = 781,
+    LANG_BG_WG_WORLD_NO_DEF             = 782,
+    LANG_BG_WG_WORLD_NO_ATK             = 783,
+
     // Room for BG/ARENA                = 773-784, 788-799 not used
     LANG_ARENA_TESTING                  = 785,
     LANG_AUTO_ANN                       = 786,
@@ -734,7 +793,16 @@ enum TrinityStrings
 
     LANG_CHANNEL_CITY                   = 819,
     // Room for in-game strings           820-999 not used
-
+    LANG_SOTA                           = 990,
+    LANG_AV                             = 991,
+    LANG_ARENA_3                        = 992,
+    LANG_ARENA_2                        = 993,
+    LANG_ARENA_1                        = 994,
+    LANG_RANDOM                         = 995,
+    LANG_EOTS                           = 996,
+    LANG_AB                             = 997,
+    LANG_WSG                            = 998,
+    LANG_WG                             = 999,
     // Level 4 (CLI only commands)
     LANG_COMMAND_EXIT                   = 1000,
     LANG_ACCOUNT_DELETED                = 1001,
@@ -1060,6 +1128,7 @@ enum TrinityStrings
     LANG_INVALID_REALMID                = 11001,
 
     // NOT RESERVED IDS                   12000-1999999999
+    LANG_NOT_WHISPER                    = 12001, 
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
 };
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
index 53f7009..4384a31 100755
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -655,6 +655,8 @@ enum Team
     TEAM_OTHER               = 0,                         // if ReputationListId > 0 && Flags != FACTION_FLAG_TEAM_HEADER
 };
 
+const Team TeamId2Team[3] = {ALLIANCE, HORDE, TEAM_OTHER};
+
 enum SpellEffects
 {
     SPELL_EFFECT_INSTAKILL                          = 1,
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
index 6ea13d3..cb33b23 100755
--- a/src/server/game/OutdoorPvP/OutdoorPvP.h
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
@@ -32,9 +32,12 @@ enum OutdoorPvPTypes
     OUTDOOR_PVP_ZM = 4,
     OUTDOOR_PVP_SI = 5,
     OUTDOOR_PVP_EP = 6,
+    OUTDOOR_PVP_WG = 7,
 };
 
-#define MAX_OUTDOORPVP_TYPES 7
+#define MAX_OUTDOORPVP_TYPES 8
+
+const uint8 CapturePointArtKit[3] = {2, 1, 21};
 
 enum ObjectiveStates
 {
diff --git a/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp b/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
index 88e6db9..9f957b4 100755
--- a/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
@@ -20,6 +20,7 @@
 #include "Player.h"
 #include "DisableMgr.h"
 #include "ScriptMgr.h"
+#include "OutdoorPvPWG.h"
 
 OutdoorPvPMgr::OutdoorPvPMgr()
 {
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 90905f2..fcecb11 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -97,9 +97,9 @@ enum QuestStatus
 {
     QUEST_STATUS_NONE           = 0,
     QUEST_STATUS_COMPLETE       = 1,
-    //QUEST_STATUS_UNAVAILABLE    = 2,
+    QUEST_STATUS_UNAVAILABLE    = 2,
     QUEST_STATUS_INCOMPLETE     = 3,
-    //QUEST_STATUS_AVAILABLE      = 4,
+    QUEST_STATUS_AVAILABLE      = 4,
     QUEST_STATUS_FAILED         = 5,
     QUEST_STATUS_REWARDED       = 6,        // Not used in DB
     MAX_QUEST_STATUS
@@ -359,13 +359,14 @@ class Quest
 
 struct QuestStatusData
 {
-    QuestStatusData(): m_status(QUEST_STATUS_NONE), m_explored(false), m_timer(0), m_playercount(0)
+    QuestStatusData(): m_status(QUEST_STATUS_NONE), m_rewarded(false), m_explored(false), m_timer(0), m_playercount(0)
     {
         memset(m_itemcount, 0, QUEST_ITEM_OBJECTIVES_COUNT * sizeof(uint16));
         memset(m_creatureOrGOcount, 0, QUEST_OBJECTIVES_COUNT * sizeof(uint16));
     }
 
     QuestStatus m_status;
+    bool m_rewarded;
     bool m_explored;
     uint32 m_timer;
     uint16 m_itemcount[QUEST_ITEM_OBJECTIVES_COUNT];
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 6322151..5d0d970 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -24,6 +24,16 @@ void AddSC_example_gossip_codebox();
 void AddSC_example_misc();
 void AddSC_example_commandscript();
 
+// Custom
+void AddSC_npc_all();
+
+//TeleNPC2
+void AddSC_npc_teleport();
+
+// Summoning Item
+void AddSC_summon();
+void AddSC_levelnpc();
+
 // spells
 void AddSC_deathknight_spell_scripts();
 void AddSC_druid_spell_scripts();
@@ -42,6 +52,16 @@ void AddSC_example_spell_scripts();
 
 void AddSC_SmartSCripts();
 
+
+// Custom
+void AddSC_Npc_Beastmaster();
+
+//Custom
+void AddSC_Npc_Buff();
+
+//Custom
+void AddSC_professionnpc();
+
 //Commands
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
@@ -62,6 +82,12 @@ void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
 void AddSC_gps_commandscript();
 
+// Custom
+void AddSC_city_conquest_boss();
+void AddSC_city_conquest_generic();
+void AddSC_city_conquest_portal();
+void AddSC_city_conquest_spawner();
+
 #ifdef SCRIPTS
 //world
 void AddSC_areatrigger_scripts();
@@ -75,6 +101,8 @@ void AddSC_npc_innkeeper();
 void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
+//guildhouse
+void AddSC_guildmaster();
 
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
@@ -592,6 +620,8 @@ void AddSC_outdoorpvp_na();
 void AddSC_outdoorpvp_si();
 void AddSC_outdoorpvp_tf();
 void AddSC_outdoorpvp_zm();
+void AddSC_outdoorpvp_wg();
+void AddSC_wintergrasp();
 
 // player
 void AddSC_chat_log();
@@ -1203,6 +1233,8 @@ void AddNorthrendScripts()
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
     AddSC_isle_of_conquest();
+
+    AddSC_wintergrasp();
 #endif
 }
 
@@ -1215,6 +1247,7 @@ void AddOutdoorPvPScripts()
     AddSC_outdoorpvp_si();
     AddSC_outdoorpvp_tf();
     AddSC_outdoorpvp_zm();
+    AddSC_outdoorpvp_wg();
 #endif
 }
 
@@ -1233,6 +1266,23 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
-
+    // All In One NPC
+    AddSC_npc_all();
+    //TeleNPC2
+    AddSC_npc_teleport();
+    // Summoning Item
+    AddSC_summon();
+    //guildhouse
+    AddSC_guildmaster();
+    AddSC_Npc_Beastmaster();
+    AddSC_levelnpc();
+    // Buff NPC
+    AddSC_Npc_Buff();
+    AddSC_city_conquest_boss();
+    AddSC_city_conquest_generic();
+    AddSC_city_conquest_portal();
+    AddSC_city_conquest_spawner();
+    // Profession Npc
+    AddSC_professionnpc();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index d5e8f71..bc444e3 100755
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -27,6 +27,8 @@
 #include "ScriptSystem.h"
 #include "Transport.h"
 #include "Vehicle.h"
+#include "sc_npc_teleport.h"
+#include "CityConquestMgr.h"
 
 // This is the global static registry of scripts.
 template<class TScript>
@@ -247,6 +249,12 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+    // City Conquest
+    sLog->outString("Initializing City TeleNPC2 Updated by LordPsyan");
+	LoadNpcTele();
+	// Load TeleNPC2 - maybe not the best place to load it ...
+    sLog->outString("Initializing City Conquest Engine Updated by LordPsyan");
+    CityConquest.LoadCities();
 
     sLog->outString("Loading C++ scripts");
 
diff --git a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
index aaafb09..5f6f0a3 100755
--- a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
@@ -22,12 +22,14 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "AuctionHouseBot.h"
 #include "AuctionHouseMgr.h"
 #include "Log.h"
 #include "Opcodes.h"
 #include "UpdateMask.h"
 #include "Util.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 //please DO NOT use iterator++, because it is slower than ++iterator!!!
 //post-incrementation is always slower than pre-incrementation !
@@ -246,6 +248,11 @@ void WorldSession::HandleAuctionSellItem(WorldPacket & recv_data)
     AH->SaveToDB(trans);
     player->SaveInventoryAndGoldToDB(trans);
     CharacterDatabase.CommitTransaction(trans);
+  if ((sIRC.BOTMASK & 1024) != 0)
+  {
+  ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(item);
+    sIRC.AHFunc(it->GetEntry(), pProto->Name1, player->GetName(), AH->GetHouseId());
+  }
 
     SendAuctionCommandResult(AH->Id, AUCTION_SELL_ITEM, AUCTION_OK);
 
diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
index d1aa002..d0bc2bb 100755
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
@@ -35,6 +35,9 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -581,7 +584,18 @@ void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
         return;
 
     if (bg)
+    {
         sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+    }
+	else
+    {  // Wintergrasp Hack till 3.2 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->SendAreaSpiritHealerQueryOpcode(_player, guid);
+        }
+    }
 }
 
 void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index 11de2c6..f4643c4 100755
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -26,7 +26,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "DatabaseEnv.h"
-
+// Playerbot mod start:
+#include "PlayerbotMgr.h"
+// Playerbot mod end.
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Group.h"
@@ -223,8 +225,36 @@ void WorldSession::HandleCharEnum(PreparedQueryResult result)
     data.put<uint8>(0, num);
 
     SendPacket(&data);
+
+
+
 }
+        // Playerbot mod start: is different from the normal HandlePlayerLoginCallback in that it
+        // sets up the bot's world session and also stores the pointer to the bot player in the master's
+        // world session m_playerBots map
+void HandlePlayerBotLoginCallback(QueryResult * /*dummy*/, SQLQueryHolder * holder)
+{
+    if (!holder)
+        return;
+
+        LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
+
+    WorldSession* masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if (! masterSession || ObjectAccessor::FindPlayer(lqh->GetGuid()))
+    {
+        delete holder;
+        return;
+    }
 
+    // The bot's WorldSession is owned by the bot's Player object
+    // The bot's WorldSession is deleted by PlayerbotMgr::LogoutPlayerBot
+    WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, 0, masterSession->Expansion(), 0, LOCALE_enUS, 0, 0);
+    botSession->m_Address = "bot";
+    botSession->HandlePlayerLogin(lqh); // will delete lqh
+    masterSession->GetPlayer()->GetPlayerbotMgr()->OnBotLogin(botSession->GetPlayer());
+}
+        // Playerbot mod end.
 void WorldSession::HandleCharEnumOpcode(WorldPacket & /*recv_data*/)
 {
     // remove expired bans
@@ -760,7 +790,27 @@ void WorldSession::HandlePlayerLoginOpcode(WorldPacket & recv_data)
 
     _charLoginCallback = CharacterDatabase.DelayQueryHolder((SQLQueryHolder*)holder);
 }
+// Playerbot mod start: Can't easily reuse HandlePlayerLoginOpcode for logging in bots because it assumes
+// a WorldSession exists for the bot. The WorldSession for a bot is created after the character is loaded.
+void PlayerbotMgr::AddPlayerBot(uint64 playerGuid)
+{
+    // has bot already been added?
+    if (ObjectAccessor::FindPlayer(playerGuid))
+        return;
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(playerGuid);
+    if (accountId == 0)
+        return;
 
+    LoginQueryHolder *holder = new LoginQueryHolder(accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+    CharacterDatabase.DelayQueryHolder((SQLQueryHolder*)holder);
+}
+// Playerbot mod end.
 void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 {
     uint64 playerGuid = holder->GetGuid();
diff --git a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
index 3d68919..b3e297f 100755
--- a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
@@ -40,7 +40,11 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
+// Playerbot mod start:
+#include "PlayerbotAI.h"
+// Playerbot mod end.
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -274,8 +278,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
             bool receiverIsPlayer = AccountMgr::IsPlayerAccount(receiver ? receiver->GetSession()->GetSecurity() : SEC_PLAYER);
             if (!receiver || (senderIsPlayer && !receiverIsPlayer && !receiver->isAcceptWhispers() && !receiver->IsInWhisperWhiteList(sender->GetGUID())))
             {
+                // If Fake WHO List system on then show player DND 
+                if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST)) 
+                { 
+                    sWorld->SendWorldText(LANG_NOT_WHISPER); 
+                    return; 
+                } 
+                else 
+                { 
                 SendPlayerNotFoundNotice(to);
                 return;
+                }
             }
 
             if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT) && senderIsPlayer && receiverIsPlayer)
@@ -296,6 +309,16 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
             GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
+            // Playerbot mod start: handle whispered command to bot
+            if (sender->GetPlayerbotAI())
+            {
+                sender->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                GetPlayer()->Whisper(msg, lang, sender->GetGUID());
+            // Playerbot mod end.
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -314,6 +337,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
@@ -426,7 +462,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
                 }
             }
 
-            if (ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
+            sIRC.Send_WoW_IRC(_player, channel, msg);
+      if (ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
 
                 if (Channel* chn = cMgr->GetChannel(channel, _player))
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
index d828a86..72e1bd0 100755
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -349,8 +349,40 @@ void WorldSession::HandleWhoOpcode(WorldPacket & recv_data)
 
         ++displaycount;
     }
-
-    data.put(0, displaycount);                            // insert right count, count displayed
+	
+    if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST) && displaycount < 49) 
+    { 
+        // Fake players on WHO LIST                            0,   1,    2,   3,    4,   5     6 
+        QueryResult result = CharacterDatabase.Query("SELECT guid,name,race,class,level,zone,gender FROM characters WHERE online>1 AND level > 3"); 
+        if (result) 
+        { 
+            do 
+            { 
+                Field *fields = result->Fetch(); 
+ 
+                std::string pname = fields[1].GetString();    // player name 
+                std::string gname;                                // guild name 
+                uint32 lvl = fields[4].GetUInt32();                // player level 
+                uint32 class_ = fields[3].GetUInt32();            // player class 
+                uint32 race = fields[2].GetUInt32();            // player race 
+                uint32 pzoneid = fields[5].GetUInt32();            // player zone id 
+                uint8 gender = fields[6].GetUInt8();            // player gender 
+ 
+                data << pname;                              // player name 
+                data << gname;                              // guild name 
+                data << uint32(lvl);                        // player level 
+                data << uint32(class_);                     // player class 
+                data << uint32(race);                       // player race 
+                data << uint8(gender);                      // player gender 
+                data << uint32(pzoneid);                    // player zone id 
+ 
+                if ((++matchcount) == 49) 
+                    break; 
+            } while (result->NextRow()); 
+        } 
+    } 
+ 
+    data.put(0, matchcount);                            // insert right count, count displayed
     data.put(4, matchcount);                              // insert right count, count of matches
 
     SendPacket(&data);
diff --git a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
index 7e80c78..b3ccb4f 100755
--- a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
@@ -32,7 +32,9 @@
 #include "BattlegroundAV.h"
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
-
+// Playerbot mod start:
+#include "PlayerbotAI.h"
+// Playerbot mod end.
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -587,8 +589,16 @@ void WorldSession::HandlePushQuestToParty(WorldPacket& recvPacket)
                     continue;
                 }
 
-                player->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetGUID(), true);
                 player->SetDivider(_player->GetGUID());
+                // Playerbot mod start:
+                if (player->GetPlayerbotAI())
+                    _player->GetPlayerbotAI()->AcceptQuest( pQuest, player );
+                else
+                {
+                    _player->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, player->GetGUID(), true);
+                    _player->SetDivider(player->GetGUID());
+                }
+                // Playerbot mod end.
             }
         }
     }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 11085c9..d80e41a 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -42,6 +42,10 @@
 #include "zlib.h"
 #include "ScriptMgr.h"
 #include "Transport.h"
+// Playerbot mod start:
+#include "PlayerbotMgr.h"
+#include "PlayerbotAI.h"
+// Playerbot mod end.
 
 bool MapSessionFilter::Process(WorldPacket* packet)
 {
@@ -86,9 +90,9 @@ bool WorldSessionFilter::Process(WorldPacket* packet)
 }
 
 /// WorldSession constructor
-WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter):
+WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter):
 m_muteTime(mute_time), m_timeOutTime(0), _player(NULL), m_Socket(sock),
-_security(sec), _accountId(id), m_expansion(expansion), _logoutTime(0),
+_security(sec), _ispremium(ispremium), _accountId(id), m_expansion(expansion), _logoutTime(0),
 m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld->GetAvailableDbcLocale(locale)),
@@ -145,6 +149,14 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
     if (!m_Socket)
         return;
 
@@ -275,6 +287,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                                 LogUnprocessedTail(packet);
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
+
+                    // Playerbot mod start:
+                    if (_player && _player->GetPlayerbotMgr())
+                        _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                    // playerbot mod end
                         break;
                     case STATUS_LOGGEDIN_OR_RECENTLY_LOGGOUT:
                         if (!_player && !m_playerRecentlyLogout)
@@ -358,7 +375,31 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         ///- If necessary, log the player out
         if (ShouldLogOut(currTime) && !m_playerLoading)
             LogoutPlayer(true);
-
+    // Playerbot mod start - Process player bot packets
+    // The PlayerbotAI class adds to the packet queue to simulate a real player
+    // since Playerbots are known to the World obj only by its master's WorldSession object
+    // we need to process all master's bot's packets.
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr()) {
+        for (PlayerBotMap::const_iterator itr = GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsBegin();
+                itr != GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsEnd(); ++itr)
+        {
+            Player* const botPlayer = itr->second;
+            WorldSession* const pBotWorldSession = botPlayer->GetSession();
+            if (botPlayer->IsBeingTeleported())
+                botPlayer->GetPlayerbotAI()->HandleTeleportAck();
+            else if (botPlayer->IsInWorld())
+            {
+                WorldPacket* packet;
+                while (pBotWorldSession->_recvQueue.next(packet))
+                {
+                    OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+                    (pBotWorldSession->*opHandle.handler)(*packet);
+                    delete packet;
+                }
+            }
+        }
+    }
+    // Playerbot mod end.
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
         {
@@ -513,11 +554,18 @@ void WorldSession::LogoutPlayer(bool Save)
         // Call script hook before deletion
         sScriptMgr->OnPlayerLogout(GetPlayer());
 
+        // Playerbot - remember player GUID for update SQL below
+        uint32 guid = _player->GetGUIDLow();
+
         ///- Remove the player from the world
         // the player may not be in the world when logging out
         // e.g if he got disconnected during a transfer to another map
         // calls to GetMap in this case may cause crashes
         _player->CleanupsBeforeDelete();
+        // Playerbot mod start: log out all player bots owned by this toon
+        if (_player->GetPlayerbotMgr())
+            _player->GetPlayerbotMgr()->LogoutAllBots();
+        // Playerbot mod end.
         sLog->outChar("Account: %d (IP: %s) Logout Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName(), _player->GetGUIDLow());
         Map* _map = _player->GetMap();
         _map->RemovePlayerFromMap(_player, true);
@@ -535,7 +583,7 @@ void WorldSession::LogoutPlayer(bool Save)
         stmt->setUInt32(0, GetAccountId());
 
         CharacterDatabase.Execute(stmt);
-
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog->outDebug(LOG_FILTER_NETWORKIO, "SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
 
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index fac910a..c5b5c72 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -211,7 +211,7 @@ class CharacterCreateInfo
 class WorldSession
 {
     public:
-        WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
+        WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
 
         bool PlayerLoading() const { return m_playerLoading; }
@@ -239,6 +239,7 @@ class WorldSession
         void SendClientCacheVersion(uint32 version);
 
         AccountTypes GetSecurity() const { return _security; }
+        bool IsPremium() const { return _ispremium; }
         uint32 GetAccountId() const { return _accountId; }
         Player* GetPlayer() const { return _player; }
         char const* GetPlayerName() const;
@@ -904,7 +905,7 @@ class WorldSession
         QueryCallback<PreparedQueryResult, CharacterCreateInfo*, true> _charCreateCallback;
         QueryResultHolderFuture _charLoginCallback;
 
-    private:
+    public:
         // private trade methods
         void moveItems(Item* myItems[], Item* hisItems[]);
 
@@ -930,6 +931,7 @@ class WorldSession
         AccountTypes _security;
         uint32 _accountId;
         uint8 m_expansion;
+        bool _ispremium;
 
         typedef std::list<AddonInfo> AddonsList;
 
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index ac6f116..94789ed 100755
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -778,6 +778,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
     //uint8 expansion = 0;
     LocaleConstant locale;
     std::string account;
+	bool isPremium = false;
     SHA1Hash sha1;
     BigNumber v, s, g, N;
     WorldPacket packet, SendAddonPacked;
@@ -939,6 +940,16 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
         return -1;
     }
 
+    QueryResult premresult =
+        LoginDatabase.PQuery ("SELECT 1 "
+                                "FROM account_premium "
+                                "WHERE id = '%u' "
+                                "AND active = 1",
+                                id);
+    if (premresult) // if account premium
+    {
+        isPremium = true;
+    }
     // Check locked state for server
     AccountTypes allowedAccountType = sWorld->GetPlayerSecurityLimit();
     sLog->outDebug(LOG_FILTER_NETWORKIO, "Allowed Level: %u Player Level %u", allowedAccountType, AccountTypes(security));
@@ -1000,7 +1011,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
     LoginDatabase.Execute(stmt);
 
     // NOTE ATM the socket is single-threaded, have this in mind ...
-    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), expansion, mutetime, locale, recruiter, isRecruiter), -1);
+    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), isPremium, expansion, mutetime, locale, recruiter, isRecruiter), -1);
 
     m_Crypt.Init(&K);
 
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 2a67d2e..d207051 100755
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -36,6 +36,7 @@
 #include "CellImpl.h"
 #include "ScriptMgr.h"
 #include "Vehicle.h"
+#include "OutdoorPvPWG.h"
 
 class Aura;
 //
@@ -4894,6 +4895,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
                                 target->CastSpell(target, 58601, true);
                             break;
+                        case 58730: // Restricted Flight Area
+                            if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
+                            {
+                                target->CastSpell(target, 58601, true);
+                                target->CastSpell(target, 45472, true);
+                            }
                     }
                     break;
                 case SPELLFAMILY_MAGE:
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index bbc07c0..25a45be 100755
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -53,6 +53,8 @@
 #include "SpellScript.h"
 #include "InstanceScript.h"
 #include "SpellInfo.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
 
 extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
 
@@ -4573,6 +4575,8 @@ void Spell::HandleEffects(Unit* pUnitTarget, Item* pItemTarget, GameObject* pGOT
 
 SpellCastResult Spell::CheckCast(bool strict)
 {
+	OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     // check death state
     if (!m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR0_PASSIVE) && !((m_spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD) || (IsTriggered() && !m_triggeredByAuraSpell)))
         return SPELL_FAILED_CASTER_DEAD;
@@ -5392,8 +5396,16 @@ SpellCastResult Spell::CheckCast(bool strict)
                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
                 {
                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
+                        {
                         if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        // Wintergrasp Antifly check
+                        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                        {
+                          if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime()==true)
+                          return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        }
+                    }
                 }
                 break;
             }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index bb898ac..381bd04 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -63,6 +63,7 @@
 #include "GameObjectAI.h"
 #include "AccountMgr.h"
 #include "InstanceScript.h"
+#include "OutdoorPvPWG.h"
 
 pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
 {
@@ -4486,6 +4487,24 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
         {
             switch (m_spellInfo->Id)
             {
+                //Teleport to Lake Wintergrasp
+                case 58622:
+                   {
+                  if(OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                        if(pvpWG->isWarTime() || pvpWG->m_timer<300000)
+                        {
+                        if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
+                    
+                        if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
+                        }
+                return;
+                   }
                 // Glyph of Backstab
                 case 63975:
                 {
@@ -7293,9 +7312,24 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
     if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
         return;
 
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     switch (m_spellInfo->Id)
     {
         case 58730: // Restricted Flight Area
+           {
+             if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+              {
+              if (pvpWG->isWarTime()==true)
+               {
+                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
+                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
+               break;
+               } else unitTarget->RemoveAura(58730);
+              }
+            break;
+            }
         case 58600: // Restricted Flight Area
             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
             break;
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index b7c31ee..cbd6cda 100755
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -30,6 +30,8 @@
 #include "CreatureAI.h"
 #include "MapManager.h"
 #include "BattlegroundIC.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 bool IsPrimaryProfessionSkill(uint32 skill)
 {
@@ -1092,6 +1094,8 @@ SpellAreaForAreaMapBounds SpellMgr::GetSpellAreaForAreaMapBounds(uint32 area_id)
 
 bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
 {
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     if (gender != GENDER_NONE)                   // not in expected gender
         if (!player || gender != player->getGender())
             return false;
@@ -1131,6 +1135,19 @@ bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32
                 return false;
             break;
         }
+        case 58730: // No fly Zone - Wintergrasp
+            {
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                  if ((pvpWG->isWarTime()==false) || !player || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)) || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->isInFlight())
+                    return false;
+                }
+            }
+            break;
+        case 58045: // Essence of Wintergrasp - Wintergrasp
+        case 57940: // Essence of Wintergrasp - Northrend
+             if (!player || player->GetTeamId() != sWorld->getWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION))
+             return false;
         case 68719: // Oil Refinery - Isle of Conquest.
         case 68720: // Quarry - Isle of Conquest.
         {
diff --git a/src/server/game/TriniChat/IRCClient.cpp b/src/server/game/TriniChat/IRCClient.cpp
new file mode 100644
index 0000000..d25c3a3
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.cpp
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+
+#include "framework/Policies/SingletonImp.h"
+INSTANTIATE_SINGLETON_1(IRCClient);
+
+#ifdef WIN32
+    #define Delay(x) Sleep(x)
+#else
+    #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient()
+{
+    for (int i = 0;i > 5;i++)
+        sIRC.Script_Lock[i] = false;
+}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (trinitycore)
+void IRCClient::run()
+{
+    sIRC.iLog.WriteLog(" %s : ****** Trinity Core With TriniChat Has Been Started ******", sIRC.iLog.GetLogDateTimeStr().c_str());
+
+    // before we begin we wait a few 
+    // mangos is still starting up.
+    ACE_Based::Thread::Sleep(500);
+    sLog->outString("\n%s\n%s\n%s\n%s",
+        "***************************************",
+        "**   TriniChat2 Threaded IRC Client   **",
+        "**     With Enhanced GM Control.     **",
+        "***************************************");
+    sLog->outString("****** TriniChat: %s ********", sIRC._Mver.c_str());
+    int cCount = 1;
+    // Clean Up MySQL Tables
+    sLog->outString("*** TriniChat: Cleaning Up Inchan Table*");
+    WorldDatabase.PExecute("DELETE FROM `irc_inchan`");
+    sIRC._Max_Script_Inst = 0;
+    // Create a loop to keep the thread running untill active is set to false
+    while (sIRC.Active && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (this->InitSock())
+        {
+            // Connect To The IRC Server
+            sLog->outString("*** TriniChat: Connecting to %s Try # %d ******", sIRC._Host.c_str(), cCount);
+           if (this->Connect(sIRC._Host.c_str(), sIRC._Port))
+           {
+               // On connection success reset the connection counter
+               cCount = 0;
+               sLog->outString("*** TriniChat: Connected And Logging In*");
+                // Login to the IRC server
+                if (this->Login(sIRC._Nick, sIRC._User, sIRC._Pass))
+                {
+                    sLog->outString("*** TriniChat: Logged In And Running!! *");
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (sIRC.Connected && !World::IsStopped()){ sIRC.SockRecv(); }
+                }
+                sLog->outString("*** TriniChat: Connection To IRC Server Lost! ***");
+            }
+            // When an error occures or connection lost cleanup
+            Disconnect();
+            // Increase the connection counter
+            cCount++;
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (sIRC._MCA != 0 && cCount == sIRC._MCA)
+                sIRC.Active = false;
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (sIRC.Active)
+                ACE_Based::Thread::Sleep(sIRC._wct);
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            sIRC.Active = false;
+            sLog->outError("** TriniChat: Could not initialize socket");
+        }
+    }
+    while (!World::IsStopped()){};
+}
+
+std::string IRCClient::GetChatLine(int nItem)
+{
+    return sIRC.ILINES[nItem];
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCClient.h b/src/server/game/TriniChat/IRCClient.h
new file mode 100644
index 0000000..3c34944
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.h
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include "framework/Policies/SingletonImp.h"
+#include "Player.h"
+#include "IRCLog.h"
+#include "IRCCmd.h"
+
+using namespace std;
+// The maximum ammount of channels used, must be >= config option
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+    IRC_WOW = 0,
+    WOW_IRC = 1,
+    JOIN_WOW = 2,
+    JOIN_IRC = 3,
+    LEAVE_WOW = 4,
+    LEAVE_IRC = 5,
+    CHANGE_NICK = 6
+};
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+    CHANNEL_JOIN,
+    CHANNEL_LEAVE,
+};
+
+enum script_Names
+{
+    MCS_Players_Online  = 0,
+};
+
+// IRCClient main class
+class IRCClient : public ACE_Based::Runnable
+{
+    public:
+        // IRCClient Constructor
+        IRCClient();
+        // IRCClient Destructor
+        ~IRCClient();
+        // ZThread Entry
+        void run();
+    public:
+        // AH Function
+        void AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction);
+        //bool BeenToGMI(float posx, float posy, std::string player, std::string from);
+        // IRCClient active
+        bool    Active;
+        // Connected to IRC
+        bool    Connected;
+        // Socket indentifier
+        int     SOCKET;
+        fd_set  sfdset;
+        // Send data to IRC, in addition the endline is added \n
+        bool    SendIRC(std::string data);
+        // This function is called in ChatHandler.cpp and processes the chat from game to IRC
+        void    Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+        // Sends a message to all players on the specified channel
+        void    Send_WoW_Channel(const char *channel, std::string chat);
+        // Send a system message to all players
+        void    Send_WoW_System(std::string Message);
+        // Send a message to the specified IRC channel
+        void    Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+        // Sends a message to all IRC Channels
+        void    Send_IRC_Channels(std::string sMsg);
+        std::string MakeMsg(std::string msg, std::string var, std::string val)
+        {
+            std::size_t start = msg.find(var);
+            if (start != std::string::npos)
+                msg.replace(start, var.length(), val);
+            return msg;
+        }
+        void    Send_WoW_Player(string sPlayer, string sMsg);
+        void    Send_WoW_Player(Player *plr, string sMsg);
+
+        // This function is called in Channel.cpp and processes Join/leave messages
+        void    Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+        void    ResetIRC();
+    public:
+        void AutoJoinChannel(Player *plr);
+
+    public:
+        bool Script_Lock[5];
+        bool _AmiOp;
+
+    public:
+        string _Mver;
+        // IRC Server host
+        string  _Host;
+        // IRC Server Port
+        int _Port;
+        // IRC Username
+        string  _User;
+        // IRC Password
+        string  _Pass;
+        // IRC Nickname
+        string  _Nick;
+        //Password for in-game channel
+        std::string _irc_pass[MAX_CONF_CHANNELS];
+        // Authentication type
+        int _Auth;
+        string _Auth_Nick;
+        // IRC Connect code
+        string  _ICC;
+        // IRC Default channel
+        string  _defchan;
+        // IRC Leave Default channel
+        int _ldefc;
+        // Wait Connect Time
+        int _wct;
+        // BotMask Options
+        int Botmask;
+        // Status Channel
+        int Status;
+        // Announce Channel
+        int anchn;
+        int autoanc;
+        // IRC Channel count
+        int _chan_count;
+        // IRC Channel list
+        // Array to store our IRC channels
+        // each element will corrospond
+        // with _wow_chan array below.
+        std::string _irc_chan[MAX_CONF_CHANNELS];
+        // Game Channel list
+        std::string _wow_chan[MAX_CONF_CHANNELS];
+        // AutoJoin Options
+        int ajoin;
+        string ajchan;
+        // Online Command Max Results
+        int onlrslt;
+        // Channel OnJoin/Restart/Kick Messages
+        string  JoinMsg;
+        string  RstMsg;
+        string  kikmsg;
+        // Misc Options
+        string  ojGM1;
+        string  ojGM2;
+        string  ojGM3;
+        string  ojGM4;
+        string  ojGM5;
+        string  ojGM6;
+	    string  ojGM7;
+	    string  ojGM8;
+        string  logfile;
+        string  logchan;
+        string  logchanpw;
+        int     logmask;
+        int     games;
+        int     gmlog;
+        // IRC Commands Security Level
+        int     CACCT;
+        int     CBAN;
+        int     CCHAN;
+        int     CCHAR;
+        int     CFUN;
+        int     CHELP;
+        int     CINCHAN;
+        int     CINFO;
+        int     CITEM;
+        int     CJAIL;
+        int     CKICK;
+        int     _KILL;
+        int     CLEVEL;
+        int     CLOOKUP;
+        int     CMONEY;
+        int     CMUTE;
+        int     CONLINE;
+        int     CPM;
+        int     CRECONNECT;
+        int     CRELOAD;
+        int     CREVIVE;
+        int     CSAVEALL;
+        int     CSERVERCMD;
+        int     CSHUTDOWN;
+        int     CSPELL;
+        int     CSYSMSG;
+        int     CTELE;
+        int     CTOP;
+		int     CPLAYER;
+        int     CWHO;
+        // BotMask
+        int     BOTMASK;
+        // Max connect attempt
+        int     _MCA;
+        // Auto rejoin when kicked from irc
+        int     _autojoinkick;
+        // IRC Command prefix
+        string  _cmd_prefx;
+        int _op_gm;
+        int _op_gm_lev;
+        // Array that contains our chatlines from the conf file
+        // To increase this value change the MAX_CHAT_LINE define above
+        // Make sure the number of elements must match your items
+        // (remeber this starts at 0 so 0..9 is 10 items)
+        // and that you load the line in the LoadConfig function.
+        string  ILINES[MAX_CHAT_LINES];
+        string  GetChatLine(int nItem);
+
+        int _Max_Script_Inst;
+        // MAX_SCRIPT_INST
+
+        IRCLog iLog;
+
+private:
+        // Returns default chatline based on enum CLINES
+        // Initialize socket library
+        bool    InitSock();
+        // Connect to IRC Server
+        bool    Connect(const char *cHost, int nPort);
+        // Login to IRC Server
+        bool    Login(std::string sNick, std::string sUser, std::string sPass);
+        // Send raw data to IRC
+        bool    SendData(const char *data);
+        // Disconnect from IRC and cleanup socket
+        void    Disconnect();
+        // Processes the data receieved from IRC
+        void    Handle_IRC(std::string sData);
+        // Receieves data from the socket.
+        void    SockRecv();
+};
+#endif
+#define sIRC Trinity::Singleton<IRCClient>::Instance()
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmd.cpp b/src/server/game/TriniChat/IRCCmd.cpp
new file mode 100644
index 0000000..251cc6a
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.cpp
@@ -0,0 +1,930 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "MapManager.h"
+#include "World.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+
+std::string IRCCmd::MakeUpper(std::string Channel)
+{
+    std::string tmpchan = Channel;
+    std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+    return tmpchan;
+}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+    CD->PCOUNT = pCnt;
+    if (CD->PARAMS.size() == 0)
+        return false;
+    return ValidParams(CD->PARAMS, pCnt);
+}
+
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+    //CD->PCOUNT = pCnt;
+    if (!CanUse(CD->USER, rLev))
+        return E_AUTH;
+    else if (pCnt == 0)
+        return E_OK;
+    else if (CD->PARAMS.size() == 0)
+        return E_SIZE;
+    else if (!ValidParams(CD->PARAMS, pCnt))
+        return E_SIZE;
+    return E_OK;
+}
+
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE)
+{
+    // If the first line of our chat is the command prefix we have a command
+    if (CHAT.substr(0, 1) == sIRC._cmd_prefx && CHAT.size() > 1)
+    {
+        _CDATA CDATA;
+        bool cValid    = false;
+        bool AuthValid = true;
+        bool dontlog   = true;
+        std::string* _PARAMS = getArray(CHAT, 2);
+        CDATA.USER      = USER;
+        CDATA.FROM      = FROM;
+        CDATA.TYPE      = TYPE;
+        CDATA.PCOUNT    = 0;
+        CDATA.CMD       = MakeUpper(_PARAMS[0].substr(1, _PARAMS[0].size() - 1));
+        CDATA.PARAMS    = _PARAMS[1];
+        if (CDATA.CMD == "LOGIN")
+        {
+            if (FROM == sIRC._Nick)
+            {             
+                if (ParamsValid(&CDATA, 2))  
+                    Handle_Login(&CDATA);
+                else
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"login <Player> <Password>)", true, "ERROR");
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Login!", true, "ERROR");
+            if (GetLevel(USER) >= sIRC.gmlog)
+                dontlog = false;
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOGOUT")
+        {
+            if (FROM == sIRC._Nick)
+            {
+                Handle_Logout(&CDATA);
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Logout!", true, "ERROR");
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ACCT")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CACCT))
+            {
+                case E_OK:
+                    Account_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"acct <Player> <(un)lock/email/pass/rename/gmlevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "BAN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CBAN))
+            {
+                case E_OK:
+                    Ban_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"ban <Player> <acct/ip>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CCHAN))
+            {
+                case E_OK:
+                    Chan_Control(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"chan <op> <IRC User>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAR")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CCHAR))
+            {
+                case E_OK:
+                    Char_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"char <Player> <mailcheat/taxicheat/maxskill/setskill/quest/mod>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "FUN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CFUN))
+            {
+                case E_OK:
+                    Fun_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"fun <Player> <Sound/Say>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "HELP")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CHELP))
+            {
+                case E_OK:
+                    Help_IRC(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"help <Command>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INCHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CINCHAN))
+            {
+                case E_OK:
+                    Inchan_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"inchan <Channel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INFO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CINFO))
+            {
+                case E_OK:
+                    Info_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"info)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ITEM")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 2, sIRC.CITEM))
+            {
+                case E_OK:
+                    Item_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "JAIL")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 1, sIRC.CJAIL))
+            {
+                case E_OK:
+                    Jail_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"jail <Player> <release/Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KICK")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CKICK))
+            {
+                case E_OK:
+                    Kick_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kick <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KILL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC._KILL))
+            {
+                case E_OK:
+                    Kill_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kill <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LEVEL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLEVEL))
+            {
+                case E_OK:
+                    Level_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"level <Player> <NewLevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOOKUP")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLOOKUP))
+            {
+                case E_OK:
+                    Lookup_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MONEY")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CMONEY))
+            {
+                case E_OK:
+                    Money_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"money <Player> <(-)Money>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MUTE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CMUTE))
+            {
+                case E_OK:
+                    Mute_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"mute <Player> <release/TimeInMins> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ONLINE")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CONLINE))
+            {
+                case E_OK:
+                    Online_Players(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"online)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PM")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CPM))
+            {
+                case E_OK:
+                    PM_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"pm <Player> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RELOAD")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRELOAD))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels("Reloading Configiguration Options.");
+                    sWorld->LoadConfigSettings(true);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RECONNECT")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRECONNECT))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels(sIRC.RstMsg);
+                    sIRC.ResetIRC();
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RESTART")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Restart_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints/sec_number_for_restart>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "REVIVE")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CREVIVE))
+            {
+                case E_OK:
+                    Revive_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"revive <Player>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SAVEALL")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSAVEALL))
+            {
+                case E_OK:
+                    Saveall_Player(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SERVER")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSERVERCMD))
+            {
+                case E_OK:
+                    Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SHUTDOWN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Shutdown_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"shutdown <TimeInSeconds>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SPELL")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CSPELL))
+            {
+                case E_OK:
+                    Spell_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SYSMSG")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSYSMSG))
+            {
+                case E_OK:
+                    Sysmsg_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"sysmsg <a/e/n/add/del/list> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TELE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CTELE))
+            {
+                case E_OK:
+                    Tele_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/GO GUID/Homebind>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TOP")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC.CTOP))
+            {
+                case E_OK:
+                    Top_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"top <accttime/chartime/money> <limit>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PLAYER")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC.CPLAYER))
+            {
+                case E_OK:
+                    Player_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"player <PLAYER>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+		else if (CDATA.CMD == "WHO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CWHO))
+            {
+                case E_OK:
+                    Who_Logged(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        if (!AuthValid && IsLoggedIn(USER))
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, "ERROR");
+        if (cValid == false && (sIRC.BOTMASK & 4) != 0)
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Unknown Command!", true, "ERROR");
+        if (cValid && dontlog)
+        {
+            sIRC.iLog.WriteLog(" %s : [ %s(%d) ] Used Command: [ %s ] With Parameters: [ %s ]", sIRC.iLog.GetLogDateTimeStr().c_str(), CDATA.USER.c_str(), GetLevel(USER), CDATA.CMD.c_str(), CDATA.PARAMS.c_str());
+            if ((sIRC.logmask & 1) != 0)
+            {
+                std::string logchan = "#";
+                logchan += sIRC.logchan;
+                std::stringstream ss;
+                ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << CDATA.USER << "(" << GetLevel(USER) << ") ] Used Command: [ " << CDATA.CMD << " ] With Parameters: [" << CDATA.PARAMS << " ]";
+                sIRC.Send_IRC_Channel(logchan, ss.str().c_str(), true);
+            }
+        }
+        return cValid;
+    }
+    return false;
+}
+
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+    if (IsLoggedIn(USER))
+    {
+        if (GetLevel(USER) >= nLevel)
+            return true;
+        else
+            return false;
+    }
+    else if (nLevel == 0)
+    {
+        return true;
+    }
+    else
+        sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+    return false;
+}
+
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+    if (CD->FROM == sIRC._Nick)
+        return CD->USER;
+    else
+        return CD->FROM;
+}
+
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+    normalizePlayerName(WHO);
+    return sObjectAccessor->FindPlayerByName(WHO.c_str());
+}
+
+_client *IRCCmd::GetClient(std::string cname)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == cname)
+            return (*i);
+    }
+    return (NULL);
+}
+
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == USER)
+            return true;
+    }
+    return false;
+}
+
+bool IRCCmd::AcctIsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if (MakeUpper((*i)->UName) == MakeUpper(USER))
+            return true;
+    }
+    return false;
+}
+
+std::string IRCCmd::AcctIsBanned(std::string ACCT)
+{
+    uint32 acctid = AccountMgr::GetId(ACCT);
+    std::string banned = "NOTBANNED";
+    QueryResult result = LoginDatabase.PQuery("SELECT banreason FROM ip_banned WHERE ip=(SELECT last_ip FROM account WHERE id = '%i')", acctid);
+    if (result)
+    {
+        banned = (*result)[0].GetCString();
+        
+        return "IP Banned. Reason:" + banned;
+    }
+    QueryResult result2 = LoginDatabase.PQuery("SELECT banreason FROM account_banned WHERE id='%i'", acctid);
+    if (result2)
+    {
+        banned = (*result2)[0].GetCString();
+        
+        return "Account Banned. Reason:" + banned;
+    }
+    return banned;
+}
+
+int IRCCmd::GetLevel(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->GMLevel;
+    }
+    return 0;
+}
+
+int IRCCmd::AcctLevel(std::string plnme)
+{
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(plnme);
+    uint32 account_id = 0;
+    uint32 security = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    security = AccountMgr::GetSecurity(account_id);
+    return security;
+}
+
+std::string IRCCmd::GetAccName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->UName;
+    }
+    return "";
+}
+
+std::string IRCCmd::GetNameFromAcct(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->UName == sName)
+            return (*i)->Name;
+    }
+    return "";
+}
+
+int IRCCmd::GetAcctIDFromName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+        {
+            uint32 acct_id = 0;
+            acct_id = AccountMgr::GetId((*i)->UName.c_str());
+            return acct_id;
+        }
+    }
+    return 0;
+}
+
+std::string IRCCmd::GetAcctNameFromID(uint32 acctid)
+{
+    QueryResult result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%d'", acctid);
+    if (result)
+    {
+        std::string name = (*result)[0].GetCString();
+        
+        return name;
+    }
+
+    return "";
+}
+
+std::string IRCCmd::GetIPFromPlayer(std::string player)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", player.c_str());
+    if (result)
+    {
+        std::string acctid = (*result)[0].GetCString();
+        
+        QueryResult result2 = LoginDatabase.PQuery("SELECT last_ip FROM account WHERE id = '%s'", acctid.c_str());
+        if (result2)
+        {
+            std::string ip = (*result2)[0].GetCString();
+            
+            return ip;
+        }       
+    }
+
+    return "";
+}
+
+std::string IRCCmd::SecToDay(std::string secons)
+{
+    unsigned int seconds = atoi(secons.c_str());
+    unsigned int days = seconds / 86400;
+    unsigned int hours = seconds / 3600 % 24;
+    unsigned int mins = seconds / 60 % 60;
+    char tottime[1000];
+    sprintf(tottime, "%iDays:%iHours:%iMinutes", days, hours, mins);
+
+    return tottime;
+}
+
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+    if (nCount == 1 && PARAMS.size() == 0)
+        return false;
+    int pcount = 0;
+    size_t p = -1;
+    for (int i = 0;i < nCount;i++)
+    {
+        p = PARAMS.find(" ", p + 1);
+        if (p == -1)
+            break;
+        else
+            pcount++;
+    }
+    nCount--;
+    if (pcount >= nCount)
+        return true;
+    else
+        return false;
+}
+
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+
+std::string IRCCmd::MakeMsg(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+void IRCClient::AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction)
+{
+    IRCCmd Command;
+    Player* plr = Command.GetPlayer(plname);
+    if (plr)
+    {
+        std::string itemname = itmnme;
+
+        char  temp [7];
+        sprintf(temp, "%u", itmid);
+        std::string itemid = temp;
+
+        std::string wowname = "";
+        std::string ircname = "";
+        switch (plr->GetTeam())
+        {
+            case 67:wowname="|cffff0000"+plname+"|r";ircname="\0034"+plname;break;      //horde
+            case 469:wowname="|cff1589FF"+plname+"|r";ircname="\00312"+plname;break;    //alliance
+        }
+        
+        std::string wowfact = "|cffFF8040[Auction House]:|r";
+        std::string ircfact = "\00304,08\037/!\\\037\017\00307 Auction House \00304,08\037/!\\\037\017";
+        switch(faction)
+        {
+            //neutral
+            case 7:wowfact="|cffff8040[Neutral Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00307 Neutral Auction House \00304,08\037/!\\\037\017";break;
+            //horde
+            case 6:wowfact="|cffff0000[Horde Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00304 Horde Auction House \00304,08\037/!\\\037\017";break;
+            //alliance
+            case 2:wowfact="|cff1589FF[Alliance Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00312 Alliance Auction House \00304,08\037/!\\\037\017";break;
+        }
+        std::string wowstr = Command.MakeMsg("%s A New Item Has Been Added |cffffffff|Hitem:%s:0:0:0:0:0:0:0|h[%s]|h|r. By: %s",wowfact.c_str(), itemid.c_str(), itemname.c_str(), wowname.c_str());
+        std::string ircstr = Command.MakeMsg("%s A New Item Has Been Added [%s]. By: %s", ircfact.c_str(), itemname.c_str(), ircname.c_str());
+
+        sIRC.Send_WoW_Channel(sIRC._wow_chan[sIRC.Status].c_str(), wowstr.c_str());
+        sIRC.Send_IRC_Channel(sIRC._irc_chan[sIRC.Status].c_str(), ircstr.c_str());
+    }
+}
+
+/* Disabled
+bool IRCClient::BeenToGMI(float posx, float posy, std::string player, std::string from)
+{
+    IRCCmd Command;
+    //std::transform(location.begin(), location.end(), location.begin(), towupper);
+    //sObjectMgr->GetAreaId
+    //if (location == "GMI" || location == "GMISLAND")
+    if (MapManager::Instance().GetZoneId(1,posx,posy) == 876)
+    {
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT name FROM Hell_GMI WHERE name = '%s'",player.c_str());
+        if (result)
+        {
+            
+            uint64 guid = sObjectMgr->GetPlayerGUIDByName(player);
+            Player* plr = sObjectMgr->GetPlayer(guid);
+
+            uint64 guid2 = sObjectMgr->GetPlayerGUIDByName(from);
+            Player* plr2 = sObjectMgr->GetPlayer(guid2);
+            if (plr) sIRC.Send_WoW_Player(plr, "You Have Already Had A Trip To GM Island. There Is Only One Tele To GM Island Per Player, Please Donate If You Would like The .tele Command.");
+            if (plr2) sIRC.Send_WoW_Player(plr2, "This Player Has Already Had Their Trip To GM Island. The Tele Has Been Canceled.");
+            else sIRC.Send_IRC_Channel(from.c_str(), MakeMsg(" \0034[ERROR] : $Player Has Already Had Their Trip To GMI! The Tele Has Been Canceled", "$Player", player.c_str()), true, "ERROR");
+            return true;
+        }
+        else
+        {
+            if (Command.AcctLevel(player) == 0)
+                WorldDatabase.PExecute("INSERT INTO `Hell_GMI` VALUES ('%s')", player.c_str());
+            return false;
+        }
+    }
+    return false;
+}*/
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmd.h b/src/server/game/TriniChat/IRCCmd.h
new file mode 100644
index 0000000..fb959b9
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+
+#define MAX_CLIENTS 50
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+#include "BattlegroundMgr.h"
+
+struct ChannelUser
+{
+    int UserType;
+    std::string Name;
+    std::string UName;
+    int UserLevel;
+};
+
+struct _client
+{
+    bool        LoggedIn;
+    std::string Name;
+    std::string UName;
+    int         GMLevel;
+};
+struct _CDATA
+{
+    std::string CMD;
+    std::string USER;
+    std::string FROM;
+    std::string PARAMS;
+    std::string TYPE;
+    int PCOUNT;
+};
+enum APVERR
+{
+    E_OK,
+    E_SIZE,
+    E_AUTH,
+    E_IVALID,
+};
+enum ESOUNDS
+{
+    S_ENTERWORLD    = 602,
+    S_QUESTFAILED   = 847,
+    S_INVITE        = 880,
+    S_LEVELUP       = 888,
+    S_COINSOUND     = 895,
+    S_WHISPER       = 3081,
+    S_STEALTH       = 3325,
+};
+class IRCCmd
+{
+    public:
+        IRCCmd();
+        ~IRCCmd();
+        
+        void    Handle_Logout(_CDATA *CD);
+        bool    IsLoggedIn(std::string USER);
+        bool    IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE);
+        bool    AcctIsLoggedIn(std::string USER);
+        _client *GetClient(std::string cname);
+
+    public:
+        static std::string MakeMsg(const char *sLine, ...);
+        static std::string ChanOrPM(_CDATA *CD);
+        int AcctLevel(std::string plnme);
+        int GetLevel(std::string sName);
+        std::string MakeUpper(std::string Channel);
+        std::string  AcctIsBanned(std::string ACCT);
+        std::list<_client*> _CLIENTS;
+        Player* GetPlayer(std::string WHO);
+
+    private:
+        // TriniChat Commands
+        void    Handle_Login(_CDATA *CD);
+        void    Account_Player(_CDATA *CD);
+        void    Ban_Player(_CDATA *CD);
+        void    Chan_Control(_CDATA *CD);
+        void    Char_Player(_CDATA *CD);
+        void    Fun_Player(_CDATA *CD);
+        void    Help_IRC(_CDATA *CD);
+        void    Inchan_Server(_CDATA *CD);
+        void    Info_Server(_CDATA *CD);
+		void	Item_Player(_CDATA *CD);
+        void    Jail_Player(_CDATA *CD);
+        void    Kick_Player(_CDATA *CD);
+        void    Kill_Player(_CDATA *CD);
+        void    Player_Player(_CDATA *CD);
+        void    Lookup_Player(_CDATA *CD);
+		void    Level_Player(_CDATA *CD);
+        void    Money_Player(_CDATA *CD);
+        void    Mute_Player(_CDATA *CD);
+        void    Online_Players(_CDATA *CD);
+        void    PM_Player(_CDATA *CD);
+		void    Restart_Trinity(_CDATA *CD);
+        void    Revive_Player(_CDATA *CD);
+        void    Saveall_Player(_CDATA *CD);
+        void    Server(_CDATA *CD);
+        void    Shutdown_Trinity(_CDATA *CD);
+        void    Spell_Player(_CDATA *CD);
+        void    Sysmsg_Server(_CDATA *CD);
+        void    Tele_Player(_CDATA *CD);
+        void    Top_Player(_CDATA *CD);
+        void    Who_Logged(_CDATA *CD);
+        bool    CanUse(std::string USER, int nLevel);
+        bool    ValidParams(std::string PARAMS, int nCount = 1);
+        bool    ParamsValid(_CDATA *CD, int pCnt);
+        int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+        std::string GetAccName(std::string sName);
+        std::string GetNameFromAcct(std::string sName);
+        std::string GetAcctNameFromID(uint32 acctid);
+        std::string GetIPFromPlayer(std::string player);
+        std::string SecToDay(std::string secons);
+        int GetAcctIDFromName(std::string sName);
+        std::string* getArray(std::string PARAMS, int nCount = 1);
+};
+inline void MakeLower(std::string& str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+}
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmde.cpp b/src/server/game/TriniChat/IRCCmde.cpp
new file mode 100644
index 0000000..3bd2954
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmde.cpp
@@ -0,0 +1,2337 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "MCS_OnlinePlayers.h"
+#include "WorldPacket.h"
+#include "Database/DatabaseEnv.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "SystemConfig.h"
+#include "Config.h"
+#include "ArenaTeamMgr.h"
+
+#pragma warning(disable:4018)
+#pragma warning(disable:4804)
+#pragma warning(disable:4700)
+
+#define Send_Player(p, m)           sIRC.Send_WoW_Player(p, m)
+#define Send_IRCA(c, m, b, t)       sIRC.Send_IRC_Channel(c, m, b, t)
+
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string isbanned = AcctIsBanned(_PARAMS[0]);
+	LoginDatabase.EscapeString(_PARAMS[0]);
+	LoginDatabase.EscapeString(_PARAMS[1]);
+    if (isbanned == "NOTBANNED")
+    {
+        if (!IsLoggedIn(CD->USER))
+        {
+            if (!AcctIsLoggedIn(_PARAMS[0].c_str()))
+            {
+                QueryResult result = LoginDatabase.PQuery("SELECT `gmlevel` FROM `account`, `account_access` WHERE `username`='%s' AND `account_access`.`id`=`account`.`id` AND `sha_pass_hash`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    int GMLevel = fields[0].GetInt16();
+                    if (GMLevel >= 0)
+                    {
+                        _client *NewClient = new _client();
+                         NewClient->Name     = CD->USER;
+                        NewClient->UName    = MakeUpper(_PARAMS[0]);
+                        NewClient->GMLevel  = fields[0].GetInt16();
+                        _CLIENTS.push_back(NewClient);
+                        Send_IRCA(CD->USER, MakeMsg("You Are Now Logged In As %s.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+                        if (sIRC._op_gm == 1 && GMLevel >= sIRC._op_gm_lev)
+                        {
+                            for (int i=1;i < sIRC._chan_count + 1;i++)
+                            sIRC.SendIRC("MODE #"+sIRC._irc_chan[i]+" +o "+CD->USER);
+                        }
+                    }
+                }else
+                    Send_IRCA(CD->USER, "Sorry, Your Username Or Password Is Incorrect. Please Try Again. ", true, "ERROR");
+            }else
+                Send_IRCA(CD->USER, MakeMsg("%s Is Already Logged In With This Username. ", GetNameFromAcct(MakeUpper(_PARAMS[0])).c_str()), true, "ERROR");
+        }else
+            Send_IRCA(CD->USER, "You are already logged in as "+ _PARAMS[0], true, "ERROR");
+    }else
+         Send_IRCA(CD->USER, "Sorry, you are "+isbanned+" and can not log in.", true, "ERROR");
+}
+
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == CD->USER)
+        {
+            _CLIENTS.erase(i);
+            delete (*i);
+            Send_IRCA(CD->USER, "Successfully logged out", true, CD->TYPE);
+            return;
+        }
+    }
+    Send_IRCA(CD->USER, "Not logged in", true, "ERROR");
+}
+
+void IRCCmd::Account_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    uint32 account_id = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    if (account_id)
+    {
+        if (account_id == GetAcctIDFromName(CD->USER) || GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            if (_PARAMS[1] == "lock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '1' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been Locked To Your Current IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been Locked To Their Current IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "unlock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '0' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been UnLocked From The Associated IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been UnLocked From The Associated IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "email")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `email` = '%s' WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your EMail Adress To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : EMail Address Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "pass")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `sha_pass_hash` = SHA1(CONCAT(UPPER(`username`),':',UPPER('%s'))) WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your Password To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Password Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "rename")
+            {
+                if (plr)
+                {
+                    plr->SetAtLoginFlag(AT_LOGIN_RENAME);
+                    Send_Player(plr, MakeMsg("%s Has Requested You Change This Characters Name, Rename Will Be Forced On Next Login!", CD->USER.c_str()));
+                }
+                CharacterDatabase.PExecute("UPDATE `characters` SET `at_login` = `at_login` | '1' WHERE `guid` = '%u'", guid);
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has Been Forced To Change Their Characters Name, Rename Will Be Forced On Next Login!", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "gmlevel")
+            {
+                const char *cgmlevel = _PARAMS[2].c_str();
+                if (GetLevel(CD->USER) >= atoi(cgmlevel))
+                {                    
+                    LoginDatabase.PExecute("UPDATE `account_access` SET `gmlevel` = '%s' WHERE `id` = '%d'", _PARAMS[2].c_str(), account_id);
+                    Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has GM Level Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "The Specified GM Level Is Higher Than Your GM Level.", true, "ERROR");
+                }
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "You Are Not A GM, You May Only Change Settings In Your Own Account.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "No such player - account lookup failed", true, "ERROR");
+}
+
+void IRCCmd::Ban_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    std::string duration = SecToDay (_PARAMS[3].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "ip")
+    {
+        std::string ip = GetIPFromPlayer(_PARAMS[0]);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (ip != "")
+        {
+            sWorld->BanAccount(BAN_IP, ip.c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] Has Had Their IP Address Banned. [%s] Reason: %s Duration: %s",_PARAMS[0].c_str() ,ip.c_str() , _PARAMS[2].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not locate IP-address for that charactername", true, "ERROR");
+    }
+    if (_PARAMS[1] == "acct")
+    {
+        
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No reason";
+        if (_PARAMS[3] == "")//set standard bantime to 1 day
+            _PARAMS[3] = "1d";
+        QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());             
+        if (result)
+        {
+            sWorld->BanAccount(BAN_ACCOUNT, _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);            
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] has been account-banned. Reason: %s Duration: %s",_PARAMS[0].c_str(), _PARAMS[2].c_str(), _PARAMS[3].c_str()),  true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not find any accounts for that accountname", true, "ERROR");
+
+    }
+    if (_PARAMS[1] == "unban")
+    {
+        std::string unbani = _PARAMS[0];
+        if (atoi(unbani.c_str()) > 0)
+        {
+            LoginDatabase.PExecute("DELETE FROM ip_banned WHERE ip = '%s'", _PARAMS[0].c_str());
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The IP Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string id = fields[0].GetString();
+
+                LoginDatabase.PExecute("DELETE FROM account_banned WHERE id = %s", id.c_str());
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The Account Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "I Cannot Locate An Account Or IP Address For The Paramaters Given.", true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Char_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 5);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    Player* plr = ObjectAccessor::FindPlayer(guid);
+    if (plr)
+    {
+        if (_PARAMS[1] == "mapcheat")
+        {
+            bool explore = false;
+            if (_PARAMS[2] != "0")
+                explore = true;
+            for (uint8 i=0; i<64; i++)
+            {
+                if (_PARAMS[2] != "0")
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
+                else
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
+            }
+            if (explore)
+            {
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Explored By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Explored All Zones.", true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Had All Zones Set To Un-Explored.", true, CD->TYPE);
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Un-Explored By: %s", CD->USER.c_str()));
+            }
+        }
+        if (_PARAMS[1] == "taxicheat")
+        {
+            if (_PARAMS[2] != "0")
+            {
+                plr->SetTaxiCheater(true);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Enabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Enabled.", true, CD->TYPE);
+            }
+            else
+            {
+                plr->SetTaxiCheater(false);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Disabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Disabled.", true, CD->TYPE);
+            }
+        }
+        if (_PARAMS[1] == "maxskill")
+        {
+            plr->UpdateSkillsToMaxSkillsForLevel();
+            Send_Player(plr, MakeMsg("Your Skills Have Been Maxed Out By: %s", CD->USER.c_str()));
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Skills Have Been Maxed Out.", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "setskill")
+        {
+            std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+            uint32 skill = atoi(_PARAMS[2].c_str());
+            uint32 step = atoi(_PARAMS[3].c_str());
+            uint32 level = atol(_PARAMS[4].c_str());
+            int32 max   = _PARAMS[5].c_str() ? atol (_PARAMS[5].c_str()) : plr->GetPureMaxSkillValue(skill);
+            SkillLineEntry const* skilllookup = sSkillLineStore.LookupEntry(skill);
+            //if skillid entered is not a number and greater then 0 then the command is being used wrong
+            if (skill >= 0)
+            {
+                //does the skill even exist
+                if (skilllookup)
+                {
+                    //does player have the skill yet
+                    if (plr->GetSkillValue(skill))
+                    {
+                        plr->SetSkill(skill,step,level,max);
+                        Send_Player(plr, MakeMsg("Skill: %s Has Been Set To Level: %i Max: %i By: %s",skilllookup->name[0], level, max, CD->USER.c_str()));
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Skill: %s Set To Level: %d Max: %d",_PARAMS[0].c_str() , skilllookup->name[0], level, max), true, CD->TYPE);
+                    }
+                    else
+                        Send_IRCA(CD->USER, MakeMsg("Player Does Not Have The %s Skill Yet.", skilllookup->name[0]), true, "ERROR");
+                }
+                else
+                    Send_IRCA(CD->USER, "That Skill ID Does Not Exist.", true, "ERROR");
+            }
+            else
+                Send_IRCA(CD->USER, "The Skill ID Entered Is Invalid.", true, "ERROR");
+        }
+        if (_PARAMS[1] == "combatstop")
+        {
+            if (!plr->isInCombat())
+            {
+                plr->CombatStop();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Was Dropped From Combat",_PARAMS[0].c_str()), true, CD->TYPE);
+            }else
+            {
+                Send_IRCA(CD->USER, "Specified Player Is Not In Combat.", true, "ERROR");
+            }
+        }
+        if (_PARAMS[1] == "quest")
+        {
+            std::string s_param  = _PARAMS[3];
+            std::string QName = "";
+            char *args = (char*)s_param.c_str();
+            uint32 qId = 0;
+            if (args[0]=='[')
+            {
+                char* cQName = strtok((char*)args, "]");
+                if (cQName && cQName[0])
+                {
+                    QName = cQName+1;
+                    WorldDatabase.EscapeString(QName);
+                    QueryResult result = WorldDatabase.PQuery("SELECT entry FROM quest_template WHERE name = '%s'", QName.c_str());
+                    if (!result)
+                    {
+                        Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                        return;
+                    }
+                    qId = result->Fetch()->GetUInt16();
+                    
+                }
+            }
+            else
+            {
+                qId = atoi(args);
+                QueryResult result = WorldDatabase.PQuery("SELECT title FROM quest_template WHERE entry = '%d'", qId);
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                    return;
+                }
+                QName = result->Fetch()->GetString();
+                
+            }
+            if (_PARAMS[2] == "add")
+            {
+                QueryResult item_max = WorldDatabase.PQuery("SELECT MAX(entry) FROM item_template");
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                for (uint32 id = 0; id < item_max; id++)
+                {
+                    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(id);
+                    if (!pProto)
+                        continue;
+
+                    if (pProto->StartQuest == qId)
+                    {
+                        Send_IRCA(CD->USER, MakeMsg("This Quest Requires Activation By Item %d, Add It To The Player And Start Quest Manually.", pProto->ItemId),true, "ERROR");
+                    }
+                }
+
+                if (plr->CanAddQuest(pQuest, true))
+                {
+                    plr->AddQuest(pQuest, NULL);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Had Quest [%s] Added To Quest Log.", _PARAMS[0].c_str(), QName.c_str()), true, "ERROR");
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "Cannot Add Quest To Player, He Either Has No Space Or He Already Has The Quest In His Quest Log.", true, "ERROR");
+                }
+            }            
+            if (_PARAMS[2] == "complete")
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                if (plr->GetQuestStatus(qId) == QUEST_STATUS_NONE)
+                {
+                    Send_IRCA(CD->USER, "Player Does Not Have This Quest In Quest Log, Cannot Complete It.", true, "ERROR");
+                }
+                else
+                {
+                    for (uint8 x = 0; x < QUEST_OBJECTIVES_COUNT; ++x)
+                    {
+                        uint32 id = pQuest->RequiredItemId[x];
+                        uint32 count = pQuest->RequiredItemCount[x];
+                        if (!id || !count)
+                            continue;
+                        uint32 curItemCount = plr->GetItemCount(id,true);
+                        ItemPosCountVec dest;
+                        uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+                        if (msg == EQUIP_ERR_OK)
+                        {
+                            Item* item = plr->StoreNewItem(dest, id, true);
+                            plr->SendNewItem(item,count-curItemCount,true,false);
+                        }
+                    }
+
+                    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        uint32 creature = pQuest->RequiredNpcOrGo[i];
+                        uint32 creaturecount = pQuest->RequiredNpcOrGoCount[i];
+                        if (uint32 spell_id = pQuest->RequiredSpellCast[i])
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,spell_id);
+                        }
+                        else if (creature > 0)
+                        {
+                            if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                                for (uint16 z = 0; z < creaturecount; ++z)
+                                    plr->KilledMonster(cInfo,0);
+                        }
+                        else if (creature < 0)
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,0);
+                        }
+                    }
+
+                    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+                    {
+                        uint32 repValue = pQuest->GetRepObjectiveValue();
+                        uint32 curRep = plr->GetReputationMgr().GetReputation(repFaction);
+                        if (curRep < repValue)
+                        {
+                            FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction);
+                            plr->GetReputationMgr().SetReputation(factionEntry,repValue);
+                        }
+                    }
+                    
+                    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+                    if (ReqOrRewMoney < 0)
+                        plr->ModifyMoney(-ReqOrRewMoney);
+
+                    plr->CompleteQuest(qId);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Status Set To Complete.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+                }
+            }
+        }
+        if (_PARAMS[1] == "mod")
+        {
+            /*if (_PARAMS[2] == "rep") TODO
+            {
+                uint32 factionId = atoi((char*)_PARAMS[3].c_str());
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+                if (!factionEntry)
+                {
+                    Send_IRCA(CD->USER, "No Faction With That Name Exists.", true, "ERROR");
+                }
+                else
+                {
+                    int32 amount = atol((char*)_PARAMS[4].c_str());
+                    if (amount > -39000 && amount < 43000)
+                    {
+                        plr->SetFactionReputation(factionId,amount);
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Reputation With Faction %s Set To %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[4].c_str()), true, CD->TYPE);
+                    }
+                    else
+                    {
+                        Send_IRCA(CD->USER, "Reputation Value Incorrect. Must Be Between -39000 and 43000.", true, "ERROR");
+                    }
+                }
+            }*/
+            if (_PARAMS[2] == "morph")
+            {
+                uint16 display_id = (uint16)atoi((char*)_PARAMS[3].c_str());
+                plr->SetDisplayId(display_id);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Morphed Into DisplayID: %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Valid Parameters Are: morph <displayid>, reputation <faction><value>.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "No Character With That Name Exists.", true, "ERROR");
+}
+
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (_PARAMS[1] == "say")
+        {
+            plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Was Forced To Say: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "sound")
+        {
+            uint32 sndid = atoi(_PARAMS[2].c_str());
+            plr->SendPlaySound(sndid ,true);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Just Heard Sound ID: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `irc_commands`");
+    if (result)
+    {
+        if (IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+                    
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > GetLevel(CD->USER))
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    if (result)
+                    {
+                        std::string cmdhlp = fields[0].GetString();
+                        
+                        Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+        else if (!IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+                    
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                    Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > 0)
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    std::string cmdhlp = fields[0].GetString();
+                    
+                    Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Database Error! Please Make Sure You Used irc_commands.sql, You Must Have A Table In Your World Database (irc_commands)!", true, "ERROR");
+}
+
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "")
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"inchan <ChannelName>)", true, "ERROR");
+        return;
+    }
+    QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        std::string output = "\0031Players In The \xF["+fields[2].GetString()+"] \0031Channel:\017 ";
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            output += fields[1].GetString() + ", ";
+            result->NextRow();
+        }
+        
+        Send_IRCA(ChanOrPM(CD), output, true, CD->TYPE);
+    }
+    else
+        Send_IRCA(ChanOrPM(CD), "\0031No Players Are Currently In \xF["+_PARAMS[0]+"] \0031Channel!", true, CD->TYPE.c_str());
+}
+
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    char clientsNum [50];
+    sprintf(clientsNum, "%u", sWorld->GetActiveSessionCount());
+    char maxClientsNum [50];
+    sprintf(maxClientsNum, "%u", sWorld->GetMaxActiveSessionCount());
+    char ircupdt [50];
+    sprintf(ircupdt, "%u", sWorld->GetUpdateTime());
+    std::string str = secsToTimeString(sWorld->GetUptime());
+    std::string svnrev = _FULLVERSION;
+
+    float rdm = (ConfigMgr::GetFloatDefault("Rate.Drop.Money", 1.0f));
+    float rxk = (ConfigMgr::GetFloatDefault("Rate.XP.Kill", 1.0f));
+    float rxq = (ConfigMgr::GetFloatDefault("Rate.XP.Quest", 1.0f));    
+    Send_IRCA(ChanOrPM(CD), "\00310Number Of Players Online: \xF"+(std::string)clientsNum+" | \00310Max Since Last Restart: \xF"+(std::string)maxClientsNum+" |\00310 UpTime: \xF"+str, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310Server: \xF"+svnrev+" |\00310 Update Time: \xF"+(std::string)ircupdt, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Server Rates - \xF[Monster XP: %u][Quest XP: %u][Money Drop Rate: %u]", int(rxk), int(rxq), int(rdm)), true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310MotD: \xF"+(std::string)sWorld->GetMotd(), true, CD->TYPE);
+
+}
+
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+
+    normalizePlayerName(_PARAMS[0]);
+    Player *chr = GetPlayer(_PARAMS[0].c_str());
+    if (_PARAMS[1] == "add")
+    {
+        std::string s_param  = _PARAMS[2];
+
+        char *args = (char*)s_param.c_str();
+        uint32 itemId = 0;
+        if (args[0]=='[')
+        {
+            char* citemName = strtok((char*)args, "]");
+            if (citemName && citemName[0])
+            {
+                std::string itemName = citemName+1;
+                WorldDatabase.EscapeString(itemName);
+                QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Item Not Found!", true, "ERROR");
+                    return;
+                }
+                itemId = result->Fetch()->GetUInt16();
+                
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount>)", true, "ERROR");
+                return;
+            }
+        }
+        else
+        {
+            std::string itemName = s_param;
+            WorldDatabase.EscapeString(itemName);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (result)
+            {
+                itemId = result->Fetch()->GetUInt16();
+            }
+            
+
+            char* cId = strtok(args, " ");
+            if (!cId)
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+                return;
+            }
+            itemId = atol(cId);
+        }
+            char* ccount = strtok(NULL, " ");
+            int32 count = 1;
+            if (ccount) { count = atol(ccount); }
+            Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+        ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemId);
+        //Subtract
+        if (count < 0)
+        {
+            plTarget->DestroyItemCount(itemId, -count, true, false);
+            char itemid2[255];
+            sprintf(itemid2,"%d",itemId);
+            std::string itake = " \00313["+ _PARAMS[0] +"] :\0031Has Had Item \xF" +itemid2+ " \0031Taken From Them!";
+            Send_IRCA(ChanOrPM(CD), itake, true, CD->TYPE);
+            return;
+        }
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+        uint8 msg = plTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+        if (msg == EQUIP_ERR_INVENTORY_FULL)                   // convert to possibel store amount
+            count -= noSpaceForCount;
+        else if (msg != EQUIP_ERR_OK)                          // other error, can't add
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",count);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+        Item* item = plTarget->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+        if (count > 0 && item)
+        {
+                plTarget->SendNewItem(item,count,true,false);
+                QueryResult result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+                char* dbitemname = NULL;
+                if (result)
+                {
+                    dbitemname = (char*)result->Fetch()->GetCString();
+                }
+                std::string iinfo = " \00313[" + _PARAMS[0] + "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+                Send_IRCA(ChanOrPM(CD), iinfo, true, CD->TYPE);
+                
+        }
+        if (noSpaceForCount > 0)
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",noSpaceForCount);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+    }
+    else
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+        return;
+    }
+}
+
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+    if (ValidParams(CD->PARAMS, 1))
+    {
+        std::string* _PARAMS = getArray(CD->PARAMS, 2);
+        if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+        {
+            Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+            return;
+        }
+        if (Player *plr = GetPlayer(_PARAMS[0]))
+        {
+            std::string sReason = "";
+            if (_PARAMS[1] == "release")
+            {
+                float rposx, rposy, rposz, rposo = 0;
+                uint32 rmapid = 0;
+                CharacterDatabase.EscapeString(_PARAMS[0]);
+                QueryResult result = CharacterDatabase.PQuery("SELECT `map`, `position_x`, `position_y`, `position_z` FROM `character_homebind` WHERE `guid` = '" UI64FMTD "'", plr->GetGUID());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    rmapid = fields[0].GetUInt16();
+                    rposx = fields[1].GetFloat();
+                    rposy = fields[2].GetFloat();
+                    rposz = fields[3].GetFloat();
+                    
+                    plr->SetMovement(MOVE_UNROOT);
+                    plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+                    plr->RemoveAurasDueToSpell(42201);
+                    plr->RemoveAurasDueToSpell(23775);
+                    plr->RemoveAurasDueToSpell(9454);
+                    Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+                    sReason = " \00313["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+                    Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+                }
+            }
+            else
+            {
+                if (_PARAMS[1] == "")
+                    _PARAMS[1] = "No Reason Given.";
+                plr->TeleportTo(13, 0, 0, 0, 0);
+                plr->SetMovement(MOVE_ROOT);
+                plr->CastSpell(plr, 42201, true);
+                plr->CastSpell(plr, 23775, true);
+                plr->CastSpell(plr, 9454, true);
+                Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+                sReason = " \00313["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+                Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+    }
+}
+
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "")
+        _PARAMS[1] = "No Reason Given.";
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        plr->GetSession()->KickPlayer();
+        Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+        if (sWorld->getBoolConfig(CONFIG_SHOW_KICK_IN_WORLD))
+            sIRC.Send_WoW_System("Player|cffff0000 "+_PARAMS[0]+"|r kicked by|cffff0000 "+CD->USER+"|r. Reason:|cffff0000"+_PARAMS[1]+"|r.");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAlive())
+        {
+            plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            plr->SaveToDB();
+            if (_PARAMS[1] == "")
+                _PARAMS[1] = "No Reason Given.";
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Already Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Player_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    uint32 plguid = atoi(_PARAMS[0].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str()))
+        plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str());
+    if (plguid > 0)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+        uint32 latency = 0;
+        Player *chr = ObjectAccessor::FindPlayer(plguid);
+        if (chr)
+        {
+            latency = chr->GetSession()->GetLatency();
+        }
+        char templatency [100];
+        sprintf(templatency, "%ums", latency);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string pguid = fields[0].GetString();
+            std::string pacct = fields[1].GetString();
+            std::string pname = fields[2].GetString();
+            uint32 praceid = fields[3].GetUInt32();
+            uint32 pclassid = fields[4].GetUInt32();
+            std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+            std::string plevel = fields[6].GetString();                
+            std::string pxp = fields[7].GetString();
+            unsigned int money = fields[8].GetInt32();
+            std::string honor = fields[9].GetString();
+            std::string totaltim = SecToDay(fields[10].GetString());
+            
+            std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+            QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+            std::string pgmlvl = "0";
+            if (gmresult)
+            {
+                Field *fields2 = gmresult->Fetch();
+                pgmlvl = fields2[0].GetString();
+            }            
+            
+            ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+            ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+            if (atoi(plevel.c_str()) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                plevel += " (" + pxp + ")";
+            unsigned int gold = money / 10000;
+            unsigned int silv = (money % 10000) / 100;
+            unsigned int cop = (money % 10000) % 100;
+            char tempgold [100];
+            sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+            if (ponline == "\x3\x30\x33Online")
+            {
+                Player * plr = sObjectAccessor->FindPlayerByName(pname.c_str());
+                if (plr)
+                {
+                    AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                    ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                    if (area->zone != 0)
+                    {
+                        AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                        ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                    }
+                }
+            }
+            std::string pinfo  = "\00310About Player: \xF"+pname+" |\00310 GM Level: \xF"+pgmlvl+" |\00310 AcctID: \xF"+pacct+" |\00310 CharID: \xF"+pguid+" |\00310 Played Time: \xF"+totaltim.c_str()+" |\00310 Latency: \xF"+templatency;
+            std::string pinfo2 = "\00310Race: \xF"+(std::string)prace->name[sWorld->GetDefaultDbcLocale()]+" |\00310 Class: \xF"+(std::string)pclass->name[sWorld->GetDefaultDbcLocale()]+" |\00310 Level: \xF"+plevel+" |\00310 Money: \xF"+tempgold+"|\00310 Status: \xF"+ponline+" |\00310 Honor: \xF"+honor;
+            //        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+            Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+            Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+            //        Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+    }
+    else
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[0].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string guid = fields[0].GetString();
+                std::string account = fields[1].GetString();
+                std::string name = fields[2].GetString();
+                MakeUpper(name);
+                items.append(name+"(Account:"+account+" - GUID:"+guid+")\0031 | \xF");
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Lookup_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "acct")
+    {
+        uint32 acctid = atoi(_PARAMS[1].c_str());
+        if (AccountMgr::GetId(_PARAMS[1]))
+            acctid = AccountMgr::GetId(_PARAMS[1]);
+        if (acctid > 0)
+        {
+            std::string DateTime = "%a, %b %d, %Y - %h:%i%p";
+            QueryResult result = LoginDatabase.PQuery("SELECT `account`.`id`, username, last_ip, (SELECT banreason FROM account_banned WHERE `account`.`id` = id LIMIT 1) as banned, (SELECT banreason FROM ip_banned WHERE ip = last_ip) as bannedip,(SELECT active FROM account_banned WHERE `account`.`id` = id) as banactive, (SELECT( unbandate - unix_timestamp( now() ) ) FROM account_banned WHERE `account`.`id` = id) as remainingtime, DATE_FORMAT(last_login, '%s') FROM `account` WHERE `account`.`id` =%d" ,DateTime.c_str(), acctid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 id = fields[0].GetUInt32();
+                std::string usrname = fields[1].GetString();                
+                std::string lastip = fields[2].GetString();
+                std::string banreason = fields[3].GetString();
+                std::string banreasonip = fields[4].GetString();
+                uint32 banactive = (fields[5].GetInt32() == 1 ? 1 : 0);
+                std::string TimeLeft = SecToDay(fields[6].GetString());
+                std::string lastlogin = fields[7].GetString();                               
+
+                QueryResult chars = CharacterDatabase.PQuery("SELECT guid, name, (SELECT SUM(totaltime) FROM characters WHERE account = %d) AS tottime FROM characters WHERE account = %u", id, id);
+                std::string characters = "None";
+                std::string totaccttime = "Never Logged In";
+                if (chars)
+                {
+                    characters = "";
+                    Field *fields = chars->Fetch();
+                    totaccttime = SecToDay(fields[2].GetString());
+                    for (uint64 i=0; i < chars->GetRowCount(); i++)
+                    {
+                        std::string guid = fields[0].GetString();
+                        std::string charname = fields[1].GetString();
+                        characters.append(charname+"("+guid+"), ");
+                        chars->NextRow();
+                    }
+                    
+                }
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Username: \xF %s | \00310AccountID: \xF %d | \00310Last IP: \xF %s | \00310Last Login: \xF %s", usrname.c_str(), id, lastip.c_str(), lastlogin.c_str()), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Total play time: \xF %s | \00310Characters:  \xF %s ", totaccttime.c_str(), characters.c_str()), true, CD->TYPE);
+                if (banreason.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0035Account banned : \xF %s | \0035Ban Active: \xF %u | \0035Ban Time: \xF %s", banreason.c_str(), banactive, TimeLeft.c_str()), true, CD->TYPE);
+                if (banreasonip.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An IP Ban. Ban Reason: %s", banreasonip.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Account ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id, username FROM `account` WHERE username LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string accts = "\002Account Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string acctid = fields[0].GetString();
+                    std::string acctname = fields[1].GetString();
+                    accts.append(acctname+"("+acctid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), accts, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Username. I Cant Find Any Users With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "char")
+    {
+        uint32 plguid = atoi(_PARAMS[1].c_str());
+        if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str()))
+            plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str());
+        if (plguid > 0)
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+            uint32 latency = 0;
+            Player *chr = ObjectAccessor::FindPlayer(plguid);
+            if (chr)
+            {
+                latency = chr->GetSession()->GetLatency();
+            }
+            char templatency [100];
+            sprintf(templatency, "%ums", latency);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string pguid = fields[0].GetString();
+                std::string pacct = fields[1].GetString();
+                std::string pname = fields[2].GetString();
+                uint32 praceid = fields[3].GetUInt32();
+                uint32 pclassid = fields[4].GetUInt32();
+                std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+                std::string plevel = fields[6].GetString();                
+                std::string pxp = fields[7].GetString();
+                unsigned int money = fields[8].GetInt32();
+                std::string honor = fields[9].GetString();
+                std::string totaltim = SecToDay(fields[10].GetString());
+                
+                std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+                QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+                std::string pgmlvl = "0";
+                if (gmresult)
+                {                
+                    Field *fields = result->Fetch();
+                    pgmlvl = fields[0].GetString();
+                }               
+                
+                ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+                ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+                if (atoi(plevel.c_str()) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    plevel += " (" + pxp + ")";
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+                if (ponline == "\x3\x30\x33Online")
+                {
+                    Player * plr = sObjectAccessor->FindPlayerByName(pname.c_str());
+                    if (plr)
+                    {
+                        AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                        ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                        if (area->zone != 0)
+                        {
+                            AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                            ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                        }
+                    }
+                }
+                std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Played Time:\x2\x3\x31\x30 " +totaltim.c_str()+" \xF |\x2 Latency:\x2\x3\x31\x30 "+templatency;
+                std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Status:\x2 " + ponline;
+                //        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+                Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+                //        Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string guid = fields[0].GetString();
+                    std::string account = fields[1].GetString();
+                    std::string name = fields[2].GetString();
+                    MakeUpper(name);
+                    items.append(name+"(Account:"+account+" - GUID:"+guid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "creature")
+    {
+        std::string creature = _PARAMS[1];
+        if (atoi(creature.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, minlevel,maxlevel, faction_A,  (SELECT count(guid) FROM creature WHERE id = '%s') as spawns FROM creature_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();                
+                std::string name = fields[1].GetString();
+                uint32 minlevel = fields[2].GetUInt32();
+                uint32 maxlevel = fields[3].GetUInt32();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+                
+
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Name:\x3\x31\x30 %s \xF|\x2 CreatureID:\x3\x31\x30 %d", name.c_str(), entry), true, CD->TYPE);
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2minlevel:\x3\x31\x30 %d \xF|\x2 maxlevel:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", minlevel, maxlevel, faction, spawns), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM creature_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Creature Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string CreatureID = fields[0].GetString();
+                    std::string Name = fields[1].GetString();
+                    items.append(Name+"("+CreatureID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature. I Cant Find Any Creatures With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "faction")
+    {
+        std::string faction = _PARAMS[1];
+        if (atoi(faction.c_str()) > 0)
+        {
+            FactionEntry const *factionEntry = sFactionStore.LookupEntry(atoi(faction.c_str()));
+            if (factionEntry)
+            {
+                std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Faction:\x3\x31\x30 %s \xF|\x2 FactionID:\x3\x31\x30 %s",name.c_str(), faction.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown FactionID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string factions = "\002Faction Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sFactionStore.GetNumRows(); id++)
+            {
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(id);
+                if (factionEntry)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char factionid[100];
+                        sprintf(factionid, "%d", id);
+                        factions.append(name+"("+factionid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                factions.append("No Factions Found.");
+            Send_IRCA(ChanOrPM(CD), factions, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "go")
+    {
+        std::string gobject = _PARAMS[1];
+        if (atoi(gobject.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, type, displayId, name, faction, (SELECT count(*) FROM gameobject WHERE id = '%s') as spawns FROM gameobject_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 type = fields[1].GetUInt32();
+                uint32 modelid = fields[2].GetUInt32();
+                std::string name = fields[3].GetString();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+                
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2GO Name:\x3\x31\x30 %s \xF|\x2 GameobjectID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Type:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d", type, faction), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown GameObject ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM gameobject_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string gos = "\002Gameobject Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string GOID = fields[0].GetString();
+                    std::string GoName = fields[1].GetString();
+                    gos.append(GoName+"("+GOID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), gos, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Game Object. I Cant Find Any Game Object's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "item")
+    {
+        std::string item = _PARAMS[1];
+        if (atoi(item.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, displayid, (SELECT count(*) FROM creature_loot_template WHERE item = '%s') as loot FROM `item_template` WHERE entry = %s", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM `character_inventory` WHERE item_template = %s", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 charcnt = fields2[0].GetUInt32();
+                
+
+                uint32 ItemID = fields[0].GetUInt32();
+                std::string ItmName = fields[1].GetString();
+                uint32 DisplayID = fields[2].GetUInt32();
+                uint32 loots = 0;
+                loots = fields[3].GetUInt32();
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Item:\x3\x31\x30 %s \xF|\x2 ItemID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Owned By:\x3\x31\x30 %d players \xF|\x2 Dropped By:\x3\x31\x30 %d creatures", ItmName.c_str(), ItemID, DisplayID, charcnt, loots), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown ItemID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM `item_template` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Item Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string ItemID = fields[0].GetString();
+                    std::string ItemName = fields[1].GetString();
+                    items.append(ItemName+"("+ItemID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "quest")
+    {
+        std::string quest = _PARAMS[1];
+        if (atoi(quest.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM character_queststatus WHERE quest = '%s' AND status = '1';", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 status = fields2[0].GetUInt32();
+                
+
+                Field *fields = result->Fetch();
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Quest Name:\x3\x31\x30 %s \xF|\x2 QuestID:\x3\x31\x30 %d \xF|\x2 Completed:\x3\x31\x30 %d times", name.c_str(), entry, status), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE Title LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string quests = "\002Quest Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string QuestID = fields[0].GetString();
+                    std::string QuestName = fields[1].GetString();
+                    quests.append(QuestName+"("+QuestID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), quests, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest. I Cant Find Any Quest's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "skill")
+    {
+        std::string skill = _PARAMS[1];
+        if (atoi(skill.c_str()) > 0)
+        {
+            SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(atoi(skill.c_str()));
+            if (skillInfo)
+            {
+                std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Skill:\x3\x31\x30 %s \xF|\x2 SkillID:\x3\x31\x30 %s",name.c_str(), skill.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SkillID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string skills = "\002Skill Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+            {
+                SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(id);
+                if (skillInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char skillid[100];
+                        sprintf(skillid, "%d", id);
+                        skills.append(name+"("+skillid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                skills.append("No Skills Found.");
+            Send_IRCA(ChanOrPM(CD), skills, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "spell")
+    {
+        std::string spell = _PARAMS[1];
+        if (atoi(spell.c_str()) > 0)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(atoi(spell.c_str()));
+            if (spellInfo)
+            {
+                std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Spell:\x3\x31\x30 %s \xF|\x2 SpellID:\x3\x31\x30 %s",name.c_str(), spell.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SpellID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string spells = "\002Spell Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSpellStore.GetNumRows(); id++)
+            {
+                SpellEntry const *spellInfo = sSpellStore.LookupEntry(id);
+                if (spellInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char itemid[100];
+                        sprintf(itemid, "%d", id);
+                        spells.append(name+"("+itemid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                spells.append("No Spells Found.");
+            Send_IRCA(ChanOrPM(CD), spells, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "tele")
+    {
+        std::string tele = _PARAMS[1];
+        if (atoi(tele.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `game_tele` WHERE id = %s", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 teleid = fields[0].GetUInt32();
+                uint32 pos_x = fields[1].GetUInt32();
+                uint32 pos_y = fields[2].GetUInt32();
+                uint32 pos_z = fields[3].GetUInt32();
+                uint32 oriet = fields[4].GetUInt32();
+                uint32 map = fields[5].GetUInt32();
+                std::string telname = fields[6].GetString();
+                
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Tele Name:\x3\x31\x30 %s \xF|\x2 TeleID:\x3\x31\x30 %d \xF|\x2 Coordinates:\x3\x31\x30 [X: %d, Y: %d, Z: %d, MAP: %d, Orientation: %d]", telname.c_str(), teleid, pos_x, pos_y, pos_z, map, oriet), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Teleport Location ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, name FROM `game_tele` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string teles = "\002Tele Location Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string TeleID = fields[0].GetString();
+                    std::string TeleName = fields[1].GetString();
+                    teles.append(TeleName+"("+TeleID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                Send_IRCA(ChanOrPM(CD), teles, true, CD->TYPE);
+                
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    } else if (i_newlvl < 1 || i_newlvl > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        Send_IRCA(CD->USER, MakeMsg("Level Must Be Between 1 And %i!",ConfigMgr::GetIntDefault("MaxPlayerLevel", 70)), true, "ERROR");
+        return;
+    } else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+		uint64 level;
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetLevelFromDB(level);
+        Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+
+        if (chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+            ChatHandler CH(chr->GetSession());
+            if (i_oldlvl == i_newlvl)
+                CH.FillSystemMessageData(&data, "Your level progress has been reset.");
+            else
+            if (i_oldlvl < i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring("You have been leveled up (%i)",i_newlvl-i_oldlvl));
+            else
+            if (i_oldlvl > i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring("You have been leveled down (%i)",i_newlvl-i_oldlvl));
+            chr->GetSession()->SendPacket(&data);
+        }
+        else
+        {
+            Player::GetLevelFromDB(guid);
+            uint64 player_guid;
+            CharacterDatabase.PExecute("UPDATE characters SET level = '%u', xp = 0 WHERE guid = '%u'", i_newlvl, GUID_LOPART(player_guid));
+        }
+    }
+    Send_IRCA(ChanOrPM(CD), "\00313[" + _PARAMS[0]+ "] : Has Been Leveled To " + _PARAMS[1] + ". By: "+CD->USER+".", true, CD->TYPE);
+}
+
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    Player *chr = ObjectAccessor::FindPlayer(guid);
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    }
+    else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        uint32 moneyuser = 0;
+        if (chr)
+            moneyuser = chr->GetMoney();
+        else {
+        CharacterDatabase.EscapeString(player);
+        std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS `gold` FROM `characters` WHERE `name` = '"+player+"';";
+        QueryResult result = CharacterDatabase.Query(sqlquery.c_str());
+            Field *fields = result->Fetch();
+            moneyuser = fields[0].GetInt32();
+            
+        }
+            int32 addmoney = money;
+            int32 newmoney = moneyuser + addmoney;
+            char s_newmoney[255];
+            sprintf(s_newmoney,"%d",newmoney);
+            if (addmoney < 0)
+            {
+                sLog->outDetail("USER1: %i, ADD: %i, DIF: %i\\n", moneyuser, addmoney, newmoney);
+                if (newmoney <= 0)
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(0);
+                        Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+                else
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had ("+s_money+"\00313) Taken From Them By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(newmoney);
+                        Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Been Given ("+tempgold+"\00313) From: "+CD->USER.c_str()+".", true, CD->TYPE);
+                if (chr)
+                {
+                    chr->ModifyMoney(addmoney);
+                    Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                }
+                else
+                    CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+            }
+    }
+}
+
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    if (guid)
+    {
+        if (_PARAMS[1] == "release")
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0' WHERE `id` = '%u'", account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." , true, CD->TYPE);
+            if (plr)
+            {
+                plr->GetSession()->m_muteTime = 0;
+                Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+            }
+        }
+        else
+        {
+            if (_PARAMS[2] == "")
+                _PARAMS[2] = "No Reason Given";
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            if (plr) 
+                plr->GetSession()->m_muteTime = mutetime;
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = " UI64FMTD " WHERE `id` = '%u'",uint64(mutetime), account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] , true, CD->TYPE);
+            if (plr) 
+                Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Does Not Exist!", true, "ERROR");
+}
+
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+        sIRC.Script_Lock[MCS_Players_Online] = true;
+        ACE_Based::Thread script(new mcs_OnlinePlayers(CD));
+}
+
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAcceptWhispers())
+        {
+            std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)0;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)(sMsg.length()+1);
+            data << sMsg;
+            data << (uint8)0;
+            plr->GetSession()->SendPacket(&data);
+            plr->SendPlaySound(3081, true);
+            Send_IRCA(ChanOrPM(CD), "\00313To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".", true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Is Not Accepting Private Messages!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player not online!", true, "ERROR");
+}
+
+void IRCCmd::Restart_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Restart Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Restart In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time,SHUTDOWN_MASK_RESTART, RESTART_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Restart.. Be Back In A Flash!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isDead())
+        {
+            plr->ResurrectPlayer(0.5f);
+            plr->SpawnCorpseBones();
+            plr->SaveToDB();
+            sIRC.Send_IRC_Channel(ChanOrPM(CD), " \00313["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+    sObjectAccessor->SaveAllPlayers();
+    Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Saved All Players!", true, CD->TYPE);
+}
+
+void IRCCmd::Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "setmotd")
+    {
+        sWorld->SetMotd(_PARAMS[1]);
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Set New Message Of The Day To: "+_PARAMS[1], true, CD->TYPE);
+    }
+    if (_PARAMS[0] == "flusharenapoints")
+    {
+        sArenaTeamMgr->DistributeArenaPoints();
+    }
+}
+
+void IRCCmd::Shutdown_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Shutdown Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Be Shut Down In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time, SHUTDOWN_MASK_IDLE , SHUTDOWN_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Shut Down.. Good Bye!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    uint32 spell = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (spellInfo)
+        {
+            std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+            if (_PARAMS[1] == "cast")
+            {
+                plr->CastSpell(plr, spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "learn")
+            {
+                plr->learnSpell(spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Learned Spell "+name+".", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "unlearn")
+            {
+                plr->removeSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".", true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "Incorrect Spell ID!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string ircchan = "#";
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+    if (_PARAMS[0] == "a")
+    {
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6610,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "e")
+    {
+        std::string str = _PARAMS[1];
+        std::string notstr = "[Server Event]: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Server Event \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (notstr.size()+1));
+        data << notstr;
+        WorldPacket data2(SMSG_PLAY_SOUND,32);
+        data2 << (uint32)1400;
+        sWorld->SendGlobalMessage(&data2);
+        sWorld->SendGlobalMessage(&data);
+        sWorld->SendWorldText(6611,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "n")
+    {
+        std::string str = "Global notify: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalMessage(&data);
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "gm")
+    {
+        std::string str = "GM Announcement: " + _PARAMS[1];
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+
+    }
+    else if (_PARAMS[0] == "add")
+    {
+        WorldDatabase.PExecute("INSERT INTO irc_autoannounce (message, addedby) VALUES ('%s', '%s')", _PARAMS[1].c_str(), CD->USER.c_str());
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6612,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "del")
+    {
+        WorldDatabase.PExecute("DELETE FROM irc_autoannounce WHERE id = %s", _PARAMS[1].c_str());
+        Send_IRCA(ChanOrPM(CD), MakeMsg("Deleted Automatic Announcement Message ID: %s", _PARAMS[1].c_str()), true, CD->TYPE);
+    }
+    else if (_PARAMS[0] == "list")
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT * FROM irc_autoannounce LIMIT 5;", _PARAMS[1].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string id = fields[0].GetString();
+                std::string message = fields[1].GetString();
+                std::string addedby = fields[2].GetString();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("ID: %s - Added By: %s - Message: %s", id.c_str(), addedby.c_str(), message.c_str()), true, CD->TYPE);
+                result->NextRow();
+            }            
+        }
+        else
+            Send_IRCA(CD->USER, "No Auto Announce Messages Are In The Database.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Please Use (a-Announce)(n-Notify)(e-Event) As Second Parameter!", true, "ERROR");
+}
+
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    bool DoTeleport = false;
+    float pX, pY, pZ, pO = 0;
+    uint32 mapid = 0;
+    std::string rMsg = " Teleport Failed!";
+    std::string wMsg = "Invalid Tele Location";
+    Player* plr = GetPlayer(_PARAMS[0]);
+    if (plr)
+    {
+        if (plr->isInFlight() || plr->isInCombat())
+        {
+            Send_IRCA(CD->USER, MakeMsg("%s Is Busy And Cannot Be Teleported! They Could Be In Combat, Or Flying.",_PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+    }
+    if (_PARAMS[1] == "l" || _PARAMS[1].size() > 2)
+    {
+        if (_PARAMS[1].size() > 1)
+            _PARAMS[2] = _PARAMS[1];
+        WorldDatabase.EscapeString(_PARAMS[2]);
+        QueryResult result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map FROM game_tele WHERE name='%s';", _PARAMS[2].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = fields[3].GetFloat();
+            mapid = fields[4].GetUInt16();
+            
+            rMsg = MakeMsg(" \00313[%s] : Teleported To %s! By: %s.",
+                _PARAMS[0].c_str(),
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            WorldDatabase.EscapeString(_PARAMS[2]);
+            QueryResult result = WorldDatabase.PQuery("SELECT name FROM game_tele WHERE name LIKE '%%%s%%' LIMIT 7;", _PARAMS[2].c_str());
+            if (result)
+            {
+                std::string telename = "<> ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    Field *fields = result->Fetch();
+                    telename.append(fields[0].GetString());
+                    result->NextRow();
+                    telename.append(" <> ");
+                }
+                
+                Send_IRCA(CD->USER, "I Cannot Find Location: "+_PARAMS[2]+" . Perhaps One Of These Will Work For You.", true, "ERROR");
+                Send_IRCA(CD->USER, telename, true, "ERROR");
+                return;
+            }
+            else
+                Send_IRCA(CD->USER, "Location Not Found! Nothing Even Close Found!", true, "ERROR");
+                return;
+        }
+    }
+    else if (_PARAMS[1] == "c")
+    {
+        std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+        pX = atof(_PARAMSA[1].c_str());
+        pY = atof(_PARAMSA[2].c_str());
+        pZ = atof(_PARAMSA[3].c_str());
+        mapid = atoi(_PARAMSA[0].c_str());
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "r")
+    {
+        if (plr)
+        {
+            pX = plr->m_recallX;
+            pY = plr->m_recallY;
+            pZ = plr->m_recallZ;
+            pO = plr->m_recallO;
+            mapid = plr->m_recallMap;
+            rMsg = MakeMsg(" \00313[%s] : Has Been Recalled To Their Previous Location.",
+                _PARAMS[0].c_str());
+            wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            Send_IRCA(CD->USER, MakeMsg("\00313[%s] : Cannot Be Recalled, They Are Not Online.", _PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+
+    }
+    else if (_PARAMS[1] == "to")
+    {
+        Player* plr2 = GetPlayer(_PARAMS[2]);
+        if (plr2)
+        {
+            plr2->GetContactPoint(plr, pX, pY, pZ);
+            mapid = plr2->GetMapId();
+        }
+        else
+        {
+            if (uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[2].c_str()))
+            {
+                bool in_flight;
+                Player::LoadPositionFromDB(mapid, pX, pY, pZ, pO, in_flight, guid);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Second Player Not Found!", true, "ERROR");
+                return;
+            }
+        }
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Player: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "cr")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM creature WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "Creature GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Creature: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+        
+      }
+    }
+    else if (_PARAMS[1] == "go")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM gameobject WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "GO GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Gameobject: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+        
+      }
+    }
+    else if (_PARAMS[1] == "homebind")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT position_x,position_y,position_z,map FROM `character_homebind` WHERE guid = '%d'", plr->GetGUID());
+        if (!result)
+        {
+          Send_IRCA(CD->USER, "Unexpected Error Loading Homebind Location", true, "ERROR");
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = 1;
+            mapid = fields[3].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To Homebind Location By: %s.",
+                _PARAMS[0].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Are Being Teleported To Your Homebind Location By: %s.",
+            CD->USER.c_str());
+            DoTeleport = true;
+            
+        }
+
+    }
+    if (DoTeleport)
+    {
+        if (MapManager::IsValidMapCoord(mapid, pX ,pY ,pZ))
+        {
+            //if (!sIRC.BeenToGMI(pX, pY, _PARAMS[0], CD->USER))
+            //{
+                //if player is online teleport them in real time, if not set the DB to our coordinates.
+                if (plr)
+                {
+                    plr->SaveRecallPosition();
+                    plr->TeleportTo(mapid, pX, pY, pZ, pO);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg, true, CD->TYPE);
+                    Send_Player(plr, wMsg);
+                }
+                else
+                {
+                    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+                    Player::SavePositionInDB(mapid,pX,pY,pZ,pO,sMapMgr->GetZoneId(mapid,pX,pY,pZ),guid);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg + " \0034*Offline Tele.* ", true, CD->TYPE);
+                }
+            //}
+        }
+        else
+            Send_IRCA(CD->USER, "Invalid Location!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Invalid Paramaters, Please Try Again [ "+sIRC._cmd_prefx+"help tele ] For More Information. ", true, "ERROR");
+}
+
+void IRCCmd::Top_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    uint32 limitr = 10;
+    if (atoi(_PARAMS[1].c_str()) > 0 && GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        limitr = atoi(_PARAMS[1].c_str());
+    if (_PARAMS[0] == "accttime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT account, name, (SUM(totaltime)) AS combinetime FROM characters GROUP BY account ORDER BY combinetime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Accounts By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                uint32 account = fields[0].GetUInt32();
+                std::string PlName = GetAcctNameFromID(account);
+                std::string Time = SecToDay(fields[2].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, PlName.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Accounts Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "chartime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, totaltime FROM characters ORDER BY totaltime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                std::string Time = SecToDay(fields[1].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "money")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, money FROM characters ORDER BY money DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Money:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                unsigned int money = fields[1].GetInt32();
+
+                uint32 rank = i+1;
+
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), tempgold));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Chan_Control(_CDATA *CD)
+{
+
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+
+	if (CD->FROM == sIRC._Nick)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : You Cannot Use This Command Through A PM Yet.", true, "ERROR");
+        return;
+    }
+
+	if (_PARAMS[0] == "op")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+CD->USER);
+    }
+
+	if (_PARAMS[0] == "deop")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "voice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+CD->USER);
+    }
+    if (_PARAMS[0] == "devoice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+CD->USER);
+    }
+};
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+    std::string OPS = "";
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        OPS.append(MakeMsg(" \002[GM:%d IRC: %s - WoW: %s]\002 ", (*i)->GMLevel, (*i)->Name.c_str(), (*i)->UName.c_str()));
+    }
+    Send_IRCA(ChanOrPM(CD), OPS, true, CD->TYPE);
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCFunc.h b/src/server/game/TriniChat/IRCFunc.h
new file mode 100644
index 0000000..e362ae9
--- /dev/null
+++ b/src/server/game/TriniChat/IRCFunc.h
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_FUNC
+#define _IRC_CLIENT_FUNC
+
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+// Delink will remove anything considered "non chat" from a string
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+    
+        while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hglyph")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+        //msg.replace(find2, 2, "\x2");
+    }
+    while((pos = msg.find("|Hquest")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hspell")) != std::string::npos)
+    {
+         std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htalent")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hachievement")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[17][6] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x34", "\x3\x31\x34", "\x3\x31\x32", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x31\x32", "\x3\x30\x37"};
+    char WoWCol[17][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "|cffffd000", "|cff808080", "|cff71d5ff", "|cffffff00", "|cffff2020", "|cff40c040", "|cff4e96f7", "|cff71d5ff", "|cffff8040"};
+    for (int i=0; i<=15; i++)
+    {
+        while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 11, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[18][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35", "\x3\x30\x37", "\x3\x30\x37"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[18][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2", "|cff808080", "|cff71d5ff"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+
+        // Remove Bold, Reverse, Underline from IRC
+        char Checker[3][3] = {"\x2","\x16","\x1F"}; // This is the Hex part not Dec. In Decimal its (2,22,31)
+        for (int I=0; I < 3; I++)
+        {
+            while ((pos = msg.find(Checker[I])) != std::string::npos)
+            {    
+                msg.replace(pos, 1, "");
+            }
+        }
+        // Finished Removing !
+
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2)
+{
+    string::const_iterator it1=s1.begin();
+    string::const_iterator it2=s2.begin();
+
+    //stop when either string's end has been reached
+    while ((it1!=s1.end()) && (it2!=s2.end()))
+    {
+        if (::toupper(*it1) != ::toupper(*it2))              //letters differ?
+            // return -1 to indicate smaller than, 1 otherwise
+            return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1;
+        //proceed to the next character in each string
+        ++it1;
+        ++it2;
+    }
+    size_t size1=s1.size(), size2=s2.size();                // cache lengths
+    //return -1,0 or 1 according to strings' lengths
+    if (size1==size2)
+        return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+std::string MakeMsgA(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+    std::string sMsg = sIRC.MakeMsg(sIRC.GetChatLine(CLINE), "$Msg", Msg);
+    if (plr->GetTeam() == 67)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\0034%s\003", plr->GetName()));
+    else if (plr->GetTeam() == 469)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\00312%s\003", plr->GetName()));
+    if (plr->isAFK())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<AFK>");
+    else if (plr->isDND())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<DND>");
+    else
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "");
+    sMsg = sIRC.MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+    sMsg = Delink(sMsg);
+    sMsg = WoWcol2IRC(sMsg);
+    return sMsg;
+}
+
+// This function checks if a channel exists in out configuration
+// TriniChat supports as many channels as you like
+bool Channel_Valid(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (nocase_cmp(sIRC._wow_chan[i], Channel)==0)
+            return true;
+    }
+    return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if ("#" + sIRC._irc_chan[i] == Channel)
+            return sIRC._wow_chan[i];
+    }
+    return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (sIRC._wow_chan[i] == Channel)
+            return sIRC._irc_chan[i];
+    }
+    return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCIO.cpp b/src/server/game/TriniChat/IRCIO.cpp
new file mode 100644
index 0000000..b8e706d
--- /dev/null
+++ b/src/server/game/TriniChat/IRCIO.cpp
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config.h"
+#include "Channel.h"
+#include "World.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+    //sLog->outDebug(sData.c_str());
+    // If first 5 chars are ERROR then something is wrong
+    // either link is being closed, nickserv ghost command, etc...
+    if (sData.substr(0, 5) == "ERROR")
+    {
+        Disconnect();
+        return;
+    }
+    if (sData.substr(0, 4) == "PING")
+    {
+        // if the first 4 characters contain PING
+        // the server is checking if we are still alive
+        // sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+    else
+    {
+        // if the first line contains : its an irc message
+        // such as private messages channel join etc.
+        if (sData.substr(0, 1) == ":")
+        {
+            // find the spaces in the receieved line
+            size_t p1 = sData.find(" ");
+            size_t p2 = sData.find(" ", p1 + 1);
+            // because the irc protocol uses simple spaces
+            // to seperate data we can easy pick them out
+            // since we know the position of the spaces
+            std::string USR = sData.substr(1, p1 - 1);
+            std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+            // trasform the commands to lowercase to make sure they always match
+            std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+            // Extract the username from the first part
+            std::string szUser = GetUser(USR);
+            // if we receieved the internet connect code
+            // we know for sure that were in and we can
+            // authenticate ourself.
+            if (CMD == sIRC._ICC)
+            {
+                // _Auth is defined in trinitycore.conf (irc.auth)
+                // 0 do not authenticate
+                // 1 use nickserv
+                // 2 use quakenet
+                // aditionally you can provide you own authentication method here
+                switch(sIRC._Auth)
+                {
+                    case 1:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Pass);
+                        break;
+                    case 2:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                    case 3:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Nick + " " + sIRC._Pass);
+                        break;
+                    case 4:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                }
+                // if we join a default channel leave this now.
+                if (sIRC._ldefc==1)
+                    SendIRC("PART #" + sIRC._defchan);
+                // Loop thru the channel array and send a command to join them on IRC.
+                for (int i=1;i < sIRC._chan_count + 1;i++)
+                {
+                        if (sIRC._irc_pass[i].size() > 0)
+                                SendIRC("JOIN #" + sIRC._irc_chan[i] + " " + sIRC._irc_pass[i]);
+                        else
+                        SendIRC("JOIN #" + sIRC._irc_chan[i]);
+                }
+                // See if there's a logchannel available, if so: join it.
+                if (sIRC.logchan.size() > 0)
+                {
+                    if (sIRC.logchanpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC.logchan + " " + sIRC.logchanpw);
+                    else
+                        SendIRC("JOIN #" + sIRC.logchan);
+                }
+            }
+            // someone joined the channel this could be the bot or another user
+            if (CMD == "join")
+            {
+                size_t p = sData.find(":", p1);
+                std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+                // if the user is us it means we join the channel
+                if ((szUser == sIRC._Nick))
+                {
+                    // its us that joined the channel
+                    Send_IRC_Channel(CHAN, MakeMsg(MakeMsg(sIRC.JoinMsg, "$Ver", sIRC._Mver.c_str()), "$Trigger", sIRC._cmd_prefx.c_str()), true);
+                }
+                else
+                {
+                    // if the user is not us its someone else that joins
+                    // so we construct a message and send this to the clients.
+                    // TriniChat now uses Send_WoW_Channel to send to the client
+                    // this makes TriniChat handle the packets instead of previously the world.
+                    if ((sIRC.BOTMASK & 2) != 0)
+                        Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+                }
+            }
+            // someone on irc left or quit the channel
+            if (CMD == "part" || CMD == "quit")
+            {
+                size_t p3 = sData.find(" ", p2 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                // Logout IRC Nick From TriniChat If User Leaves Or Quits IRC.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    _CDATA CDATA;
+                    CDATA.USER      = szUser;
+                    Command.Handle_Logout(&CDATA);
+                }
+                // Construct a message and inform the clients on the same channel.
+                if ((sIRC.BOTMASK & 2) != 0)
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+            }
+            // someone changed their nick
+            if (CMD == "nick" && (sIRC.BOTMASK & 128) != 0)
+            {
+                MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+                // If the user is logged in and changes their nick 
+                // then we want to either log them out or update 
+                // their nick in the bot. I chose to update the bots user list.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    std::string NewNick = sData.substr(sData.find(":", p2) + 1);
+                    // On freenode I noticed the server sends an extra character
+                    // at the end of the string, so we need to erase the last
+                    // character of the string. if you have a problem with getting
+                    // the last letter of your nick erased, then remove the - 1.
+                    NewNick.erase(NewNick.length() - 1, 1);
+
+                    for (std::list<_client*>::iterator i=Command._CLIENTS.begin(); i!=Command._CLIENTS.end();i++)
+                    {
+                        if ((*i)->Name == szUser)
+                        {
+                            (*i)->Name     = NewNick;
+                            sIRC.Send_IRC_Channel(NewNick.c_str(), "I Noticed You Changed Your Nick, I Have Updated My Internal Database Accordingly.", true, "NOTICE");
+                            
+                            // Figure why not output to the logfile, makes tracing problems easier.
+                            sIRC.iLog.WriteLog(" %s : %s Changed Nick To: %s", sIRC.iLog.GetLogDateTimeStr().c_str(), szUser.c_str(), NewNick.c_str());
+                        }
+                    }
+                }
+
+            }
+            // someone was kicked from irc
+            if (CMD == "kick")
+            {
+                // extract the details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(":", p4);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+                // if the one kicked was us
+                if (WHO == sIRC._Nick)
+                {
+                    // and autojoin is enabled
+                    // return to the channel
+                    if (sIRC._autojoinkick == 1)
+                    {
+                        SendIRC("JOIN " + CHAN);
+                        Send_IRC_Channel(CHAN, sIRC.kikmsg, true);
+                    }
+                }
+                else
+                {
+                    // if it is not us who was kicked we need to inform the clients someone
+                    // was removed from the channel
+                    // construct a message and send it to the players.
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+                }
+            }
+            // a private chat message was receieved.
+            if (CMD == "privmsg" || CMD == "notice")
+            {
+                // extract the values
+                size_t p = sData.find(" ", p2 + 1);
+                std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+                std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+                // if this is our username it means we recieved a PM
+                if (FROM == sIRC._Nick)
+                {
+                    if (CHAT.find("\001VERSION\001") < CHAT.size())
+                    {
+                        Send_IRC_Channel(szUser, MakeMsg("\001VERSION TriniChat %s ©2008-2009 |Death|, Cybrax, Machiavelli\001", "%s" , sIRC._Mver.c_str()), true, "PRIVMSG");
+                    }
+                    // a pm is required for certain commands
+                    // such as login. to validate the command
+                    // we send it to the command class wich handles
+                    // evrything else.
+                    Command.IsValid(szUser, FROM, CHAT, CMD);
+                }
+                else
+                {
+                    // if our name is not in it, it means we receieved chat on one of the channels
+                    // magchat is in. the first thing we do is check if it is a command or not
+                    if (!Command.IsValid(szUser, FROM, CHAT, CMD))
+                    {
+                        Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                    }
+                    // if we indeed receieved a command we do not want to display this to the players
+                    // so only incanse the isvalid command returns false it will be sent to all player.
+                    // the isvalid function will automaitcly process the command on true.
+                }
+            }
+            if (CMD == "mode")
+            {
+                // extract the mode details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(" ", p4 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string MODE = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string NICK = sData.substr(p4 + 1, p5 - p4 - 1);
+                bool _AmiOp;
+                _AmiOp = false;
+                //A mode was changed on us
+                if (NICK.c_str() == sIRC._Nick)
+                    _AmiOp = true;
+
+            }
+        }
+    }
+}
+
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if (sIRC.Connected && (sIRC.BOTMASK & 1)!= 0)
+    {
+        if (Channel_Valid(Channel))
+        {
+            std::string GMRank = "";
+            std::string pname = plr->GetName();
+            bool DoGMAnnounce = false;
+            if (plr->GetSession()->GetSecurity() > 0 && (sIRC.BOTMASK & 8)!= 0)
+                DoGMAnnounce = true;
+            if (plr->isGameMaster() && (sIRC.BOTMASK & 16)!= 0)
+                DoGMAnnounce = true;
+            if (DoGMAnnounce)
+            {
+                switch(plr->GetSession()->GetSecurity())    //switch case to determine what rank the "gm" is
+                {
+                    case 0: GMRank = "";break;
+                    case 1: GMRank = "\0037"+sIRC.ojGM1;break;
+                    case 2: GMRank = "\0037"+sIRC.ojGM2;break;
+                    case 3: GMRank = "\0037"+sIRC.ojGM3;break;
+                    case 4: GMRank = "\0037"+sIRC.ojGM4;break;
+                    case 5: GMRank = "\0037"+sIRC.ojGM5;break;
+	 	     case 6: GMRank = "\0037"+sIRC.ojGM6;break;
+		     case 7: GMRank = "\0037"+sIRC.ojGM7;break;
+		     case 8: GMRank = "\0037"+sIRC.ojGM8;break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+            std::string query = "INSERT INTO `irc_inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+            std::string lchan = "DELETE FROM `irc_inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+            switch(nAction)
+            {
+                case CHANNEL_JOIN:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    WorldDatabase.PExecute(query.c_str(), plr->GetGUID());
+                    break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    break;
+            }
+        }
+    }
+}
+
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, std::string nType)
+{
+    std::string mType = "PRIVMSG";
+    if (Command.MakeUpper(nType.c_str()) == "NOTICE")
+        mType = "NOTICE";
+    if (Command.MakeUpper(nType.c_str()) == "ERROR" && (sIRC.BOTMASK & 32)!= 0)
+        mType = "NOTICE";
+    if (sIRC.Connected)
+    {
+        if (NoPrefix)
+            SendIRC(mType + " " + sChannel + " :" + sMsg);
+        else
+            SendIRC(mType + " #" + sChannel + " :" + sMsg);
+    }
+}
+
+// This function sends a message to all irc channels
+// that TriniChat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+        Send_IRC_Channel(sIRC._irc_chan[i], sMsg);
+}
+
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if (Channel_Valid(Channel) && Msg.substr(0, 1) != ".")
+        Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+}
+
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+    normalizePlayerName(sPlayer);
+    if (Player* plr = sObjectAccessor->FindPlayerByName(sPlayer.c_str()))
+        Send_WoW_Player(plr, sMsg);
+}
+
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << (uint8)CHAT_MSG_SYSTEM;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)0;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)(sMsg.length()+1);
+    data << sMsg;
+    data << (uint8)0;
+    plr->GetSession()->SendPacket(&data);
+}
+
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+    if (!(strlen(channel) > 0))
+        return;
+
+    #ifdef USE_UTF8
+        std::string chat2 = chat;
+        if (ConvertUTF8(chat2.c_str(), chat2))
+            chat = chat2;
+    #endif
+
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = channelMgr(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (Channel *chn = cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    data.Initialize(SMSG_MESSAGECHAT);
+                    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << IRCcol2WoW(chat.c_str());
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::Send_WoW_System(std::string Message)
+{
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+    SendData("QUIT");
+    Disconnect();
+}
+
+#define CHAT_INVITE_NOTICE 0x18
+
+// this function should be called on player login Player::AddToWorld
+void IRCClient::AutoJoinChannel(Player *plr)
+{
+    //this will work if at least 1 player is logged in regrdless if he is on the channel or not
+    // the first person that login empty server is the one with bad luck and wont be invited, 
+    // if at least 1 player is online the player will be inited to the chanel
+
+    std::string m_name = sIRC.ajchan;
+    WorldPacket data;
+    data.Initialize(SMSG_CHANNEL_NOTIFY, 1+m_name.size()+1);
+    data << uint8(CHAT_INVITE_NOTICE);
+    data << m_name.c_str();
+
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            data << uint64(itr->second->GetGUID());
+            break;
+        }
+    }
+    plr->GetSession()->SendPacket(&data);
+}
diff --git a/src/server/game/TriniChat/IRCLog.cpp b/src/server/game/TriniChat/IRCLog.cpp
new file mode 100644
index 0000000..bdc053a
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCLog.h"
+#include "Config.h"
+#include "IRCClient.h"
+#include <stdarg.h>
+#include "World.h"
+
+IRCLog::IRCLog()
+{
+    std::string logsDir = ConfigMgr::GetStringDefault("LogsDir","");
+    std::string ircLogName = logsDir + "/IRC_";
+    std::string ircLogTimestamp = GetLogDateStr();
+        ircLogName += ircLogTimestamp +".log";
+    ircLogfile.open (ircLogName.c_str(), std::ios::app);
+}
+
+IRCLog::~IRCLog()
+{
+    ircLogfile.close();
+}
+// Was added because using the time for logs is very annoying... one log per day.. much cleaner looking..
+std::string IRCLog::GetLogDateStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf,20,"%04d-%02d-%02d",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday);
+    return std::string(buf);
+}
+
+std::string IRCLog::GetLogDateTimeStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[30];
+    snprintf(buf,30,"[ %04d-%02d-%02d ] [ %02d:%02d:%02d ]",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday,aTm->tm_hour,aTm->tm_min,aTm->tm_sec);
+    return std::string(buf);
+}
+
+void IRCLog::WriteLog(const char *what, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, what);
+    vsnprintf(tmpoutp, 1024, what, ap);
+    va_end(ap);
+    ircLogfile << tmpoutp;
+    ircLogfile << "\n";
+    ircLogfile.flush();
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCLog.h b/src/server/game/TriniChat/IRCLog.h
new file mode 100644
index 0000000..426ff4e
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_LOG_H
+#define _IRC_LOG_H
+
+#include "Common.h"
+#include <fstream>
+
+class IRCLog
+{
+    public:
+        IRCLog();
+        ~IRCLog();
+
+    public:
+        void WriteLog(const char *what, ...);
+        std::string GetLogDateStr() const;
+        std::string GetLogDateTimeStr() const;
+    private:
+        std::ofstream ircLogfile;
+};
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCSock.cpp b/src/server/game/TriniChat/IRCSock.cpp
new file mode 100644
index 0000000..e4e9844
--- /dev/null
+++ b/src/server/game/TriniChat/IRCSock.cpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+
+
+#define _UNICODE
+
+#ifdef _MBCS
+#undef _MBCS
+#endif
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        sLog->outError("IRC Error: Winsock Initialization Error");
+        return false;
+    }
+    #endif
+    if ((sIRC.SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        sLog->outError("IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if (setsockopt (sIRC.SOCKET, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof (on)) == -1)
+    {
+        sLog->outError("IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(sIRC.SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(sIRC.SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(sIRC.SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+    sIRC.Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        sLog->outError("IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(sIRC.SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        sLog->outError("IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    //FD_ZERO(&sIRC.sfdset);
+    //FD_SET(sIRC.SOCKET,&sIRC.sfdset);
+    sIRC.Connected = true;
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+    if (SendIRC("HELLO"))
+        if (SendIRC("PASS " + sPass))
+            if (SendIRC("NICK " + sNick))
+                if (SendIRC("USER " + sUser + " " + (std::string)hostname + " TriniChat :TriniChat "+sIRC._Mver.c_str()))
+                    return true;
+    return false;
+}
+
+bool IRCClient::SendData(const char *data)
+{
+    if (sIRC.Connected)
+    {
+        if (send(sIRC.SOCKET, data, strlen(data), 0) == -1)
+        {
+            sLog->outError("IRC Error: Socket Receieve ** \n");
+            //Disconnect();
+            return false;
+        }
+    }
+    return true;
+}
+
+bool IRCClient::SendIRC(std::string data)
+{
+    std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+
+void IRCClient::Disconnect()
+{
+    if (sIRC.SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(sIRC.SOCKET);
+        //WSACleanup();
+        #else
+        close(sIRC.SOCKET);
+        #endif
+    }
+}
+
+void IRCClient::SockRecv()
+{
+//    wchar_t bufferdata;
+
+    char szBuffer[MAXDATASIZE];
+
+    memset(szBuffer, 0, MAXDATASIZE);
+    
+    int nBytesRecv = ::recv(sIRC.SOCKET, szBuffer, MAXDATASIZE - 1, 0);
+    if (nBytesRecv == -1)
+    {
+        sLog->outError("Connection lost.");
+        sIRC.Connected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            sLog->outError("Error occurred while receiving from socket.");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                Handle_IRC(reply);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.cpp b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
new file mode 100644
index 0000000..7a9b17e
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "MCS_OnlinePlayers.h"
+
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+
+mcs_OnlinePlayers::mcs_OnlinePlayers() { CD = NULL; }
+
+mcs_OnlinePlayers::mcs_OnlinePlayers(_CDATA *_CD)
+{
+    //create a new instance of data struct and copy its data
+    CD = new _CDATA();
+    CD->CMD = _CD->CMD;
+    CD->FROM = _CD->FROM;
+    CD->PARAMS = _CD->PARAMS;
+    CD->PCOUNT = _CD->PCOUNT;
+    CD->USER = _CD->USER;
+    CD->TYPE = _CD->TYPE;
+}
+
+mcs_OnlinePlayers::~mcs_OnlinePlayers()
+{
+    if (CD)
+        delete CD;
+}
+
+void mcs_OnlinePlayers::run()
+{
+    int OnlineCount = 0;
+    std::string IRCOut = "";
+	HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            OnlineCount++;
+            Player *plr = itr->second->GetSession()->GetPlayer();
+            std::string ChatTag = " ";
+            switch(plr->GetSession()->GetSecurity())
+            {
+                  case 0: ChatTag.append("");break;
+                  case 1: ChatTag.append("\0037"+sIRC.ojGM1);break;
+                  case 2: ChatTag.append("\0037"+sIRC.ojGM2);break;
+                  case 3: ChatTag.append("\0037"+sIRC.ojGM3);break;
+                  case 4: ChatTag.append("\0037"+sIRC.ojGM4);break;
+                  case 5: ChatTag.append("\0037"+sIRC.ojGM5);break;
+		   case 6: ChatTag.append("\0037"+sIRC.ojGM6);break;
+		   case 7: ChatTag.append("\0037"+sIRC.ojGM7);break;
+		   case 8: ChatTag.append("\0037"+sIRC.ojGM8);break;
+            }
+            if (plr->isAFK())
+                ChatTag.append("\002\0037<AFK>\003\002");
+            else if (plr->isDND())
+                ChatTag.append("\002\0037<DND>\003\002");
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+
+            IRCOut.append(IRCCmd::MakeMsg("%s\002%s\003\017\002(%d)\002\017", ChatTag.c_str(), plr->GetName(), plr->getLevel()));
+
+            // after XX players have been added to the string
+            // output to irc and reset for the next XX
+            if (OnlineCount % sIRC.onlrslt == 0)
+            {
+                sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002 %s", IRCOut.c_str()), true, CD->TYPE.c_str());
+                IRCOut = "";
+                ACE_Based::Thread::Sleep(1000);
+            }
+        }
+    }
+    // Remainder in IRCOUT && Total plyersonline
+    sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002Players Online(%d):\017 %s", OnlineCount, IRCOut.c_str()), true, CD->TYPE);
+
+    sIRC.Script_Lock[MCS_Players_Online] = false;
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.h b/src/server/game/TriniChat/MCS_OnlinePlayers.h
new file mode 100644
index 0000000..9e4276b
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_ONLINE
+#define _IRC_CLIENT_ONLINE
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+
+class mcs_OnlinePlayers : public ACE_Based::Runnable
+{
+    public:
+        mcs_OnlinePlayers();
+        mcs_OnlinePlayers(_CDATA *_CD);
+        ~mcs_OnlinePlayers();
+        void run();
+    public:
+        _CDATA *CD;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/framework/CMakeLists.txt b/src/server/game/TriniChat/framework/CMakeLists.txt
new file mode 100644
index 0000000..bcf3603
--- /dev/null
+++ b/src/server/game/TriniChat/framework/CMakeLists.txt
@@ -0,0 +1,11 @@
+SET(trinityframework_STAT_SRCS
+   Policies/ObjectLifeTime.cpp
+   Utilities/EventProcessor.cpp
+)
+
+include_directories(
+  ${ACE_INCLUDE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/framework
+)
+
+add_library(trinityframework STATIC ${trinityframework_STAT_SRCS})
diff --git a/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h b/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
new file mode 100644
index 0000000..282968d
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_FACTORY_HOLDER
+#define TRINITY_FACTORY_HOLDER
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include "ObjectRegistry.h"
+#include "Policies/SingletonImp.h"
+
+/** FactoryHolder holds a factory object of a specific type
+ */
+template<class T, class Key = std::string>
+class FactoryHolder
+{
+    public:
+        typedef ObjectRegistry<FactoryHolder<T, Key >, Key > FactoryHolderRegistry;
+        typedef Trinity::Singleton<FactoryHolderRegistry > FactoryHolderRepository;
+
+        FactoryHolder(Key k) : i_key(k) {}
+        virtual ~FactoryHolder() {}
+        inline Key key() const { return i_key; }
+
+        void RegisterSelf(void) { FactoryHolderRepository::Instance().InsertItem(this, i_key); }
+        void DeregisterSelf(void) { FactoryHolderRepository::Instance().RemoveItem(this, false); }
+
+        /// Abstract Factory create method
+        virtual T* Create(void *data = NULL) const = 0;
+    private:
+        Key i_key;
+};
+
+/** Permissible is a classic way of letting the object decide
+ * whether how good they handle things.  This is not retricted
+ * to factory selectors.
+ */
+template<class T>
+class Permissible
+{
+    public:
+        virtual ~Permissible() {}
+        virtual int Permit(const T *) const = 0;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h b/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
new file mode 100644
index 0000000..e661942
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_OBJECTREGISTRY_H
+#define TRINITY_OBJECTREGISTRY_H
+
+#include "Platform/Define.h"
+#include "Utilities/UnorderedMap.h"
+#include "Policies/Singleton.h"
+
+#include <string>
+#include <vector>
+#include <map>
+
+/** ObjectRegistry holds all registry item of the same type
+ */
+template<class T, class Key = std::string>
+class ObjectRegistry
+{
+    public:
+        typedef std::map<Key, T *> RegistryMapType;
+
+        /// Returns a registry item
+        const T* GetRegistryItem(Key key) const
+        {
+            typename RegistryMapType::const_iterator iter = i_registeredObjects.find(key);
+            return( iter == i_registeredObjects.end() ? NULL : iter->second );
+        }
+
+        /// Inserts a registry item
+        bool InsertItem(T *obj, Key key, bool override = false)
+        {
+            typename RegistryMapType::iterator iter = i_registeredObjects.find(key);
+            if( iter != i_registeredObjects.end() )
+            {
+                if( !override )
+                    return false;
+                delete iter->second;
+                i_registeredObjects.erase(iter);
+            }
+
+            i_registeredObjects[key] = obj;
+            return true;
+        }
+
+        /// Removes a registry item
+        void RemoveItem(Key key, bool delete_object = true)
+        {
+            typename RegistryMapType::iterator iter = i_registeredObjects.find(key);
+            if( iter != i_registeredObjects.end() )
+            {
+                if( delete_object )
+                    delete iter->second;
+                i_registeredObjects.erase(iter);
+            }
+        }
+
+        /// Returns true if registry contains an item
+        bool HasItem(Key key) const
+        {
+            return (i_registeredObjects.find(key) != i_registeredObjects.end());
+        }
+
+        /// Inefficiently return a vector of registered items
+        unsigned int GetRegisteredItems(std::vector<Key> &l) const
+        {
+            unsigned int sz = l.size();
+            l.resize(sz + i_registeredObjects.size());
+            for (typename RegistryMapType::const_iterator iter = i_registeredObjects.begin(); iter != i_registeredObjects.end(); ++iter)
+                l[sz++] = iter->first;
+            return i_registeredObjects.size();
+        }
+
+        /// Return the map of registered items
+        RegistryMapType const &GetRegisteredItems() const
+        {
+            return i_registeredObjects;
+        }
+
+    private:
+        RegistryMapType i_registeredObjects;
+        friend class Trinity::OperatorNew<ObjectRegistry<T, Key> >;
+
+        // protected for friend use since it should be a singleton
+        ObjectRegistry() {}
+        ~ObjectRegistry()
+        {
+            for (typename RegistryMapType::iterator iter=i_registeredObjects.begin(); iter != i_registeredObjects.end(); ++iter)
+                delete iter->second;
+            i_registeredObjects.clear();
+        }
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/Grid.h b/src/server/game/TriniChat/framework/GameSystem/Grid.h
new file mode 100644
index 0000000..65bf3c9
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/Grid.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_GRID_H
+#define TRINITY_GRID_H
+
+/*
+  @class Grid
+  Grid is a logical segment of the game world represented inside TrinIty.
+  Grid is bind at compile time to a particular type of object which
+  we call it the object of interested.  There are many types of loader,
+  specially, dynamic loader, static loader, or on-demand loader.  There's
+  a subtle difference between dynamic loader and on-demand loader but
+  this is implementation specific to the loader class.  From the
+  Grid's perspective, the loader meets its API requirement is suffice.
+*/
+
+#include "Platform/Define.h"
+#include "Policies/ThreadingModel.h"
+#include "TypeContainer.h"
+#include "TypeContainerVisitor.h"
+
+// forward declaration
+template<class A, class T, class O> class GridLoader;
+
+template
+<
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES,
+class ThreadModel = Trinity::SingleThreaded<ACTIVE_OBJECT>
+>
+class Grid
+{
+    // allows the GridLoader to access its internals
+    template<class A, class T, class O> friend class GridLoader;
+    public:
+
+        /** destructor to clean up its resources. This includes unloading the
+        grid if it has not been unload.
+        */
+        ~Grid() {}
+
+        /** an object of interested enters the grid
+         */
+        template<class SPECIFIC_OBJECT> void AddWorldObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_objects.template insert<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** an object of interested exits the grid
+         */
+        template<class SPECIFIC_OBJECT> void RemoveWorldObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_objects.template remove<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** Refreshes/update the grid. This required for remote grids.
+         */
+        void RefreshGrid(void) { /* TBI */}
+
+        /** Locks a grid.  Any object enters must wait until the grid is unlock.
+         */
+        void LockGrid(void) { /* TBI */ }
+
+        /** Unlocks the grid.
+         */
+        void UnlockGrid(void) { /* TBI */ }
+
+        /** Grid visitor for grid objects
+         */
+        template<class T> void Visit(TypeContainerVisitor<T, TypeMapContainer<GRID_OBJECT_TYPES> > &visitor)
+        {
+            visitor.Visit(i_container);
+        }
+
+        /** Grid visitor for world objects
+         */
+        template<class T> void Visit(TypeContainerVisitor<T, TypeMapContainer<WORLD_OBJECT_TYPES> > &visitor)
+        {
+            visitor.Visit(i_objects);
+        }
+
+        /** Returns the number of object within the grid.
+         */
+        unsigned int ActiveObjectsInGrid(void) const { return /*m_activeGridObjects.size()+*/i_objects.template Count<ACTIVE_OBJECT>(); }
+
+        /** Inserts a container type object into the grid.
+         */
+        template<class SPECIFIC_OBJECT> void AddGridObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_container.template insert<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** Removes a containter type object from the grid
+         */
+        template<class SPECIFIC_OBJECT> void RemoveGridObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_container.template remove<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /*bool NoWorldObjectInGrid() const
+        {
+            return i_objects.GetElements().isEmpty();
+        }
+
+        bool NoGridObjectInGrid() const
+        {
+            return i_container.GetElements().isEmpty();
+        }*/
+    private:
+
+        typedef typename ThreadModel::Lock Guard;
+        typedef typename ThreadModel::VolatileType VolatileType;
+
+        TypeMapContainer<GRID_OBJECT_TYPES> i_container;
+        TypeMapContainer<WORLD_OBJECT_TYPES> i_objects;
+        //typedef std::set<void*> ActiveGridObjects;
+        //ActiveGridObjects m_activeGridObjects;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridLoader.h b/src/server/game/TriniChat/framework/GameSystem/GridLoader.h
new file mode 100644
index 0000000..03fa0f5
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridLoader.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_GRIDLOADER_H
+#define TRINITY_GRIDLOADER_H
+
+/**
+  @class GridLoader
+  The GridLoader is working in conjuction with the Grid and responsible
+  for loading and unloading object-types (one or more) when objects
+  enters a grid.  Unloading is scheduled and might be canceled if
+  an interested object re-enters.  GridLoader does not do the actuall
+  loading and unloading but implements as a template pattern that
+  delicate its loading and unloading for the actualy loader and unloader.
+  GridLoader manages the grid (both local and remote).
+ */
+
+#include "Platform/Define.h"
+#include "Grid.h"
+#include "TypeContainerVisitor.h"
+
+template
+<
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES
+>
+class GridLoader
+{
+    public:
+
+        /** Loads the grid
+         */
+        template<class LOADER>
+            void Load(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, LOADER &loader)
+        {
+            grid.LockGrid();
+            loader.Load(grid);
+            grid.UnlockGrid();
+        }
+
+        /** Stop the grid
+         */
+        template<class STOPER>
+            void Stop(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, STOPER &stoper)
+        {
+            grid.LockGrid();
+            stoper.Stop(grid);
+            grid.UnlockGrid();
+        }
+        /** Unloads the grid
+         */
+        template<class UNLOADER>
+            void Unload(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, UNLOADER &unloader)
+        {
+            grid.LockGrid();
+            unloader.Unload(grid);
+            grid.UnlockGrid();
+        }
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h b/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
new file mode 100644
index 0000000..7979910
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _GRIDREFMANAGER
+#define _GRIDREFMANAGER
+
+#include "Utilities/LinkedReference/RefManager.h"
+
+template<class OBJECT>
+class GridReference;
+
+template<class OBJECT>
+class GridRefManager : public RefManager<GridRefManager<OBJECT>, OBJECT>
+{
+    public:
+        typedef LinkedListHead::Iterator< GridReference<OBJECT> > iterator;
+
+        GridReference<OBJECT>* getFirst() { return (GridReference<OBJECT>*)RefManager<GridRefManager<OBJECT>, OBJECT>::getFirst(); }
+        GridReference<OBJECT>* getLast() { return (GridReference<OBJECT>*)RefManager<GridRefManager<OBJECT>, OBJECT>::getLast(); }
+
+        iterator begin() { return iterator(getFirst()); }
+        iterator end() { return iterator(NULL); }
+        iterator rbegin() { return iterator(getLast()); }
+        iterator rend() { return iterator(NULL); }
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridReference.h b/src/server/game/TriniChat/framework/GameSystem/GridReference.h
new file mode 100644
index 0000000..d2e3a45
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridReference.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _GRIDREFERENCE_H
+#define _GRIDREFERENCE_H
+
+#include "Utilities/LinkedReference/Reference.h"
+
+template<class OBJECT>
+class GridRefManager;
+
+template<class OBJECT>
+class GridReference : public Reference<GridRefManager<OBJECT>, OBJECT>
+{
+    protected:
+        void targetObjectBuildLink()
+        {
+            // called from link()
+            this->getTarget()->insertFirst(this);
+            this->getTarget()->incSize();
+        }
+        void targetObjectDestroyLink()
+        {
+            // called from unlink()
+            if(this->isValid()) this->getTarget()->decSize();
+        }
+        void sourceObjectDestroyLink()
+        {
+            // called from invalidate()
+            this->getTarget()->decSize();
+        }
+    public:
+        GridReference() : Reference<GridRefManager<OBJECT>, OBJECT>() {}
+        ~GridReference() { this->unlink(); }
+        GridReference *next() { return (GridReference*)Reference<GridRefManager<OBJECT>, OBJECT>::next(); }
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/NGrid.h b/src/server/game/TriniChat/framework/GameSystem/NGrid.h
new file mode 100644
index 0000000..3810286
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/NGrid.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_NGRID_H
+#define TRINITY_NGRID_H
+
+/** NGrid is nothing more than a wrapper of the Grid with an NxN cells
+ */
+
+#include "GameSystem/Grid.h"
+#include "GameSystem/GridReference.h"
+#include "Timer.h"
+#include "Util.h"
+
+#define DEFAULT_VISIBILITY_NOTIFY_PERIOD      1000
+
+class GridInfo
+{
+public:
+    GridInfo()
+        : i_timer(0), i_unloadActiveLockCount(0), i_unloadExplicitLock(false), i_unloadReferenceLock(false),
+          vis_Update(0, irand(0,DEFAULT_VISIBILITY_NOTIFY_PERIOD)) {}
+    GridInfo(time_t expiry, bool unload = true )
+        : i_timer(expiry), i_unloadActiveLockCount(0), i_unloadExplicitLock(!unload), i_unloadReferenceLock(false),
+          vis_Update(0, irand(0,DEFAULT_VISIBILITY_NOTIFY_PERIOD)) {}
+    const TimeTracker& getTimeTracker() const { return i_timer; }
+    bool getUnloadLock() const { return i_unloadActiveLockCount || i_unloadExplicitLock || i_unloadReferenceLock; }
+    void setUnloadExplicitLock( bool on ) { i_unloadExplicitLock = on; }
+    void setUnloadReferenceLock( bool on ) { i_unloadReferenceLock = on; }
+    void incUnloadActiveLock() { ++i_unloadActiveLockCount; }
+    void decUnloadActiveLock() { if(i_unloadActiveLockCount) --i_unloadActiveLockCount; }
+
+    void setTimer(const TimeTracker& pTimer) { i_timer = pTimer; }
+    void ResetTimeTracker(time_t interval) { i_timer.Reset(interval); }
+    void UpdateTimeTracker(time_t diff) { i_timer.Update(diff); }
+    PeriodicTimer& getRelocationTimer() { return vis_Update; }
+private:
+    TimeTracker i_timer;
+    PeriodicTimer vis_Update;
+
+    uint16 i_unloadActiveLockCount : 16;                    // lock from active object spawn points (prevent clone loading)
+    bool   i_unloadExplicitLock    : 1;                     // explicit manual lock or config setting
+    bool   i_unloadReferenceLock   : 1;                     // lock from instance map copy
+};
+
+typedef enum
+{
+    GRID_STATE_INVALID = 0,
+    GRID_STATE_ACTIVE = 1,
+    GRID_STATE_IDLE = 2,
+    GRID_STATE_REMOVAL= 3,
+    MAX_GRID_STATE = 4
+} grid_state_t;
+
+template
+<
+unsigned int N,
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES,
+class ThreadModel = Trinity::SingleThreaded<ACTIVE_OBJECT>
+>
+class NGrid
+{
+    public:
+
+        typedef Grid<ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> GridType;
+        NGrid(uint32 id, int32 x, int32 y, time_t expiry, bool unload = true)
+            : i_gridId(id), i_x(x), i_y(y), i_cellstate(GRID_STATE_INVALID), i_GridObjectDataLoaded(false)
+        {
+            i_GridInfo = GridInfo(expiry, unload);
+        }
+
+        const GridType& operator()(unsigned short x, unsigned short y) const
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        GridType& operator()(unsigned short x, unsigned short y)
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        const uint32& GetGridId(void) const { return i_gridId; }
+        void SetGridId(const uint32 id) const { i_gridId = id; }
+        grid_state_t GetGridState(void) const { return i_cellstate; }
+        void SetGridState(grid_state_t s) { i_cellstate = s; }
+        int32 getX() const { return i_x; }
+        int32 getY() const { return i_y; }
+
+        void link(GridRefManager<NGrid<N, ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> >* pTo)
+        {
+            i_Reference.link(pTo, this);
+        }
+        bool isGridObjectDataLoaded() const { return i_GridObjectDataLoaded; }
+        void setGridObjectDataLoaded(bool pLoaded) { i_GridObjectDataLoaded = pLoaded; }
+
+        GridInfo* getGridInfoRef() { return &i_GridInfo; }
+        const TimeTracker& getTimeTracker() const { return i_GridInfo.getTimeTracker(); }
+        bool getUnloadLock() const { return i_GridInfo.getUnloadLock(); }
+        void setUnloadExplicitLock( bool on ) { i_GridInfo.setUnloadExplicitLock(on); }
+        void setUnloadReferenceLock( bool on ) { i_GridInfo.setUnloadReferenceLock(on); }
+        void incUnloadActiveLock() { i_GridInfo.incUnloadActiveLock(); }
+        void decUnloadActiveLock() { i_GridInfo.decUnloadActiveLock(); }
+        void ResetTimeTracker(time_t interval) { i_GridInfo.ResetTimeTracker(interval); }
+        void UpdateTimeTracker(time_t diff) { i_GridInfo.UpdateTimeTracker(diff); }
+
+        template<class SPECIFIC_OBJECT> void AddWorldObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            getGridType(x, y).AddWorldObject(obj);
+        }
+
+        template<class SPECIFIC_OBJECT> void RemoveWorldObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            getGridType(x, y).RemoveWorldObject(obj);
+        }
+
+        template<class T, class TT> void Visit(TypeContainerVisitor<T, TypeMapContainer<TT> > &visitor)
+        {
+            for (unsigned int x=0; x < N; ++x)
+                for (unsigned int y=0; y < N; ++y)
+                    getGridType(x, y).Visit(visitor);
+        }
+
+        template<class T, class TT> void Visit(const uint32 &x, const uint32 &y, TypeContainerVisitor<T, TypeMapContainer<TT> > &visitor)
+        {
+            getGridType(x, y).Visit(visitor);
+        }
+
+        unsigned int ActiveObjectsInGrid(void) const
+        {
+            unsigned int count=0;
+            for (unsigned int x=0; x < N; ++x)
+                for (unsigned int y=0; y < N; ++y)
+                    count += i_cells[x][y].ActiveObjectsInGrid();
+            return count;
+        }
+
+        template<class SPECIFIC_OBJECT> bool AddGridObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            return getGridType(x, y).AddGridObject(obj);
+        }
+
+        template<class SPECIFIC_OBJECT> bool RemoveGridObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            return getGridType(x, y).RemoveGridObject(obj);
+        }
+
+    private:
+
+        GridType& getGridType(const uint32& x, const uint32& y)
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        uint32 i_gridId;
+        GridInfo i_GridInfo;
+        GridReference<NGrid<N, ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> > i_Reference;
+        int32 i_x;
+        int32 i_y;
+        grid_state_t i_cellstate;
+        GridType i_cells[N][N];
+        bool i_GridObjectDataLoaded;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
new file mode 100644
index 0000000..c2c9b4f
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPECONTAINER_H
+#define TRINITY_TYPECONTAINER_H
+
+/*
+ * Here, you'll find a series of containers that allow you to hold multiple
+ * types of object at the same time.
+ */
+
+#include <map>
+#include <vector>
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include "GameSystem/GridRefManager.h"
+
+/*
+ * @class ContainerMapList is a mulit-type container for map elements
+ * By itself its meaningless but collaborate along with TypeContainers,
+ * it become the most powerfully container in the whole system.
+ */
+template<class OBJECT> struct ContainerMapList
+{
+    //std::map<OBJECT_HANDLE, OBJECT *> _element;
+    GridRefManager<OBJECT> _element;
+};
+
+template<> struct ContainerMapList<TypeNull>                /* nothing is in type null */
+{
+};
+template<class H, class T> struct ContainerMapList<TypeList<H, T> >
+{
+    ContainerMapList<H> _elements;
+    ContainerMapList<T> _TailElements;
+};
+
+/*
+ * @class ContaierArrayList is a multi-type container for
+ * array of elements.
+ */
+template<class OBJECT> struct ContainerArrayList
+{
+    std::vector<OBJECT> _element;
+};
+
+// termination condition
+template<> struct ContainerArrayList<TypeNull> {};
+// recursion
+template<class H, class T> struct ContainerArrayList<TypeList<H, T> >
+{
+    ContainerArrayList<H> _elements;
+    ContainerArrayList<T> _TailElements;
+};
+
+/*
+ * @class ContainerList is a simple list of different types of elements
+ *
+ */
+template<class OBJECT> struct ContainerList
+{
+    OBJECT _element;
+};
+
+/* TypeNull is underfined */
+template<> struct ContainerList<TypeNull> {};
+template<class H, class T> struct ContainerList<TypeList<H, T> >
+{
+    ContainerList<H> _elements;
+    ContainerMapList<T> _TailElements;
+};
+
+#include "TypeContainerFunctions.h"
+
+/*
+ * @class TypeMapContainer contains a fixed number of types and is
+ * determined at compile time.  This is probably the most complicated
+ * class and do its simplest thing, that is, holds objects
+ * of different types.
+ */
+
+template<class OBJECT_TYPES>
+class TypeMapContainer
+{
+    public:
+        template<class SPECIFIC_TYPE> size_t Count() const { return Trinity::Count(i_elements, (SPECIFIC_TYPE*)NULL); }
+
+        /// inserts a specific object into the container
+        template<class SPECIFIC_TYPE> bool insert(SPECIFIC_TYPE *obj)
+        {
+            SPECIFIC_TYPE* t = Trinity::Insert(i_elements, obj);
+            return (t != NULL);
+        }
+
+        ///  Removes the object from the container, and returns the removed object
+        template<class SPECIFIC_TYPE> bool remove(SPECIFIC_TYPE* obj)
+        {
+            SPECIFIC_TYPE* t = Trinity::Remove(i_elements, obj);
+            return (t != NULL);
+        }
+
+        ContainerMapList<OBJECT_TYPES> & GetElements(void) { return i_elements; }
+        const ContainerMapList<OBJECT_TYPES> & GetElements(void) const { return i_elements;}
+
+    private:
+        ContainerMapList<OBJECT_TYPES> i_elements;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
new file mode 100644
index 0000000..edfbb40
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TYPECONTAINER_FUNCTIONS_H
+#define TYPECONTAINER_FUNCTIONS_H
+
+/*
+ * Here you'll find a list of helper functions to make
+ * the TypeContainer usefull.  Without it, its hard
+ * to access or mutate the container.
+ */
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include <map>
+
+namespace Trinity
+{
+    /* ContainerMapList Helpers */
+    // count functions
+    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<SPECIFIC_TYPE> &elements, SPECIFIC_TYPE* /*fake*/)
+    {
+        return elements._element.getSize();
+    };
+
+    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE* /*fake*/)
+    {
+        return 0;
+    }
+
+    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE* /*fake*/)
+    {
+        return 0;
+    }
+
+    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<TypeList<SPECIFIC_TYPE, T> >&elements, SPECIFIC_TYPE* fake)
+    {
+        return Count(elements._elements,fake);
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> size_t Count(const ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE* fake)
+    {
+        return Count(elements._TailElements, fake);
+    }
+
+    // non-const insert functions
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Insert(ContainerMapList<SPECIFIC_TYPE> &elements, SPECIFIC_TYPE *obj)
+    {
+        //elements._element[hdl] = obj;
+        obj->GetGridRef().link(&elements._element, obj);
+        return obj;
+    };
+
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Insert(ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> SPECIFIC_TYPE* Insert(ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;                                        // a missed
+    }
+
+    // Recursion
+    template<class SPECIFIC_TYPE, class H, class T> SPECIFIC_TYPE* Insert(ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE *obj)
+    {
+        SPECIFIC_TYPE* t= Insert(elements._elements, obj);
+        return (t != NULL ? t : Insert(elements._TailElements, obj));
+    }
+
+    // non-const remove method
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Remove(ContainerMapList<SPECIFIC_TYPE> & /*elements*/, SPECIFIC_TYPE *obj)
+    {
+        obj->GetGridRef().unlink();
+        return obj;
+    }
+
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Remove(ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> SPECIFIC_TYPE* Remove(ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;                                        // a missed
+    }
+
+    template<class SPECIFIC_TYPE, class T, class H> SPECIFIC_TYPE* Remove(ContainerMapList<TypeList<H, T> > &elements, SPECIFIC_TYPE *obj)
+    {
+        // The head element is bad
+        SPECIFIC_TYPE* t = Remove(elements._elements, obj);
+        return ( t != NULL ? t : Remove(elements._TailElements, obj) );
+    }
+
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
new file mode 100644
index 0000000..2affcc4
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TYPECONTAINER_FUNCTIONS_PTR_H
+#define TYPECONTAINER_FUNCTIONS_PTR_H
+
+/*
+ * Here you'll find a list of helper functions to make
+ * the TypeContainer usefull.  Without it, its hard
+ * to access or mutate the container.
+ */
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include <map>
+
+namespace Trinity
+{
+    /* ContainerMapList Helpers */
+    // count functions
+    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return elements._element.size();
+    //    };
+    //
+    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return 0;
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return 0;
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<TypeList<SPECIFIC_TYPE, T> >&elements, SPECIFIC_TYPE* fake)
+    //    {
+    //        return Count(elements._elements,fake);
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class H, class T> size_t Count(const ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE* fake)
+    //    {
+    //        return Count(elements._TailElements, fake);
+    //    }
+
+    // non-const find functions
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
+        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
+    };
+
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// terminate recursion
+    }
+
+    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// this is a missed
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl,fake);
+        return (!t ? Find(elements._TailElements, hdl,fake) : t);
+    }
+
+    // const find functions
+    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        typename CountedPtr<SPECIFIC_TYPE>::iterator iter = elements._element.find(hdl);
+        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
+    };
+
+    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    template<class SPECIFIC_TYPE, class T> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl,fake);
+        if(!t)
+            t = Find(elements._TailElement, hdl,fake);
+
+        return t;
+    }
+
+    // non-const insert functions
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        elements._element[hdl] = obj;
+        return obj;
+    };
+
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// a missed
+    }
+
+    // Recursion
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeList<H, T> >&elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t= Insert(elements._elements, obj, hdl);
+        return (!t ? Insert(elements._TailElements, obj, hdl) : t);
+    }
+
+    // non-const remove method
+    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
+        if( iter != elements._element.end() )
+        {
+            elements._element.erase(iter);
+            return true;
+        }
+
+        return false;                                       // found... terminate the search
+    }
+
+    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return false;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> bool Remove(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return false;
+    }
+
+    template<class SPECIFIC_TYPE, class T, class H> bool Remove(ContainerMapList<TypeList<H, T> > &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        // The head element is bad
+        bool t = Remove(elements._elements, obj, hdl);
+        return ( !t ? Remove(elements._TailElements, obj, hdl) : t );
+    }
+
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
new file mode 100644
index 0000000..f15075e
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPECONTAINERVISITOR_H
+#define TRINITY_TYPECONTAINERVISITOR_H
+
+/*
+ * @class TypeContainerVisitor is implemented as a visitor pattern.  It is
+ * a visitor to the TypeContainerList or TypeContainerMapList.  The visitor has
+ * to overload its types as a visit method is called.
+ */
+
+#include "Platform/Define.h"
+#include "TypeContainer.h"
+
+// forward declaration
+template<class T, class Y> class TypeContainerVisitor;
+
+// visitor helper
+template<class VISITOR, class TYPE_CONTAINER> void VisitorHelper(VISITOR &v, TYPE_CONTAINER &c)
+{
+    v.Visit(c);
+};
+
+// terminate condition for container list
+template<class VISITOR> void VisitorHelper(VISITOR &v, ContainerList<TypeNull> &c)
+{
+}
+
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+// recursion for container list
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// terminate condition container map list
+template<class VISITOR> void VisitorHelper(VISITOR &/*v*/, ContainerMapList<TypeNull> &/*c*/)
+{
+}
+
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerMapList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+// recursion container map list
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerMapList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// array list
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerArrayList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+template<class VISITOR> void VisitorHelper(VISITOR &/*v*/, ContainerArrayList<TypeNull> &/*c*/)
+{
+}
+
+// recursion
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerArrayList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// for TypeMapContainer
+template<class VISITOR, class OBJECT_TYPES> void VisitorHelper(VISITOR &v, TypeMapContainer<OBJECT_TYPES> &c)
+{
+    VisitorHelper(v, c.GetElements());
+}
+
+template<class VISITOR, class TYPE_CONTAINER>
+class TypeContainerVisitor
+{
+    public:
+        TypeContainerVisitor(VISITOR &v) : i_visitor(v) {}
+
+        void Visit(TYPE_CONTAINER &c)
+        {
+            VisitorHelper(i_visitor, c);
+        }
+
+        void Visit(const TYPE_CONTAINER &c) const
+        {
+            VisitorHelper(i_visitor, c);
+        }
+
+    private:
+        VISITOR &i_visitor;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Network/SocketDefines.h b/src/server/game/TriniChat/framework/Network/SocketDefines.h
new file mode 100644
index 0000000..4936609
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Network/SocketDefines.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SOCKETDEFINES_H
+#define TRINITY_SOCKETDEFINES_H
+
+#ifdef WIN32
+
+/* Windows socket definitions
+ */
+#define FD_SETSIZE 1024
+#include <winsock2.h>
+#include <Ws2tcpip.h>
+
+typedef SOCKET SocketHandle;
+typedef fd_set SelectSet;
+
+#else
+
+/* The unix socket definitions
+ */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#ifdef __APPLE_CC__
+#include <sys/select.h>
+#endif
+
+typedef int SocketHandle;
+typedef fd_set SelectSet;
+#endif
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Platform/CompilerDefs.h b/src/server/game/TriniChat/framework/Platform/CompilerDefs.h
new file mode 100644
index 0000000..fb7dbfe
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Platform/CompilerDefs.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_COMPILERDEFS_H
+#define TRINITY_COMPILERDEFS_H
+
+#define PLATFORM_WINDOWS 0
+#define PLATFORM_UNIX    1
+#define PLATFORM_APPLE   2
+#define PLATFORM_INTEL   3
+
+// must be first (win 64 also define WIN32)
+#if defined( _WIN64 )
+#  define PLATFORM PLATFORM_WINDOWS
+#elif defined( __WIN32__ ) || defined( WIN32 ) || defined( _WIN32 )
+#  define PLATFORM PLATFORM_WINDOWS
+#elif defined( __APPLE_CC__ )
+#  define PLATFORM PLATFORM_APPLE
+#elif defined( __INTEL_COMPILER )
+#  define PLATFORM PLATFORM_INTEL
+#else
+#  define PLATFORM PLATFORM_UNIX
+#endif
+
+#define COMPILER_MICROSOFT 0
+#define COMPILER_GNU       1
+#define COMPILER_BORLAND   2
+#define COMPILER_INTEL     3
+
+#ifdef _MSC_VER
+#  define COMPILER COMPILER_MICROSOFT
+#elif defined( __BORLANDC__ )
+#  define COMPILER COMPILER_BORLAND
+#elif defined( __INTEL_COMPILER )
+#  define COMPILER COMPILER_INTEL
+#elif defined( __GNUC__ )
+#  define COMPILER COMPILER_GNU
+#else
+#  pragma error "FATAL ERROR: Unknown compiler."
+#endif
+
+#if COMPILER == COMPILER_MICROSOFT
+#  pragma warning( disable : 4267 )                         // conversion from 'size_t' to 'int', possible loss of data
+#  pragma warning( disable : 4786 )                         // identifier was truncated to '255' characters in the debug information
+#endif
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Platform/Define.h b/src/server/game/TriniChat/framework/Platform/Define.h
new file mode 100644
index 0000000..9285bf2
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Platform/Define.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef TRINITY_DEFINE_H
+#define TRINITY_DEFINE_H
+
+#include <sys/types.h>
+
+#include <ace/Basic_Types.h>
+#include <ace/ACE_export.h>
+
+#include "Platform/CompilerDefs.h"
+
+#define TRINITY_LITTLEENDIAN 0
+#define TRINITY_BIGENDIAN    1
+
+#if !defined(TRINITY_ENDIAN)
+#  if defined (ACE_BIG_ENDIAN)
+#    define TRINITY_ENDIAN TRINITY_BIGENDIAN
+#  else //ACE_BYTE_ORDER != ACE_BIG_ENDIAN
+#    define TRINITY_ENDIAN TRINITY_LITTLEENDIAN
+#  endif //ACE_BYTE_ORDER
+#endif //TRINITY_ENDIAN
+
+#if PLATFORM == PLATFORM_WINDOWS
+#  define TRINITY_PATH_MAX MAX_PATH
+#  ifndef DECLSPEC_NORETURN
+#    define DECLSPEC_NORETURN __declspec(noreturn)
+#  endif //DECLSPEC_NORETURN
+#else //PLATFORM != PLATFORM_WINDOWS
+#  define TRINITY_PATH_MAX PATH_MAX
+#  define DECLSPEC_NORETURN
+#endif //PLATFORM
+
+#if !defined(DEBUG)
+#  define TRINITY_INLINE inline
+#else //DEBUG
+#  if !defined(TRINITY_DEBUG)
+#    define TRINITY_DEBUG
+#  endif //TRINITY_DEBUG
+#  define TRINITY_INLINE
+#endif //!DEBUG
+
+#if COMPILER == COMPILER_GNU
+#  define ATTR_NORETURN __attribute__((noreturn))
+#  define ATTR_PRINTF(F,V) __attribute__ ((format (printf, F, V)))
+#else //COMPILER != COMPILER_GNU
+#  define ATTR_NORETURN
+#  define ATTR_PRINTF(F,V)
+#endif //COMPILER == COMPILER_GNU
+
+typedef ACE_INT64 int64;
+typedef ACE_INT32 int32;
+typedef ACE_INT16 int16;
+typedef ACE_INT8 int8;
+typedef ACE_UINT64 uint64;
+typedef ACE_UINT32 uint32;
+typedef ACE_UINT16 uint16;
+typedef ACE_UINT8 uint8;
+
+#if COMPILER != COMPILER_MICROSOFT
+typedef uint16      WORD;
+typedef uint32      DWORD;
+#endif //COMPILER
+
+typedef uint64 OBJECT_HANDLE;
+
+#endif //TRINITY_DEFINE_H
diff --git a/src/server/game/TriniChat/framework/Policies/CreationPolicy.h b/src/server/game/TriniChat/framework/Policies/CreationPolicy.h
new file mode 100644
index 0000000..c78382e
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/CreationPolicy.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_CREATIONPOLICY_H
+#define TRINITY_CREATIONPOLICY_H
+
+#include <stdlib.h>
+#include "../Platform/Define.h"
+
+namespace Trinity
+{
+    /**
+     * OperatorNew policy creates an object on the heap using new.
+     */
+    template <class T>
+        class OperatorNew
+    {
+        public:
+            static T* Create(void) { return (new T); }
+            static void Destroy(T *obj) { delete obj; }
+    };
+
+    /**
+     * LocalStaticCreation policy creates an object on the stack
+     * the first time call Create.
+     */
+    template <class T>
+        class LocalStaticCreation
+    {
+        union MaxAlign
+        {
+            char t_[sizeof(T)];
+            short int shortInt_;
+            int int_;
+            long int longInt_;
+            float float_;
+            double double_;
+            long double longDouble_;
+            struct Test;
+            int Test::* pMember_;
+            int (Test::*pMemberFn_)(int);
+        };
+        public:
+            static T* Create(void)
+            {
+                static MaxAlign si_localStatic;
+                return new(&si_localStatic) T;
+            }
+
+            static void Destroy(T *obj) { obj->~T(); }
+    };
+
+    /**
+     * CreateUsingMalloc by pass the memory manger.
+     */
+    template<class T>
+        class CreateUsingMalloc
+    {
+        public:
+            static T* Create()
+            {
+                void* p = ::malloc(sizeof(T));
+                if (!p) return 0;
+                return new(p) T;
+            }
+
+            static void Destroy(T* p)
+            {
+                p->~T();
+                ::free(p);
+            }
+    };
+
+    /**
+     * CreateOnCallBack creates the object base on the call back.
+     */
+    template<class T, class CALL_BACK>
+        class CreateOnCallBack
+    {
+        public:
+            static T* Create()
+            {
+                return CALL_BACK::createCallBack();
+            }
+
+            static void Destroy(T *p)
+            {
+                CALL_BACK::destroyCallBack(p);
+            }
+    };
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
new file mode 100644
index 0000000..fd16873
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <cstdlib>
+#include "ObjectLifeTime.h"
+
+namespace Trinity
+{
+    extern "C" void external_wrapper(void *p)
+    {
+        std::atexit( (void (*)())p );
+    }
+
+    void at_exit( void (*func)() )
+    {
+        external_wrapper((void*)func);
+    }
+}
+
diff --git a/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
new file mode 100644
index 0000000..2e9dff7
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_OBJECTLIFETIME_H
+#define TRINITY_OBJECTLIFETIME_H
+
+#include <stdexcept>
+#include "../Platform/Define.h"
+
+typedef void (* Destroyer)(void);
+
+namespace Trinity
+{
+    void at_exit( void (*func)() );
+
+    template <class T>
+        class ObjectLifeTime
+    {
+        public:
+            static void ScheduleCall(void (*destroyer)() )
+            {
+                at_exit( destroyer );
+            }
+
+            DECLSPEC_NORETURN static void OnDeadReference(void) ATTR_NORETURN;
+
+    };
+
+    template <class T>
+        void ObjectLifeTime<T>::OnDeadReference(void)       // We don't handle Dead Reference for now
+    {
+        throw std::runtime_error("Dead Reference");
+    }
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Policies/Singleton.h b/src/server/game/TriniChat/framework/Policies/Singleton.h
new file mode 100644
index 0000000..da89855
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/Singleton.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SINGLETON_H
+#define TRINITY_SINGLETON_H
+
+/**
+ * @brief class Singleton
+ */
+
+#include "CreationPolicy.h"
+#include "ThreadingModel.h"
+#include "ObjectLifeTime.h"
+
+namespace Trinity
+{
+    template
+        <
+        typename T,
+        class ThreadingModel = Trinity::SingleThreaded<T>,
+        class CreatePolicy = Trinity::OperatorNew<T>,
+        class LifeTimePolicy = Trinity::ObjectLifeTime<T>
+        >
+        class Singleton
+    {
+        public:
+            static T& Instance();
+
+        protected:
+            Singleton() {};
+
+        private:
+
+            // Prohibited actions...this does not prevent hijacking.
+            Singleton(const Singleton &);
+            Singleton& operator=(const Singleton &);
+
+            // Singleton Helpers
+            static void DestroySingleton();
+
+            // data structure
+            typedef typename ThreadingModel::Lock Guard;
+            static T *si_instance;
+            static bool si_destroyed;
+    };
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Policies/SingletonImp.h b/src/server/game/TriniChat/framework/Policies/SingletonImp.h
new file mode 100644
index 0000000..3e985cd
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/SingletonImp.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SINGLETONIMPL_H
+#define TRINITY_SINGLETONIMPL_H
+
+#include "Singleton.h"
+
+// avoid the using namespace here cuz
+// its a .h file afterall
+
+template
+<
+typename T,
+class ThreadingModel,
+class CreatePolicy,
+class LifeTimePolicy
+>
+T&
+Trinity::Singleton<T, ThreadingModel, CreatePolicy, LifeTimePolicy >::Instance()
+{
+    if( !si_instance )
+    {
+        // double-checked Locking pattern
+        Guard();
+        if( !si_instance )
+        {
+            if( si_destroyed )
+            {
+                si_destroyed = false;
+                LifeTimePolicy::OnDeadReference();
+            }
+            si_instance = CreatePolicy::Create();
+            LifeTimePolicy::ScheduleCall(&DestroySingleton);
+        }
+    }
+
+    return *si_instance;
+}
+
+template
+<
+typename T,
+class ThreadingModel,
+class CreatePolicy,
+class LifeTimePolicy
+>
+void
+Trinity::Singleton<T, ThreadingModel, CreatePolicy, LifeTimePolicy>::DestroySingleton()
+{
+    CreatePolicy::Destroy(si_instance);
+    si_instance = NULL;
+    si_destroyed = true;
+}
+
+#define INSTANTIATE_SINGLETON_1(TYPE) \
+    template class Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_2(TYPE, THREADINGMODEL) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_3(TYPE, THREADINGMODEL, CREATIONPOLICY ) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeType<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_4(TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >::si_destroyed = false
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Policies/ThreadingModel.h b/src/server/game/TriniChat/framework/Policies/ThreadingModel.h
new file mode 100644
index 0000000..49bb172
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ThreadingModel.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_THREADINGMODEL_H
+#define TRINITY_THREADINGMODEL_H
+
+/**
+ * @class ThreadingModel<T>
+ *
+ */
+
+#include "../Platform/Define.h"
+
+namespace Trinity
+{
+    inline void Guard(void *) {}
+
+    template<typename MUTEX> class GeneralLock
+    {
+        public:
+            GeneralLock(MUTEX &m) : i_mutex(m)
+            {
+                i_mutex.acquire();
+            }
+
+            ~GeneralLock()
+            {
+                i_mutex.release();
+            }
+        private:
+            GeneralLock(const GeneralLock &);
+            GeneralLock& operator=(const GeneralLock &);
+            MUTEX &i_mutex;
+    };
+
+    template <class T>
+        class SingleThreaded
+    {
+        public:
+
+            struct Lock                                     // empty object
+            {
+                Lock() {}
+                Lock(const T &) {}
+                Lock(const SingleThreaded<T> &)             // for single threaded we ignore this
+                {
+                }
+            };
+
+            typedef T VolatileType;
+    };
+
+    // object level lockable
+    template<class T, class MUTEX>
+        class ObjectLevelLockable
+    {
+        public:
+            ObjectLevelLockable() : i_mtx() {}
+
+            friend class Lock;
+
+            class Lock
+            {
+                public:
+                    Lock(ObjectLevelLockable<T, MUTEX> &host) : i_lock(host.i_mtx)
+                    {
+                    }
+
+                private:
+                    GeneralLock<MUTEX> i_lock;
+            };
+
+            typedef volatile T VolatileType;
+
+        private:
+            // prevent the compiler creating a copy construct
+            ObjectLevelLockable(const ObjectLevelLockable<T, MUTEX> &);
+            ObjectLevelLockable<T, MUTEX>& operator=(const ObjectLevelLockable<T, MUTEX> &);
+
+            MUTEX i_mtx;
+    };
+
+    template<class T, class MUTEX>
+        class ClassLevelLockable
+    {
+        public:
+            class Lock;
+            friend class Lock;
+            typedef volatile T VolatileType;
+
+            ClassLevelLockable() {}
+
+            class Lock
+            {
+                public:
+                    Lock(T& /*host*/) { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    Lock(ClassLevelLockable<T, MUTEX> &) { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    Lock() { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    ~Lock() { ClassLevelLockable<T, MUTEX>::si_mtx.release(); }
+            };
+
+        private:
+            static MUTEX si_mtx;
+    };
+
+}
+
+template<class T, class MUTEX> MUTEX Trinity::ClassLevelLockable<T, MUTEX>::si_mtx;
+
+#define INSTANTIATE_CLASS_MUTEX(CTYPE,MUTEX) \
+    template class Trinity::ClassLevelLockable<CTYPE, MUTEX >
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/ByteConverter.h b/src/server/game/TriniChat/framework/Utilities/ByteConverter.h
new file mode 100644
index 0000000..f8b6bd7
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/ByteConverter.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef TRINITY_BYTECONVERTER_H
+#define TRINITY_BYTECONVERTER_H
+
+/** ByteConverter reverse your byte order.  This is use
+    for cross platform where they have different endians.
+ */
+
+#include<Platform/Define.h>
+#include<algorithm>
+
+namespace ByteConverter
+{
+    template<size_t T>
+        inline void convert(char *val)
+    {
+        std::swap(*val, *(val + T - 1));
+        convert<T - 2>(val + 1);
+    }
+
+    template<> inline void convert<0>(char *) {}
+    template<> inline void convert<1>(char *) {}            // ignore central byte
+
+    template<typename T> inline void apply(T *val)
+    {
+        convert<sizeof(T)>((char *)(val));
+    }
+}
+
+#if TRINITY_ENDIAN == TRINITY_BIGENDIAN
+template<typename T> inline void EndianConvert(T& val) { ByteConverter::apply<T>(&val); }
+template<typename T> inline void EndianConvertReverse(T&) { }
+#else
+template<typename T> inline void EndianConvert(T&) { }
+template<typename T> inline void EndianConvertReverse(T& val) { ByteConverter::apply<T>(&val); }
+#endif
+
+template<typename T> void EndianConvert(T*);         // will generate link error
+template<typename T> void EndianConvertReverse(T*);  // will generate link error
+
+inline void EndianConvert(uint8&) { }
+inline void EndianConvert( int8&) { }
+inline void EndianConvertReverse(uint8&) { }
+inline void EndianConvertReverse( int8&) { }
+
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/Callback.h b/src/server/game/TriniChat/framework/Utilities/Callback.h
new file mode 100644
index 0000000..d2e2c36
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/Callback.h
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_CALLBACK_H
+#define TRINITY_CALLBACK_H
+
+/// ------------ BASE CLASSES ------------
+
+namespace Trinity
+{
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class _Callback
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2, ParamType3, ParamType4);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            ParamType4 m_param4;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2, m_param3, m_param4); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2), m_param3(param3), m_param4(param4) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4> const& cb)
+                : m_object(cb.object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3), m_param4(cb.m_param4) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2, typename ParamType3 >
+    class _Callback < Class, ParamType1, ParamType2, ParamType3 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2, ParamType3);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2, m_param3); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2, ParamType3 > const& cb)
+                : m_object(cb.object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class _Callback < Class, ParamType1, ParamType2 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2 > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class _Callback < Class, ParamType1 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            void _Execute() { (m_object->*m_method)(m_param1); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1)
+                : m_object(object), m_method(method), m_param1(param1) {}
+            _Callback(_Callback < Class, ParamType1 > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method), m_param1(cb.m_param1) {}
+    };
+
+    template < class Class >
+    class _Callback < Class >
+    {
+        protected:
+            typedef void (Class::*Method)();
+            Class *m_object;
+            Method m_method;
+            void _Execute() { (m_object->*m_method)(); }
+        public:
+            _Callback(Class *object, Method method)
+                : m_object(object), m_method(method) {}
+            _Callback(_Callback < Class > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method) {}
+    };
+
+    /// ---- Statics ----
+
+    template < typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class _SCallback
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2, ParamType3, ParamType4);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            ParamType4 m_param4;
+            void _Execute() { (*m_method)(m_param1, m_param2, m_param3, m_param4); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : m_method(method), m_param1(param1), m_param2(param2), m_param3(param3), m_param4(param4) {}
+            _SCallback(_SCallback < ParamType1, ParamType2, ParamType3, ParamType4> const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3), m_param4(cb.m_param4) {}
+    };
+
+    template < typename ParamType1, typename ParamType2, typename ParamType3 >
+    class _SCallback < ParamType1, ParamType2, ParamType3 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2, ParamType3);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            void _Execute() { (*m_method)(m_param1, m_param2, m_param3); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : m_method(method), m_param1(param1), m_param2(param2), m_param3(param3) {}
+            _SCallback(_SCallback < ParamType1, ParamType2, ParamType3 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3) {}
+    };
+
+    template < typename ParamType1, typename ParamType2 >
+    class _SCallback < ParamType1, ParamType2 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            void _Execute() { (*m_method)(m_param1, m_param2); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2)
+                : m_method(method), m_param1(param1), m_param2(param2) {}
+            _SCallback(_SCallback < ParamType1, ParamType2 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2) {}
+    };
+
+    template < typename ParamType1 >
+    class _SCallback < ParamType1 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1);
+            Method m_method;
+            ParamType1 m_param1;
+            void _Execute() { (*m_method)(m_param1); }
+        public:
+            _SCallback(Method method, ParamType1 param1)
+                : m_method(method), m_param1(param1) {}
+            _SCallback(_SCallback < ParamType1 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1) {}
+    };
+
+    template < >
+    class _SCallback < >
+    {
+        protected:
+            typedef void (*Method)();
+            Method m_method;
+            void _Execute() { (*m_method)(); }
+        public:
+            _SCallback(Method method)
+                : m_method(method) {}
+            _SCallback(_SCallback <> const& cb)
+                : m_method(cb.m_method) {}
+    };
+}
+
+/// --------- GENERIC CALLBACKS ----------
+
+namespace Trinity
+{
+    class ICallback
+    {
+        public:
+            virtual void Execute() = 0;
+            virtual ~ICallback() {}
+    };
+
+    template < class CB >
+    class _ICallback : public CB, public ICallback
+    {
+        public:
+            _ICallback(CB const& cb) : CB(cb) {}
+            void Execute() { CB::_Execute(); }
+    };
+
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class Callback :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4 > C4;
+        public:
+            Callback(Class *object, typename C4::Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : _ICallback< C4 >(C4(object, method, param1, param2, param3, param4)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2, typename ParamType3 >
+    class Callback < Class, ParamType1, ParamType2, ParamType3 > :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2, ParamType3 > C3;
+        public:
+            Callback(Class *object, typename C3::Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _ICallback< C3 >(C3(object, method, param1, param2, param3)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class Callback < Class, ParamType1, ParamType2 > :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2 > C2;
+        public:
+            Callback(Class *object, typename C2::Method method, ParamType1 param1, ParamType2 param2)
+                : _ICallback< C2 >(C2(object, method, param1, param2)) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class Callback < Class, ParamType1 > :
+        public _ICallback< _Callback < Class, ParamType1 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1 > C1;
+        public:
+            Callback(Class *object, typename C1::Method method, ParamType1 param1)
+                : _ICallback< C1 >(C1(object, method, param1)) {}
+    };
+
+    template < class Class >
+    class Callback < Class > : public _ICallback< _Callback < Class > >
+    {
+        private:
+            typedef _Callback < Class > C0;
+        public:
+            Callback(Class *object, typename C0::Method method)
+                : _ICallback< C0 >(C0(object, method)) {}
+    };
+}
+
+/// ---------- QUERY CALLBACKS -----------
+
+#include "QueryResult.h"
+class QueryResult;
+
+namespace Trinity
+{
+    class IQueryCallback
+    {
+        public:
+            virtual void Execute() = 0;
+            virtual ~IQueryCallback() {}
+            virtual void SetResult(QueryResult_AutoPtr result) = 0;
+            virtual QueryResult_AutoPtr GetResult() = 0;
+    };
+
+    template < class CB >
+    class _IQueryCallback : public CB, public IQueryCallback
+    {
+        public:
+            _IQueryCallback(CB const& cb) : CB(cb) {}
+            void Execute() { CB::_Execute(); }
+            void SetResult(QueryResult_AutoPtr result) { CB::m_param1 = result; }
+            QueryResult_AutoPtr GetResult() { return CB::m_param1; }
+    };
+
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void >
+    class QueryCallback :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > QC3;
+        public:
+            QueryCallback(Class *object, typename QC3::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _IQueryCallback< QC3 >(QC3(object, method, result, param1, param2, param3)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class QueryCallback < Class, ParamType1, ParamType2 > :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2 > QC2;
+        public:
+            QueryCallback(Class *object, typename QC2::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2)
+                : _IQueryCallback< QC2 >(QC2(object, method, result, param1, param2)) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class QueryCallback < Class, ParamType1 > :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1 > QC1;
+        public:
+            QueryCallback(Class *object, typename QC1::Method method, QueryResult_AutoPtr result, ParamType1 param1)
+                : _IQueryCallback< QC1 >(QC1(object, method, result, param1)) {}
+    };
+
+    template < class Class >
+    class QueryCallback < Class > : public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr > QC0;
+        public:
+            QueryCallback(Class *object, typename QC0::Method method, QueryResult_AutoPtr result)
+                : _IQueryCallback< QC0 >(QC0(object, method, result)) {}
+    };
+
+    /// ---- Statics ----
+
+    template < typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void >
+    class SQueryCallback :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > QC3;
+        public:
+            SQueryCallback(typename QC3::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _IQueryCallback< QC3 >(QC3(method, result, param1, param2, param3)) {}
+    };
+
+    template < typename ParamType1, typename ParamType2 >
+    class SQueryCallback < ParamType1, ParamType2 > :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2 > QC2;
+        public:
+            SQueryCallback(typename QC2::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2)
+                : _IQueryCallback< QC2 >(QC2(method, result, param1, param2)) {}
+    };
+
+    template < typename ParamType1 >
+    class SQueryCallback < ParamType1 > :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1 > QC1;
+        public:
+            SQueryCallback(typename QC1::Method method, QueryResult_AutoPtr result, ParamType1 param1)
+                : _IQueryCallback< QC1 >(QC1(method, result, param1)) {}
+    };
+
+    template < >
+    class SQueryCallback < > : public _IQueryCallback< _SCallback < QueryResult_AutoPtr > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr > QC0;
+        public:
+            SQueryCallback(QC0::Method method, QueryResult_AutoPtr result)
+                : _IQueryCallback< QC0 >(QC0(method, result)) {}
+    };
+}
+
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
new file mode 100644
index 0000000..d3cfe55
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef  TRINITY_REFERENCE_H
+#define  TRINITY_REFERENCE_H
+
+/**
+ * Referencer<T>
+ * Referencer is an object that holds a reference holder that  hold a reference
+ * counted object.  When an object's reference count drop to zero, it removes
+ * the object.  This is a non intrusive mechanism and any object at any point
+ * in time can be referenced.  When and object is reference counted, do not
+ * pass the object directly to other methods but rather, pass its
+ * reference around.  Objects can be reference counted in both single threaded
+ * model and multi-threaded model
+ */
+
+#include <stdexcept>
+#include "Platform/Define.h"
+#include "Policies/ThreadingModel.h"
+#include "ReferenceHolder.h"
+
+template
+<
+typename T,
+class THREADING_MODEL = Trinity::SingleThreaded<T>
+>
+class Referencer
+{
+    typedef typename THREADING_MODEL::Lock Lock;
+    typedef ReferenceHolder<T, THREADING_MODEL> ReferenceeHolder;
+    public:
+
+        /// Constructs a referencer.
+        Referencer(T *ref = NULL);
+
+        /// Copy constructor
+        Referencer(const Referencer &obj) : i_holder(NULL) { *this = obj; }
+
+        /// Destructor
+        ~Referencer();
+
+        /// Referencee accessor
+        T* referencee(void) { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        const T* referencee(void) const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        //T& referencee(void){ return _referencee(); }
+        //const T& referencee(void) const { return const_cast<Referencer *>(this)->_referencee(); }
+        operator T&(void) { return _referencee(); }
+        operator const T&(void) const { return *const_cast<Referencer *>(this)->_referencee(); }
+
+        /// cast operators
+        T* operator*() { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        T const * operator*() const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        /// overload operators
+        T* operator->() { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        const T * operator->() const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        /// operator =
+        Referencer& operator=(const Referencer &obj);
+        Referencer& operator=(T *);
+
+        /// returns true if i_referencee is null
+        bool isNull(void) const { return i_holder == NULL; }
+
+    private:
+
+        T& _referencee(void)
+        {
+            if( i_holder == NULL )
+                throw std::runtime_error("Invalid access to null pointer");
+            return *i_holder->i_referencee;
+        }
+
+        void deReference(ReferenceeHolder *);
+        void addReference(ReferenceeHolder *);
+
+        // private data
+        ReferenceeHolder *i_holder;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
new file mode 100644
index 0000000..597e985
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_REFERENCEHOLDER_H
+#define TRINITY_REFERENCEHOLDER_H
+
+/** ReferenceHolder holds the actualy referenced obejct as well the refence
+    count.  The ReferenecHolder implements as a policy base object and
+    will decided by the Reference class to be consnsitent.
+ */
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+struct ReferenceHolder : public THREADING_MODEL
+{
+    explicit ReferenceHolder(T *ref) : i_referencee(ref), i_referenceCount(0) {}
+    T *i_referencee;
+    unsigned int i_referenceCount;
+    typedef typename THREADING_MODEL::Lock Lock;
+};
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
new file mode 100644
index 0000000..cde3301
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_REFERENCEIMPL_H
+#define TRINITY_REFERENCEIMPL_H
+
+#include "Reference.h"
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>::Referencer(T *ref)
+: i_holder(NULL)
+{
+    if( ref != NULL )
+    {
+        i_holder = new ReferenceeHolder(ref);
+        ++i_holder->i_referenceCount;
+    }
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>::~Referencer()
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    i_holder = NULL;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>&
+Referencer<T, THREADING_MODEL>::operator=(const Referencer<T, THREADING_MODEL> &obj)
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    if( obj.i_holder != NULL )
+        addReference(obj.i_holder);
+    i_holder = obj.i_holder;
+    return *this;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>&
+Referencer<T, THREADING_MODEL>::operator=(T *ref)
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    i_holder = NULL;
+    if( ref != NULL )
+    {
+        i_holder = new ReferenceeHolder(ref);
+        ++i_holder->i_referenceCount;
+    }
+
+    return *this;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+void
+Referencer<T, THREADING_MODEL>::deReference(ReferenceHolder<T, THREADING_MODEL> *holder)
+{
+    assert( holder != NULL && holder->i_referenceCount > 0);
+    bool delete_object = false;
+
+    {
+        // The guard is within the scope due to the guard
+        // must release earlier than expected.
+        Lock guard(*holder);
+        Guard(&guard);
+
+        --holder->i_referenceCount;
+        if( holder->i_referenceCount == 0 )
+            delete_object = true;
+    }
+
+    if( delete_object )
+    {
+        delete holder->i_referencee;
+        delete holder;
+    }
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+void
+Referencer<T, THREADING_MODEL>::addReference(ReferenceHolder<T, THREADING_MODEL> *holder)
+{
+    assert( i_holder != NULL );
+    Lock guard(*holder);
+    Guard(&guard);
+
+    ++holder->i_referenceCount;
+}
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedList.h b/src/server/game/TriniChat/framework/Utilities/LinkedList.h
new file mode 100644
index 0000000..b266877
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedList.h
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _LINKEDLIST
+#define _LINKEDLIST
+
+#include "Common.h"
+
+//============================================
+class LinkedListHead;
+
+class LinkedListElement
+{
+    private:
+        friend class LinkedListHead;
+
+        LinkedListElement* iNext;
+        LinkedListElement* iPrev;
+    public:
+        LinkedListElement() { iNext = NULL; iPrev = NULL; }
+        ~LinkedListElement() { delink(); }
+
+        bool hasNext() const { return(iNext && iNext->iNext != NULL); }
+        bool hasPrev() const { return(iPrev && iPrev->iPrev != NULL); }
+        bool isInList() const { return(iNext != NULL && iPrev != NULL); }
+
+        LinkedListElement      * next()       { return hasNext() ? iNext : NULL; }
+        LinkedListElement const* next() const { return hasNext() ? iNext : NULL; }
+        LinkedListElement      * prev()       { return hasPrev() ? iPrev : NULL; }
+        LinkedListElement const* prev() const { return hasPrev() ? iPrev : NULL; }
+
+        LinkedListElement      * nocheck_next()       { return iNext; }
+        LinkedListElement const* nocheck_next() const { return iNext; }
+        LinkedListElement      * nocheck_prev()       { return iPrev; }
+        LinkedListElement const* nocheck_prev() const { return iPrev; }
+
+        void delink()
+        {
+            if(isInList())
+            {
+                iNext->iPrev = iPrev; iPrev->iNext = iNext; iNext = NULL; iPrev = NULL;
+            }
+        }
+
+        void insertBefore(LinkedListElement* pElem)
+        {
+            pElem->iNext = this;
+            pElem->iPrev = iPrev;
+            iPrev->iNext = pElem;
+            iPrev = pElem;
+        }
+
+        void insertAfter(LinkedListElement* pElem)
+        {
+            pElem->iPrev = this;
+            pElem->iNext = iNext;
+            iNext->iPrev = pElem;
+            iNext = pElem;
+        }
+};
+
+//============================================
+
+class LinkedListHead
+{
+    private:
+        LinkedListElement iFirst;
+        LinkedListElement iLast;
+        uint32 iSize;
+    public:
+        LinkedListHead()
+        {
+            // create empty list
+
+            iFirst.iNext = &iLast;
+            iLast.iPrev = &iFirst;
+            iSize = 0;
+        }
+
+        bool isEmpty() const { return(!iFirst.iNext->isInList()); }
+
+        LinkedListElement      * getFirst()       { return(isEmpty() ? NULL : iFirst.iNext); }
+        LinkedListElement const* getFirst() const { return(isEmpty() ? NULL : iFirst.iNext); }
+
+        LinkedListElement      * getLast() { return(isEmpty() ? NULL : iLast.iPrev); }
+        LinkedListElement const* getLast() const  { return(isEmpty() ? NULL : iLast.iPrev); }
+
+        void insertFirst(LinkedListElement* pElem)
+        {
+            iFirst.insertAfter(pElem);
+        }
+
+        void insertLast(LinkedListElement* pElem)
+        {
+            iLast.insertBefore(pElem);
+        }
+
+        uint32 getSize() const
+        {
+            if(!iSize)
+            {
+                uint32 result = 0;
+                LinkedListElement const* e = getFirst();
+                while(e)
+                {
+                    ++result;
+                    e = e->next();
+                }
+                return result;
+            }
+            else
+                return iSize;
+        }
+
+        void incSize() { ++iSize; }
+        void decSize() { --iSize; }
+
+        template<class _Ty>
+            class Iterator
+        {
+            public:
+                typedef std::bidirectional_iterator_tag     iterator_category;
+                typedef _Ty                                 value_type;
+                typedef ptrdiff_t                           difference_type;
+                typedef ptrdiff_t                           distance_type;
+                typedef _Ty*                                pointer;
+                typedef _Ty const*                          const_pointer;
+                typedef _Ty&                                reference;
+                typedef _Ty const &                         const_reference;
+
+                Iterator() : _Ptr(0)
+                {                                           // construct with null node pointer
+                }
+
+                Iterator(pointer _Pnode) : _Ptr(_Pnode)
+                {                                           // construct with node pointer _Pnode
+                }
+
+                Iterator& operator=(Iterator const &_Right)
+                {
+                    return (*this) = _Right._Ptr;
+                }
+
+                Iterator& operator=(const_pointer const &_Right)
+                {
+                    _Ptr = (pointer)_Right;
+                    return (*this);
+                }
+
+                reference operator*()
+                {                                           // return designated value
+                    return *_Ptr;
+                }
+
+                pointer operator->()
+                {                                           // return pointer to class object
+                    return _Ptr;
+                }
+
+                Iterator& operator++()
+                {                                           // preincrement
+                    _Ptr = _Ptr->next();
+                    return (*this);
+                }
+
+                Iterator operator++(int)
+                {                                           // postincrement
+                    iterator _Tmp = *this;
+                    ++*this;
+                    return (_Tmp);
+                }
+
+                Iterator& operator--()
+                {                                           // predecrement
+                    _Ptr = _Ptr->prev();
+                    return (*this);
+                }
+
+                Iterator operator--(int)
+                {                                           // postdecrement
+                    iterator _Tmp = *this;
+                    --*this;
+                    return (_Tmp);
+                }
+
+                bool operator==(Iterator const &_Right) const
+                {                                           // test for iterator equality
+                    return (_Ptr == _Right._Ptr);
+                }
+
+                bool operator!=(Iterator const &_Right) const
+                {                                           // test for iterator inequality
+                    return (!(*this == _Right));
+                }
+
+                bool operator==(pointer const &_Right) const
+                {                                           // test for pointer equality
+                    return (_Ptr != _Right);
+                }
+
+                bool operator!=(pointer const &_Right) const
+                {                                           // test for pointer equality
+                    return (!(*this == _Right));
+                }
+
+                bool operator==(const_reference _Right) const
+                {                                           // test for reference equality
+                    return (_Ptr == &_Right);
+                }
+
+                bool operator!=(const_reference _Right) const
+                {                                           // test for reference equality
+                    return (_Ptr != &_Right);
+                }
+
+                pointer _Mynode()
+                {                                           // return node pointer
+                    return (_Ptr);
+                }
+
+            protected:
+                pointer _Ptr;                               // pointer to node
+        };
+
+        typedef Iterator<LinkedListElement> iterator;
+};
+
+//============================================
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h b/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
new file mode 100644
index 0000000..4a1545f
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _REFERENCE_H
+#define _REFERENCE_H
+
+#include "Utilities/LinkedList.h"
+
+//=====================================================
+
+template <class TO, class FROM> class Reference : public LinkedListElement
+{
+    private:
+        TO* iRefTo;
+        FROM* iRefFrom;
+    protected:
+        // Tell our refTo (target) object that we have a link
+        virtual void targetObjectBuildLink() = 0;
+
+        // Tell our refTo (taget) object, that the link is cut
+        virtual void targetObjectDestroyLink() = 0;
+
+        // Tell our refFrom (source) object, that the link is cut (Target destroyed)
+        virtual void sourceObjectDestroyLink() = 0;
+    public:
+        Reference() { iRefTo = NULL; iRefFrom = NULL; }
+        virtual ~Reference() {}
+
+        // Create new link
+        void link(TO* toObj, FROM* fromObj)
+        {
+            assert(fromObj);                                // fromObj MUST not be NULL
+            if(isValid())
+                unlink();
+            if(toObj != NULL)
+            {
+                iRefTo = toObj;
+                iRefFrom = fromObj;
+                targetObjectBuildLink();
+            }
+        }
+
+        // We don't need the reference anymore. Call comes from the refFrom object
+        // Tell our refTo object, that the link is cut
+        void unlink() { targetObjectDestroyLink(); delink(); iRefTo = NULL; iRefFrom = NULL; }
+
+        // Link is invalid due to destruction of referenced target object. Call comes from the refTo object
+        // Tell our refFrom object, that the link is cut
+        void invalidate()                                   // the iRefFrom MUST remain!!
+        {
+            sourceObjectDestroyLink(); delink(); iRefTo = NULL;
+        }
+
+        bool isValid() const                                // Only check the iRefTo
+        {
+            return iRefTo != NULL;
+        }
+
+        Reference<TO,FROM>       * next()       { return((Reference<TO,FROM>       *) LinkedListElement::next()); }
+        Reference<TO,FROM> const * next() const { return((Reference<TO,FROM> const *) LinkedListElement::next()); }
+        Reference<TO,FROM>       * prev()       { return((Reference<TO,FROM>       *) LinkedListElement::prev()); }
+        Reference<TO,FROM> const * prev() const { return((Reference<TO,FROM> const *) LinkedListElement::prev()); }
+
+        Reference<TO,FROM>       * nocheck_next()       { return((Reference<TO,FROM>       *) LinkedListElement::nocheck_next()); }
+        Reference<TO,FROM> const * nocheck_next() const { return((Reference<TO,FROM> const *) LinkedListElement::nocheck_next()); }
+        Reference<TO,FROM>       * nocheck_prev()       { return((Reference<TO,FROM>       *) LinkedListElement::nocheck_prev()); }
+        Reference<TO,FROM> const * nocheck_prev() const { return((Reference<TO,FROM> const *) LinkedListElement::nocheck_prev()); }
+
+        TO* operator ->() const { return iRefTo; }
+        TO* getTarget() const { return iRefTo; }
+
+        FROM* getSource() const { return iRefFrom; }
+};
+
+//=====================================================
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h b/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
new file mode 100644
index 0000000..7e294b4
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _REFMANAGER_H
+#define _REFMANAGER_H
+//=====================================================
+
+#include "Utilities/LinkedList.h"
+#include "Utilities/LinkedReference/Reference.h"
+
+template <class TO, class FROM> class RefManager : public LinkedListHead
+{
+    public:
+        typedef LinkedListHead::Iterator< Reference<TO, FROM> > iterator;
+        RefManager() { }
+        virtual ~RefManager() { clearReferences(); }
+
+        Reference<TO, FROM>* getFirst() { return ((Reference<TO, FROM>*) LinkedListHead::getFirst()); }
+        Reference<TO, FROM> const* getFirst() const { return ((Reference<TO, FROM> const*) LinkedListHead::getFirst()); }
+        Reference<TO, FROM>* getLast() { return ((Reference<TO, FROM>*) LinkedListHead::getLast()); }
+        Reference<TO, FROM> const* getLast() const { return ((Reference<TO, FROM> const*) LinkedListHead::getLast()); }
+
+        iterator begin() { return iterator(getFirst()); }
+        iterator end() { return iterator(NULL); }
+        iterator rbegin() { return iterator(getLast()); }
+        iterator rend() { return iterator(NULL); }
+
+        void clearReferences()
+        {
+            LinkedListElement* ref;
+            while((ref = getFirst()) != NULL)
+            {
+                ((Reference<TO, FROM>*) ref)->invalidate();
+                ref->delink();                              // the delink might be already done by invalidate(), but doing it here again does not hurt and insures an empty list
+            }
+        }
+};
+
+//=====================================================
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/TypeList.h b/src/server/game/TriniChat/framework/Utilities/TypeList.h
new file mode 100644
index 0000000..02bc080
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/TypeList.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPELIST_H
+#define TRINITY_TYPELIST_H
+
+/*
+  @struct TypeList
+  TypeList is the most simple but yet the most powerfull class of all.  It holds
+  at compile time the different type of objects in a linked list.
+ */
+
+class TypeNull;
+
+template<typename HEAD, typename TAIL>
+struct TypeList
+{
+    typedef HEAD Head;
+    typedef TAIL Tail;
+};
+
+// enough for now.. can be expand at any point in time as needed
+#define TYPELIST_1(T1)                  TypeList<T1,TypeNull>
+#define TYPELIST_2(T1, T2)              TypeList<T1, TYPELIST_1(T2) >
+#define TYPELIST_3(T1, T2, T3)          TypeList<T1, TYPELIST_2(T2, T3) >
+#define TYPELIST_4(T1, T2, T3, T4)      TypeList<T1, TYPELIST_3(T2, T3, T4) >
+#define TYPELIST_5(T1, T2, T3, T4, T5)  TypeList<T1, TYPELIST_4(T2, T3, T4, T5) >
+#endif
+
diff --git a/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h b/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
new file mode 100644
index 0000000..fce5ec8
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_UNORDERED_MAP_H
+#define TRINITY_UNORDERED_MAP_H
+
+#include "Platform/CompilerDefs.h"
+#include "Platform/Define.h"
+
+#if COMPILER == COMPILER_INTEL
+#include <ext/hash_map>
+#elif COMPILER == COMPILER_GNU && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+#include <tr1/unordered_map>
+#elif COMPILER == COMPILER_GNU && __GNUC__ >= 3
+#include <ext/hash_map>
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1500 && _HAS_TR1    // VC9.0 and later
+#include <unordered_map>
+#else
+#include <hash_map>
+#endif
+
+#ifdef _STLPORT_VERSION
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1500 && _HAS_TR1
+#define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1300
+#define UNORDERED_MAP stdext::hash_map
+using stdext::hash_map;
+#elif COMPILER == COMPILER_INTEL
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#elif COMPILER == COMPILER_GNU && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+#define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_GNU && __GNUC__ >= 3
+#define UNORDERED_MAP __gnu_cxx::hash_map
+
+namespace __gnu_cxx
+{
+    template<> struct hash<unsigned long long>
+    {
+        size_t operator()(const unsigned long long &__x) const { return (size_t)__x; }
+    };
+    template<typename T> struct hash<T *>
+    {
+        size_t operator()(T * const &__x) const { return (size_t)__x; }
+    };
+
+};
+
+#else
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#endif
+#endif
+
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index d2a4323..c9c1931 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -74,6 +74,9 @@
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
+#include "IRCClient.h"
+#include "AuctionHouseBot.h"
+#include "OutdoorPvPWG.h"
 
 volatile bool World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -457,9 +460,13 @@ void World::LoadConfigSettings(bool reload)
     rate_values[RATE_DROP_ITEM_REFERENCED] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
     rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
     rate_values[RATE_DROP_MONEY]  = ConfigMgr::GetFloatDefault("Rate.Drop.Money", 1.0f);
-    rate_values[RATE_XP_KILL]     = ConfigMgr::GetFloatDefault("Rate.XP.Kill", 1.0f);
-    rate_values[RATE_XP_QUEST]    = ConfigMgr::GetFloatDefault("Rate.XP.Quest", 1.0f);
-    rate_values[RATE_XP_EXPLORE]  = ConfigMgr::GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_KILL]            = ConfigMgr::GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_KILL_PREMIUM]    = ConfigMgr::GetFloatDefault("Rate.XP.Kill.Premium", 1.0f);
+    rate_values[RATE_XP_QUEST]           = ConfigMgr::GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_QUEST_PREMIUM]   = ConfigMgr::GetFloatDefault("Rate.XP.Quest.Premium", 1.0f);
+    rate_values[RATE_XP_EXPLORE]         = ConfigMgr::GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_EXPLORE_PREMIUM] = ConfigMgr::GetFloatDefault("Rate.XP.Explore.Premium", 1.0f);
+
     rate_values[RATE_REPAIRCOST]  = ConfigMgr::GetFloatDefault("Rate.RepairCost", 1.0f);
     if (rate_values[RATE_REPAIRCOST] < 0.0f)
     {
@@ -664,6 +671,7 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_WHO_LIST]            = ConfigMgr::GetBoolDefault("AllowTwoSide.WhoList", false);
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND]          = ConfigMgr::GetBoolDefault("AllowTwoSide.AddFriend", false);
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = ConfigMgr::GetBoolDefault("AllowTwoSide.trade", false);
+    m_bool_configs[CONFIG_FAKE_WHO_LIST]					  = ConfigMgr::GetBoolDefault("Fake.WHO.List", false);
     m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = ConfigMgr::GetIntDefault ("StrictPlayerNames",  0);
     m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = ConfigMgr::GetIntDefault ("StrictCharterNames", 0);
     m_int_configs[CONFIG_STRICT_PET_NAMES]                    = ConfigMgr::GetIntDefault ("StrictPetNames",     0);
@@ -732,13 +740,13 @@ void World::LoadConfigSettings(bool reload)
     }
     else
         m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
-
+/* Removed to allow XP gain after level 100. By LordPsyan
     if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
     {
         sLog->outError("MaxPlayerLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_MAX_PLAYER_LEVEL], MAX_LEVEL, MAX_LEVEL);
         m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
     }
-
+*/
     m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = ConfigMgr::GetIntDefault("MinDualSpecLevel", 40);
 
     m_int_configs[CONFIG_START_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("StartPlayerLevel", 1);
@@ -1184,12 +1192,187 @@ void World::LoadConfigSettings(bool reload)
 
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = ConfigMgr::GetIntDefault("MaxPingTime", 30);
+	
+    //Wintergrasp
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED]         = ConfigMgr::GetBoolDefault("OutdoorPvP.Wintergrasp.Enabled", true);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD] = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.SaveState.Period", 10000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME]       = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.StartTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME]      = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.BattleTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL]         = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.Interval", 150);
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR]    = ConfigMgr::GetBoolDefault("OutdoorPvP.Wintergrasp.CustomHonorRewards", false);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE]       = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleWin", 3000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE]      = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleLose", 1250);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER]    = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamageTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER]  = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING] = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING]  = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding", 1500);
+    m_bool_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE]  = ConfigMgr::GetBoolDefault("OutdoorPvP.Wintergrasp.Antifarm.Enable", false);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK]  = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Atk", 5);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF]  = ConfigMgr::GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Def", 5);
 
     // misc
     m_bool_configs[CONFIG_PDUMP_NO_PATHS] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowPaths", true);
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowOverwrite", true);
 
-    sScriptMgr->OnConfigLoad(reload);
+    sScriptMgr->OnConfigLoad(reload);  
+
+    // IRC Configurations.
+
+
+    int ConfCnt = 0;
+    sIRC._chan_count = 0;
+    if (ConfigMgr::GetIntDefault("irc.active", 1) == 1)
+        sIRC.Active = true;
+    else
+        sIRC.Active = false;
+
+    sIRC._Host = ConfigMgr::GetStringDefault("irc.host", "irc.freenode.net");
+    if (sIRC._Host.size() > 0)
+        ConfCnt++;
+    sIRC._Mver = "Version 3.0.0";
+    sIRC._Port = ConfigMgr::GetIntDefault("irc.port", 6667);
+    sIRC._User = ConfigMgr::GetStringDefault("irc.user", "TriniChat");
+    sIRC._Pass = ConfigMgr::GetStringDefault("irc.pass", "Services Password");
+    sIRC._Nick = ConfigMgr::GetStringDefault("irc.nick", "TriniChat");
+    sIRC._Auth = ConfigMgr::GetIntDefault("irc.auth", 0);
+    sIRC._Auth_Nick = ConfigMgr::GetStringDefault("irc.auth.nick", "AuthNick");
+    sIRC._ICC = ConfigMgr::GetStringDefault("irc.icc", "001");
+    sIRC._defchan = ConfigMgr::GetStringDefault("irc.defchan", "lobby");
+    sIRC._ldefc = ConfigMgr::GetIntDefault("irc.ldef", 0);
+    sIRC._wct = ConfigMgr::GetIntDefault("irc.wct", 30000);
+    sIRC.ajoin = ConfigMgr::GetIntDefault("irc.ajoin", 1);
+    sIRC.ajchan = ConfigMgr::GetStringDefault("irc.ajchan", "world");
+    sIRC.onlrslt = ConfigMgr::GetIntDefault("irc.online.result", 10);
+    sIRC.BOTMASK = ConfigMgr::GetIntDefault("Botmask", 0);
+    sIRC.logfile = ConfigMgr::GetStringDefault("irc.logfile.prefix", "IRC_");
+    sIRC.logmask = ConfigMgr::GetIntDefault("irc.logmask", 0);
+    sIRC.logchan = ConfigMgr::GetStringDefault("irc.logchannel","");
+    sIRC.logchanpw = ConfigMgr::GetStringDefault("irc.logchannelpassword","");
+    for (int i = 1; i < MAX_CONF_CHANNELS;i++)
+    {
+        std::ostringstream ss;
+        ss << i;
+        std::string ci = "irc.chan_" + ss.str();
+        std::string pw = "irc.pass_" + ss.str();
+        std::string t_chan = ConfigMgr::GetStringDefault(ci.c_str(), "");
+        if (t_chan.size() > 0)
+        {
+            sIRC._chan_count++;
+            sIRC._irc_chan[sIRC._chan_count] = t_chan;
+            sIRC._irc_pass[sIRC._chan_count] = ConfigMgr::GetStringDefault(pw.c_str(), t_chan.c_str());
+            ci = "wow.chan_" + ss.str();
+            sIRC._wow_chan[sIRC._chan_count] = ConfigMgr::GetStringDefault(ci.c_str(), t_chan.c_str());
+        }
+    }
+    sIRC.JoinMsg = ConfigMgr::GetStringDefault("irc.joinmsg", "TriniChat2 $Ver for Trinitycore 3.3.x Maintained by SPGM of Trinitycore http://code.google.com/p/spgm-trinity/");
+    sIRC.RstMsg  = ConfigMgr::GetStringDefault("irc.rstmsg", "TriniChat Is Restarting, I Will Be Right Back!");
+    sIRC.kikmsg = ConfigMgr::GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+    // IRC LINES
+    sIRC.ILINES[WOW_IRC] = ConfigMgr::GetStringDefault("chat.wow_irc", "\003<WoW>[\002$Name($Level)\002\003] $Msg");
+    sIRC.ILINES[IRC_WOW] = ConfigMgr::GetStringDefault("chat.irc_wow", "\003<IRC>[$Name]: $Msg");
+    sIRC.ILINES[JOIN_WOW] = ConfigMgr::GetStringDefault("chat.join_wow", "\00312>>\00304 $Name \003Joined The Channel!");
+    sIRC.ILINES[JOIN_IRC] = ConfigMgr::GetStringDefault("chat.join_irc", "\003[$Name]: Has Joined IRC!");
+    sIRC.ILINES[LEAVE_WOW] = ConfigMgr::GetStringDefault("chat.leave_wow", "\00312<<\00304 $Name \003Left The Channel!");
+    sIRC.ILINES[LEAVE_IRC] = ConfigMgr::GetStringDefault("chat.leave_irc", "\003[$Name]: Has Left IRC!");
+    sIRC.ILINES[CHANGE_NICK] = ConfigMgr::GetStringDefault("chat.change_nick", "\003<> $Name Is Now Known As $NewName!");
+    // TriniChat Options
+    sIRC._MCA = ConfigMgr::GetIntDefault("irc.maxattempt", 10);
+    sIRC._autojoinkick = ConfigMgr::GetIntDefault("irc.autojoin_kick", 1);
+    sIRC._cmd_prefx = ConfigMgr::GetStringDefault("irc.command_prefix", ".");
+
+    sIRC._op_gm = ConfigMgr::GetIntDefault("irc.op_gm_login", 0);
+    sIRC._op_gm_lev = ConfigMgr::GetIntDefault("irc.op_gm_level", 3);
+
+    // Misc Options
+    sIRC.games = ConfigMgr::GetIntDefault("irc.fun.games", 0);
+    sIRC.gmlog = ConfigMgr::GetIntDefault("irc.gmlog", 1);
+    sIRC.BOTMASK = ConfigMgr::GetIntDefault("BotMask", 0);
+    sIRC.Status = ConfigMgr::GetIntDefault("irc.StatusChannel", 1);
+    sIRC.anchn = ConfigMgr::GetIntDefault("irc.AnnounceChannel", 1);
+    sIRC.autoanc = ConfigMgr::GetIntDefault("irc.auto.announce", 30);
+    sIRC.ojGM1 = ConfigMgr::GetStringDefault("irc.gm1", "[VIP]");
+    sIRC.ojGM2 = ConfigMgr::GetStringDefault("irc.gm2", "[Donator]");
+    sIRC.ojGM3 = ConfigMgr::GetStringDefault("irc.gm3", "[Bug Tracker]");
+    sIRC.ojGM4 = ConfigMgr::GetStringDefault("irc.gm4", "[Moderator]");
+    sIRC.ojGM5 = ConfigMgr::GetStringDefault("irc.gm5", "[Game Master]");
+    sIRC.ojGM6 = ConfigMgr::GetStringDefault("irc.gm6", "[Admin]");
+    sIRC.ojGM7 = ConfigMgr::GetStringDefault("irc.gm7", "[Developer]");
+    sIRC.ojGM8 = ConfigMgr::GetStringDefault("irc.gm8", "[Owner]");
+    // REQUIRED GM LEVEL
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `irc_commands` ORDER BY `Command`");
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            //TODO: ELSEIF? STRCMP?
+            std::string command = fields[0].GetCString();
+            uint32 gmlvl = fields[1].GetUInt32();
+            if (command == "acct") sIRC.CACCT = gmlvl;
+            if (command == "ban") sIRC.CBAN = gmlvl;
+            if (command == "char") sIRC.CCHAN = gmlvl;
+            if (command == "char") sIRC.CCHAR = gmlvl;
+            if (command == "fun") sIRC.CFUN = gmlvl;
+            if (command == "help") sIRC.CHELP = gmlvl;
+            if (command == "inchan") sIRC.CINCHAN = gmlvl;
+            if (command == "info") sIRC.CINFO = gmlvl;
+            if (command == "item") sIRC.CITEM = gmlvl;
+            if (command == "jail") sIRC.CJAIL = gmlvl;
+            if (command == "kick") sIRC.CKICK = gmlvl;
+            if (command == "kill") sIRC._KILL = gmlvl;
+            if (command == "level") sIRC.CLEVEL = gmlvl;
+            if (command == "lookup") sIRC.CLOOKUP = gmlvl;
+            if (command == "money") sIRC.CMONEY = gmlvl;
+            if (command == "mute") sIRC.CMUTE = gmlvl;
+            if (command == "online") sIRC.CONLINE = gmlvl;
+            if (command == "pm") sIRC.CPM = gmlvl;
+            if (command == "reconnect") sIRC.CRECONNECT = gmlvl;
+            if (command == "reload") sIRC.CRELOAD = gmlvl;
+            if (command == "restart") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "revive") sIRC.CREVIVE = gmlvl;
+            if (command == "saveall") sIRC.CSAVEALL = gmlvl;
+            if (command == "server") sIRC.CSERVERCMD = gmlvl;
+            if (command == "shutdown") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "spell") sIRC.CSPELL = gmlvl;
+            if (command == "sysmsg") sIRC.CSYSMSG = gmlvl;
+            if (command == "tele") sIRC.CTELE = gmlvl;
+            if (command == "top") sIRC.CTOP = gmlvl;
+            if (command == "who") sIRC.CWHO = gmlvl;
+            result->NextRow();
+        }       
+    }
+    else
+    {
+        sIRC.CACCT     = 3;
+        sIRC.CBAN      = 3;
+        sIRC.CCHAN     = 3;
+        sIRC.CCHAR     = 3;
+        sIRC.CFUN      = 3;
+        sIRC.CHELP     = 3;
+        sIRC.CINCHAN   = 3;
+        sIRC.CINFO     = 3;
+        sIRC.CITEM     = 3;
+        sIRC.CJAIL     = 3;
+        sIRC.CKICK     = 3;
+        sIRC._KILL     = 3;
+        sIRC.CLEVEL    = 3;
+        sIRC.CLOOKUP   = 3;
+        sIRC.CMONEY    = 3;
+        sIRC.CMUTE     = 3;
+        sIRC.CONLINE   = 3;
+        sIRC.CPM       = 3;
+        sIRC.CRECONNECT= 3;
+        sIRC.CRELOAD   = 3;
+        sIRC.CREVIVE   = 3;
+        sIRC.CSAVEALL  = 3;
+        sIRC.CSERVERCMD= 3;
+        sIRC.CSHUTDOWN = 3;
+        sIRC.CSPELL    = 3;
+        sIRC.CSYSMSG   = 3;
+        sIRC.CTELE     = 3;
+        sIRC.CTOP      = 3;
+        sIRC.CWHO      = 3;
+    }
 }
 
 /// Initialize the World
@@ -1203,6 +1386,7 @@ void World::SetInitialWorldSettings()
 
     ///- Initialize config settings
     LoadConfigSettings();
+	sLog->outString("Loading TrinityCore configuration settings...");
 
     ///- Initialize Allowed Security Level
     LoadDBAllowedSecurityLevel();
@@ -1600,6 +1784,10 @@ void World::SetInitialWorldSettings()
     sLog->outString("Returning old mails...");
     sObjectMgr->ReturnOrDeleteOldMails(false);
 
+	// Loads the jail conf out of the database
+    sLog->outString("Loading JailConfing...");    
+    sObjectMgr->LoadJailConf();
+
     sLog->outString("Loading Autobroadcasts...");
     LoadAutobroadcasts();
 
@@ -1654,6 +1842,9 @@ void World::SetInitialWorldSettings()
     LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, startstring, uptime, revision) VALUES('%u', " UI64FMTD ", '%s', 0, '%s')",
                             realmID, uint64(m_startTime), isoDate, _FULLVERSION);       // One-time query
 
+    static uint32 autoanc = 1;
+    autoanc = sIRC.autoanc;
+
     m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
     m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
@@ -1667,6 +1858,8 @@ void World::SetInitialWorldSettings()
 
     m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
 
+	m_timers[WUPDATE_AUTOANC].SetInterval(autoanc*MINUTE*1000);
+
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
     //one second is 1000 -(tested on win system)
@@ -1731,6 +1924,9 @@ void World::SetInitialWorldSettings()
 
     LoadCharacterNameData();
 
+    sLog->outString("Initialize AuctionHouseBot...");
+    auctionbot.Initialize();
+
     // possibly enable db logging; avoid massive startup spam by doing it here.
     if (sLog->GetLogDBLater())
     {
@@ -1897,6 +2093,7 @@ void World::Update(uint32 diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -2016,6 +2213,12 @@ void World::Update(uint32 diff)
         WorldDatabase.KeepAlive();
     }
 
+    if (m_timers[WUPDATE_AUTOANC].Passed())
+    {
+        m_timers[WUPDATE_AUTOANC].Reset();
+        SendRNDBroadcastIRC();
+    }
+
     // update the instance reset times
     sInstanceSaveMgr->Update();
 
@@ -2602,6 +2805,20 @@ void World::SendAutoBroadcast()
     sLog->outDetail("AutoBroadcast: '%s'", msg.c_str());
 }
 
+void World::SendRNDBroadcastIRC()
+{
+    std::string msg;
+    QueryResult result = WorldDatabase.PQuery("SELECT `message` FROM `irc_autoannounce` ORDER BY RAND() LIMIT 1");
+    if (!result)
+        return;
+    msg = result->Fetch()[0].GetString();
+    
+    sWorld->SendWorldText(6612,msg.c_str());
+    std::string ircchan = "#";
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+    sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s", "%s", msg.c_str()), true);
+}
+
 void World::UpdateRealmCharCount(uint32 accountId)
 {
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
@@ -2938,3 +3155,29 @@ CharacterNameData const* World::GetCharacterNameData(uint32 guid) const
     else
         return NULL;
 }
+
+void World::SendWintergraspState()
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+    if (!pvpWG)
+        return;
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+            if (pvpWG->isWarTime())
+            {
+                // "Battle in progress"
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            } else
+                // Time to next battle
+            {
+                pvpWG->SendInitWorldStatesTo(itr->second->GetPlayer());
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+                // Hide unneeded info which in center of screen
+                itr->second->GetPlayer()->SendInitWorldStates(itr->second->GetPlayer()->GetZoneId(), itr->second->GetPlayer()->GetAreaId());
+            }
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 0243837..1afa5c1 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -74,6 +74,7 @@ enum WorldTimers
     WUPDATE_EVENTS,
     WUPDATE_CLEANDB,
     WUPDATE_AUTOBROADCAST,
+	WUPDATE_AUTOANC,
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_DELETECHARS,
     WUPDATE_PINGDB,
@@ -99,6 +100,7 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TWO_SIDE_WHO_LIST,
     CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND,
     CONFIG_ALLOW_TWO_SIDE_TRADE,
+	CONFIG_FAKE_WHO_LIST,
     CONFIG_ALL_TAXI_PATHS,
     CONFIG_INSTANT_TAXI,
     CONFIG_INSTANCE_IGNORE_LEVEL,
@@ -158,6 +160,9 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED,
+    CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE,
     CONFIG_PDUMP_NO_PATHS,
     CONFIG_PDUMP_NO_OVERWRITE,
     BOOL_CONFIG_VALUE_COUNT
@@ -306,6 +311,18 @@ enum WorldIntConfigs
     CONFIG_DB_PING_INTERVAL,
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
+    CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL,
+    CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF,
     CONFIG_MAX_INSTANCES_PER_HOUR,
     INT_CONFIG_VALUE_COUNT
 };
@@ -333,8 +350,11 @@ enum Rates
     RATE_DROP_ITEM_REFERENCED_AMOUNT,
     RATE_DROP_MONEY,
     RATE_XP_KILL,
+    RATE_XP_KILL_PREMIUM,
     RATE_XP_QUEST,
+    RATE_XP_QUEST_PREMIUM,
     RATE_XP_EXPLORE,
+    RATE_XP_EXPLORE_PREMIUM,
     RATE_REPAIRCOST,
     RATE_REPUTATION_GAIN,
     RATE_REPUTATION_LOWLEVEL_KILL,
@@ -534,6 +554,9 @@ class World
         void AddSession(WorldSession* s);
         void SendAutoBroadcast();
         bool RemoveSession(uint32 id);
+
+		void SendRNDBroadcastIRC();
+
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
         const SessionMap& GetAllSessions() const { return m_sessions; }
@@ -746,6 +769,18 @@ class World
 
         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
+		
+        uint32 GetWintergrapsTimer() { return m_WintergrapsTimer; }
+        uint32 GetWintergrapsState() { return m_WintergrapsState; }
+        uint32 m_WintergrapsTimer;
+        uint32 m_WintergrapsState;
+        void SendWintergraspState();
+        void SetWintergrapsTimer(uint32 timer, uint32 state)
+        {
+            m_WintergrapsTimer = timer;
+            m_WintergrapsState = state;
+        }
+
     protected:
         void _UpdateGameTime();
         // callback for UpdateRealmCharacters
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index d34b1b8..5741584 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -31,6 +31,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -123,6 +126,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
diff --git a/src/server/scripts/Commands/cs_gm.cpp b/src/server/scripts/Commands/cs_gm.cpp
index b69f800..38ddc19 100644
--- a/src/server/scripts/Commands/cs_gm.cpp
+++ b/src/server/scripts/Commands/cs_gm.cpp
@@ -122,7 +122,7 @@ public:
         for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
         {
             AccountTypes itrSec = itr->second->GetSession()->GetSecurity();
-            if ((itr->second->isGameMaster() || (!AccountMgr::IsPlayerAccount(itrSec) && itrSec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
+            if ((itr->second->isGameMaster() || (!AccountMgr::IsModeratorAccount(itrSec) && itrSec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
                 (!handler->GetSession() || itr->second->IsVisibleGloballyFor(handler->GetSession()->GetPlayer())))
             {
                 if (first)
@@ -155,7 +155,7 @@ public:
     static bool HandleGMListFullCommand(ChatHandler* handler, char const* /*args*/)
     {
         ///- Get the accounts with GM Level >0
-        QueryResult result = LoginDatabase.PQuery("SELECT a.username, aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel >= %u", SEC_MODERATOR);
+        QueryResult result = LoginDatabase.PQuery("SELECT a.username, aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel > %u", SEC_MODERATOR);
         if (result)
         {
             handler->SendSysMessage(LANG_GMLIST);
diff --git a/src/server/scripts/Custom/AIO-4.0a.cpp b/src/server/scripts/Custom/AIO-4.0a.cpp
new file mode 100644
index 0000000..9b5be4f
--- /dev/null
+++ b/src/server/scripts/Custom/AIO-4.0a.cpp
@@ -0,0 +1,1351 @@
+/*
+
+
+Full NPC with lots of menus, and options.
+By: Blue
+Rewritten by: LordPsyan http://www.flaminglegion.net
+Version: 4.0a // Will be updated
+
+/*-------------------------------------
+*
+*
+		DEFINES
+*
+//------------------------------------*/
+#include "ScriptPCH.h"
+// Whisps
+#define notvip "Aww, you are not a VIP Member. You can get extra menu options with VIP status. Check website for details."
+#define yesvip "OH! Welcome honored VIP Member!"
+#define skillsmaxed "You skills are now maxed"
+#define votewhisper "Time to vote"
+#define donationhelp "Please donate to help the realm"
+#define normalhelp "If you need help, ask."
+#define ingamehelp "If you need help ingame, contact a GM"
+#define nosickness "You do not have Ressurection Sickness"
+#define nopet "You do not have a pet"
+#define WELCOME_MSG 100013
+#define MENU_MSG    100012
+
+// TOKEN ------------------------
+#define tokenbuy "I want to buy a Donation Chip."
+#define tokenchange "I want to change 500 Credit Chips to 1 Donation Chip."
+
+// mails
+#define moneymail 60003
+
+// items
+#define token1 99999 // Token1 entry number (swap). 
+#define token2 99998 // Token2 entry number (receive).
+#define vasarolhatotoken 100000 // Available as token -.-
+
+// Trainers
+#define dk		28474
+#define wari	914
+#define pala	23128
+#define sami	17204
+#define hunta	5115
+#define rogue	4584
+#define dudu	16655
+#define mage	28958
+#define priest	4090
+#define lock	23534
+
+//Teleport
+#define HMX 1937.47f
+#define HMY -3851.29f
+#define HMZ 91.1006f
+#define HMM 169
+
+#define AMX 2531.33f
+#define AMY -3090.56f
+#define AMZ 99.9714f
+#define AMM 169
+
+//Levelroad Teleport
+#define HLX -11383.3f
+#define HLY -4783.08f
+#define HLZ 3.50361f
+#define HLM 1
+
+#define ALX -11878.6f
+#define ALY -4603.53f
+#define ALZ 5.02386f
+#define ALM 1
+// DO NOT EDIT HERE //
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+
+
+
+class npc_all : public CreatureScript
+{
+public:
+    npc_all() : CreatureScript("npc_all") { }
+ 
+bool OnGossipHello(Player *player, Creature *_Creature)
+ 
+{
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Teleport", GOSSIP_SENDER_MAIN, 101); // 1.1
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Remove Sickness", GOSSIP_SENDER_MAIN, 120);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Reset Talent Points", GOSSIP_SENDER_MAIN, 121);
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Vote", GOSSIP_SENDER_MAIN, 113); // Not Configured
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Server Menus", GOSSIP_SENDER_MAIN, 104);
+		if (player->GetSession()->GetSecurity() >= 1)
+		{
+		_Creature->MonsterWhisper(yesvip, player->GetGUID());
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Morph", GOSSIP_SENDER_MAIN, 100);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Set My Skills to Maximum", GOSSIP_SENDER_MAIN, 102);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Trainers", GOSSIP_SENDER_MAIN, 103); // 1.2
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Funny Things", GOSSIP_SENDER_MAIN, 105);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Announcer", GOSSIP_SENDER_MAIN, 106);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Buffs", GOSSIP_SENDER_MAIN, 125);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Vip functions", GOSSIP_SENDER_MAIN, 110);// No Data.
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Buy", GOSSIP_SENDER_MAIN, 107); // Not configured
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Change", GOSSIP_SENDER_MAIN, 108); // Not Configured
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Reputations", GOSSIP_SENDER_MAIN, 123); // Not Configured. No Data.
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Titles", GOSSIP_SENDER_MAIN, 124); // No Data for adding titles.
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Battleground Control", GOSSIP_SENDER_MAIN, 109);
+		} else { _Creature->MonsterWhisper(notvip, player->GetGUID()); }
+
+    player->SEND_GOSSIP_MENU(WELCOME_MSG,_Creature->GetGUID());
+    return true;
+}
+
+void SendDefaultMenu(Player *player, Creature *_Creature, uint32 action)
+{
+
+// Not allow in combat
+if (player->isInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+    switch(action)
+ 
+    {
+
+		//////////////// MAIN MENUS -> Normal Menus //////////////////
+	case 100: // Morphs
+        player->ADD_GOSSIP_ITEM(4, "Back to normal", GOSSIP_SENDER_MAIN, 724);
+    	player->ADD_GOSSIP_ITEM(4, "Illidan", GOSSIP_SENDER_MAIN, 500);
+    	player->ADD_GOSSIP_ITEM(4, "Kil'jaeden", GOSSIP_SENDER_MAIN, 501);
+    	player->ADD_GOSSIP_ITEM(4, "Akama", GOSSIP_SENDER_MAIN, 502);
+    	player->ADD_GOSSIP_ITEM(4, "Deathknight", GOSSIP_SENDER_MAIN, 503);
+    	player->ADD_GOSSIP_ITEM(4, "Tauren", GOSSIP_SENDER_MAIN, 504);
+    	player->ADD_GOSSIP_ITEM(4, "Undead", GOSSIP_SENDER_MAIN, 505);
+    	player->ADD_GOSSIP_ITEM(4, "Human", GOSSIP_SENDER_MAIN, 506);
+    	player->ADD_GOSSIP_ITEM(4, "Lich King", GOSSIP_SENDER_MAIN, 507);
+    	player->ADD_GOSSIP_ITEM(4, "Tirion", GOSSIP_SENDER_MAIN, 508);
+    	player->ADD_GOSSIP_ITEM(4, "Uther Lightbringer", GOSSIP_SENDER_MAIN, 509);
+    	player->ADD_GOSSIP_ITEM(4, "Arthas", GOSSIP_SENDER_MAIN, 510);
+		///////////// From SPGM
+		player->ADD_GOSSIP_ITEM(4, "Algalon", GOSSIP_SENDER_MAIN, 711);
+		player->ADD_GOSSIP_ITEM(4, "Doomwalker", GOSSIP_SENDER_MAIN, 712);
+		player->ADD_GOSSIP_ITEM(4, "Doomlord Kazzak", GOSSIP_SENDER_MAIN, 713);
+		player->ADD_GOSSIP_ITEM(4, "Onyxia", GOSSIP_SENDER_MAIN, 714);
+		player->ADD_GOSSIP_ITEM(4, "Thaddius", GOSSIP_SENDER_MAIN, 715);
+		player->ADD_GOSSIP_ITEM(4, "Gluth", GOSSIP_SENDER_MAIN, 716);
+		player->ADD_GOSSIP_ITEM(4, "Maexxna", GOSSIP_SENDER_MAIN, 717);
+		player->ADD_GOSSIP_ITEM(4, "Sapphiron", GOSSIP_SENDER_MAIN, 718);
+		player->ADD_GOSSIP_ITEM(4, "Noth The Plaguebringer", GOSSIP_SENDER_MAIN, 719);
+		player->ADD_GOSSIP_ITEM(4, "Kel'Thuzad", GOSSIP_SENDER_MAIN, 720);
+		player->ADD_GOSSIP_ITEM(4, "Kael'thas Sunstrider", GOSSIP_SENDER_MAIN, 721);
+		player->ADD_GOSSIP_ITEM(4, "C'thun", GOSSIP_SENDER_MAIN, 722);
+		player->ADD_GOSSIP_ITEM(4, "Thrall", GOSSIP_SENDER_MAIN, 723);
+    	player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+	break;
+
+
+	case 101: // Teleport
+		player->ADD_GOSSIP_ITEM(1, "Raids/Dungeons", GOSSIP_SENDER_MAIN, 600);
+		player->ADD_GOSSIP_ITEM(1, "Cities", GOSSIP_SENDER_MAIN, 601);
+    	//player->ADD_GOSSIP_ITEM(1, "Fun places", GOSSIP_SENDER_MAIN, 602); // Only For Funservers. Not Configured
+		//player->ADD_GOSSIP_ITEM(1, "Events", GOSSIP_SENDER_MAIN, 603); // Funservers. Not Configured
+		player->ADD_GOSSIP_ITEM(1, "Areas", GOSSIP_SENDER_MAIN, 604);
+    	player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 102: // Skill maxer
+        player->CLOSE_GOSSIP_MENU();
+		player->UpdateSkillsToMaxSkillsForLevel();
+		_Creature->MonsterWhisper(skillsmaxed, player->GetGUID());
+		break;
+
+	case 103: // Trainers
+
+		player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+		player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+		//player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802); // Not Configured.
+		player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 104: // Server Menus
+		player->ADD_GOSSIP_ITEM(1, "Help! I've got hacked (Lock Account)", GOSSIP_SENDER_MAIN, 900);
+		player->ADD_GOSSIP_ITEM(0, "Report Lagg", GOSSIP_SENDER_MAIN, 901);
+		player->ADD_GOSSIP_ITEM(0, "Help", GOSSIP_SENDER_MAIN, 903);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 105: // Funny Things, Need some more
+		//player->ADD_GOSSIP_ITEM(0, "Money", GOSSIP_SENDER_MAIN, 1000); // DELETE THIS IF YOU DONT WANT PLAYERS TO GET MONEY
+		player->ADD_GOSSIP_ITEM(0, "Drunk", GOSSIP_SENDER_MAIN, 1001);
+		player->ADD_GOSSIP_ITEM(0, "Sober", GOSSIP_SENDER_MAIN, 1002);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 106: // Announcer Part
+		player->ADD_GOSSIP_ITEM(0, "Join Warsong Guilch!", GOSSIP_SENDER_MAIN, 1100);
+        player->ADD_GOSSIP_ITEM(0, "Join Arathi Basin!", GOSSIP_SENDER_MAIN, 1101);
+        player->ADD_GOSSIP_ITEM(0, "Join Wintergrasp!", GOSSIP_SENDER_MAIN, 1102);
+        player->ADD_GOSSIP_ITEM(0, "Join Strand of the ancients!", GOSSIP_SENDER_MAIN, 1103);
+        player->ADD_GOSSIP_ITEM(0, "Join Alterac Valley!", GOSSIP_SENDER_MAIN, 1104);
+        player->ADD_GOSSIP_ITEM(0, "Join Random Battleground!", GOSSIP_SENDER_MAIN, 1105);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 2v2!", GOSSIP_SENDER_MAIN, 1106);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 3v3!", GOSSIP_SENDER_MAIN, 1107);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 5v5!", GOSSIP_SENDER_MAIN, 1108);
+        player->ADD_GOSSIP_ITEM(0, "Join Eye of the Storm!", GOSSIP_SENDER_MAIN, 1109);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+	case 107: // Token -> BUY
+		player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 108: // Token ->Change
+		player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 109: // Battleground function
+		player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+		player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+		player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+		player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+		player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+	case 110: // VIP Functions, from another script(by me :D)
+        player->ADD_GOSSIP_ITEM(0, "Repair", GOSSIP_SENDER_MAIN, 1500);
+        player->ADD_GOSSIP_ITEM(0, "Nyugit szeretnék", GOSSIP_SENDER_MAIN, 1501);
+        player->ADD_GOSSIP_ITEM(0, "Surgery", GOSSIP_SENDER_MAIN, 1502);
+        player->ADD_GOSSIP_ITEM(0, "Faction change", GOSSIP_SENDER_MAIN, 1503);
+        player->ADD_GOSSIP_ITEM(0, "Race Change", GOSSIP_SENDER_MAIN, 1504);
+        //player->ADD_GOSSIP_ITEM(0, "Move?", GOSSIP_SENDER_MAIN, 1505); Not yet implemented
+        player->ADD_GOSSIP_ITEM(0, "Name Change", GOSSIP_SENDER_MAIN, 1506);
+        player->ADD_GOSSIP_ITEM(0, "Save Character", GOSSIP_SENDER_MAIN, 1507);
+        player->ADD_GOSSIP_ITEM(0, "Mailbox", GOSSIP_SENDER_MAIN, 1508);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+
+	case 111: // VOte
+        _Creature->MonsterWhisper(votewhisper, player->GetGUID());
+        player->ADD_GOSSIP_ITEM(0, "1 - %VOTE1%", GOSSIP_SENDER_MAIN, 1600);
+        player->ADD_GOSSIP_ITEM(0, "2 - %VOTE2%", GOSSIP_SENDER_MAIN, 1601);
+        player->ADD_GOSSIP_ITEM(0, "3 - %VOTE3%", GOSSIP_SENDER_MAIN, 1602);
+        player->ADD_GOSSIP_ITEM(0, "4 - %VOTE4%", GOSSIP_SENDER_MAIN, 1603);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+
+    case 124: // Titles, Not Ready Yet!
+        player->ADD_GOSSIP_ITEM(0, "Jenkins", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM(0, "Loremaster", GOSSIP_SENDER_MAIN, 3001);
+        player->ADD_GOSSIP_ITEM(0, "the Seeker", GOSSIP_SENDER_MAIN, 3002);
+        player->ADD_GOSSIP_ITEM(0, "the Argent Defender", GOSSIP_SENDER_MAIN, 3003);
+        player->ADD_GOSSIP_ITEM(0, "Bane of the Fallen King", GOSSIP_SENDER_MAIN, 3004);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Frozen Wastes", GOSSIP_SENDER_MAIN, 3005);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Naaru", GOSSIP_SENDER_MAIN, 3006);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Naxxramas", GOSSIP_SENDER_MAIN, 3007);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Ulduar", GOSSIP_SENDER_MAIN, 3008);
+        player->ADD_GOSSIP_ITEM(0, "Hand of A'dal", GOSSIP_SENDER_MAIN, 3009);
+        player->ADD_GOSSIP_ITEM(0, "the Immortal", GOSSIP_SENDER_MAIN, 3010);
+        player->ADD_GOSSIP_ITEM(0, "the Patient", GOSSIP_SENDER_MAIN, 3011);
+        player->ADD_GOSSIP_ITEM(0, "the Undying", GOSSIP_SENDER_MAIN, 3012);
+        player->ADD_GOSSIP_ITEM(0, "Ambassador", GOSSIP_SENDER_MAIN, 3013);
+        player->ADD_GOSSIP_ITEM(0, "Bloodsail Admiral", GOSSIP_SENDER_MAIN, 3014);
+        player->ADD_GOSSIP_ITEM(0, "Crusader", GOSSIP_SENDER_MAIN, 3015);
+        player->ADD_GOSSIP_ITEM(0, "the Diplomat", GOSSIP_SENDER_MAIN, 3016);
+        player->ADD_GOSSIP_ITEM(0, "the Exalted", GOSSIP_SENDER_MAIN, 3017);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+        /// Buffer part
+    case 125: // buffer
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Power Word: Fortitude, Rank 8", GOSSIP_SENDER_MAIN, 4000);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Kings", GOSSIP_SENDER_MAIN, 4001);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Bleesing of Mights", GOSSIP_SENDER_MAIN,4002);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Wisdom", GOSSIP_SENDER_MAIN, 4003);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Mark of the Wild, Rank 9", GOSSIP_SENDER_MAIN, 4004);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Arcane Intellect, Rank 7", GOSSIP_SENDER_MAIN, 4005);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Soul Stone", GOSSIP_SENDER_MAIN, 4006);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Thorns, Rank 8", GOSSIP_SENDER_MAIN, 4007);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Divine Spirit, Rank 8", GOSSIP_SENDER_MAIN, 4008);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Shadow Protection, Rank 5", GOSSIP_SENDER_MAIN, 4009);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+         break;
+
+	case 4000:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48161, false); // target, spellid, triggered-e
+        break;
+ 
+        case 4001:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 25898, false);
+        break;
+ 
+        case 4002:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48934, false);
+        break;
+ 
+        case 4003:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48938, false);
+        break;
+ 
+        case 4004:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48469, false);
+        break;          
+        
+        case 4005:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 42995, false);
+        break;
+ 
+        case 4006:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 47883, false);
+        break;
+ 
+        case 4007:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 53307, false);
+        break;
+ 
+        case 4008:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48073, false);
+        break;
+ 
+        case 4009:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48169, false);
+        break;
+
+
+        /////////// NORMAL MENUS -> ACTION OR MENU
+
+
+
+        ///-- Server Menus part start --///
+		case 900: // Hacked
+        // Closes the account
+        LoginDatabase.PQuery("UPDATE `account` SET `locked`=1 WHERE `id`='%s'", player->GetSession()->GetAccountId());
+        LoginDatabase.PQuery("INSERT INTO `hacked` (`charname`) VALUES ('%s'", player->GetName()); // Report it to the DB.
+        break;
+
+		case 901: // Report lagg
+        player->CLOSE_GOSSIP_MENU();
+		_Creature->MonsterWhisper(('%s', player->GetSession()->GetAccountId()), player->GetGUID());
+        //LoginDatabase.PExecute("INSERT INTO `lagreports` (`account`) VALUES ('%s'", player->GetSession()->GetAccountId());
+        _Creature->MonsterWhisper("Lagg report done.", player->GetGUID());
+        break;
+
+		case 902: // Help
+        player->ADD_GOSSIP_ITEM(0, "Donation Help", GOSSIP_SENDER_MAIN, 1700);
+        player->ADD_GOSSIP_ITEM(0, "Ingame Help", GOSSIP_SENDER_MAIN, 1701);
+        player->ADD_GOSSIP_ITEM(0, "Normal Help", GOSSIP_SENDER_MAIN, 1702);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+
+		case 1700: // Donation Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Donations can be done on www.flaminglegion.net", player->GetGUID());
+        break;
+
+		case 1701: // INGAME HELP
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Contact a GM for help", player->GetGUID());
+        break;
+
+		case 1702: // Normal Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Helpful information can be found on www.flaminglegion.net", player->GetGUID());
+        break;
+        /// -- Server Menus part End -- ///
+
+        /// -- Funny Things Menu Start -- /// money drunk sober
+
+		case 1000: // Money
+        player->CLOSE_GOSSIP_MENU();
+        player->GetMail(moneymail);
+        _Creature->MonsterWhisper("Check your mailbox.", player->GetGUID());
+        break;
+
+		case 1001: // Drunk
+        player->CLOSE_GOSSIP_MENU();
+        player->CastSpell(player, 46876, false);
+        break;
+
+        case 1002: // Sober
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDrunkValue(0, 9);
+        break;
+        /// -- Funny Things Menu End -- ///
+
+        /// -- Announcer Part Start -- ///
+
+		case 1100:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_WSG);
+        break;
+ 
+        case 1101:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_AB);
+        break;
+ 
+        case 1102:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_WG);
+        break;
+ 
+        case 1103:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_SOTA);
+        break;
+ 
+        case 1104:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_AV);
+        break;
+ 
+        case 1105:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_RANDOM);
+        break;
+ 
+        case 1106:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_ARENA_1);
+        break;
+ 
+        case 1107:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_ARENA_2);
+        break;
+ 
+        case 1108:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_ARENA_3);
+        break;
+ 
+        case 1109:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player).SendSysMessage(LANG_EOTS);
+        break;
+
+        /// -- Announcer part end -- ///
+
+        /////////////////////////////////
+        //        BREAK		   //
+        //////////////////////////////////
+        //////////////////////////////////
+
+	/*************************************************************************/
+
+        /// -- Morph Part Start -- ///
+
+               case 500:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(21135);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 501:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23200);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 502:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20681);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 503:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16508);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 504:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17332);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;          
+        
+        case 505:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(2789);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 506:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16280);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 507:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24191);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 508:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(22209);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 509:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23889);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+ 
+        case 510:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24949);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+
+        case 711: // Algalon
+        player->CLOSE_GOSSIP_MENU();
+	    player->SetDisplayId(28641);
+	    player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 712: // Doomwalker
+        player->CLOSE_GOSSIP_MENU();
+	    player->SetDisplayId(16630);
+	    player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 713: // Doomlord kazzak
+        player->CLOSE_GOSSIP_MENU();
+	    player->SetDisplayId(17887);
+	    player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.10f);
+        break;
+
+        case 714: // Onyxia
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(8570);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 715: // Thaddius
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16137);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 716: // Gluth
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16064);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 717: // Maexxna
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15928);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.15f);
+        break;
+
+        case 718: // Sapphiron
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16033);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 719: // Noth The Plaguebringer
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16590);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+        break;
+
+        case 720: // Kel'Thuzad
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15945);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 721: // Kael'thas Sunstrider
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20023);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.5f);
+        break;
+
+        case 722: // C'thun
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15786);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 723: // Thrall
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(4527);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+
+        case 724: // Demorph
+		player->CLOSE_GOSSIP_MENU();
+		player->DeMorph();
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+		break;
+/// -- Morph Part End -- ///
+
+/// -- Teleport Part Start -- ///
+        case 600: // Raid dungeon
+        player->ADD_GOSSIP_ITEM(0, "ICC", GOSSIP_SENDER_MAIN, 1900);
+        player->ADD_GOSSIP_ITEM(0, "Naxxramas", GOSSIP_SENDER_MAIN, 1901);
+        player->ADD_GOSSIP_ITEM(0, "Ulduar", GOSSIP_SENDER_MAIN, 1902);
+        player->ADD_GOSSIP_ITEM(0, "Nexus", GOSSIP_SENDER_MAIN, 1903);
+        player->ADD_GOSSIP_ITEM(0, "Argent Tournament Grounds", GOSSIP_SENDER_MAIN, 1904);
+        player->ADD_GOSSIP_ITEM(0, "Azjol-Nerub", GOSSIP_SENDER_MAIN, 1905);
+        player->ADD_GOSSIP_ITEM(0, "Drak' Tharon Keep", GOSSIP_SENDER_MAIN, 1906);
+        player->ADD_GOSSIP_ITEM(0, "Gundrak", GOSSIP_SENDER_MAIN, 1907);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Keep", GOSSIP_SENDER_MAIN, 1908);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Pinnacle", GOSSIP_SENDER_MAIN, 1909);
+        player->ADD_GOSSIP_ITEM(0, "Vault of Archavon", GOSSIP_SENDER_MAIN, 1910);
+        player->ADD_GOSSIP_ITEM(0, "Violet Hold", GOSSIP_SENDER_MAIN, 1911);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+        
+        case 601: // Cities
+
+        player->ADD_GOSSIP_ITEM(0, "Teleport Stormwind", GOSSIP_SENDER_MAIN, 1800);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Ironforge", GOSSIP_SENDER_MAIN, 1801);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Darnassus", GOSSIP_SENDER_MAIN, 1802);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Exodar", GOSSIP_SENDER_MAIN, 1803);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Shattrath", GOSSIP_SENDER_MAIN, 1804);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Dalaran", GOSSIP_SENDER_MAIN, 1805);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Gurubashi Arena", GOSSIP_SENDER_MAIN, 1806);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Orgrimmar", GOSSIP_SENDER_MAIN, 1807);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Undercity", GOSSIP_SENDER_MAIN, 1808);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Silvermoon", GOSSIP_SENDER_MAIN, 1809);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Thunder Bluff", GOSSIP_SENDER_MAIN, 1810);
+    if (player->GetTeam() == ALLIANCE)
+	{
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance Mall", GOSSIP_SENDER_MAIN, 5000);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance LevelRoad", GOSSIP_SENDER_MAIN, 9998);
+    }else{
+        player->ADD_GOSSIP_ITEM(0, "Teleport Horde Mall", GOSSIP_SENDER_MAIN, 5001);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Horde LevelRoad", GOSSIP_SENDER_MAIN, 9999);
+    }
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+
+        case 604: // areas
+        player->ADD_GOSSIP_ITEM(0, "Ashenvale", GOSSIP_SENDER_MAIN, 1863);
+        player->ADD_GOSSIP_ITEM(0, "Arathi Highlands", GOSSIP_SENDER_MAIN, 1867);
+        player->ADD_GOSSIP_ITEM(0, "Azshara", GOSSIP_SENDER_MAIN, 1877);
+        player->ADD_GOSSIP_ITEM(0, "Azuremyst Isle", GOSSIP_SENDER_MAIN, 1850);
+        player->ADD_GOSSIP_ITEM(0, "Badlands", GOSSIP_SENDER_MAIN, 1870);
+        player->ADD_GOSSIP_ITEM(0, "Barrens", GOSSIP_SENDER_MAIN, 1861);
+        player->ADD_GOSSIP_ITEM(0, "Blades Edge Mountain", GOSSIP_SENDER_MAIN, 1887);
+        player->ADD_GOSSIP_ITEM(0, "Blasted Lands", GOSSIP_SENDER_MAIN, 1874);
+        player->ADD_GOSSIP_ITEM(0, "Borean Tundra", GOSSIP_SENDER_MAIN, 1890);
+        player->ADD_GOSSIP_ITEM(0, "Burning Steppes", GOSSIP_SENDER_MAIN, 1882);
+        player->ADD_GOSSIP_ITEM(0, "Darkshore", GOSSIP_SENDER_MAIN, 1858);
+        player->ADD_GOSSIP_ITEM(0, "Desolace", GOSSIP_SENDER_MAIN, 1868);
+        player->ADD_GOSSIP_ITEM(0, "Next Page", GOSSIP_SENDER_MAIN, 605);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+        case 605: // areas page 2
+        player->ADD_GOSSIP_ITEM(0, "Dragonblight", GOSSIP_SENDER_MAIN, 1891);
+        player->ADD_GOSSIP_ITEM(0, "Dun Morogh", GOSSIP_SENDER_MAIN, 1853);
+        player->ADD_GOSSIP_ITEM(0, "Durotar", GOSSIP_SENDER_MAIN, 1854);
+        player->ADD_GOSSIP_ITEM(0, "Elwynn Forest", GOSSIP_SENDER_MAIN, 1852);
+        player->ADD_GOSSIP_ITEM(0, "Eversong Woods", GOSSIP_SENDER_MAIN, 1857);
+        player->ADD_GOSSIP_ITEM(0, "Felwood", GOSSIP_SENDER_MAIN, 1878);
+        player->ADD_GOSSIP_ITEM(0, "Grizzly Hills", GOSSIP_SENDER_MAIN, 1892);
+        player->ADD_GOSSIP_ITEM(0, "Hellfire Peninsula", GOSSIP_SENDER_MAIN, 1883);
+        player->ADD_GOSSIP_ITEM(0, "Hillsbrad Foothills", GOSSIP_SENDER_MAIN, 1866);
+        player->ADD_GOSSIP_ITEM(0, "Hinterlands", GOSSIP_SENDER_MAIN, 1872);
+        player->ADD_GOSSIP_ITEM(0, "Howling Fjord", GOSSIP_SENDER_MAIN, 1896);
+        player->ADD_GOSSIP_ITEM(0, "Icecrown", GOSSIP_SENDER_MAIN, 1897);
+        player->ADD_GOSSIP_ITEM(0, "Next Page", GOSSIP_SENDER_MAIN, 606);
+        player->ADD_GOSSIP_ITEM(0, "Previous Page", GOSSIP_SENDER_MAIN, 604);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+        case 606: // areas page 3
+        player->ADD_GOSSIP_ITEM(0, "Loch Modan", GOSSIP_SENDER_MAIN, 1859);
+        player->ADD_GOSSIP_ITEM(0, "Nagrand", GOSSIP_SENDER_MAIN, 1886);
+        player->ADD_GOSSIP_ITEM(0, "Netherstorm", GOSSIP_SENDER_MAIN, 1888);
+        player->ADD_GOSSIP_ITEM(0, "Mulgore", GOSSIP_SENDER_MAIN, 1855);
+        player->ADD_GOSSIP_ITEM(0, "Redridge Mountains", GOSSIP_SENDER_MAIN, 1860);
+        player->ADD_GOSSIP_ITEM(0, "Searing Gorge", GOSSIP_SENDER_MAIN, 1875);
+        player->ADD_GOSSIP_ITEM(0, "Shadowmoon Valley", GOSSIP_SENDER_MAIN, 1889);
+        player->ADD_GOSSIP_ITEM(0, "Sholazar Basin", GOSSIP_SENDER_MAIN, 1894);
+        player->ADD_GOSSIP_ITEM(0, "Silithus", GOSSIP_SENDER_MAIN, 1880);
+        player->ADD_GOSSIP_ITEM(0, "Stonetalon Mountains", GOSSIP_SENDER_MAIN, 1862);
+        player->ADD_GOSSIP_ITEM(0, "Storm Peaks", GOSSIP_SENDER_MAIN, 1895);
+        player->ADD_GOSSIP_ITEM(0, "Stranglethorn Vale", GOSSIP_SENDER_MAIN, 1869);
+        player->ADD_GOSSIP_ITEM(0, "Next Page", GOSSIP_SENDER_MAIN, 607);
+        player->ADD_GOSSIP_ITEM(0, "Previous Page", GOSSIP_SENDER_MAIN, 605);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+        case 607: // areas page 4
+        player->ADD_GOSSIP_ITEM(0, "Swamp of Sorrows", GOSSIP_SENDER_MAIN, 1871);
+        player->ADD_GOSSIP_ITEM(0, "Tanaris", GOSSIP_SENDER_MAIN, 1873);
+        player->ADD_GOSSIP_ITEM(0, "Teldrassil", GOSSIP_SENDER_MAIN, 1851);
+        player->ADD_GOSSIP_ITEM(0, "Terokkar Forest", GOSSIP_SENDER_MAIN, 1885);
+        player->ADD_GOSSIP_ITEM(0, "Thousand Needles", GOSSIP_SENDER_MAIN, 1865);
+        player->ADD_GOSSIP_ITEM(0, "Tirisfal Glades", GOSSIP_SENDER_MAIN, 1856);
+        player->ADD_GOSSIP_ITEM(0, "Un Goro Crater", GOSSIP_SENDER_MAIN, 1876);
+        player->ADD_GOSSIP_ITEM(0, "Wetlands", GOSSIP_SENDER_MAIN, 1864);
+        player->ADD_GOSSIP_ITEM(0, "Western Plaguelands", GOSSIP_SENDER_MAIN, 1881);
+        player->ADD_GOSSIP_ITEM(0, "Winterspring", GOSSIP_SENDER_MAIN, 1879);
+        player->ADD_GOSSIP_ITEM(0, "Zangarmarsh", GOSSIP_SENDER_MAIN, 1884);
+        player->ADD_GOSSIP_ITEM(0, "Zul'Drak", GOSSIP_SENDER_MAIN, 1893);
+        player->ADD_GOSSIP_ITEM(0, "Previous Page", GOSSIP_SENDER_MAIN, 606);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+        break;
+
+        /// tele loactions
+
+        // RAIDS & Dungeons
+
+        case 1900: // icc
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 5873.819824f, 2110.979980f, 636.010986f, 0.0f);
+        	break;
+        	
+        case 1901: // Naxxramas
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 3665.904053f, -1267.064575f, 243.512207f, 0.0f);
+        	break;
+
+        case 1902: // Ulduar
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 8948.200165f, -1268.270020f, 1025.500000f, 0.0f);
+        	break;
+        case 1903: // Nexus
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 3785.800049f, 6944.919922f, 104.620003f, 0.0f);
+        	break;
+        case 1904: // Argent tournement
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 8513.266602f, 638.120728f, 547.324890f, 0.0f);
+        	break;
+        case 1905: // Azjol-Nerub
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 3707.86f, 2150.23f, 36.7568f, 0.0f);
+        	break;
+        case 1906: // Drak' Tharon Keep
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 4774.6f, -2032.92f, 229.145f, 0.0f);
+        	break;
+        case 1907: // Gundrak
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 6910.8f, -4603.23f, 450.61f, 0.0f);
+        	break;
+        case 1908: // Utgarde Keep
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 1219.72f, -4865.28f, 41.2479f, 0.0f);
+        	break;
+        case 1909: // Utgarde Pinnacle
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 1259.33f, -4852.02f, 215.763f, 0.0f);
+        	break;
+        case 1910: // Vault of Archavon
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 5453.72f, 2840.79f, 421.277f, 0.0f);
+        	break;
+        case 1911: // Violet Hold
+        	player->CLOSE_GOSSIP_MENU();
+        	player->TeleportTo(571, 5689.03f, 508.278f, 652.763f, 0.0f);
+        	break;
+
+/////// cities
+
+		case 1800: // Stormwind
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f); // Teleport(location)
+        break;
+ 
+        case 1801: // Ironforge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+        break;
+ 
+        case 1802: // Darnassus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+        break;
+        
+        case 1803: // Exodar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3954.20f, -11656.54f, -138.69f, 0.0f);
+        break;
+ 
+        case 1804: // Shattrath
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        break;
+ 
+        case 1805: // Dalaran
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5819.08f, 643.99f, 647.80f, 3.32f);
+        break;
+ 
+        case 1806: // Gurubashi Arena
+        player->CLOSE_GOSSIP_MENU();
+ 
+        player->TeleportTo(0,  -13277.4f, 127.372f, 26.1418f, 1.0f);
+        break;
+ 
+        case 1807: // Orgrimmar
+         player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+        break;
+        
+        case 1808: // Undercity
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+        
+        break;
+ 
+        case 1809: // Silvermoon
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+        break;
+ 
+        case 1810: // Thunder Bluff
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -1290.0f, 147.033997f, 129.682007f, 4.919000f);
+		break;
+
+		case 5001: // Horde Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HMM, HMX, HMY, HMZ, 0.0f);
+		break;
+
+		case 5000: // Alliance Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(AMM, AMX, AMY, AMZ, 0.0f);
+		break;
+
+// Leveling Roads
+		case 9999:	// horde level road
+        player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(HLM, HLX, HLY, HLZ, 0.0f);
+		break;
+
+		case 9998:	//alliance level road
+        player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(ALM, ALX, ALY, ALZ, 0.0f);
+		break;
+// Zones
+		case 1850:  // Azuremyst Isle
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -4216.870117f, -12336.900391f, 4.340638f, 0.0f);
+		break;
+		case 1851:  // Teldrassil
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 10111.299805f, 1557.729980f, 1324.329956f, 0.0f);
+		break;
+		case 1852:  // Elwynn Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9617.059570f, -288.949005f, 57.305149f, 0.0f);
+		break;
+		case 1853:  // Dun Morogh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5451.549805f, -656.992004f, 392.674988f, 0.0f);
+		break;
+		case 1854:  // Durotar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1007.780029f, -446.220215f, 11.202200f, 0.0f);
+		break;
+		case 1855:  // Mulgore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -2192.620117f, -736.317017f, -13.327400f, 0.0f);
+		break;
+		case 1856:  // Tirisfal Glades
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 2036.020020f, 161.330994f, 33.867401f, 0.0f);
+		break;
+		case 1857:  // Eversong Woods
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9079.919922f, -7193.229980f, 55.601299f, 0.0f);
+		break;
+		case 1858:  // Darkshore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 5756.250000f, 298.505005f, 20.604900f, 0.0f);
+		break;
+		case 1859:  // Loch Modan
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5202.939941f, -2855.179932f, 335.953827f, 0.0f);
+		break;
+		case 1860:  // Redridge Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9551.809570f, -2204.729980f, 93.473000f, 0.0f);
+		break;
+		case 1861:  // The Barrens
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 884.539978f, -3548.449951f, 91.853165f, 0.0f);
+		break;
+		case 1862:  // Stonetalon Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1570.920044f, 1031.520020f, 137.959000f, 0.0f);
+		break;
+		case 1863:  // Ashenvale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1928.339966f, -2165.949951f, 93.789597f, 0.0f);
+		break;
+		case 1864:  // Wetlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -3242.810059f, -2469.040039f, 15.922600f, 0.0f);
+		break;
+		case 1865:  // Thousand Needles
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -4969.020020f, -1726.890015f, -62.126911f, 0.0f);
+		break;
+		case 1866:  // Hillsbrad Foothills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -436.657013f, -581.254028f, 53.594398f, 0.0f);
+		break;
+		case 1867:  // Arathi Highlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -1508.510010f, -2732.060059f, 32.498600f, 0.0f);
+		break;
+		case 1868:  // Desolace
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -606.395020f, 2211.750000f, 92.981796f, 0.0f);
+		break;
+		case 1869:  // Stranglethorn Vale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -12644.299805f, -377.411011f, 10.102062f, 0.0f);
+		break;
+		case 1870:  // Badlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -6779.200195f, -3423.639893f, 241.667007f, 0.0f);
+		break;
+		case 1871:  // Spawm of Sorrows
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -10345.400391f, -2773.419922f, 21.990000f, 0.0f);
+		break;
+		case 1872:  // The Hinterlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 119.387001f, -3190.370117f, 117.330994f, 0.0f);
+		break;
+		case 1873:  // Tanaris
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7931.200195f, -3414.280029f, 80.736496f, 0.0f);
+		break;
+		case 1874:  // Blasted Lands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11182.500000f, -3016.669922f, 7.422350f, 0.0f);
+		break;
+		case 1875:  // Searing Gorge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -7012.470215f, -1065.130005f, 241.785995f, 0.0f);
+		break;
+		case 1876:  // Un Goro Crater
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7943.220215f, -2119.090088f, -218.344589f, 0.0f);
+		break;
+		case 1877:  // Azshara
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 3341.360107f, -4603.790039f, 92.502701f, 0.0f);
+		break;
+		case 1878:  // Felwood
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 4102.250000f, -1006.789978f, 272.717010f, 0.0f);
+		break;
+		case 1879:  // Winterspring
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 6759.180176f, -4419.629883f, 763.213989f, 0.0f);
+		break;
+		case 1880:  // Silithus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7426.870117f, 1005.309998f, 1.133590f, 0.0f);
+		break;
+		case 1881:  // Western Plaguelands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1728.650024f, -1602.250000f, 63.428963f, 0.0f);
+		break;
+		case 1882:  // Burning Steppes
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8118.540039f, -1633.829956f, 132.996002f, 0.0f);
+		break;
+		case 1883:  // Hellfire Peninsula
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -211.237000f, 4278.540039f, 86.567802f, 0.0f);
+		break;
+		case 1884:  // Zangarmarsh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -54.862099f, 5813.439941f, 20.605900f, 0.0f);
+		break;
+		case 1885:  // Terokkar Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -2000.469971f, 4451.540039f, 8.369170f, 0.0f);
+		break;
+		case 1886:  // Nagrand
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1145.949951f, 8182.350098f, 3.602490f, 0.0f);
+		break;
+		case 1887:  // Blades Edge Mountain
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3037.669922f, 5962.859863f, 130.774002f, 0.0f);
+		break;
+		case 1888:  // Netherstorm
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3830.229980f, 3426.500000f, 88.614502f, 0.0f);
+		break;
+		case 1889:  // Shadowmoon Valley
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3077.271973f, 2878.689209f, 82.129242f, 0.0f);
+		break;
+		case 1890:  // Borean Tundra
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 3256.570068f, 5278.229980f, 40.804588f, 0.0f);
+		break;
+		case 1891:  // Dragonblight
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4103.359863f, 264.477997f, 50.501900f, 0.0f);
+		break;
+		case 1892:  // Grizzly Hills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4391.729980f, -3587.919922f, 238.531006f, 0.0f);
+		break;
+		case 1893:  // Zul' Drak
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5560.229980f, -3211.659912f, 371.709015f, 0.0f);
+		break;
+		case 1894:  // Sholazar Basin
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5323.000000f, 4942.000000f, -133.558670f, 0.0f);
+		break;
+		case 1895:  // The Storm Peaks
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7527.140137f, -1260.890015f, 919.049011f, 0.0f);
+		break;
+		case 1896:  // Howling Fjord
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 1902.150024f, -4883.910156f, 161.363007f, 0.0f);
+		break;
+		case 1897:  // Icecrown
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7253.640137f, 1644.780029f, 433.679993f, 0.0f);
+		break;
+
+
+		/// -- Tele part stop -- ///
+
+	/// -- Dungeons, Raids -- ///
+
+
+		/// -- BG Control Part Start -- /// 
+	/*        player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!*/
+
+		case 1400: // WSG 100%
+        /* Comment: IDS:
+        SOTA - 9
+        AV - 1
+        WSG - 2
+        AB - 3
+        EOTS - 7*/
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=2");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+		case 1401: // EOTS 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 2, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=7");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+		case 1402: // AB 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 2, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=3");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+		case 1403: // Sota 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 2)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=9");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+		case 1404: // AV 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(2, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=1");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        /// -- BG Modify Part End -- ///
+
+        /* Break */
+
+
+
+
+
+        /// -- Token Part Start -- ///
+
+        /*
+        	case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        break;
+
+		case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        break;
+        */
+
+		case 1201: // Token change
+        if(player->HasItemCount(token1, 1, false))
+        {
+        player->ItemRemovedQuestCheck(token1, 1);
+        player->AddItem(token2, 1);
+        } else {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "You don't have got enough token.", GOSSIP_SENDER_MAIN, 12345);
+        break;
+        }
+
+		case 1200:
+        player->ADD_GOSSIP_ITEM_EXTENDED(0, tokenbuy, GOSSIP_SENDER_MAIN, 2000, "Are you sure you want to buy a token?", -10000, 0);
+        break;
+		case 2000:
+        player->AddItem(vasarolhatotoken, 1);
+        break;
+
+        ///-- Token Part End --///
+
+        ///-- Trainers Part Start --///
+        /*
+		player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+		player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+		player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802);
+		player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+		*/
+
+		case 803: // Mount Trainer
+		{
+		player->CLOSE_GOSSIP_MENU();
+		player->learnSpell(33388, false);
+		player->learnSpell(33391, false);
+		player->learnSpell(34090, false);
+		player->learnSpell(34091, false);
+		player->learnSpell(54197, false);
+		}
+
+		case 800: // profs
+        // SPGM
+	    player->ADD_GOSSIP_ITEM(3, "Alchemy"                     , GOSSIP_SENDER_MAIN, 2100);
+		player->ADD_GOSSIP_ITEM(3, "Blacksmithing"           , GOSSIP_SENDER_MAIN, 2101);
+		player->ADD_GOSSIP_ITEM(3, "Enchanter"        , GOSSIP_SENDER_MAIN, 2102);
+		player->ADD_GOSSIP_ITEM(3, "Engineering"              , GOSSIP_SENDER_MAIN, 2103);
+		player->ADD_GOSSIP_ITEM(3, "Herbalism"            , GOSSIP_SENDER_MAIN, 2104);
+		player->ADD_GOSSIP_ITEM(3, "Inscription"        , GOSSIP_SENDER_MAIN, 2105);
+		player->ADD_GOSSIP_ITEM(3, "Jewelcrafting"           , GOSSIP_SENDER_MAIN, 2106);
+		player->ADD_GOSSIP_ITEM(3, "Leatherworking"           , GOSSIP_SENDER_MAIN, 2107);
+		player->ADD_GOSSIP_ITEM(3, "Mining"         	   , GOSSIP_SENDER_MAIN, 2108);
+		player->ADD_GOSSIP_ITEM(3, "Skinning"        , GOSSIP_SENDER_MAIN, 2109);
+		player->ADD_GOSSIP_ITEM(3, "Tailoring"           	   , GOSSIP_SENDER_MAIN, 2110);
+		player->ADD_GOSSIP_ITEM(3, "Cooking"              , GOSSIP_SENDER_MAIN, 2111);		
+		player->ADD_GOSSIP_ITEM(3, "First Aid"            , GOSSIP_SENDER_MAIN, 2112);
+		player->ADD_GOSSIP_ITEM(3, "Fishing"              , GOSSIP_SENDER_MAIN, 2113);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+		case 801: // Class Trainers
+
+		player->ADD_GOSSIP_ITEM(3, "Death Knight"          , GOSSIP_SENDER_MAIN, 2200);
+		player->ADD_GOSSIP_ITEM(3, "Druid"        	   , GOSSIP_SENDER_MAIN, 2201);
+		player->ADD_GOSSIP_ITEM(3, "Hunter"            , GOSSIP_SENDER_MAIN, 2202);
+		player->ADD_GOSSIP_ITEM(3, "Mage"            , GOSSIP_SENDER_MAIN, 2203);
+		player->ADD_GOSSIP_ITEM(3, "Paladin"             , GOSSIP_SENDER_MAIN, 2204);
+		player->ADD_GOSSIP_ITEM(3, "Priest"    	        , GOSSIP_SENDER_MAIN, 2205);
+		player->ADD_GOSSIP_ITEM(3, "Rogue"                       , GOSSIP_SENDER_MAIN, 2206);
+		player->ADD_GOSSIP_ITEM(3, "Shaman"        	   , GOSSIP_SENDER_MAIN, 2207);
+		player->ADD_GOSSIP_ITEM(3, "Warlock"        , GOSSIP_SENDER_MAIN, 2208);
+		player->ADD_GOSSIP_ITEM(3, "Warrior"                 , GOSSIP_SENDER_MAIN, 2209);
+        player->SEND_GOSSIP_MENU(MENU_MSG,_Creature->GetGUID());
+		break;
+
+        case 2200:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dk,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2201:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dudu,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;	
+
+        case 2202:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(hunta,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+       	case 2203:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(mage,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2204:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(pala,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+       	case 2205:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(priest,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+       	case 2206:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(rogue,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;		
+
+        case 2207:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(sami,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;        
+        	
+       	case 2208:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(lock,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;        	
+        	
+       	case 2209:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(wari,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        //Sickness,Reset Talent Start//
+        case 121: // Reset Talent Pont
+        player->CLOSE_GOSSIP_MENU();
+        player->SendTalentWipeConfirm(_Creature->GetGUID());
+        break;
+
+        case 120: //Sickness leszedése
+        if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0))
+        {
+        	_Creature->MonsterWhisper(nosickness, player->GetGUID());
+        }
+        else
+        {
+        _Creature->CastSpell(player,38588,false); // Flash Heal
+        player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+        player->CLOSE_GOSSIP_MENU();
+        break;
+        //Sickness,Reset Talent End//
+        ////// Prof trainers
+
+        case 2100: // Alchemy
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(33630,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        player->SummonCreature(28703,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2101: // Blacksmithing
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(28694,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+case 2102: // Enchanting
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28693,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+	player->SummonCreature(33633,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2103: // Engineering
+   player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28697,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2104: // Herbalism
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28704,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+case 2105: // Inscription
+ player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28702,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2106: // Jewelcrafting
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28701,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2107: // Leatherworking
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28700,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2108: // Mining
+    player->CLOSE_GOSSIP_MENU();	player->SummonCreature(28698,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2109: // Skinning
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28696,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2110: // Tailoring
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28699,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2111: // Cooking
+   player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28705,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2112: // First Aid
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28706,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);;
+break;
+
+        case 2113: // Fishing
+    player->CLOSE_GOSSIP_MENU();
+	player->SummonCreature(28742,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+}
+//return true;
+    }
+
+bool OnGossipSelect(Player* player, Creature* _Creature, uint32 sender, uint32 action)
+{
+	// Main menu
+	player->PlayerTalkClass->ClearMenus();
+	if (sender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu(player, _Creature, action);
+
+return true;
+}
+};
+ 
+void AddSC_npc_all()
+{
+    new npc_all();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 1570ca1..e7d7d3b 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -10,6 +10,17 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/AIO-4.0a.cpp
+  Custom/summon.cpp
+  Custom/guildmaster.cpp
+  Custom/beastmaster.cpp
+  Custom/npcbuff.cpp
+  Custom/levelnpc.cpp
+  Custom/city_conquest_boss.cpp
+  Custom/city_conquest_generic.cpp
+  Custom/city_conquest_portal.cpp
+  Custom/city_conquest_spawner.cpp
+  Custom/professionnpc.cpp
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/beastmaster.cpp b/src/server/scripts/Custom/beastmaster.cpp
new file mode 100644
index 0000000..e5c9eb3
--- /dev/null
+++ b/src/server/scripts/Custom/beastmaster.cpp
@@ -0,0 +1,915 @@
+//Modified by Marcus patched by LordPsyan
+//original script created by ??
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_ITEM_STABLE "Stable"
+#define GOSSIP_ITEM_NEWPET "New Pet"
+#define GOSSIP_ITEM_BOAR "Boar"
+#define GOSSIP_ITEM_SERPENT "Serpent"
+#define GOSSIP_ITEM_SCRAB "Scrab"
+#define GOSSIP_ITEM_LION "Lion"
+#define GOSSIP_ITEM_WOLF "Wolf"
+#define GOSSIP_ITEM_RAVAGER "Ravenger"
+ 
+#define GOSSIP_ITEM_UNTRAINEPET "Restart Pet"
+#define BEAST_MSG                 100008
+#define MSG_CHOOSE                100009
+
+class Npc_Beastmaster : public CreatureScript
+{
+public:
+        Npc_Beastmaster() : CreatureScript("Npc_Beastmaster") { }
+
+void CreatePet(Player *player, Creature * m_creature, uint32 entry) {
+
+	if(ConfigMgr::GetBoolDefault("BeastMaster.OnlyHunter", false)) // Checks to see if Only Hunters can have pets.
+     {
+        if(player->getClass() != CLASS_HUNTER) {
+            m_creature->MonsterWhisper("You are not a Hunter!", player->GetGUID());
+            return;
+        }
+     }
+        if(player->GetPet()) {
+            m_creature->MonsterWhisper("First you must drop your Pet!", player->GetGUID());
+            return;
+        }
+ 
+        Creature *creatureTarget = m_creature->SummonCreature(entry, player->GetPositionX(), player->GetPositionY()+2, player->GetPositionZ(), player->GetOrientation(), TEMPSUMMON_CORPSE_TIMED_DESPAWN, 500);
+        if(!creatureTarget) return;
+        
+        Pet* pet = player->CreateTamedPetFrom(creatureTarget, 0);
+        if(!pet) return;
+ 
+        // kill original creature
+        creatureTarget->setDeathState(JUST_DIED);
+        creatureTarget->RemoveCorpse();
+        creatureTarget->SetHealth(0);                       // just for nice GM-mode view
+ 
+        pet->SetPower(POWER_HAPPINESS, 1048000);
+ 
+        //pet->SetUInt32Value(UNIT_FIELD_PETEXPERIENCE,0);
+        //pet->SetUInt32Value(UNIT_FIELD_PETNEXTLEVELEXP, uint32((Trinity::XP::xp_to_level(70))/4));
+ 
+        // prepare visual effect for levelup
+            pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel() - 1);
+        pet->GetMap()->AddToMap((Creature*)pet);
+        // visual effect for levelup
+        pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel());
+ 
+        
+        if(!pet->InitStatsForLevel(player->getLevel()))
+            sLog->outError ("Pet Create fail: no init stats for entry %u", entry);
+ 
+        pet->UpdateAllStats();
+        
+        // caster have pet now
+        player->SetMinion(pet, true);
+ 
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        pet->InitTalentForLevel();
+        player->PetSpellInitialize();
+        
+        //end
+        //player->PlayerTalkClass->CloseGossip();
+        m_creature->MonsterWhisper("Pet added. You might want to feed it and name it somehow.", player->GetGUID());
+		return;
+    }
+ 
+ 
+bool OnGossipHello(Player *player, Creature * m_creature)
+{
+	bool EnableHunterSpells = ConfigMgr::GetBoolDefault("BeastMaster.EnableHunterSpells", true);
+    // Not allow in combat
+if (player->isInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    m_creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return true;
+}
+ 	if(ConfigMgr::GetBoolDefault("BeastMaster.OnlyHunter", false)) // Checks to see if Only Hunters can have pets.
+     {
+        if(player->getClass() != CLASS_HUNTER)
+        {
+            m_creature->MonsterWhisper("You are not a Hunter!", player->GetGUID());
+            return true;
+        }
+		}
+		if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+        {
+		player->ADD_GOSSIP_ITEM(4, "(100 Chips) Get a New Pet.", GOSSIP_SENDER_MAIN, 30);
+		} else {
+        player->ADD_GOSSIP_ITEM(4, "(100 Gold) Get a New Pet.", GOSSIP_SENDER_MAIN, 30);
+		}
+		if(ConfigMgr::GetBoolDefault("BeastMaster.EnableExotic", false))
+		{
+        if (player->CanTameExoticPets())
+        {
+            if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+			player->ADD_GOSSIP_ITEM(4, "(200 Chips) Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+			else
+			player->ADD_GOSSIP_ITEM(4, "(200 Gold) Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+        }
+		} else {
+            if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+			player->ADD_GOSSIP_ITEM(4, "(200 Chips) Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+			else
+			player->ADD_GOSSIP_ITEM(4, "(200 Gold) Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+			}
+		if(EnableHunterSpells)
+	    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 6000);
+        player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, GOSSIP_OPTION_STABLEPET);
+        player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, GOSSIP_OPTION_VENDOR);
+                player->ADD_GOSSIP_ITEM(5, "Close Beastmaster Window.", GOSSIP_SENDER_MAIN, 150);
+        player->SEND_GOSSIP_MENU(BEAST_MSG, m_creature->GetGUID());
+        return true;
+    }
+ 
+bool OnGossipSelect(Player *player, Creature * m_creature, uint32 sender, uint32 action)
+    {
+                player->PlayerTalkClass->ClearMenus();
+        switch (action)
+        {
+
+        case 100:
+		    if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+            player->ADD_GOSSIP_ITEM(4, "(100 Tokens) Get a New Pet.", GOSSIP_SENDER_MAIN, 30);
+			else
+            player->ADD_GOSSIP_ITEM(4, "(100 Gold) Get a New Pet.", GOSSIP_SENDER_MAIN, 30);
+			if(ConfigMgr::GetBoolDefault("BeastMaster.EnableExotic", false))
+			{
+            if (player->CanTameExoticPets())
+            {
+                player->ADD_GOSSIP_ITEM(4, "Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+            }
+			}else 
+			player->ADD_GOSSIP_ITEM(4, "Get a New Exotic Pet.", GOSSIP_SENDER_MAIN, 50);
+            player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, GOSSIP_OPTION_STABLEPET);
+            player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, GOSSIP_OPTION_VENDOR);
+                        player->ADD_GOSSIP_ITEM(5, "Close Beastmaster Window.", GOSSIP_SENDER_MAIN, 150);
+            player->SEND_GOSSIP_MENU(MSG_CHOOSE, m_creature->GetGUID());
+                break;
+
+                case 150:
+                        player->CLOSE_GOSSIP_MENU();
+                break;
+        
+        case 30:
+            player->ADD_GOSSIP_ITEM(2, "<- Back to Main Menu.", GOSSIP_SENDER_MAIN, 100);
+            player->ADD_GOSSIP_ITEM(4, "Next Page. ->", GOSSIP_SENDER_MAIN, 31);
+            player->ADD_GOSSIP_ITEM(6, "Bat.", GOSSIP_SENDER_MAIN, 18);
+            player->ADD_GOSSIP_ITEM(6, "Bear.", GOSSIP_SENDER_MAIN, 1);
+            player->ADD_GOSSIP_ITEM(6, "Boar.", GOSSIP_SENDER_MAIN, 2);
+            player->ADD_GOSSIP_ITEM(6, "Cat.", GOSSIP_SENDER_MAIN, 4);
+            player->ADD_GOSSIP_ITEM(6, "Carrion Bird.", GOSSIP_SENDER_MAIN, 5);
+            player->ADD_GOSSIP_ITEM(6, "Crab.", GOSSIP_SENDER_MAIN, 6);
+            player->ADD_GOSSIP_ITEM(6, "Crocolisk.", GOSSIP_SENDER_MAIN, 7);
+            player->ADD_GOSSIP_ITEM(6, "Dragonhawk.", GOSSIP_SENDER_MAIN, 17);
+            player->ADD_GOSSIP_ITEM(6, "Gorilla.", GOSSIP_SENDER_MAIN, 8);
+            player->ADD_GOSSIP_ITEM(6, "Hyena.", GOSSIP_SENDER_MAIN, 9);
+            player->ADD_GOSSIP_ITEM(6, "Moth.", GOSSIP_SENDER_MAIN, 10);
+            player->ADD_GOSSIP_ITEM(6, "Owl.", GOSSIP_SENDER_MAIN, 11);
+            player->SEND_GOSSIP_MENU(MSG_CHOOSE, m_creature->GetGUID());
+                break;
+        
+        case 31:  
+            player->ADD_GOSSIP_ITEM(2, "<- Back to Main Menu.", GOSSIP_SENDER_MAIN, 30);
+            player->ADD_GOSSIP_ITEM(4, "<- Previous Page.", GOSSIP_SENDER_MAIN, 30);
+            player->ADD_GOSSIP_ITEM(6, "Raptor.", GOSSIP_SENDER_MAIN, 20);
+            player->ADD_GOSSIP_ITEM(6, "Ravager.", GOSSIP_SENDER_MAIN, 19);
+            player->ADD_GOSSIP_ITEM(6, "Strider.", GOSSIP_SENDER_MAIN, 13);
+            player->ADD_GOSSIP_ITEM(6, "Scorpid.", GOSSIP_SENDER_MAIN, 414);
+            player->ADD_GOSSIP_ITEM(6, "Spider.", GOSSIP_SENDER_MAIN, 16);
+            player->ADD_GOSSIP_ITEM(6, "Serpent.", GOSSIP_SENDER_MAIN, 21);  
+            player->ADD_GOSSIP_ITEM(6, "Wasp.", GOSSIP_SENDER_MAIN, 93);
+            player->SEND_GOSSIP_MENU(MSG_CHOOSE, m_creature->GetGUID());
+                break;
+        
+        case 50:  
+            player->ADD_GOSSIP_ITEM(2, "<- Back to Main Menu.", GOSSIP_SENDER_MAIN, 100);
+                        player->ADD_GOSSIP_ITEM(2, "<- Get a New Normal Pet.", GOSSIP_SENDER_MAIN, 100);
+            player->ADD_GOSSIP_ITEM(6, "Chimaera.", GOSSIP_SENDER_MAIN, 51);
+            player->ADD_GOSSIP_ITEM(6, "Core Hound.", GOSSIP_SENDER_MAIN, 52);
+            player->ADD_GOSSIP_ITEM(6, "Devilsaur.", GOSSIP_SENDER_MAIN, 53);
+            player->ADD_GOSSIP_ITEM(6, "Rhino.", GOSSIP_SENDER_MAIN, 54);
+            player->ADD_GOSSIP_ITEM(6, "Silithid.", GOSSIP_SENDER_MAIN, 55);
+            player->ADD_GOSSIP_ITEM(6, "Worm.", GOSSIP_SENDER_MAIN, 56);  
+            player->ADD_GOSSIP_ITEM(6, "Loque'nahak.", GOSSIP_SENDER_MAIN, 57);
+            player->ADD_GOSSIP_ITEM(6, "Skoll.", GOSSIP_SENDER_MAIN, 58);
+            player->ADD_GOSSIP_ITEM(6, "Gondria.", GOSSIP_SENDER_MAIN, 59);
+            player->SEND_GOSSIP_MENU(MSG_CHOOSE, m_creature->GetGUID());
+                break;
+      
+            case GOSSIP_OPTION_STABLEPET:
+                player->GetSession()->SendStablePet(m_creature->GetGUID());
+            break; 
+            case GOSSIP_OPTION_VENDOR:
+				player->GetSession()->SendListInventory(m_creature->GetGUID());
+            break;
+            case 51: //chimera
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 21879);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 21879);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+			break;
+            case 52: //core hound
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+			    CreatePet(player, m_creature, 21108);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 21108);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 53: //Devilsaur
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 20931);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 20931);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 54: //rhino
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 30445);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 30445);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 55: //silithid
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 5460);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 5460);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 56: //Worm
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 30148);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 30148);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 57: //Loque'nahak
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 32517);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 32517);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 58: //Skoll
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 35189);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 35189);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 59: //Gondria
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.ExoticTokens",0)), true);
+				CreatePet(player, m_creature, 33776);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 33776);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.ExoticCost",0)));
+					}
+            break;
+            case 16: //Spider
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 2349);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 2349);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 17: //Dragonhawk
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 27946);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 27946);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 18: //Bat
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 28233);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 28233);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 19: //Ravager
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 17199);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 17199);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 20: //Raptor
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 14821);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 14821);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 21: //Serpent
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 28358);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 28358);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 1: //bear
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 29319);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 29319);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 2: //Boar
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				               CreatePet(player, m_creature, 29996);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 29996);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+            break;
+            case 93: //Bug
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 28085);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 28085);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 4: //cat
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 28097);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 28097);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 5: //carrion
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 26838);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 26838);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 6: //crab
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 24478);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 24478);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;   
+            case 7: //crocolisk
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 1417);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 1417);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;  
+            case 8: //gorilla
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 28213);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 28213);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 9: //hynea
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 13036);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 13036);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 10: //Moth
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 27421);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 27421);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 11: //owl
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 23136);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 23136);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 13: //strider
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 22807);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 22807);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+            case 414: //scorpid
+                if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				    {
+				    if (!player->HasItemCount((ConfigMgr::GetIntDefault("BeastMaster.ItemEntryNum",0)), (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0))))
+                        {
+                        player->CLOSE_GOSSIP_MENU();
+                        m_creature->MonsterWhisper("You ain't gots no darn chips.", player->GetGUID());
+                        return true;
+                        } else {
+				               player->DestroyItemCount(99999, (ConfigMgr::GetIntDefault("BeastMaster.NormalTokens",0)), true);
+				CreatePet(player, m_creature, 9698);
+				               }
+					}
+				else if (player->GetMoney() < (ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)))
+                    {
+                    player->CLOSE_GOSSIP_MENU();
+                    m_creature->MonsterWhisper("You don't have enough money.", player->GetGUID());
+                    return true;
+                    } else {
+					CreatePet(player, m_creature, 9698);
+				    player->ModifyMoney(-(ConfigMgr::GetIntDefault("BeastMaster.NormalCost",0)));
+					}
+                        break;
+        case 6000: // buy hunter spells
+		    player->ADD_GOSSIP_ITEM( 5, "(200 chips) Learn Call Pet"              , GOSSIP_SENDER_MAIN, 6001);
+            player->ADD_GOSSIP_ITEM( 5, "(200 chips) Learn Dismiss Pet"           , GOSSIP_SENDER_MAIN, 6002);
+			player->ADD_GOSSIP_ITEM( 5, "(200 chips) Learn Feed Pet"              , GOSSIP_SENDER_MAIN, 6003);
+            player->ADD_GOSSIP_ITEM(2, "<- Back to Main Menu."                    , GOSSIP_SENDER_MAIN, 100);
+			
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,m_creature->GetGUID());
+		break;
+
+		case 6001: // Call Pet
+            if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				{
+				if (!player->HasItemCount(99999, 200))
+                    {
+                player->CLOSE_GOSSIP_MENU();
+                m_creature->MonsterWhisper("You need at least 200 credit Chips to learn this.", player->GetGUID());
+                return true;
+                } else
+			player->learnSpell(883,false); // call pet
+			player->DestroyItemCount(99999, 200, true);
+			player->CLOSE_GOSSIP_MENU();
+			}
+		break;
+
+		case 6002: // Dismiss Pet
+            if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				{
+				if (!player->HasItemCount(99999, 200))
+                    {
+                player->CLOSE_GOSSIP_MENU();
+                m_creature->MonsterWhisper("You need at least 200 credit Chips to learn this.", player->GetGUID());
+                return true;
+                } else
+			player->learnSpell(2641,false); // call pet
+			player->DestroyItemCount(99999, 200, true);
+			player->CLOSE_GOSSIP_MENU();
+			}
+		break;
+
+		case 6003: // Feed Pet
+            if(ConfigMgr::GetBoolDefault("BeastMaster.UseTokens", true))
+				{
+				if (!player->HasItemCount(99999, 200))
+                    {
+                player->CLOSE_GOSSIP_MENU();
+                m_creature->MonsterWhisper("You need at least 200 credit Chips to learn this.", player->GetGUID());
+                return true;
+                } else
+			player->learnSpell(6991,false); // call pet
+			player->DestroyItemCount(99999, 200, true);
+			player->CLOSE_GOSSIP_MENU();
+			}
+		break;
+
+        }
+        return true;
+    }
+};
+ 
+void AddSC_Npc_Beastmaster()
+{
+    new Npc_Beastmaster();
+}
diff --git a/src/server/scripts/Custom/city_conquest_boss.cpp b/src/server/scripts/Custom/city_conquest_boss.cpp
new file mode 100644
index 0000000..334a0de
--- /dev/null
+++ b/src/server/scripts/Custom/city_conquest_boss.cpp
@@ -0,0 +1,76 @@
+#include "ScriptPCH.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "../../game/CityConquest/CityConquestMgr.h"
+
+static int entry;
+
+struct city_conquest_bossAI : public ScriptedAI
+{
+    city_conquest_bossAI(Creature *c) : ScriptedAI(c)
+	{
+		sLog->outString("CQM: Boss loaded to world - %u", me->GetEntry());
+		CityConquest.RegisterCreature(me, 1);
+		entry = me->GetEntry();
+	}
+
+    void Reset()
+    {
+
+    }
+
+    void EnterCombat(Unit* pWho)
+    {
+
+    }
+
+    void EnterEvadeMode()
+    {
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        DoMeleeAttackIfReady();
+    }
+
+	void JustDied(Unit* Killer)
+    {
+		QueryResult result
+			= WorldDatabase.PQuery("SELECT city_id, boss_entry_A, boss_entry_H FROM city_capture_bosses WHERE boss_entry_A = %u OR boss_entry_H = %u OR "
+			//                             0        1             2
+			"spawner_entry = %u", entry, entry, entry);
+
+		if (result)
+		{
+			Field *fields = result->Fetch();
+			Cities::iterator l;
+			for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+			{
+				City *ct = *l;
+				if (ct->id == fields[0].GetInt32())
+				{
+					if (entry == fields[2].GetInt32() || entry == fields[1].GetInt32())
+					{
+						CityConquest.SwitchFaction(ct->id);
+						return;
+					}
+				}
+			}
+		}
+    }
+};
+class city_conquest_boss : public CreatureScript
+{
+public:
+    city_conquest_boss() : CreatureScript("city_conquest_boss") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+    return new city_conquest_bossAI (creature);
+	}
+};
+
+void AddSC_city_conquest_boss()
+{
+    new city_conquest_boss;
+}
diff --git a/src/server/scripts/Custom/city_conquest_generic.cpp b/src/server/scripts/Custom/city_conquest_generic.cpp
new file mode 100644
index 0000000..a8c82ac
--- /dev/null
+++ b/src/server/scripts/Custom/city_conquest_generic.cpp
@@ -0,0 +1,51 @@
+#include "ScriptPCH.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "../../game/CityConquest/CityConquestMgr.h"
+
+struct city_conquest_genericAI : public ScriptedAI
+{
+    city_conquest_genericAI(Creature *c) : ScriptedAI(c)
+	{
+		sLog->outString("CQM: Generic creature loaded to world - %u", me->GetEntry());
+		CityConquest.RegisterCreature(me, 0);
+	}
+
+    void Reset()
+    {
+
+    }
+
+    void EnterCombat(Unit* pWho)
+    {
+
+    }
+
+    void EnterEvadeMode()
+    {
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        DoMeleeAttackIfReady();
+    }
+};
+
+class city_conquest_generic : public CreatureScript
+{
+public:
+    city_conquest_generic() : CreatureScript("city_conquest_generic") { }
+
+	CreatureAI *GetAI(Creature *creature) const
+    {
+    return new city_conquest_genericAI (creature);
+	}
+
+};
+
+void AddSC_city_conquest_generic()
+{
+
+    new city_conquest_generic;
+
+}
diff --git a/src/server/scripts/Custom/city_conquest_portal.cpp b/src/server/scripts/Custom/city_conquest_portal.cpp
new file mode 100644
index 0000000..fbd878e
--- /dev/null
+++ b/src/server/scripts/Custom/city_conquest_portal.cpp
@@ -0,0 +1,201 @@
+#include "ScriptPCH.h"
+#include "../../game/CityConquest/CityConquestMgr.h"
+#include <stdio.h>
+#include <time.h>
+#include <list>
+#define START_OFFSET			2000
+#define PORT_OFFSET				5000
+#define GOSSIP_ACTION_MAIN		1000
+#define GOSSIP_ACTION_SARTLIST	1003
+#define GOSSIP_ACTION_PORTLIST	1001
+#define GOSSIP_ACTION_CLOSE		1002
+#define CC_GREET                100006
+#define CC_MENU                 100007
+
+int GetActiveSieges(Player* pPlayer)
+{
+	int side = 1;
+	if(pPlayer->TeamForRace(pPlayer->getRace())==ALLIANCE)
+		side = 0;
+	Cities::iterator l;
+	int i = 0;
+	for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+	{
+		City *ct = *l;
+		if (ct->controlled != side && ct->active == true)
+		{
+			i++;
+		}
+	}
+	return i;
+}
+
+int GetActiveSiegesAll(Player* pPlayer)
+{
+	Cities::iterator l;
+	int i = 0;
+	for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+	{
+		City *ct = *l;
+		if (ct->active == true)
+		{
+			i++;
+		}
+	}
+	return i;
+}
+
+void StartSiegeList(int beginAt, Player* pPlayer, Creature* pCreature)
+{
+	Cities::iterator l;
+	int side = 1;
+	if(pPlayer->TeamForRace(pPlayer->getRace())==ALLIANCE)
+		side = 0;
+
+	int i = 0;
+	int lastid = 0;
+	for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+	{
+		City *ct = *l;
+		if (ct->controlled != side && ct->active == false && ct->minlevel <= pPlayer->getLevel() && ct->maxlevel >= pPlayer->getLevel() && CityConquest.CanStartSiege(ct->id, side) && ct->id >= beginAt)
+		{
+			if (i < 8)
+				lastid = ct->id;
+			if (i < 9)
+			{
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ct->name, GOSSIP_SENDER_MAIN, START_OFFSET + ct->id);
+				i++;
+			}
+			else if (i == 9)
+			{
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Next >>", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SARTLIST + lastid);
+				i++;
+			}
+
+		}
+	}
+	pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<< Back", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_MAIN);
+	pPlayer->SEND_GOSSIP_MENU(CC_MENU, pCreature->GetGUID());
+}
+
+void TeleportList( Player* pPlayer, Creature* pCreature)
+{
+	Cities::iterator l;
+	int side = 1;
+	if(pPlayer->TeamForRace(pPlayer->getRace())==ALLIANCE)
+		side = 0;
+
+	for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+	{
+		City *ct = *l;
+		if (ct->active == true)
+		{
+			char * nm;
+			nm = new char[ct->name.size()+1];
+			nm[ct->name.size()] = 0;
+			memcpy(nm, ct->name.c_str(), ct->name.size());
+			char msg[500];
+
+			if (ct->controlled == side)
+			{
+				sprintf(msg, "Defend: %s", nm);
+
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, msg, GOSSIP_SENDER_MAIN, PORT_OFFSET + ct->id);
+			}
+			else
+			{
+				sprintf(msg, "Attack: %s", nm);
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, msg, GOSSIP_SENDER_MAIN, PORT_OFFSET + ct->id);
+			}
+
+		}
+	}
+
+	pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<< Back", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_MAIN);
+	pPlayer->SEND_GOSSIP_MENU(CC_MENU, pCreature->GetGUID());
+}
+
+void MainMenu(Player* pPlayer, Creature* pCreature)
+{
+	
+	if (GetActiveSieges(pPlayer) < 5)
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "New Conquest", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SARTLIST + 1);
+	    
+	if (GetActiveSiegesAll(pPlayer) > 0)
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Aid in Conquest", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_PORTLIST);
+	    
+	pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Bye", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_CLOSE);
+	pPlayer->SEND_GOSSIP_MENU(CC_GREET, pCreature->GetGUID());
+}
+class city_conquest_portal : public CreatureScript
+{
+public:
+    city_conquest_portal() : CreatureScript("city_conquest_portal") {}
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    MainMenu(pPlayer, pCreature);
+	return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 action)
+{
+	pPlayer->PlayerTalkClass->ClearMenus();
+	int id = 0;
+	int side = 1;
+		if(pPlayer->TeamForRace(pPlayer->getRace())==ALLIANCE)
+			side = 0;
+
+	if (action >= PORT_OFFSET)
+	{
+		id = action - PORT_OFFSET;
+		Cities::iterator l;
+		for (l = CityConquest.cities.begin(); l != CityConquest.cities.end(); ++l)
+		{
+			City *ct = *l;
+			if (ct->id == id)
+			{
+				if (ct->controlled == side)
+					pPlayer->TeleportTo(ct->port_defense->map, ct->port_defense->x, ct->port_defense->y, ct->port_defense->z, ct->port_defense->o, 0);
+				else
+					pPlayer->TeleportTo(ct->port_attack->map, ct->port_attack->x, ct->port_attack->y, ct->port_attack->z, ct->port_attack->o, 0);
+				pPlayer->PlayerTalkClass->SendCloseGossip();
+			}
+		}
+	}
+	else if (action >= START_OFFSET)
+	{
+		int side = 1;
+		if(pPlayer->TeamForRace(pPlayer->getRace())==ALLIANCE)
+			side = 0;
+		id = action - START_OFFSET;
+		CityConquest.StartSiege(id, side);
+		MainMenu(pPlayer, pCreature);
+	}
+	else if (action >= GOSSIP_ACTION_SARTLIST)
+	{
+		id = action - GOSSIP_ACTION_SARTLIST;
+		StartSiegeList(id, pPlayer, pCreature);
+	}
+	else if (action == GOSSIP_ACTION_CLOSE)
+	{
+		pPlayer->PlayerTalkClass->SendCloseGossip();
+	}
+	else if (action == GOSSIP_ACTION_PORTLIST)
+	{
+		TeleportList(pPlayer, pCreature);
+	}
+	else if (action == GOSSIP_ACTION_MAIN)
+	{
+		MainMenu(pPlayer, pCreature);
+	}
+
+    return true;
+}
+};
+
+
+void AddSC_city_conquest_portal()
+{
+    new city_conquest_portal;
+}
diff --git a/src/server/scripts/Custom/city_conquest_spawner.cpp b/src/server/scripts/Custom/city_conquest_spawner.cpp
new file mode 100644
index 0000000..aa3404b
--- /dev/null
+++ b/src/server/scripts/Custom/city_conquest_spawner.cpp
@@ -0,0 +1,67 @@
+#include "ScriptPCH.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "../../game/CityConquest/CityConquestMgr.h"
+
+static int entry;
+
+struct city_conquest_spawnerAI : public ScriptedAI
+{
+    city_conquest_spawnerAI(Creature *c) : ScriptedAI(c)
+	{
+		sLog->outString("CQM: Generic creature loaded to world - %u", me->GetEntry());
+		CityConquest.RegisterCreature(me, 2);
+		entry = me->GetEntry();
+	}
+
+    void Reset()
+    {
+
+    }
+
+    void EnterCombat(Unit* pWho)
+    {
+
+    }
+
+    void EnterEvadeMode()
+    {
+    }
+
+	void SummonedCreatureDespawn(Creature *pSummoned)
+    {
+		QueryResult result
+			= WorldDatabase.PQuery("SELECT city_id FROM city_capture_bosses WHERE  "
+			//                             0
+			"spawner_entry = %u", entry);
+
+		if (result)
+		{
+			Field *fields = result->Fetch();
+			CityConquest.EndSiege(fields[0].GetInt32());
+		}
+
+    }
+
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        DoMeleeAttackIfReady();
+    }
+};
+
+class city_conquest_spawner : public CreatureScript
+{
+public:
+    city_conquest_spawner() : CreatureScript("city_conquest_spawner") {}
+
+	CreatureAI *GetAI(Creature *creature) const
+    {
+    return new city_conquest_spawnerAI (creature);
+	}
+};
+
+void AddSC_city_conquest_spawner()
+{
+    new city_conquest_spawner;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
new file mode 100644
index 0000000..38c3b7a
--- /dev/null
+++ b/src/server/scripts/Custom/guildmaster.cpp
@@ -0,0 +1,339 @@
+#include "ScriptPCH.h"
+
+//extern DatabaseMysql SD2Database;
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to GuildHouse"
+#define MSG_GOSSIP_BUY           "Buy GuildHouse (1000 gold)"
+#define MSG_GOSSIP_SELL          "Sell GuildHouse (500 gold)"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in combat and cannot be teleported to your GuildHouse."
+#define MSG_NOGUILDHOUSE         "Your guild currently does not own a GuildHouse."
+#define MSG_NOFREEGH             "Unfortunately, all GuildHouses are in use."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already own a GuildHouse (%s)."
+#define MSG_NOTENOUGHMONEY       "You do not have the %u gold required to purchase a GuildHouse."
+#define MSG_GHOCCUPIED           "This GuildHouse is unavailable for purchase as it is currently in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You have successfully purchased a GuildHouse."
+#define MSG_SOLD                 "You have sold your GuildHouse and have received %u gold."
+#define MSG_NOTINGUILD           "You need to be in a guild before you can use a GuildHouse."
+
+#define CODE_SELL "SELL"
+#define MSG_CODEBOX_SELL "Type \"" CODE_SELL "\" into the field to confirm that you want to sell your GuildHouse."
+
+#define OFFSET_GH_ID_TO_ACTION 1500
+#define OFFSET_SHOWBUY_FROM 10000
+
+#define ACTION_TELE 1001
+#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE 1003
+
+#define ICON_GOSSIP_BALOON 0
+#define ICON_GOSSIP_WING 2
+#define ICON_GOSSIP_BOOK 3
+#define ICON_GOSSIP_WHEEL1 4
+#define ICON_GOSSIP_WHEEL2 5
+#define ICON_GOSSIP_GOLD 6
+#define ICON_GOSSIP_BALOONDOTS 7
+#define ICON_GOSSIP_TABARD 8
+#define ICON_GOSSIP_XSWORDS 9
+
+#define COST_GH_BUY 10000000 //1000 g.
+#define COST_GH_SELL 5000000 //500 g.
+
+#define GOSSIP_COUNT_MAX 10
+
+bool isPlayerGuildLeader(Player *player)
+{
+ return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+ if (guildId == 0)
+ {
+ //if player has no guild
+ return false;
+ }
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
+ if (result)
+ {
+ Field *fields = result->Fetch();
+ x = fields[0].GetFloat();
+ y = fields[1].GetFloat();
+ z = fields[2].GetFloat();
+ map = fields[3].GetUInt32();
+ return true;
+ }
+
+ return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+ if (player->GetGuildId() == 0)
+ {
+ //if player has no guild
+ _creature->MonsterWhisper(MSG_NOTINGUILD, player->GetGUID());
+ return;
+ }
+
+ if (!player->getAttackers().empty())
+ {
+ //if player in combat
+ _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player->GetGUID());
+ return;
+ }
+
+ float x, y, z;
+ uint32 map;
+
+ if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+ {
+ //teleport player to the specified location
+ player->TeleportTo(map, x, y, z, 0.0f);
+ }
+ else
+ _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player->GetGUID());
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+ //show not occupied guildhouses
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+ showFromId, GOSSIP_COUNT_MAX);
+
+ if (result)
+ {
+ uint32 guildhouseId = 0;
+ std::string comment = "";
+ do
+ {
+ Field *fields = result->Fetch();
+ guildhouseId = fields[0].GetInt32();
+ comment = fields[1].GetString();
+
+ //send comment as a gossip item
+ //transmit guildhouseId in Action variable
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_GH_ID_TO_ACTION);
+ }
+ while (result->NextRow());
+
+ if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+ {
+ //assume that we have additional page
+ //add link to next GOSSIP_COUNT_MAX items
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_SHOWBUY_FROM);
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //all guildhouses are occupied
+ _creature->MonsterWhisper(MSG_NOFREEGH, player->GetGUID());
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+ //just show GHs from beginning
+ showBuyList(player, _creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ {
+ if (whisper)
+ {
+ //whisper to player "already have etc..."
+ Field *fields = result->Fetch();
+ char msg[100];
+ sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetString());
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ }
+
+ return true;
+ }
+
+ return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+ if (player->GetMoney() < COST_GH_BUY)
+ {
+ //show how much money player need to buy GH (in gold)
+ char msg[100];
+ sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY / 10000);
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ return;
+ }
+
+ if (isPlayerHasGuildhouse(player, _creature, true))
+ {
+ //player already have GH
+ return;
+ }
+
+ QueryResult result;
+
+ //check if somebody already occupied this GH
+ result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
+
+ if (result)
+ {
+ _creature->MonsterWhisper(MSG_GHOCCUPIED, player->GetGUID());
+ return;
+ }
+
+ //update DB
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
+ player->GetGuildId(), guildhouseId);
+
+ if (result)
+ player->ModifyMoney(-COST_GH_BUY);
+ _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player->GetGUID());
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ QueryResult result;
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ player->ModifyMoney(COST_GH_SELL);
+
+ //display message e.g. "here your money etc."
+ char msg[100];
+ sprintf(msg, MSG_SOLD, COST_GH_SELL / 10000);
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ }
+}
+
+class guildmaster : public CreatureScript
+{
+ public:
+ guildmaster() : CreatureScript("guildmaster") { }
+
+ bool GossipSelectWithCode(Player *player, Creature *_creature, uint32 sender, uint32 action, const char* sCode)
+ {
+ if (sender == GOSSIP_SENDER_MAIN)
+ {
+ if (action == ACTION_SELL_GUILDHOUSE)
+ {
+ int i = -1;
+ try
+ {
+ //compare code
+
+ if (strlen(sCode) + 1 == sizeof CODE_SELL)
+ i = strcmp(CODE_SELL, sCode);
+ }
+
+ catch(char *str) {sLog->outErrorDb(str);
+ }
+
+ if (i == 0)
+ {
+ //right code
+ sellGuildhouse(player, _creature);
+ }
+
+ player->CLOSE_GOSSIP_MENU();
+ return true;
+ }
+ }
+ return false;
+}
+
+ bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
+ {
+ player->PlayerTalkClass->ClearMenus();
+ if (sender != GOSSIP_SENDER_MAIN)
+ return false;
+
+ switch (action)
+ {
+ case ACTION_TELE:
+ //teleport player to GH
+ player->CLOSE_GOSSIP_MENU();
+ teleportPlayerToGuildHouse(player, _creature);
+ break;
+ case ACTION_SHOW_BUYLIST:
+ //show list of GHs which currently not occupied
+ showBuyList(player, _creature);
+ break;
+ default:
+ if (action > OFFSET_SHOWBUY_FROM)
+ {
+ showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+ }
+ else if (action > OFFSET_GH_ID_TO_ACTION)
+ {
+ //player clicked on buy list
+ player->CLOSE_GOSSIP_MENU();
+
+ //get guildhouseId from action
+ //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+ buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+ }
+ break;
+ }
+
+ return true;
+ }
+
+
+ bool OnGossipHello(Player *player, Creature *_creature)
+ {
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE,
+ GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+ if (isPlayerGuildLeader(player))
+ {
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ //and additional for guildhouse owner (Removed :
+ player->PlayerTalkClass->GetGossipMenu().AddMenuItem(ICON_GOSSIP_GOLD, 0, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_CODEBOX_SELL, 0, true);
+ }
+ else
+ {
+ //show additional menu for guild leader
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY,
+ GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+ }
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+ return true;
+ }
+
+
+};
+void AddSC_guildmaster()
+{
+ new guildmaster();
+}
diff --git a/src/server/scripts/Custom/levelnpc.cpp b/src/server/scripts/Custom/levelnpc.cpp
new file mode 100644
index 0000000..a98b9b7
--- /dev/null
+++ b/src/server/scripts/Custom/levelnpc.cpp
@@ -0,0 +1,194 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created by LordPsyan for Flaminglegion.net
+ *
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+#define LEVEL_MSG                100004
+#define MSG_CHOOSE                100005
+
+class levelnpc : public CreatureScript
+{
+public:
+    levelnpc() : CreatureScript("levelnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+	if(ConfigMgr::GetBoolDefault("LevelNPC.OnlyGMs", false)) // If LevelNPC.OnlyGMs is enabled in trinitycore.conf
+		if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+		{
+			pCreature->MonsterWhisper("Sorry, I can only add levels to Platinum Members.", pPlayer->GetGUID());
+			return true;
+		}
+
+	bool EnableLevel80 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel80", true);
+	bool EnableLevel100 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel100", true);
+	bool EnableLevel150 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel150", true);
+	bool EnableLevel200 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel200", true);
+	bool EnableLevel255 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel255", true);
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+	}
+	else
+	{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+	}
+    pPlayer->SEND_GOSSIP_MENU(LEVEL_MSG,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->isInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+	bool EnableLevel80 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel80", true);
+	bool EnableLevel100 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel100", true);
+	bool EnableLevel150 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel150", true);
+	bool EnableLevel200 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel200", true);
+	bool EnableLevel255 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel255", true);
+	
+//Mony Check
+if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((ConfigMgr::GetIntDefault("LevelNPC.ItemEntryNum",0)), 0))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer->GetGUID());
+	return;
+}
+}
+else if(pPlayer->GetMoney() < (ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+	return;
+}
+
+switch(uiAction)
+{
+
+//////////////////////////////////////////////////Leveling///////////////////////////////////////////////////////////////
+case 1000: //Leveling
+	if(EnableLevel80 && pPlayer->getLevel() < 80)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(1 Donation Chip) Instant 80 ->"         , GOSSIP_SENDER_MAIN, 1001);
+	if(EnableLevel100 && pPlayer->getLevel() < 100 && pPlayer->getLevel() >= 80)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(2 Donation Chips) Instant 100 ->"        , GOSSIP_SENDER_MAIN, 1002);
+	if(EnableLevel150 && pPlayer->getLevel() < 150 && pPlayer->getLevel() >= 100)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(5 Donation Chips) Instant 150 ->"        , GOSSIP_SENDER_MAIN, 1003);
+	if(EnableLevel200 && pPlayer->getLevel() < 200 && pPlayer->getLevel() >= 150)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(10 Donation Chips) Instant 200 ->"       , GOSSIP_SENDER_MAIN, 1004);
+	if(EnableLevel255 && pPlayer->getLevel() < 255 && pPlayer->getLevel() >= 200)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(20 Donation Chips) Instant 255 ->"       , GOSSIP_SENDER_MAIN, 1005);
+		pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                       , GOSSIP_SENDER_MAIN, 3000);
+	pPlayer->SEND_GOSSIP_MENU(MSG_CHOOSE,pCreature->GetGUID());
+break;
+case 3000: //Leveling
+	if(EnableLevel80)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+    pPlayer->SEND_GOSSIP_MENU(MSG_CHOOSE,pCreature->GetGUID());
+break;
+case 1001: // Leveling
+	pPlayer->GiveLevel(80);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1002: // Leveling
+	pPlayer->GiveLevel(100);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 2, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1003: // Leveling
+	pPlayer->GiveLevel(150);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 5, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1004: // Leveling
+	pPlayer->GiveLevel(200);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 10, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1005: // Leveling
+	pPlayer->GiveLevel(255);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 20, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 5000://Remove Res Sickness
+	if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+	{
+		pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+	pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+	// Main menu
+	pPlayer->PlayerTalkClass->ClearMenus();
+	if (uiSender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_levelnpc()
+{
+
+new levelnpc();
+
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..1e51336
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,221 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->isGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->isGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->isGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (!player->isGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->isInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player->GetGUID());
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
diff --git a/src/server/scripts/Custom/npcbuff.cpp b/src/server/scripts/Custom/npcbuff.cpp
new file mode 100644
index 0000000..9bd8a55
--- /dev/null
+++ b/src/server/scripts/Custom/npcbuff.cpp
@@ -0,0 +1,425 @@
+/* Copyright (C) 2010 SAMCC Studios <http://www.samccstudios.com/>
+ * Written by LordPsyan
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+ /* 
+Script Name: npc_buff v1.1
+Complete: 100%
+Comment: Database Driven Buff Master
+*/
+
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define GOSSIP_SMALLBUFF        2000
+#define GOSSIP_LARGEBUFF        3000
+#define GOSSIP_GMBUFF           4000
+#define GOSSIP_PLAYERTOOLS      5000
+
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+#define NB_BUFF_PAGE            10
+#define MSG_TYPE                100002
+#define MSG_BUFF                100003
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+class npc_buff : public CreatureScript
+{
+public:
+    npc_buff() : CreatureScript("npc_buff") {}
+	
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+	if(ConfigMgr::GetBoolDefault("Npc_Buff.OnlyGMs", false)) // If Npc_Buff.OnlyGMs is enabled in worldserver.conf
+		if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+		{
+			pCreature->MonsterWhisper("Sorry, I can only Buff Platinum Members.", pPlayer->GetGUID());
+			return true;
+		}
+
+	bool EnableSmallBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+	bool EnableGreatBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+	bool EnableGMBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+	bool EnablePlayerTools = ConfigMgr::GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+	bool EnableResSickness = ConfigMgr::GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+	bool EnableGivemeGold = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+	// Main Menu
+
+	// Check config if "Small  Buff " is enabled or not
+	if(EnableSmallBuff)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Great Buff" is enabled or not
+	if(EnableGreatBuff)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_SENDER_MAIN, 2000);
+	// Check config if "GM Buff" is enabled or not
+	if(EnableGMBuff)
+	{
+	if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+		{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+		}
+	}
+	// Check config if "Player Tools" is enabled or not
+	if(EnablePlayerTools)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_SENDER_MAIN, 4000);
+
+	// Check config file if "Remove res sickness" option is enabled or not
+	if(EnableResSickness)
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+
+return true;
+}
+
+bool showSmallBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+ 
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+ 
+	pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ 
+ //show Spells from beginning
+ showSmallBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGreatBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+ 
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 3000 AND `cat_number` > 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+ 
+	pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ 
+ //show Spells from beginning
+ showGreatBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGmBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+ 
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 4000 AND `cat_number` > 3000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+ 
+	pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ 
+ //show Spells from beginning
+ showGmBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPlayerTools(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+ 
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 5000 AND `cat_number` > 4000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+ 
+	pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ 
+ //show Spells from beginning
+ showPlayerTools(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->isInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+	bool EnableSmallBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+	bool EnableGreatBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+	bool EnableGMBuff = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+	bool EnablePlayerTools = ConfigMgr::GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+	bool EnableResSickness = ConfigMgr::GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+	bool EnableGivemeGold = ConfigMgr::GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+//Money Check
+if (pPlayer->GetMoney() < (ConfigMgr::GetFloatDefault("BuffGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+	return;
+}
+
+
+  // send name as gossip item
+
+
+       QueryResult result;
+		uint32 spellId = 0;
+		uint32 catNumber = 0;
+		uint32 goldCost = 0;
+		std::string spellName = "";
+
+        result = WorldDatabase.PQuery("SELECT `spell_id`, `cat_number`, `cost`, `name` FROM `npc_buff_spells` WHERE `cat_number` = %u LIMIT 1", uiAction);
+		
+        if (result)
+        {
+		
+			do {
+			
+            Field *fields = result->Fetch();
+			spellId = fields[0].GetInt32();
+			catNumber = fields[1].GetInt32();
+			goldCost = fields[2].GetInt32();
+			spellName = fields[3].GetString();
+
+            if (pPlayer->GetMoney() < goldCost)
+            {
+                pCreature->MonsterWhisper("You dont have enough money!", pPlayer->GetGUID());
+                pPlayer->CLOSE_GOSSIP_MENU();
+                return;
+            } 
+			else if (uiAction < 5000 && uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && uiAction != 4000 && uiAction != 5005)
+			{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pPlayer->CastSpell(pPlayer,spellId,false);
+    pPlayer->ModifyMoney(-goldCost);
+				
+			}
+
+			} while (result->NextRow());
+        } else {
+			//pPlayer->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+        }
+
+ switch(uiAction)
+{
+
+case 1000: //Small  Buff
+		 showSmallBuff(pPlayer, pCreature, 0);
+		//pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 2000: //Great Buff
+		
+		
+		showGreatBuff(pPlayer, pCreature, 0);
+		//pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 3000: //GM  Buff
+
+		showGmBuff(pPlayer, pCreature, 0);
+		//pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 4000: //Player Tools
+	// Check config if "Give me Gold" is enabled or not
+
+		showPlayerTools(pPlayer, pCreature, 0);
+		//pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+	// Main Menu
+	// Check config if "Small  Buff " is enabled or not
+	if(EnableSmallBuff)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SMALLBUFF, 1000);
+	// Check config if "Great Buff" is enabled or not
+	if(EnableGreatBuff)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_LARGEBUFF, 2000);
+	// Check config if "GM Buff" is enabled or not
+	if(EnableGMBuff)
+	{
+	if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+		{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+		}
+	}
+	// Check config if "Player Tools" is enabled or not
+	if(EnablePlayerTools)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_PLAYERTOOLS, 4000);
+	// Check if Ress Sickness option is enabled
+	if(EnableResSickness)
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+break;
+
+case 5000://Remove Res Sickness
+	if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+	{
+		pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+	pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+	// Main menu
+	pPlayer->PlayerTalkClass->ClearMenus();
+	if (uiSender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+void AddSC_Npc_Buff()
+{
+    new npc_buff();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/professionnpc.cpp b/src/server/scripts/Custom/professionnpc.cpp
new file mode 100644
index 0000000..faae354
--- /dev/null
+++ b/src/server/scripts/Custom/professionnpc.cpp
@@ -0,0 +1,397 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#define PROF_MSG                  100010
+#define MSG_CHOOSE                100011
+
+class professionnpc : public CreatureScript
+{
+public:
+    professionnpc() : CreatureScript("professionnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.OnlyGMs", false)) // If ProfessionNPC.OnlyGMs is enabled in trinitycore.conf
+		if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+		{
+			pCreature->MonsterWhisper("Sorry, I can only trade to game masters.", pPlayer->GetGUID());
+			return true;
+		}
+
+	bool EnableProfessions = ConfigMgr::GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+	bool EnableSecondarySkills = ConfigMgr::GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+	
+	// Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+	else // Main Menu for Horde
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+
+    pPlayer->SEND_GOSSIP_MENU(PROF_MSG,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->isInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+	bool EnableProfessions = ConfigMgr::GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+	bool EnableSecondarySkills = ConfigMgr::GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+	
+//Mony Check
+if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((ConfigMgr::GetIntDefault("ProfessionNPC.ItemEntryNum",0)), 1))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer->GetGUID());
+	return;
+}
+else if(pPlayer->GetMoney() < (ConfigMgr::GetIntDefault("SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+	return;
+}
+}
+switch(uiAction)
+{
+
+case 1000: //Profession
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Alchemy."              , GOSSIP_SENDER_MAIN, 1001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Blacksmithing."        , GOSSIP_SENDER_MAIN, 1002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Enchanting."           , GOSSIP_SENDER_MAIN, 1003);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Engineering."          , GOSSIP_SENDER_MAIN, 1004);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Herbalism."            , GOSSIP_SENDER_MAIN, 1005);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Inscription."          , GOSSIP_SENDER_MAIN, 1006);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Jewelcrafting."        , GOSSIP_SENDER_MAIN, 1007);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Leatherworking."       , GOSSIP_SENDER_MAIN, 1008);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Mining."               , GOSSIP_SENDER_MAIN, 1009);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Skinning."             , GOSSIP_SENDER_MAIN, 1010);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Tailoring."            , GOSSIP_SENDER_MAIN, 1011);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_CHOOSE,pCreature->GetGUID());
+break;
+
+case 2000: //Secondary Skills
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Cooking."              , GOSSIP_SENDER_MAIN, 2001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "First Aid."            , GOSSIP_SENDER_MAIN, 2002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Fishing."              , GOSSIP_SENDER_MAIN, 2003);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_CHOOSE,pCreature->GetGUID());
+break;
+
+case 3000: //Back To Main Menu
+	// Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+	else // Main Menu for Horde
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+
+	pPlayer->SEND_GOSSIP_MENU(MSG_CHOOSE,pCreature->GetGUID());
+break;
+
+//////////////////////////////////////////////////Professions///////////////////////////////////////////////////////////////
+
+case 1001: // Alchemy
+	if(!pPlayer->UpdateSkill(171,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(171,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1002: // Blacksmithing
+	if(!pPlayer->UpdateSkill(164,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(164,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1003: // Enchanting
+	if(!pPlayer->UpdateSkill(333,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(333,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1004: // Engineering
+	if(!pPlayer->UpdateSkill(202,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(202,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1005: // Herbalism
+	if(!pPlayer->UpdateSkill(182,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(182,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1006: // Inscription
+	if(!pPlayer->UpdateSkill(773,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(773,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1007: // Jewelcrafting
+	if(!pPlayer->UpdateSkill(755,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(755,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1008: // Leatherworking
+	if(!pPlayer->UpdateSkill(165,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(165,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1009: // Mining
+	if(!pPlayer->UpdateSkill(186,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(186,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1010: // Skinning
+	if(!pPlayer->UpdateSkill(393,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(393,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1011: // Tailoring
+	if(!pPlayer->UpdateSkill(197,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(197,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+//////////////////////////////////////////////////Secondary Skills///////////////////////////////////////////////////////////////
+
+case 2001: // Cooking
+	if(!pPlayer->UpdateSkill(185,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(185,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2002: // First Aid
+	if(!pPlayer->UpdateSkill(129,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(129,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2003: // Fishing
+	if(!pPlayer->UpdateSkill(356,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(356,(ConfigMgr::GetIntDefault("SkillPoints",0)));
+	if(ConfigMgr::GetBoolDefault("ProfessionNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99999, 1, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+	// Main menu
+	pPlayer->PlayerTalkClass->ClearMenus();
+	if (uiSender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_professionnpc()
+{
+
+new professionnpc();
+
+}
diff --git a/src/server/scripts/Custom/summon.cpp b/src/server/scripts/Custom/summon.cpp
new file mode 100644
index 0000000..5b68b72
--- /dev/null
+++ b/src/server/scripts/Custom/summon.cpp
@@ -0,0 +1,46 @@
+#include "ScriptPCH.h"
+ 
+class summon : public ItemScript
+{
+        public:
+                summon() : ItemScript("summon")
+                {
+                }
+                bool OnUse(Player* pPlayer, Item* pItem, SpellCastTargets const& /*targets*/)
+                {
+   uint32 sSpell = 18282; //Icerune Visual Spell when used
+   if (pPlayer->isInCombat())
+   {
+        pPlayer->GetSession()->SendNotification("You are in combat.");
+   }
+  
+   else if (pPlayer->isMoving())
+   {
+        pPlayer->GetSession()->SendNotification("You can not do that while moving.");
+   }
+  
+   else if (pPlayer->FindNearestCreature(100000, 40) || pPlayer->FindNearestCreature(100000, 8))
+   {
+        pPlayer->GetSession()->SendNotification("Flaming Legion Vortex can not be summoned right now. Another Vortex is nearby.");
+   }
+  
+   else
+   {
+        float x, y, z, o = pPlayer->GetOrientation();
+  
+        if (o >= 3.141592)
+         o = o - 3.141592;
+        else
+         o = o + 3.141592;
+        pPlayer->GetClosePoint(x, y, z, pPlayer->GetObjectSize());
+        Creature* pCreature = pPlayer->SummonCreature(100000, x, y, z+1.2, o, TEMPSUMMON_TIMED_DESPAWN, 80000);
+        pCreature->CastSpell(pCreature, 40162);
+        return false;
+   }
+  return false;
+                }
+};
+void AddSC_summon()
+{
+        new summon();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index 53b4788..7ed64cd 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -12,6 +12,7 @@ set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Northrend/isle_of_conquest.cpp
   Northrend/storm_peaks.cpp
+  Northrend/wintergrasp.cpp
   Northrend/Ulduar/HallsOfLightning/instance_halls_of_lightning.cpp
   Northrend/Ulduar/HallsOfLightning/boss_bjarngrim.cpp
   Northrend/Ulduar/HallsOfLightning/halls_of_lightning.h
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
index ec0de41..007740c 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
@@ -17,6 +17,8 @@
 
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 /* Vault of Archavon encounters:
 1 - Archavon the Stone Watcher event
@@ -46,6 +48,21 @@ class instance_archavon : public InstanceMapScript
                 KoralonDeath = 0;
             }
 
+            void OnPlayerEnter(Player *m_player)
+            {
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                    if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                    {
+                       if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (m_player->ToPlayer()->GetTeam() == ALLIANCE))
+                       return;
+                       else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (m_player->ToPlayer()->GetTeam() == HORDE))
+                       return;
+                       else m_player->CastSpell(m_player, SPELL_TELEPORT_FORTRESS, true);
+                    }
+                }
+            }
+
             void OnCreatureCreate(Creature* creature)
             {
                 switch (creature->GetEntry())
diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
new file mode 100644
index 0000000..e04b54e
--- /dev/null
+++ b/src/server/scripts/Northrend/wintergrasp.cpp
@@ -0,0 +1,438 @@
+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
+*
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptPCH.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+#include "Vehicle.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if (pCreature->isQuestGiver())
+        pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        if (pPlayer->HasAura(SPELL_CORPORAL))
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+        else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+        }
+    }
+    else
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+        {
+            case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+        }
+    }
+
+    return true;
+}
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_demolisher_engineererAI(pCreature);
+    }
+
+    struct npc_demolisher_engineererAI : public ScriptedAI
+    {
+        npc_demolisher_engineererAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            me->SetReactState(REACT_PASSIVE);
+        }
+    };
+
+};
+
+enum eWintergraspBattleMage
+{
+    SPELL_PORTAL_VISUAL        = 60223,
+    GO_WINTERGRASP_PORTAL    = 193772
+};
+
+class npc_wg_ally_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_ally_battle_mage() : CreatureScript("npc_wg_ally_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_ally_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_ally_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_ally_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->getSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeAlly != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.037271f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(5.515240f);
+                                    me->SendMovementFlagUpdate();
+                                    me->MonsterYell("Reinforcements are needed on the Wintergrasp battlefield! I have opened a portal for quick travel to the battle at The Silver Enclave.", LANG_UNIVERSAL, 0);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_ALLIANCE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class npc_wg_horde_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_horde_battle_mage() : CreatureScript("npc_wg_horde_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_horde_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_horde_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_horde_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->getSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeHorde != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.356160f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5924.042969f, 570.354492f, 661.087280f, 5.930885f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(6.003930f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class go_wg_veh_teleporter : public GameObjectScript
+{
+public:
+    go_wg_veh_teleporter() : GameObjectScript("go_wg_veh_teleporter") { }
+
+    bool OnGossipHello(Player *pPlayer, GameObject * pGO)
+    {
+        if (GameObject* trigger = pGO->FindNearestGameObject(190375, 500)) // Wintergrasp Fortress Gate
+            if (Vehicle * veh = pPlayer->GetVehicle())
+            {
+                Position triggerPos;
+                trigger->GetPosition(&triggerPos);
+                triggerPos.m_positionX -= 30;
+                veh->Relocate(triggerPos);
+            }
+        
+        return true;
+    }
+};
+
+void AddSC_wintergrasp()
+{
+    new npc_demolisher_engineerer();
+    new npc_wg_ally_battle_mage();
+    new npc_wg_horde_battle_mage();
+    new go_wg_veh_teleporter();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
index 450f0f6..39be275 100644
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
@@ -22,6 +22,8 @@ set(scripts_STAT_SRCS
   OutdoorPvP/OutdoorPvPHP.h
   OutdoorPvP/OutdoorPvPZM.h
   OutdoorPvP/OutdoorPvPNA.h
+  OutdoorPvP/OutdoorPvPWG.cpp
+  OutdoorPvP/OutdoorPvPWG.h
 )
 
 message("  -> Prepared: Outdoor PVP Zones")
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
new file mode 100644
index 0000000..5b3803f
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -0,0 +1,2142 @@
+/*
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Group.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+#include "GameObject.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->UpdateEntry(entry); // SetOriginalEntry as used before may lead to crash
+       if (cr->GetAreaId() == 4575)
+           cr->AI()->EnterEvadeMode();
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisible(true);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    m_wartime  = sWorld->getWorldState(WORLDSTATE_WINTERGRASP_WARTIME) ? true : false;
+    m_timer    = uint32(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_TIMER));
+    m_defender = TeamId(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS) ? true : false);
+    m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (m_timer == 0)
+       m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    QueryResult result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+        " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+        CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
+        31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog->outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        }while(result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr->GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER-300 ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog->outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog->outError("Cannot add capture point!");
+                continue;
+            }
+            // West fortress Workshop fix
+            if(goData->id==192028 || goData->id==192029)
+                workshop->m_capturePointGUID = goData->id;
+
+            const CreatureData *creData = sObjectMgr->GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr->GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    }while(result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog->outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr->mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr->mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr->GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr->mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr->AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld->SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RemoveOfflinePlayerWGAuras();
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && /*MaingateDestroyed==true &&*/ m_gate &&  m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+           if (obj->GetEntry()==191810)
+            {
+               //obj->TakenDamage(30000);
+               MaingateDestroyed=true;
+            }
+
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+                case BUILDING_TOWER:
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+                case BUILDING_TOWER:
+                     --m_towerDamagedCount[state->GetTeam()];
+                     ++m_towerDestroyedCount[state->GetTeam()];
+                     if (state->GetTeam() == getAttackerTeam())
+                     {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+
+                        if (attStack!=0)
+                        {
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+                        }
+                         else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+
+                     // Add Support of Quests Toppling the Towers & Southern Sabotage
+                        if (obj->GetEntry()==190356 || obj->GetEntry()==190357 || obj->GetEntry()==190358)
+                        (*itr)->RewardPlayerAndGroupAtEvent(TOWER_PVP_DESTROYED, obj);
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                    }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+         SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog->outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 /*guidlow*/, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                team = TEAM_ALLIANCE;
+            else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                team = TEAM_HORDE;
+            else
+                return;
+
+            if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+            {
+                if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                {
+                    if (CanBuildVehicle(workshop))
+                        m_vehicles[team].insert(creature);
+                    else
+                    {
+                        creature->setDeathState(DEAD);
+                        creature->SetRespawnTime(DAY);
+                        return;
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            creature->SetReactState(REACT_PASSIVE);
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = creature;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = creature;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            UpdateCreatureInfo(creature);
+        default:
+            m_creatures.insert(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnCreatureRemove(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            // the faction may be changed in uncharm
+            // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+            if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                team = TEAM_ALLIANCE;
+            else if (m_vehicles[TEAM_HORDE].erase(creature))
+                team = TEAM_HORDE;
+            else
+                return;
+
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+            break;
+        default:
+            m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectCreate(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.insert(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = go;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->Building.Health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            } else {
+                go->GetGOValue()->Building.Health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectRemove(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectRemove(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.erase(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+            itr->second->building = NULL;
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building && itr->second->building->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING);
+            itr->second->health = itr->second->building->GetGOValue()->Building.Health;
+            itr->second->damageState = DAMAGE_INTACT;
+        }
+        else
+            itr->second->health = 0;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisible(true);
+            } else {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            }
+            return false;
+        case CREATURE_OTHER:
+            if (isWarTime())
+            {
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            } else {
+                creature->RestoreFaction();
+                creature->SetVisible(true);
+            }
+            return false;
+        case CREATURE_SPIRIT_GUIDE:
+            if (isWarTime())
+            {
+                /* Uncomment if want to disable ressurect for both factions at the same time at fortress graveyard
+                if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+                {
+                    FortressSpirit = creature;
+                    if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                            FortressSpirit->UpdateEntry(CRE_SPI_A);
+                    if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                        FortressSpirit->UpdateEntry(CRE_SPI_H);
+                }*/
+                creature->SetVisible(true);
+            }
+            else
+                creature->SetVisible(false);
+
+            return false;
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisible(isWarTime() ? false : true);
+            return false;
+        case CREATURE_ENGINEER:
+           return false;
+        case CREATURE_SIEGE_VEHICLE:
+            if (!isWarTime())
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->DisappearAndDie();
+            }
+            return false;
+        case CREATURE_QUESTGIVER:
+           creature->AI()->EnterEvadeMode();
+           return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            switch (entry)
+            {
+                case 30740://Alliance guard
+                {
+                    if (getDefenderTeam() == TEAM_ALLIANCE)
+                    {
+                       if (creature->GetAreaId()==4575)
+                          creature->SetPhaseMask(257, true);
+                    } else {
+                       if (creature->GetAreaId()==4575)
+                           creature->SetPhaseMask(256, true);
+                    }
+                }
+                case 30739://Horde guard
+                {
+                    if (getDefenderTeam() == TEAM_ALLIANCE)
+                    {
+                       if (creature->GetAreaId()==4575)
+                          creature->SetPhaseMask(64, true);
+                    } else {
+                       if (creature->GetAreaId()==4575)
+                          creature->SetPhaseMask(65, true);
+                    }
+                }
+            }
+            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+            if (itr != m_creEntryPair.end())
+            {
+                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                _RespawnCreatureIfNeeded(creature, entry);
+                creature->AI()->EnterEvadeMode();
+            }
+            return false;
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+       if (creature->GetEntry() != 30400 || creature->GetEntry() != 30499)
+           creature->SetReactState(REACT_AGGRESSIVE);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsGridLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr->MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction;
+    uint32 defFaction;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+    else
+    {
+        attFaction = 35;
+        defFaction = 35;
+    }
+
+    if (!go || !go->GetGOInfo())
+       return true;
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 8256://Alliance Banner
+        case 5651://Alliance Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             }
+             return true;
+        case 8257://Horde Banner
+        case 5652://Horde Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             }
+             return true;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() < 75)
+        {
+            plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+            return;
+        }
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::HandlePlayerResurrects(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (pPlayer->getLevel() > 74)
+        {
+            // Tenacity
+            if (pPlayer->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                pPlayer->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (pPlayer->HasAura(SPELL_TENACITY))
+                    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                pPlayer->SetAuraStack(SPELL_TENACITY, pPlayer, newStack);
+            }
+
+            if (pPlayer->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(pPlayer, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!pPlayer->GetSession()->PlayerLogout())
+    {
+        if (pPlayer->GetVehicle())
+            pPlayer->GetVehicle()->Dismiss();
+        pPlayer->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(pPlayer, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        } else killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        } else killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    } else {
+        switch (GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        } else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+    } else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld->SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+    //Announce in all world, comment it if you don't like/need it
+    // Announce 30 minutes left
+    if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+
+    // Announce 10 minutes left
+    if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = ObjectAccessor::FindPlayer(*itr2);
+                            if (!plr)
+                                continue;
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                            if (sh && plr->GetDistance2d(sh) <= 18.0f)
+                            {
+                                plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                                m_ResurrectQueue.push_back(*itr2);
+                            }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                } else m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = ObjectAccessor::FindPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor->ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    } else {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+           if (m_changeAlly == true || m_changeHorde == true) // If wg is switching (.wg switch)
+           {
+           RebuildAllBuildings();
+           m_changeAlly = false;
+           m_changeHorde = false;
+           }
+        }
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(entry), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        } else {
+            if (m_timer != 1)
+                sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_WARTIME, m_wartime);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_TIMER, m_timer);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS, m_defender);
+        m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+   return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{// Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{// Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+       sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    m_changeAlly = true;
+    m_changeHorde = true;
+
+    sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr->GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+    uint32 CountDef=0;
+    uint32 CountAtk=0;
+    m_wartime = true;
+    MaingateDestroyed = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountDef++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountAtk++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+    {
+        if ((CountAtk < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+        {
+            if (CountAtk<=CountDef)
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+            if (CountDef<CountAtk)
+            {
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+                m_changeDefender=true;
+            }
+            forceStopBattle();
+            return;
+        }
+    }
+
+    //Uncomment to tele Defenders inside Fortress
+    //TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    //Remove Essence of Wintergrasp to all players
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld->UpdateAreaDependentAuras();
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+        {
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+    }
+    UpdateTenacityStack();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld->UpdateAreaDependentAuras();
+    //Sound on End Battle
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if (getDefenderTeam()==TEAM_ALLIANCE)
+            TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+        else
+            TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+        (*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+    }
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+        (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+                sObjectAccessor->ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                {
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+                }
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+            baseHonor = team == getDefenderTeam() ? sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    } else {
+                        marks = 1;
+                        honor = 0;
+                    }
+                } else {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    } else {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            } else {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+    // update go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+       UpdateGameObjectInfo(*itr);
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog->outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr->MoveCreData(guid, 571, posAlli);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = ObjectAccessor::FindPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = ObjectAccessor::FindPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(*itr);
+            if (!plr)
+                continue;
+
+            if (plr->getFaction() == ALLIANCE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(*itr);
+            if (!plr)
+                continue;
+            if (plr->getFaction() == HORDE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state) : OPvPCapturePoint(opvp), m_spiGuid(0), m_spiritguide(NULL), m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_engGuid(0), m_engineer(NULL), m_buildingState(state), m_wintergrasp(opvp) {}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    } else {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+    entry = 0;
+    guide_entry = 0;
+    guide_entry_fortress_horde = 0;
+    guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+            if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+            {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+            } else {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+            }
+        }
+    } else if (m_engineer)
+        m_engineer->SetVisible(false);
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+        OutdoorPvP_wintergrasp() : OutdoorPvPScript("outdoorpvp_wg") { }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
new file mode 100644
index 0000000..ec078d5
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+const uint32 WintergraspFaction[3] = {1802, 1801, 35};
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+    SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
+    SPELL_TELEPORT_HORDE_CAMP                    = 58633,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205,
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298,
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+     DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+enum OutdoorPVPWGStatus
+{
+    WORLDSTATE_WINTERGRASP_WARTIME            = 31001,
+    WORLDSTATE_WINTERGRASP_TIMER              = 31002,
+    WORLDSTATE_WINTERGRASP_DEFENDERS          = 31003,
+    WORLDSTATE_WINTERGRASP_CONTROLING_FACTION = 31004,
+    WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB.
+    TOWER_PVP_DESTROYED                          = 35074, //Quest Objective - Toppling the Towers & Southern Sabotage
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+         : worldState(_worldState), health(0)
+         , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), damageState(DAMAGE_INTACT), team(_team)
+         , building(NULL), graveTeam(NULL), type(BUILDING_WALL) {}
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    TeamId team;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        bool MaingateDestroyed;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+        void OnCreatureCreate(Creature *creature);
+        void OnGameObjectCreate(GameObject *go);
+        void OnCreatureRemove(Creature *creature);
+        void OnGameObjectRemove(GameObject *go);
+        void ProcessEvent(GameObject *obj, uint32 eventId);
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+        bool Update(uint32 diff);
+        void BroadcastStateChange(BuildingState *state) const;
+        uint32 GetData(uint32 id);
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+        bool m_changeAlly;
+        bool m_changeHorde;
+
+    protected:
+        // Temporal BG specific till 3.2
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        GameObjectSet m_gobjectsDestroyable;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+        uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() { }
+        void ChangeTeam(TeamId oldteam);
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+#endif
\ No newline at end of file
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.cpp b/src/server/shared/Database/Implementation/LoginDatabase.cpp
index 7e497c4..22b9abe 100755
--- a/src/server/shared/Database/Implementation/LoginDatabase.cpp
+++ b/src/server/shared/Database/Implementation/LoginDatabase.cpp
@@ -40,7 +40,7 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BY_IP, "SELECT id FROM account WHERE last_ip = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_INS_IP_BANNED, "INSERT INTO ip_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_DEL_IP_NOT_BANNED, "DELETE FROM ip_banned WHERE ip = ?", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_BANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_BANNED, "INSERT INTO account_banned VALUES (?, ?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_UPD_ACCOUNT_NOT_BANNED, "UPDATE account_banned SET active = 0 WHERE id = ? AND active != 0", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_DEL_REALM_CHARACTERS, "DELETE FROM realmcharacters WHERE acctid = ? AND realmid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_INS_REALM_CHARACTERS, "INSERT INTO realmcharacters (numchars, acctid, realmid) VALUES (?, ?, ?)", CONNECTION_ASYNC)
@@ -62,4 +62,5 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PREPARE_STATEMENT(LOGIN_DEL_ACCOUNT_ACCESS, "DELETE FROM account_access WHERE id = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_DEL_ACCOUNT_ACCESS_BY_REALM, "DELETE FROM account_access WHERE id = ? AND (RealmID = ? OR RealmID = -1)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_ACCESS, "INSERT INTO account_access (id,gmlevel,RealmID) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+	PREPARE_STATEMENT(LOGIN_SET_ACCOUNT_PREMIUM, "UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.h b/src/server/shared/Database/Implementation/LoginDatabase.h
index afb1880..4079277 100755
--- a/src/server/shared/Database/Implementation/LoginDatabase.h
+++ b/src/server/shared/Database/Implementation/LoginDatabase.h
@@ -82,6 +82,7 @@ enum LoginDatabaseStatements
     LOGIN_DEL_ACCOUNT_ACCESS,
     LOGIN_DEL_ACCOUNT_ACCESS_BY_REALM,
     LOGIN_INS_ACCOUNT_ACCESS,
+    LOGIN_SET_ACCOUNT_PREMIUM,
 
     MAX_LOGINDATABASE_STATEMENTS,
 };
diff --git a/src/server/shared/Utilities/Util.h b/src/server/shared/Utilities/Util.h
index b67761c..67a9a83 100755
--- a/src/server/shared/Utilities/Util.h
+++ b/src/server/shared/Utilities/Util.h
@@ -245,7 +245,12 @@ inline bool isEastAsianCharacter(wchar_t wchar)
         return true;
     return false;
 }
-
+// Playerbot mod start:
+inline bool isWhiteSpace(char c)
+{
+    return ::isspace(int(c)) != 0;
+}
+// Playerbot mod end.
 inline bool isNumeric(wchar_t wchar)
 {
     return (wchar >= L'0' && wchar <=L'9');
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 60adce4..40f092e 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -129,6 +129,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Trinichat
   ${CMAKE_SOURCE_DIR}/src/server/game/Weather
   ${CMAKE_SOURCE_DIR}/src/server/game/World
   ${CMAKE_SOURCE_DIR}/src/server/authserver/Server
diff --git a/src/server/worldserver/CommandLine/CliRunnable.cpp b/src/server/worldserver/CommandLine/CliRunnable.cpp
index 8e04a9c..f927dd7 100755
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp
@@ -34,6 +34,7 @@
 #include "MapManager.h"
 #include "Player.h"
 #include "Util.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 #if PLATFORM != PLATFORM_WINDOWS
 #include <readline/readline.h>
@@ -546,6 +547,15 @@ bool ChatHandler::HandleServerToggleQueryLogging(const char* /* args */)
     return true;
 }
 
+//Reconnect TriniChat to IRC server via CLI command
+bool ChatHandler::HandleIRCRelogCommand(const char *args)
+{
+    SendSysMessage("TriniChat is dropping from IRC Server");
+    sIRC.ResetIRC();
+    SendSysMessage("TriniChat is reconnecting to IRC Server");
+    return true;
+}
+
 /// @}
 
 #ifdef linux
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 23f925d..79fe8c1 100755
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -30,6 +30,7 @@
 
 #include "Log.h"
 #include "Master.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 #ifndef _TRINITY_CORE_CONFIG
 # define _TRINITY_CORE_CONFIG  "worldserver.conf"
diff --git a/src/server/worldserver/Master.cpp b/src/server/worldserver/Master.cpp
index d84cfc1..b6797f4 100755
--- a/src/server/worldserver/Master.cpp
+++ b/src/server/worldserver/Master.cpp
@@ -41,7 +41,7 @@
 #include "Timer.h"
 #include "Util.h"
 #include "AuthSocket.h"
-
+#include "../../game/TriniChat/IRCClient.h"
 #include "BigNumber.h"
 
 #ifdef _WIN32
@@ -252,6 +252,15 @@ int Master::Run()
         soap_thread = new ACE_Based::Thread(runnable);
     }
 
+  // Start up TriniChat
+    if (sIRC.Active == 1)
+    {
+        ACE_Based::Thread irc(new IRCClient);
+        irc.setPriority ((ACE_Based::Priority)2);
+    }
+    else
+        sLog->outString("*** TriniChat Is Disabled. *");
+
     ///- Start up freeze catcher thread
     if (uint32 freeze_delay = ConfigMgr::GetIntDefault("MaxCoreStuckTime", 0))
     {
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 1e37f50..8fbb5fa 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -1144,6 +1144,13 @@ InstantLogout = 1
 DisableWaterBreath = 4
 
 #
+#    Enable or Disable "Fatigue" timer
+#           default = 1 (enabled)
+#                   = 0 (disabled)
+
+fatigue.enabled = 1
+
+#
 #    AllFlightPaths
 #        Description: Character knows all flight paths (of both factions) after creation.
 #        Default:     0 - (Disabled)
@@ -1505,6 +1512,14 @@ AllowTwoSide.Trade = 0
 
 TalentsInspecting = 1
 
+#    Fake.WHO.List 
+#        Add fake players to fill in WHO LIST (who is online list, "O" button) if there is less then 
+#        49 real players online (need to set online=2 in character database in order to work) 
+#        Default: 0 (disabled) 
+#                 1 (enabled) 
+
+Fake.Who.List = 0 
+
 #
 ###################################################################################################
 
@@ -2046,10 +2061,18 @@ Rate.Drop.Item.ReferencedAmount = 1
 #        Default:     1 - (Rate.XP.Kill)
 #                     1 - (Rate.XP.Quest)
 #                     1 - (Rate.XP.Explore)
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
+#        XP rates Premium modifier
+#        Default: 1
 
 Rate.XP.Kill    = 1
 Rate.XP.Quest   = 1
 Rate.XP.Explore = 1
+Rate.XP.Kill.Premium    = 1
+Rate.XP.Quest.Premium   = 1
+Rate.XP.Explore.Premium = 1
 
 #
 #    Rate.RepairCost
@@ -2518,6 +2541,289 @@ Network.TcpNodelay = 1
 #
 ###################################################################################################
 
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisableBeta_PTR_Unused
+#        Disable certain items that are usually unavailable to Players
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+###############################################################################
+# AUCTION HOUSE BOT GLYPHS PART
+#
+#    AuctionHouseBot.SellGlyphs
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.SellGlyphs = 0
+AuctionHouseBot.GlyphsCount = 0
+AuctionHouseBot.DisableGlyphBelowLevel = 0
+AuctionHouseBot.DisableGlyphAboveLevel = 0
+AuctionHouseBot.GlyphBuyOutPriceMin = 0
+AuctionHouseBot.GlyphBuyOutPriceMax = 0
+AuctionHouseBot.GlyphBidPriceMin = 0
+AuctionHouseBot.GlyphBidPriceMax = 0
+
 ###################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
@@ -2785,4 +3091,560 @@ PlayerDump.DisallowPaths = 1
 PlayerDump.DisallowOverwrite = 1
 
 #
+##########################################################
+#
+#       Profession NPC
+#
+# Enable or Disable Primary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableProfessions = 1
+
+# Enable or Disable Secondary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableSecondarySkills = 1
+
+# Number of Skill points
+#         default = 10
+
+SkillPoints = 10
+
+# GM Only
+#         default = 0 (Anyone can use)
+#                   = 1 (GM only)
+
+ProfessionNPC.OnlyGMs = 0
+
+# Cost of skill points (in copper)
+#         default = 10000 (10 gold)
+
+SkillGoldCost = 10000
+
+# Use Tokens instead of gold
+#         default = 0 (Use Gold)
+#                 = 1 (Use Tokens)
+
+ProfessionNPC.UseTokens = 1
+
+# Entry number of "token" Item
+#         default = 0 (No item. ProfessionNPC.UseTokens must = 0)
+#                 = n (n = entry number of item)
+
+ProfessionNPC.ItemEntryNum = 99999
 ###################################################################################################
+# TriniChat IRC BOT For Trinity Core Configuration File #
+#########################################################
+# irc.active
+# Enable TriniChat Addon
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.active = 1
+
+##################################################
+# irc.icc
+# IRC connect code
+# Default: 001 - Welcome To Network msg
+# 375 - Beginning Of MOTD
+# 376 - End Of MOTD
+#
+irc.icc = 001
+
+##################################################
+# irc.host
+# IRC server to have TriniChat connect to
+#
+irc.host = "irc.xxxx.net"
+
+##################################################
+# irc.port
+# IRC server port to use
+#
+irc.port = "1337"
+
+##################################################
+# irc.user
+# The username to have TriniChat use to connect to the IRC server
+# irc.nick
+# IRC nickname to be used by the bot
+# irc.pass
+# The password to be used to identify to NickServ (IRC NickName Enforcement Services)
+#
+irc.user = "Trini_Chat"
+irc.nick = "Trini_Chat"
+irc.pass = "ServicesPass"
+
+##################################################
+# irc.auth
+# IRC Authentication Method
+# Default: 0 - Disable
+# 1 - NickServ - Normal Method - PRIVMSG NickServ :IDENTIFY Password
+# 2 - NickServ - Alternate Method To Identify To A Different Nick - PRIVMSG NickServ :IDENTIFY irc.auth.nick Password
+# 3 - QuakeNet - Normal Method - PRIVMSG Q@CServe.quakenet.org :AUTH irc.nick Password
+# 4 - QuakeNet - Alternate Method To Identify To A Different Nick - PRIVMSG Q@CServe.quakenet.org :AUTH irc.auth.nick Password
+# irc.auth.nick
+# IRC Nickname to use if Auth method 2 or 4 is used
+#
+irc.auth = 0
+irc.auth.nick = "AuthNick"
+
+##################################################
+# irc.ldef
+# Leave a defined IRC channel on server connect
+# Default: 0 - Disable
+# 1 - Enable
+# irc.defchan
+# IRC channel to leave on server connect if irc.ldef is on
+#
+irc.ldef = 0
+irc.defchan = "lobby"
+
+##################################################
+# irc.wct
+# Time to wait before (re)attemptimg connection to IRC server
+# Default: 30000 - (30 Seconds)
+# irc.maxattempt
+# Maximum attempts to try IRC server
+# Default: 20
+#
+irc.wct = 30000
+irc.maxattempt = 20
+
+##################################################
+# irc.auto.announce
+# Time to wait in Minutes to announce random messages from database.
+# Default: 30 - (30 Minutes)
+#
+irc.auto.announce = 30
+
+##################################################
+# irc.autojoin_kick
+# Autojoin IRC channel if kicked
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.autojoin_kick = 1
+
+##################################################
+# irc.command_prefix
+# IRC command prefix
+# Example: (.)online all
+#
+irc.command_prefix = "\"
+
+##################################################
+# irc.joinmsg
+# irc.rstmsg
+# irc.kickmsg
+# TriniChat bot join/restart/kick messages
+#
+irc.joinmsg = "Trinity Core With TriniChat $Ver Is Up And Running! Command Trigger Is: $Trigger"
+irc.rstmsg = "TriniChat Is Restarting, I Will Be Right Back."
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+
+##################################################
+# irc.chan_#
+# wow.chan_#
+# IRC and WOW channels to link. Leave # out of IRC channel. Both channels _ARE_ case sensitive
+# NOTE: you can have more than 1 IRC channel linked to wow channels, as in example:
+# Example: irc.chan_1 = "Trinity"
+# irc.chan_2 = "trinity2"
+# wow.chan_1 = "world"
+# wow.chan_2 = "LookingForGroup"
+# irc.pass_#
+# Passwords for said IRC channels (IRC server side)
+# Example:
+# irc.pass_1 = "password" password for irc channel #1
+# irc.pass_2 = "password2" password for irc channel #2
+irc.chan_1 = "ircchan"
+wow.chan_1 = "world"
+irc.pass_1 = "pass"
+
+##################################################
+# irc.StatusChannel
+# Channel Number To Display Status Messages In (AuctionHouse, Levels, Deaths, Etc)
+# Default: 1 - Channel ID 1
+# irc.AnnounceChannel
+# Channel Number To Display Announcements In (Announces, Notifies, Event)
+# Default: 1 - Channel ID 1
+#
+irc.StatusChannel = 1
+irc.AnnounceChannel = 1
+
+##################################################
+# irc.op_gm_login
+# Op The GM In All Channels The Bot Is On When They Log In To TriniChat
+# Default: 0 - Disable
+# 1 - Enable
+# irc.op_gm_level
+# The Minimum GM Level Required To Have The Bot Op The User
+# Default: 5 - GM Level 5
+#
+irc.op_gm_login = 0
+irc.op_gm_level = 3
+
+##################################################
+# irc.ajoin (Experimental/Under Development)
+# Force players to autojoin a WOW in game channel
+# Atleast one player must be in the channel on server start, and atleast one person online for invite to work
+# Default: 0 - Disable
+# 1 - Enable
+# irc.ajchan
+# Channel to join if above is Enabled.
+#
+irc.ajoin = 1
+irc.ajchan = "world"
+
+##################################################
+# irc.online.result
+# Maximum number of results per line for the online command
+#
+irc.online.result = 30
+
+##################################################
+# chat.*** (Defineable Strings) (maybe more in future)
+# wow_* - String is displayed in IRC channel
+# irc_* - String is displayed in WOW channel
+# Options: $Name, $Level, $Msg, $GM (not all options work in every string)
+#
+chat.wow_irc = "<WoW>[$Name($Level)] $Msg"
+chat.irc_wow = "<IRC>[$Name]: $Msg"
+chat.join_wow = "12>>04 $GM$Name Joined The $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "12<<04 $GM$Name Left The $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "<> $Name Is Now Known As $NewName!"
+
+##################################################
+# Botmask
+# This defines what the bot announces, if its 0 everything is disabled
+# simply add the values of the elements you want to create this mask.
+# Example: WoW join/leaves are 1 and IRC join/leaves are 2, if you want both of these active then the BotMask is 3.
+# (1)Display WoW Chan Join/Leaves In IRC
+# (2)Display IRC Chan Join/Leaves/NickChanges In WoW
+# (4)Display Unknown Command Message When Trigger Is Used And No Command Exists
+# (8)Announce Security Level > 0 As GM At Login
+# (16)Announce GM In GM ON State AS GM At Login
+# (32)Return Errors To Notice. (If disabled then default is Private Message)
+# (64)Display WoW Status Messages (Levels/Deaths)
+# (128)Display Nick Changes From IRC In WOW
+# (256)Display WoW Announces/Notifies In IRC
+# (512)Do Not Let Players Use Commands On Higher GM Level Players
+# (1024)Enable AuctionHouse Announcements !!DISSABLED!!
+#
+Botmask = 1023
+
+##################################################
+# irc.gmlog
+# Minimum GM level to not show login/pass info in IRC logs
+# irc.logfile.prefix
+# The prefix of the IRC logfile. Directories can be added here.
+# Example: "IRC/IRC_" outputs IRC_YYYY-MM-DD.log to the IRC subdirectory in your logs dir
+# irc.logchannel
+# Specefies the channel where logged output gets broadcasted.
+# Default: "" (none)
+# irc.logchannelpw
+# The password for the log channel.
+# irc.logmask
+# Bitmask, see Botmask for explanation. Determines what gets logged to the logchannel.
+# (0) Do not broadcast into logchannel.
+# (1) Broadcast IRC Commands into logchannel.
+# (2) Broadcast Ingame GM Commands into logchannel.
+# (3) Broadcast both IRC Commands and GM Commands into logchannel.
+irc.gmlog = 1
+irc.logfile.prefix = "IRC_"
+irc.logchannel = "testlog"
+irc.logchannelpw = ""
+irc.logmask = 3
+
+##################################################
+# irc.fun.games (Experimental/Under Development)
+# Enable TriniChat Games
+# Default: 0 - Disable
+# 1 - Enable
+#
+irc.fun.games = 0
+
+##################################################
+# irc.gm#
+# GM tag to append to (GM onjoin / online command) IRC color codes are acceptable
+#
+irc.gm1 = "[VIP]"
+irc.gm2 = "[Donator]"
+irc.gm3 = "[Bug Tracker]"
+irc.gm4 = "[Moderator]"
+irc.gm5 = "[Game Master]"
+irc.gm6 = "[Admin]"
+irc.gm7 = "[Developer]"
+irc.gm8 = "[Owner]"
+
+###################################################
+#######################################################################
+#   OutdoorPvP.Wintergrasp.Enabled
+#       Determines whether the Wintergrasp battle is enabled or not.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.SaveState.Period
+#      Interval of Save Wintergrasp State Data  to restore it after crash/shutdown/restart
+#      Interval (in milliseconds)
+#      Default (10000 milliseconds)
+#      Warning:  Do not set it less 1 second!
+#
+#   OutdoorPvP.Wintergrasp.StartTime
+#       The start time of the first battle after server starts (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.BattleTime
+#       Time limit of a battle (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.Interval
+#       Interval between battles (in minutes)
+#       Default: 150
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorRewards
+#       Defines whether custom honor rewards should be given to player
+#        for partaking in the Wintergrasp Battle.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
+#       Defines the amount of honor points that should be given to the
+#        team winning the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 3000
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
+#       Defines the amount of honor points that should be given to the
+#        team losing the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1250
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
+#       Defines the amount of honor points that should be given to the
+#        team for damaging a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
+#       Defines the amount of honor points that should be given to the
+#        team for destroying a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
+#       Defines the amount of honor points that should be given to the
+#        team for damaged buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
+#      Defines the amount of honor points that should be given to the
+#        team for intact buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1500
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Enable
+#		Enable or Disable antifarm system
+#              (Default: 0)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Atk
+#		Min count atack players for antifarm
+#              (Default: 5)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Def
+#		Min count defense players for antifarm
+#              (Default: 5)
+#
+##########################################################
+
+OutdoorPvP.Wintergrasp.Enabled = 1
+OutdoorPvP.Wintergrasp.SaveState.Period = 60000
+OutdoorPvP.Wintergrasp.StartTime = 30
+OutdoorPvP.Wintergrasp.BattleTime = 30
+OutdoorPvP.Wintergrasp.Interval = 150
+OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
+OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
+OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
+OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
+OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
+OutdoorPvP.Wintergrasp.Antifarm.Enable = 1
+OutdoorPvP.Wintergrasp.Antifarm.Atk = 1
+OutdoorPvP.Wintergrasp.Antifarm.Def = 1
+
+##########################################################
+# NPC Buff rewritten by LordPsyan
+#
+#        GM Only
+#         Default 0 = Any Player
+#                 1 = GM1 or higher
+
+Npc_Buff.OnlyGMs = 0
+
+#     Enables Small Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableSmallBuff = 1
+
+#     Enables Geat Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGreatBuff = 1
+
+#     Enables GM Only Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGMBuff = 1
+
+#     Enables Player Tools
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnablePlayerTools = 1
+
+#     Enables Remove Res Sickness
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableRemoveResSickness = 1
+
+################################################################################
+#
+#       Level NPC
+#
+# Enable or Disable Instant Level 80
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+LevelNPC.EnableLevel80 = 1
+
+#
+# Enable or Disable Instant Level 100
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+LevelNPC.EnableLevel100 = 1
+
+#
+# Enable or Disable Instant Level 150
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+LevelNPC.EnableLevel150 = 1
+
+#
+# Enable or Disable Instant Level 200
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+LevelNPC.EnableLevel200 = 1
+
+#
+# Enable or Disable Instant Level 255
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+LevelNPC.EnableLevel255 = 1
+
+# Platinum Only
+#         default = 0 (Anyone can use)
+#                   = 1 (Platinum only)
+
+LevelNPC.OnlyGMs = 0
+
+# Cost of Max Levels (in copper)
+#         default = 10000 (10 gold)
+
+LevelNPC.SkillGoldCost = 10000
+
+# Use Tokens instead of gold
+#         default = 0 (Use Gold)
+#                 = 1 (Use Tokens)
+
+LevelNPC.UseTokens = 1
+
+# Entry number of "token" Item
+#         default = 0 (No item. LevelNPC.UseTokens must = 0)
+#                 = n (n = entry number of item)
+
+LevelNPC.ItemEntryNum = 99998
+
+##########################################################
+###################################################################################################################
+# PLAYERBOTAI CONFIGURATION
+#
+#    PlayerbotAI.DisableBots
+#        Disable the bot command and bot menu
+#        Default: 0 - off
+#                 1 - on
+#
+#    PlayerbotAI.DebugWhisper
+#        Enable debug output by whispering master
+#        Default: 0 - off
+#                 1 - on
+#
+#    PlayerbotAI.FollowDistanceMin
+#    PlayerbotAI.FollowDistanceMax
+#        Min. and Max. follow distance for bots
+#        Default: 0.5 / 1.0
+#
+#    PlayerbotAI.MaxNumBots
+#        Limits the number of bots per account (Max 9)
+#        Default: 9
+#
+#    PlayerbotAI.RestrictBotLevel
+#        Restrict the allowed bot level (Current Max 80)
+#        Default: 80
+#
+#    PlayerbotAI.BotguyQuests
+#        List of Quest ids, any of which, once completed will enable botguy menu on NPCs
+#        List must be enclosed in double quotes ("") and multiple Quest Ids separated by a delimiter(,)
+#        Example: "805,383,2160,54,8350,9313,1656,2159"
+#        Default: "" no quest restriction, memu always displayed by NPCs
+#
+#    PlayerbotAI.BotguyCost
+#        Cost (Copper coins) levied on summoning a bot
+#        If player has the cost, botguy menu will be displayed by NPCs
+#        Default: 0 - no cost, menu always displayed by NPCs
+#
+#    PlayerbotAI.Collect.Combat
+#    PlayerbotAI.Collect.Quest
+#    PlayerbotAI.Collect.Profession
+#    PlayerbotAI.Collect.Loot
+#    PlayerbotAI.Collect.Skin
+#    PlayerbotAI.Collect.Objects
+#        Enable collection options for after combat, quest items, profession, all loot, skin, or nearby objects
+#                 0 - off
+#        Default: 1 - on
+#
+#    PlayerbotAI.SellGarbage
+#        Allow bots to automatically sell all [GRAY|POOR] quality items as the player activates vendor
+#        Default: 0 - off
+#                 1 - on
+#
+###################################################################################################################
+
+PlayerbotAI.DisableBots = 0
+PlayerbotAI.DebugWhisper = 0
+PlayerbotAI.FollowDistanceMin = 0.5
+PlayerbotAI.FollowDistanceMax = 1.0
+PlayerbotAI.MaxNumBots = 9
+PlayerbotAI.RestrictBotLevel = 80
+PlayerbotAI.BotguyQuests = ""
+PlayerbotAI.BotguyCost = 0
+PlayerbotAI.Collect.Combat = 1
+PlayerbotAI.Collect.Quest = 1
+PlayerbotAI.Collect.Profession = 1
+PlayerbotAI.Collect.Loot = 1
+PlayerbotAI.Collect.Skin = 1
+PlayerbotAI.Collect.Objects = 1
+PlayerbotAI.SellGarbage = 0
-- 
1.7.2.3

