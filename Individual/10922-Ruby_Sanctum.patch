diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index e1b0921..0bb6ad0 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -15,6 +15,7 @@ if( WITH_SQL )
       scripts
       base
       create
+	  Ruby_Sanctum
     DESTINATION
       shared/trinity/sql
   )
diff --git a/sql/Ruby_Sanctum/world_ruby_sanctum.sql b/sql/Ruby_Sanctum/world_ruby_sanctum.sql
new file mode 100644
index 0000000..040f01e
--- /dev/null
+++ b/sql/Ruby_Sanctum/world_ruby_sanctum.sql
@@ -0,0 +1,66 @@
+DELETE FROM `script_texts` WHERE `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM `script_texts` WHERE `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM `script_texts` WHERE `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO `script_texts` (`entry`, `content_default`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '17490', '1', '0'),        
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '17491', '1', '0'),       
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '17492', '0', '0'),       
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '17493', '0', '0'),     
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '17494', '0', '0'),      
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '17495', '0', '0'),     
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '17496', '0', '0'),     
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '17497', '0', '0'),  
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, 17525, 1, 0),
+
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, 17514, 1, 0),
+( -1752020, "HALION! I...", 0, 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, 17516, 1, 0),
+
+( -1752022, "You will sssuffer for this intrusion!", 0, 17528, 1, 0),
+( -1752023, "As it should be...", 0, 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, 17532, 1, 0),
+
+(-1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,17499,0,0),
+(-1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,17500,0,0),
+(-1752029, 'Another hero falls.',NULL,17501,0,0),
+(-1752030, 'Hahahahaha.',NULL,17502,0,0),
+(-1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,17503,0,0),
+(-1752032, 'Not good enough.',NULL,17504,0,0),
+(-1752033, 'The heavens burn!',NULL,17505,0,0),
+(-1752034, 'Beware the shadow!',NULL,17506,0,0),
+(-1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,17507,0,0),
+(-1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,17508,0,0);
+
+UPDATE `instance_template` SET `script`='instance_ruby_sanctum' WHERE (`map`='724');
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74562') AND (`spell_effect`='74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74792') AND (`spell_effect`='74800');
+INSERT INTO `spell_linked_spell` VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO `spell_linked_spell` VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM `creature` WHERE `id`=39863 AND `map`=724;
+INSERT INTO `creature` VALUES (null,39863,724,15,1,0,0,3144.93,527.233,72.8887,0.110395,300,0,0,11156000,0,0,0,0,0,0);
+
+REPLACE `spell_script_names` SET `ScriptName` = 'spell_halion_portal', `spell_id`=74812;
+
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `data10`=74812 WHERE `entry`=202796;
\ No newline at end of file
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 48056f7..7df5d55 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -485,6 +485,13 @@ void AddSC_storm_peaks();
 void AddSC_zuldrak();
 void AddSC_crystalsong_forest();
 
+void AddSC_boss_baltharus();	//RubySanctum
+void AddSC_boss_halion();
+void AddSC_boss_ragefire();
+void AddSC_boss_zarithrian();
+void AddSC_instance_ruby_sanctum();
+
+
 //outland
 void AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
 void AddSC_boss_shirrak_the_dead_watcher();
@@ -1170,6 +1177,12 @@ void AddNorthrendScripts()
     AddSC_storm_peaks();
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
+
+    AddSC_boss_baltharus();	//RubySanctum
+    AddSC_boss_halion();
+    AddSC_boss_ragefire();
+    AddSC_boss_zarithrian();
+    AddSC_instance_ruby_sanctum();
 #endif
 }
 
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index cad7688..57c2aec 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -171,6 +171,13 @@ set(scripts_STAT_SRCS
   Northrend/DraktharonKeep/drak_tharon_keep.h
   Northrend/DraktharonKeep/boss_tharon_ja.cpp
   Northrend/DraktharonKeep/boss_dred.cpp
+  Northrend/RubySanctum/boss_baltharus.cpp
+  Northrend/RubySanctum/boss_halion.cpp
+  Northrend/RubySanctum/boss_ragefire.cpp
+  Northrend/RubySanctum/boss_zarithrian.cpp
+  Northrend/RubySanctum/instance_ruby_sanctum.cpp
+  Northrend/RubySanctum/ruby_sanctum.h
+  
 )
 
 message("  -> Prepared: Northrend")
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
new file mode 100644
index 0000000..f6ba7c3
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
@@ -0,0 +1,340 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752001,
+    SAY_SLAY1           = -1752002,
+	SAY_SLAY2           = -1752003,
+    SAY_DEATH           = -1752004,
+    SAY_SUMMON_CLONE    = -1752005,
+
+    SAY_XERESTRASZA_1  = -1752008,
+	SAY_XERESTRASZA_2  = -1752009,
+	SAY_XERESTRASZA_3  = -1752010,
+	SAY_XERESTRASZA_4  = -1752011,
+	SAY_XERESTRASZA_5  = -1752012,
+	SAY_XERESTRASZA_6  = -1752013,
+	SAY_XERESTRASZA_7  = -1752014,
+	SAY_XERESTRASZA_8  = -1752015,
+	SAY_XERESTRASZA_9  = -1752016
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE            = 40504,
+    SPELL_REPELLING_WAVE    = 74509,
+    SPELL_ENERVATING_BRAND  = 74502,
+    SPELL_BLADE_TEMPEST     = 75125,
+    SPELL_SUMMON_CLONE      = 74511
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE           = 1,
+    EVENT_CAST_REPELLING_WAVE   = 2,
+    EVENT_CAST_ENERVATING_BRAND = 3,
+    EVENT_CAST_BLADE_TEMPEST    = 4,
+    EVENT_CAST_SUMMON_CLONE     = 5,
+    
+    ACTION_START_EVENT          = 6,
+    EVENT_XERESTRASZA_3         = 7,
+    EVENT_XERESTRASZA_4         = 8,
+    EVENT_XERESTRASZA_5         = 9,
+    EVENT_XERESTRASZA_6         = 10,
+    EVENT_XERESTRASZA_7         = 11,
+    EVENT_XERESTRASZA_8         = 12,
+    EVENT_XERESTRASZA_9         = 13
+};
+
+Creature* pXerestrasza;
+
+class boss_baltharus : public CreatureScript
+{
+    public:
+        boss_baltharus() : CreatureScript("boss_baltharus") { }
+
+        struct boss_baltharusAI : public BossAI
+        {
+            boss_baltharusAI(Creature* pCreature) : BossAI(pCreature, DATA_BALTHARUS)
+    	    {
+                ASSERT(instance);
+    	    }
+
+    	    void Reset()
+    	    {
+                instance->SetBossState(DATA_BALTHARUS, NOT_STARTED);
+                bClone = false;
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_REPELLING_WAVE, urand(20000,30000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+    	    }
+
+    	    void EnterCombat(Unit*)
+    	    {
+                instance->SetBossState(DATA_BALTHARUS, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+    		    if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_CAST_REPELLING_WAVE:
+                            DoCast(SPELL_REPELLING_WAVE);
+                            events.ScheduleEvent(EVENT_CAST_REPELLING_WAVE, urand(20000,30000));
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCast(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+                            break;
+                    }
+                }
+
+                if(!bClone)
+                {
+                    if(me->GetHealth() <= ((me->GetMaxHealth() / 100) * 50))
+				    {
+					    bClone = true;
+					    DoCast(SPELL_SUMMON_CLONE);
+					    DoScriptText(SAY_SUMMON_CLONE, me);
+				    }
+                }
+
+    		    DoMeleeAttackIfReady();
+    	    }
+
+            void JustSummoned(Creature *summon)
+            {
+                summons.Summon(summon);
+            }
+
+    	    void KilledUnit(Unit *victim)
+    	    {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+    	    }
+
+            void JustReachedHome()
+            {
+                summons.DespawnAll();
+                instance->SetData(DATA_BALTHARUS, FAIL);
+            }
+
+    	    void JustDied(Unit*)
+    	    {
+                DoScriptText(SAY_DEATH, me);
+                pXerestrasza->AI()->DoAction(ACTION_START_EVENT);
+                _JustDied();
+    	    }
+
+        private:
+            bool bClone;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+    	    return new boss_baltharusAI(pCreature);
+        }
+
+};
+
+class boss_baltharus_summon : public CreatureScript
+{
+    public:
+        boss_baltharus_summon() : CreatureScript("boss_baltharus_summon") { }
+
+        struct boss_baltharus_summonAI : public ScriptedAI
+        {
+            boss_baltharus_summonAI(Creature* pCreature) : ScriptedAI(pCreature)
+    	    {
+                pInstance = me->GetInstanceScript();
+    	    }
+
+    	    void Reset()
+    	    {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+    		    if (!UpdateVictim())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCast(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+                            break;
+                    }
+                }
+
+    		    DoMeleeAttackIfReady();
+    	    }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+    	    return new boss_baltharus_summonAI(pCreature);
+        }
+
+};
+
+class npc_xerestrasza : public CreatureScript
+{
+    public:
+        npc_xerestrasza() : CreatureScript("npc_xerestrasza") { }
+
+        struct npc_xerestraszaAI : public ScriptedAI
+        {
+    	    npc_xerestraszaAI(Creature *pCreature) : ScriptedAI(pCreature)
+    	    {
+    		    pInstance = me->GetInstanceScript();
+                pXerestrasza = me;
+    	    }
+
+            void Reset()
+            {
+                events.Reset();
+                bIntro = false;
+                pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+            }
+
+            void MoveInLineOfSight(Unit*)
+    	    {
+    		    if(!bIntro)
+    		    {
+    			    DoScriptText(SAY_XERESTRASZA_1, me);
+                    pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+    			    bIntro = true;
+    		    }
+    	    }
+
+            void DoAction(const int32 action)
+            {
+                if (action == ACTION_START_EVENT)
+                {
+                    me->GetMotionMaster()->MovePoint(1, 3153.5490f, 385.53f, 86.33f);
+                    pInstance->SetData(DATA_XERESTRASZA,IN_PROGRESS);
+                    DoScriptText(SAY_XERESTRASZA_2, me);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_3,9000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_4,20000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_5,31000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_6,42000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_7,53000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_8,64000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_9,75000); 
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_XERESTRASZA_3:
+                            DoScriptText(SAY_XERESTRASZA_3, me);
+                            break;
+                        case EVENT_XERESTRASZA_4:
+                            DoScriptText(SAY_XERESTRASZA_4, me);
+                            break;
+                        case EVENT_XERESTRASZA_5:
+                            DoScriptText(SAY_XERESTRASZA_5, me);
+                            break;
+                        case EVENT_XERESTRASZA_6:
+                            DoScriptText(SAY_XERESTRASZA_6, me);
+                            break;
+                        case EVENT_XERESTRASZA_7:
+                            DoScriptText(SAY_XERESTRASZA_7, me);
+                            break;
+                        case EVENT_XERESTRASZA_8:
+                            DoScriptText(SAY_XERESTRASZA_8, me);
+                            break;
+                        case EVENT_XERESTRASZA_9:
+                            DoScriptText(SAY_XERESTRASZA_9, me);
+                            pInstance->SetData(DATA_XERESTRASZA,DONE);
+                            break;
+                    }
+                }
+            }
+
+    	private:
+            bool bIntro;
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+    	    return new npc_xerestraszaAI(pCreature);
+        }
+};
+
+
+void AddSC_boss_baltharus()
+{
+    new boss_baltharus;
+    new boss_baltharus_summon;
+    new npc_xerestrasza;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..3cdc6be
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
@@ -0,0 +1,521 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+        SAY_SPAWN       = -1752027,
+        SAY_AGGRO       = -1752028,
+        SAY_SLAY1       = -1752029,
+        SAY_SLAY2       = -1752030,
+        SAY_DEATH       = -1752031,
+        SAY_BERSERK     = -1752032,
+        SAY_SPECIAL1    = -1752033,
+        SAY_SPECIAL2    = -1752034,
+        SAY_PHASE2      = -1752035,
+        SAY_PHASE3      = -1752036
+};
+
+enum eSpells
+{
+    //All
+    SPELL_TWILIGHT_PRECISION        = 78243,
+    SPELL_CLEAVE                    = 74524,
+    SPELL_TAIL_LASH                 = 74531,
+    SPELL_BERSEK                    = 26662,
+    SPELL_TWILIGHT_DIVISION         = 75063,
+    SPELL_SUMMON_TWILIGHT_PORTAL    = 74809,
+
+    //halion
+    SPELL_FLAME_BREATH_10_NORMAL    = 74525,
+    SPELL_FLAME_BREATH_25_NORMAL    = 74526,
+    SPELL_FLAME_BREATH_10_HEROIC    = 74527,
+    SPELL_FLAME_BREATH_25_HEROIC    = 74528,
+    SPELL_FIERY_COMBUSTION          = 74562,
+
+    //twilight halion
+    SPELL_DUSK_SHROUD               = 75476,
+    SPELL_SOUL_CONSUMPTION          = 74792,
+    SPELL_DARK_BREATH_10_NORMAL     = 74806,
+    SPELL_DARK_BREATH_25_NORMAL     = 75954,
+    SPELL_DARK_BREATH_10_HEROIC     = 75955,
+    SPELL_DARK_BREATH_25_HEROIC     = 75956,
+
+    SPELL_CORPOREALITY_EVEN         = 74826,
+    SPELL_CORPOREALITY_20I          = 74827, 
+    SPELL_CORPOREALITY_40I          = 74828,
+    SPELL_CORPOREALITY_60I          = 74829,
+    SPELL_CORPOREALITY_80I          = 74830,
+    SPELL_CORPOREALITY_100I         = 74831,
+    SPELL_CORPOREALITY_20D          = 74832,
+    SPELL_CORPOREALITY_40D          = 74833,
+    SPELL_CORPOREALITY_60D          = 74834,
+    SPELL_CORPOREALITY_80D          = 74835,
+    SPELL_CORPOREALITY_100D         = 74836
+};
+
+enum eEvents
+{
+    EVENT_CAST_TWILIGHT_PRECISION   = 1,
+    EVENT_CAST_CLEAVE               = 2,
+    EVENT_CAST_FIERY_COMBUSTION     = 3,
+    EVENT_CAST_TAIL_LASH            = 4,
+    EVENT_CAST_FLAME_BREATH         = 5,
+    EVENT_CAST_DARK_BREATH          = 6,
+    EVENT_CAST_SOUL_CONSUMPTION     = 7,
+    EVENT_CAST_DUSK_SHROUD          = 8,
+    EVENT_FLAME_WALL                = 9,
+    EVENT_CAST_BERSEK               = 10,
+    EVENT_DPS                       = 11
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+    PHASE_3   = 3,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2,
+    PHASE_3_MASK  = 1 << PHASE_3
+};
+
+Creature* pHalion;
+Creature* pTwilight;
+uint32 HalionDamage, TwilightDamage;
+static const Position SpawnPos = {3144.93f, 527.233f, 72.8887f, 0.110395f};
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature *pCreature) : BossAI(pCreature, DATA_HALION)
+                {
+                    ASSERT(instance);
+                    pHalion = me;
+                }
+
+            void Reset()
+    	    {
+                if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS)
+                {
+                    pHalion->SetHealth(pTwilight->GetHealth());
+                    return;
+                }
+                instance->SetBossState(DATA_HALION, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000,PHASE_ALL);
+                events.ScheduleEvent(SPELL_BERSEK, 9999999,PHASE_ALL);
+                PercentDamage = 0;
+                HalionDamage = 0;
+    	    }
+
+    	    void EnterCombat(Unit*)
+    	    {
+                instance->SetBossState(DATA_HALION, IN_PROGRESS);
+                
+                if(events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    pHalion->SetHealth(pTwilight->GetHealth());
+                    return;
+                }
+                
+                events.ScheduleEvent(EVENT_FLAME_WALL, 1000,PHASE_1);
+                DoScriptText(SAY_AGGRO, me);
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (instance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(instance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                GameObject* go_flame;
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) || (events.GetPhaseMask() & PHASE_3_MASK))
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_TWILIGHT_PRECISION:
+                                DoCast(me, SPELL_TWILIGHT_PRECISION);
+                                break;
+                            case EVENT_FLAME_WALL:
+                                go_flame = me->SummonGameObject(GO_FLAME_WALLS2, (float)3154.56, (float)535.418, (float)72.8889, (float)4.47206, 0, 0, (float)0.786772, (float)-0.617243, 300);
+                                go_flame->SetPhaseMask(0,true);
+                                break;
+                            case EVENT_CAST_TAIL_LASH:
+                                DoCast(me, SPELL_TAIL_LASH);
+                                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                                break;
+                            case EVENT_CAST_CLEAVE:
+                                DoCast(me, SPELL_CLEAVE);
+                                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(me, RAID_MODE(SPELL_FLAME_BREATH_10_NORMAL, SPELL_FLAME_BREATH_25_NORMAL, SPELL_FLAME_BREATH_10_HEROIC, SPELL_FLAME_BREATH_25_HEROIC));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000),PHASE_ALL);break;
+                            case EVENT_DPS:
+                                CastCorporeality();
+                                events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                                break;
+                            case EVENT_CAST_FIERY_COMBUSTION:
+                                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+    				            if (pTarget && !pTarget->HasAura(SPELL_FIERY_COMBUSTION))
+    					            DoCast(pTarget, SPELL_FIERY_COMBUSTION);
+                                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000,PHASE_ALL);
+                                break;
+                        }
+                    }
+                }
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) && ((me->GetHealth()*100) / me->GetMaxHealth() <= 75))
+    			{
+                    events.SetPhase(PHASE_2);
+    				DoScriptText(SAY_PHASE2, me);
+    				me->SetReactState(REACT_PASSIVE);
+    				me->AttackStop();
+    				me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    DoCast(me, SPELL_SUMMON_TWILIGHT_PORTAL);
+    				DoCast(me, SPELL_TWILIGHT_DIVISION);
+                    me->SummonCreature(NPC_TWILIGHT_HALION,SpawnPos);
+                    me->SetVisible(false);
+                    instance->SetBossState(DATA_HALION, SPECIAL);
+    			}
+                DoMeleeAttackIfReady();
+    	    }
+
+            void CastCorporeality()
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                uint32 TotalDamage = HalionDamage+TwilightDamage;
+                if (TotalDamage > 0)
+                {
+                    PercentDamage = HalionDamage / TotalDamage * 100;
+                }
+                else
+                {
+                    PercentDamage=50;
+                }
+                HalionDamage = 0;
+                TwilightDamage = 0;
+
+                if (PercentDamage < 5)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_100I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_100D, true);
+                }
+                else if (PercentDamage < 15)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_80I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_80D, true);
+                }
+                else if (PercentDamage < 25)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_60I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_60D, true);
+                }
+                else if (PercentDamage < 35)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_40I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_40D, true);
+                }
+                else if (PercentDamage < 45)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_20I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_20D, true);
+                }
+                else if (PercentDamage < 55)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_EVEN, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_EVEN, true);
+                }
+                else if (PercentDamage < 65)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_20I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_20D, true);
+                }
+                else if (PercentDamage < 75)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_40I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_40D, true);
+                }
+                else if (PercentDamage < 85)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_60I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_60D, true);
+                }
+                else if (PercentDamage < 95)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_80I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_80D, true);
+                }
+                else
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_100I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_100D, true);
+                }
+            }
+
+            void SetPhase3()
+            {
+                events.SetPhase(PHASE_3);
+                GameObject* portal = me->SummonGameObject(GO_TWILIGHT_PORTAL2, (float)3154.56, (float)535.418, (float)72.8889, (float)4.47206, 0, 0, (float)0.786772, (float)-0.617243, 300000);
+                portal->SetPhaseMask(32,true);
+                portal->SetRespawnTime(9999999);
+                events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                pHalion->SetHealth(pTwilight->GetHealth());
+            }
+
+            void DamageTaken(Unit *who, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                HalionDamage += dmg;	
+                
+                instance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                if(summon->GetEntry()==NPC_TWILIGHT_HALION)
+                {
+                    summon->SetPhaseMask(32,true);
+                }
+                summons.Summon(summon);
+            }
+
+    	    void KilledUnit(Unit *victim)
+    	    {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+    	    }
+
+    	    void JustDied(Unit*)
+    	    {
+                _JustDied();
+                DoScriptText(SAY_DEATH, me);
+    	    }
+
+        private:
+            uint32 PercentDamage;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_halionAI(pCreature);
+        }
+
+};
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+                {
+                    pInstance = me->GetInstanceScript();
+                    pTwilight = me;
+                }
+
+            void Reset()
+    	    {
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                events.Reset();
+                events.SetPhase(PHASE_2);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999,PHASE_ALL);
+                me->SetMaxHealth(pHalion->GetMaxHealth());
+                TwilightDamage = 0;
+    	    }
+
+    	    void EnterCombat(Unit*)
+    	    {
+                me->SetHealth(pHalion->GetHealth());
+                pInstance->SetData(DATA_TWILIGHT_HALION,IN_PROGRESS);
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+                if (!UpdateVictim())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (pInstance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(pInstance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_TWILIGHT_PRECISION:
+                            DoCast(me, SPELL_TWILIGHT_PRECISION);
+                            events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 10000,PHASE_ALL);
+                            break;
+                        case EVENT_CAST_TAIL_LASH:
+                            DoCast(me, SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_DARK_BREATH:
+                            DoCast(me, RAID_MODE(SPELL_DARK_BREATH_10_NORMAL, SPELL_DARK_BREATH_25_NORMAL, SPELL_DARK_BREATH_10_HEROIC, SPELL_DARK_BREATH_25_HEROIC));
+                            events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000),PHASE_ALL);break;
+                        case EVENT_CAST_CLEAVE:
+                            DoCast(me, SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                            break;
+                        case EVENT_CAST_DUSK_SHROUD:
+                            DoCast(me, SPELL_DUSK_SHROUD);
+                            events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_SOUL_CONSUMPTION:
+                            DoCast(me, SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_BERSEK:
+                            DoCast(me, SPELL_BERSEK);
+                            events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999,PHASE_ALL);
+                            break;
+                        case EVENT_DPS:
+                            if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->CastCorporeality();
+                            events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                            break;
+                    }
+                }
+
+                if ((events.GetPhaseMask() & PHASE_2_MASK) && ((me->GetHealth()*100) / me->GetMaxHealth() <= 50))
+    			{
+                    events.SetPhase(PHASE_3);
+    				DoScriptText(SAY_PHASE3, me);
+                    pHalion->SetReactState(REACT_AGGRESSIVE);
+    				pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    pHalion->SetVisible(true);
+                    CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->SetPhase3();
+                    events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+    			}
+
+                DoMeleeAttackIfReady();
+    	    }
+
+            void DamageTaken(Unit *who, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                TwilightDamage += dmg;	
+
+                pInstance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+    	    void KilledUnit(Unit *victim)
+    	    {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+    	    }
+
+    	    void JustDied(Unit*)
+    	    {
+                DoScriptText(SAY_DEATH, me);
+                
+                pInstance->SetData(DATA_TWILIGHT_HALION,DONE);
+    	    }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_twilight_halionAI(pCreature);
+        }
+
+};
+
+class spell_halion_portal : public SpellScriptLoader
+{
+    public:
+        spell_halion_portal() : SpellScriptLoader("spell_halion_portal") { }
+
+        class spell_halion_portal_SpellScript : public SpellScript
+        {
+        	PrepareSpellScript(spell_halion_portal_SpellScript)
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                //PreventHitDefaultEffect(EFFECT_0);
+                GetHitPlayer()->RemoveAurasDueToSpell(74807);
+                GetHitPlayer()->SetPhaseMask(1,true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_halion_portal_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_portal_SpellScript();
+        }
+};
+
+
+void AddSC_boss_halion()
+{
+    new boss_halion;
+    new boss_twilight_halion;
+    new spell_halion_portal;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
new file mode 100644
index 0000000..8b3b248
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
@@ -0,0 +1,174 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752022,
+    SAY_SLAY1           = -1752023,
+	SAY_SLAY2           = -1752024,
+    SAY_DEATH           = -1752025
+};
+
+enum eSpells
+{
+	SPELL_CONFLAGRATION     = 74456,
+    SPELL_ENRAGE            = 78722,
+	SPELL_FLAME_BREATH_10   = 74403,
+	SPELL_FLAME_BREATH_25   = 74404,
+	SPELL_FLAME_BEACON      = 74453
+};
+
+enum eEvents
+{
+    EVENT_CAST_CONFLAGRATION      = 1,
+    EVENT_CAST_ENRAGE             = 2,
+    EVENT_CAST_FLAME_BREATH       = 3,
+    EVENT_CAST_FLAME_BEACON       = 4,
+    EVENT_CAST_CONFLAGRATION_FLY  = 5,
+    EVENT_CAST_CONFLAGRATION_CAST = 6
+};
+
+#define TARGETS_10 2
+#define TARGETS_25 5
+
+class boss_ragefire : public CreatureScript
+{
+    public:
+        boss_ragefire() : CreatureScript("boss_ragefire") { }
+
+        struct boss_ragefireAI : public BossAI
+        {
+            boss_ragefireAI(Creature *pCreature) : BossAI(pCreature, DATA_RAGEFIRE)
+    	    {
+                ASSERT(instance);
+                me->SetUnitMovementFlags(MOVEMENTFLAG_CAN_FLY);
+    	    }
+
+    	    void Reset()
+    	    {
+                instance->SetBossState(DATA_RAGEFIRE, NOT_STARTED);
+                playerList.clear();
+                bConflagration = false;
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+                if(!UpdateVictim() || !CheckInRoom())
+    			    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if (!bConflagration)
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION:
+                                bConflagration = true;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_FLY, 1000);
+                                break;
+                            case EVENT_CAST_ENRAGE:
+                                DoCast(SPELL_ENRAGE);
+                                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25,SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+                                break;
+                        }
+                    }
+                }
+                else
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION_FLY:
+                                me->GetMotionMaster()->MovePoint(1, (float)3159.04, (float)676.08, (float)103.05);
+                                SelectTargetList(playerList, RAID_MODE(TARGETS_10,TARGETS_25,TARGETS_10,TARGETS_25), SELECT_TARGET_RANDOM, 0, true);
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_FLAME_BEACON, true);
+                                }
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_CAST, 5000);
+                                break;
+                            case EVENT_CAST_CONFLAGRATION_CAST:
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_CONFLAGRATION, true);
+                                }
+                                playerList.clear();
+                                me->GetMotionMaster()->MoveTargetedHome();
+                                bConflagration = false;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                                break;
+                        }
+                    }
+                }
+
+    		    DoMeleeAttackIfReady();
+    	    }
+
+    	    void EnterCombat(Unit*)
+    	    {
+                instance->SetBossState(DATA_RAGEFIRE, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+    	    }
+
+    	    void KilledUnit(Unit *victim)
+    	    {
+    		    DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+    	    }
+
+    	    void JustDied(Unit*)
+    	    {
+                _JustDied();
+        		DoScriptText(SAY_DEATH, me);
+                instance->SetBossState(DATA_RAGEFIRE, DONE);
+    	    }
+
+        private:
+            bool bConflagration;
+            std::list<Unit *> playerList;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+    	    return new boss_ragefireAI(pCreature);
+        }
+
+};
+
+
+void AddSC_boss_ragefire()
+{
+    new boss_ragefire;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
new file mode 100644
index 0000000..e932686
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
@@ -0,0 +1,116 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+	SAY_AGGRO = -1752017,
+	SAY_SLAY1 = -1752018,
+	SAY_SLAY2 = -1752019,
+	SAY_DEATH = -1752020
+};
+
+enum eSpells
+{
+	SPELL_CLEAVE_ARMOR         = 74367,
+	SPELL_INTIMIDATING_ROAR    = 74384
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE_ARMOR      = 1,
+    EVENT_CAST_INTIMIDATING_ROAR = 2
+};
+
+class boss_zarithrian : public CreatureScript
+{
+    public:
+        boss_zarithrian() : CreatureScript("boss_zarithrian") { }
+
+        struct boss_zarithrianAI : public BossAI
+        {
+            boss_zarithrianAI(Creature *pCreature) : BossAI(pCreature, DATA_ZARITHRIAN)
+    	    {
+                ASSERT(instance);
+    	    }
+
+    	    void Reset()
+    	    {
+                instance->SetBossState(DATA_ZARITHRIAN, NOT_STARTED);
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+    	    }
+
+    	    void EnterCombat(Unit*)
+    	    {
+                instance->SetBossState(DATA_ZARITHRIAN, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+    	    }
+
+    	    void UpdateAI(const uint32 diff)
+    	    {
+                if(!UpdateVictim() || !CheckInRoom())
+			        return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE_ARMOR:
+                            DoCastVictim(SPELL_CLEAVE_ARMOR);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                            break;
+                        case EVENT_CAST_INTIMIDATING_ROAR:
+                            DoCast(SPELL_INTIMIDATING_ROAR);
+                            events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                            break;
+                    }
+                }
+
+    		    DoMeleeAttackIfReady();
+    	    }
+
+    	    void KilledUnit(Unit *victim)
+    	    {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+    	    }
+
+    	    void JustDied(Unit*)
+    	    {
+                _JustDied();
+                DoScriptText(SAY_DEATH, me);
+    	    }
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+    	    return new boss_zarithrianAI(pCreature);
+        }
+
+};
+
+void AddSC_boss_zarithrian()
+{
+    new boss_zarithrian;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
new file mode 100644
index 0000000..cf6c19c
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
@@ -0,0 +1,234 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+static const DoorData doorData[8] =
+{
+    {GO_FIRE_FIELD,   DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_RAGEFIRE,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS2, DATA_HALION,          DOOR_TYPE_ROOM,    BOUNDARY_NONE},
+    {GO_FLAME_WALLS2, DATA_TWILIGHT_HALION, DOOR_TYPE_ROOM,    BOUNDARY_NONE},
+    {0,               0,                    DOOR_TYPE_ROOM,    BOUNDARY_NONE}
+};
+
+class instance_ruby_sanctum : public InstanceMapScript
+{
+    public:
+        instance_ruby_sanctum() : InstanceMapScript("instance_ruby_sanctum", 724) { }
+
+        struct instance_ruby_sanctum_InstanceMapScript : public InstanceScript
+        {
+            instance_ruby_sanctum_InstanceMapScript(Map *pMap) : InstanceScript(pMap)
+            {
+                SetBossNumber(MAX_ENCOUNTER);
+                LoadDoorData(doorData);
+
+                m_uiDataDamage = 0;
+
+                m_uiXerestrasza = 0;
+                m_uiTwilightHalion = 0;
+
+                m_uiBaltharusGUID = 0;
+                m_uiZarithrianGUID = 0;
+                m_uiRagefireGUID = 0;
+                m_uiHalionGUID = 0;
+                m_uiXerestraszaGUID = 0;
+                m_uiTwilightHalionGUID = 0;
+            }
+
+            void OnCreatureCreate(Creature *pCreature, bool  /*add*/)
+            {
+                switch(pCreature->GetEntry())
+                {
+                    case NPC_BALTHARUS:     m_uiBaltharusGUID = pCreature->GetGUID();   break;
+                    case NPC_RAGEFIRE:      m_uiRagefireGUID = pCreature->GetGUID();    break;
+                    case NPC_XERESTRASZA:   m_uiXerestraszaGUID = pCreature->GetGUID(); break;
+                    case NPC_ZARITHRIAN:
+                        m_uiZarithrianGUID = pCreature->GetGUID();
+                        pCreature->SetReactState(REACT_PASSIVE);
+                        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_HALION:        
+                        m_uiHalionGUID = pCreature->GetGUID();
+                        pCreature->SetVisible(false);
+                        pCreature->SetReactState(REACT_PASSIVE);
+                        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_TWILIGHT_HALION: m_uiTwilightHalionGUID = pCreature->GetGUID(); break;
+                }
+            }
+
+            void OnGameObjectCreate(GameObject* pGo, bool add)
+            {
+                switch (pGo->GetEntry())
+                {
+                    case GO_FIRE_FIELD:
+                    case GO_FLAME_WALLS:
+                    case GO_FLAME_WALLS2:
+                        AddDoor(pGo, add);
+                        break;
+                    case GO_TWILIGHT_PORTAL1: break;
+                    case GO_TWILIGHT_PORTAL2: break;
+                    default: break;
+                }
+            }
+
+            void SetData(uint32 uiType, uint32 uiData)
+            {
+                switch(uiType)
+    		    {
+                    case DATA_XERESTRASZA:     m_uiXerestrasza    = uiData; break;
+                    case DATA_TWILIGHT_HALION: m_uiTwilightHalion = uiData; break;
+                    case DATA_DAMAGE:          m_uiDataDamage     = uiData; break;   
+                }
+            }
+
+            uint32 GetData(uint32 uiType)
+    	    {
+    		    switch(uiType)
+                {
+    			    case DATA_XERESTRASZA:     return m_uiXerestrasza;    break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalion; break;
+                    case DATA_DAMAGE:          return m_uiDataDamage;     break;
+                }
+                return 0;
+    	    }
+
+            void BossZarithrian()
+            {
+                if (Creature* Zarithrian = instance->GetCreature(GetData64(DATA_ZARITHRIAN)))
+                {
+                    Zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    Zarithrian->SetReactState(REACT_AGGRESSIVE);
+                }
+            }
+
+            bool SetBossState(uint32 type, EncounterState state)
+            {
+                if (!InstanceScript::SetBossState(type, state))
+                    return false;
+
+                switch (type)
+                {
+                    case DATA_BALTHARUS:
+                        if(state==DONE)
+                        {
+                            if(GetBossState(DATA_RAGEFIRE)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_RAGEFIRE: 
+                        if(state==DONE)
+                        {
+                            if(GetBossState(DATA_BALTHARUS)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_ZARITHRIAN:
+                        if(GetBossState(DATA_BALTHARUS)==DONE && GetBossState(DATA_RAGEFIRE)==DONE)
+                        {
+                            if(state==DONE)
+                            {
+                                if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+                                {
+                                    halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    halion->SetVisible(true);
+                                    halion->SetReactState(REACT_AGGRESSIVE);
+                                }
+                            }
+                        }
+                        break;
+                    case DATA_HALION: break;
+                }
+
+                return true;
+            }
+
+    	    uint64 GetData64(uint32 uiData)
+            {
+                switch(uiData)
+                {
+                    case DATA_BALTHARUS:       return m_uiBaltharusGUID;      break;
+                    case DATA_ZARITHRIAN:      return m_uiZarithrianGUID;     break;
+                    case DATA_RAGEFIRE:        return m_uiRagefireGUID;       break;
+                    case DATA_HALION:          return m_uiHalionGUID;         break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalionGUID; break;
+                    case DATA_XERESTRASZA:     return m_uiXerestraszaGUID;    break;
+                    default: break;
+                }
+                return 0;
+    	    }
+
+            std::string GetSaveData()
+            {
+                std::ostringstream saveStream;
+                saveStream << GetBossSaveData() << " " << m_uiXerestrasza;
+                return saveStream.str();
+            }
+
+            void Load(const char* strIn)
+            {
+                if (!strIn)
+                {
+                    return;
+                }
+
+                std::istringstream loadStream(strIn);
+
+                uint32 tmpState;
+                
+                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                {
+                    loadStream >> tmpState;
+                    if (tmpState == IN_PROGRESS || tmpState > SPECIAL)
+                        tmpState = NOT_STARTED;
+                    SetBossState(i, EncounterState(tmpState));
+                }
+
+                loadStream >> m_uiXerestrasza;
+            }
+
+            private:
+                uint32 m_uiXerestrasza;
+                uint32 m_uiTwilightHalion;
+                uint32 m_uiDataDamage;
+
+                uint64 m_uiBaltharusGUID;
+                uint64 m_uiZarithrianGUID;
+                uint64 m_uiRagefireGUID;
+                uint64 m_uiHalionGUID;
+                uint64 m_uiXerestraszaGUID;
+                uint64 m_uiTwilightHalionGUID;
+        };
+        
+        InstanceScript* GetInstanceScript (InstanceMap *pMap) const
+        {
+            return new instance_ruby_sanctum_InstanceMapScript(pMap);
+        }
+};
+
+
+void AddSC_instance_ruby_sanctum()
+{
+    new instance_ruby_sanctum;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
new file mode 100644
index 0000000..03c247f
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
@@ -0,0 +1,130 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+DELETE FROM script_texts where `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM script_texts where `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM script_texts where `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO script_texts (`entry`, `content_default`, `npc_entry`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '', '17490', '1', '0'),	 	
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '', '17491', '1', '0'),	 	
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '', '17492', '0', '0'),	 	
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '', '17493', '0', '0'), 	
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '', '17494', '0', '0'), 	
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '', '17495', '0', '0'),	
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '', '17496', '0', '0'),	
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '', '17497', '0', '0'),	
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, "", 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, "", 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, "", 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, "", 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, "", 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, "", 17525, 1, 0),
+
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, "", 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, "", 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, "", 17514, 1, 0),
+( -1752020, "HALION! I...", 0, "", 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, "", 17516, 1, 0),
+
+( -1752022, "You will sssuffer for this intrusion!", 0, "", 17528, 1, 0),
+( -1752023, "As it should be...", 0, "", 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, "", 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, "", 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, "", 17532, 1, 0),
+
+(-1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,NULL,17499,0,0),
+(-1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,NULL,17500,0,0),
+(-1752029, 'Another hero falls.',NULL,NULL,17501,0,0),
+(-1752030, 'Hahahahaha.',NULL,NULL,17502,0,0),
+(-1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,NULL,17503,0,0),
+(-1752032, 'Not good enough.',NULL,NULL,17504,0,0),
+(-1752033, 'The heavens burn!',NULL,NULL,17505,0,0),
+(-1752034, 'Beware the shadow!',NULL,NULL,17506,0,0),
+(-1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,NULL,17507,0,0),
+(-1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,NULL,17508,0,0);
+
+UPDATE `instance_template` SET `script`='instance_ruby_sanctum' WHERE (`map`='724');
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+
+REPLACE `spell_script_names` SET `ScriptName` = 'spell_halion_portal', `spell_id`=74812;
+
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `data10`=74812 WHERE `entry`=202796;
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74562') AND (`spell_effect`='74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74792') AND (`spell_effect`='74800');
+INSERT INTO spell_linked_spell VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO spell_linked_spell VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM creature WHERE `id`=39863 and `map`=724;
+INSERT INTO creature VALUES (null,39863,724,15,1,0,0,3144.93,527.233,72.8887,0.110395,300,0,0,11156000,0,0,0);
+*/
+
+#ifndef DEF_RUBY_SANCTUM_H
+#define DEF_RUBY_SANCTUM_H
+
+enum eData
+{
+    DATA_BALTHARUS       = 0,
+    DATA_RAGEFIRE        = 1,
+    DATA_ZARITHRIAN      = 2,
+    DATA_HALION          = 3,
+    MAX_ENCOUNTER        = 4,
+    DATA_XERESTRASZA     = 5,
+    DATA_TWILIGHT_HALION = 6,
+    DATA_DAMAGE          = 7
+};
+
+enum eAchievementData
+{
+    TWILIGHT_DESTROYER_NORMAL_10    = 4817,
+    TWILIGHT_DESTROYER_NORMAL_25    = 4815,
+    TWILIGHT_DESTROYER_HEROIC_10    = 4818,
+    TWILIGHT_DESTROYER_HEROIC_25    = 4816
+};
+
+enum eCreature
+{
+	NPC_BALTHARUS        = 39751,
+    NPC_BALTHARUS_SUMMON = 39899,
+	NPC_ZARITHRIAN       = 39746,
+	NPC_RAGEFIRE         = 39747,
+	NPC_HALION           = 39863,
+    NPC_TWILIGHT_HALION  = 40142,
+	NPC_XERESTRASZA      = 40429
+};
+
+enum eGameObject
+{
+    GO_FIRE_FIELD       = 203005,
+    GO_FLAME_WALLS      = 203006,
+    GO_FLAME_WALLS2     = 203007,
+    GO_TWILIGHT_PORTAL1 = 202794,
+    GO_TWILIGHT_PORTAL2 = 202796
+};
+
+#endif
+
