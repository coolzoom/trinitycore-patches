diff --git a/src/server/game/AI/BotAI/PlayerbotAI.cpp b/src/server/game/AI/BotAI/PlayerbotAI.cpp
new file mode 100644
index 0000000..3130838
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotAI.cpp
@@ -0,0 +1,6195 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "SharedDefines.h"
+#include "GossipDef.h"
+#include "Config.h"
+#include "BattlegroundAV.h"
+#include "LootMgr.h"
+#include "Guild.h"
+#include "Group.h"
+#include <ctime>
+#include <algorithm>
+
+// Packing/Unpacking 2xuint8 <-> uint64
+#define PACK(high, low)			((high << 8) | low)
+#define UNPACK(val, high, low)	high = val >> 8; low = val &255;
+#define UNPACK_HIGH(val)		(val >> 8)
+#define UNPACK_LOW(val)			(val & 255)
+
+/*
+* Packets often compress the GUID (global unique identifier)
+* This function extracts the guid from the packet and decompresses it.
+* The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+* the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+* there will be only 3 words. The first word is shifted to the left 0 times,
+* the second is shifted 3 times, and the third is shifted 6.
+*/
+uint64 extractGuid(WorldPacket &packet)
+{
+    uint8 mask; packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while(true)
+    {
+        if(mask & testMask)
+        {
+            uint8 word; packet >> word;
+            guid += (word << bit);
+        }
+        if(bit == 7) break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+// Extract a list of talent ids
+void extractTalentIds(const std::string &text, std::list<uint32> &talents)
+{
+	// Link Format:
+	// |color|Htalent:talent_id:rank|h[name]|h|r
+    uint8 pos = 0;
+    while(true)
+    {
+        int i = text.find("Htalent:", pos);
+		if (i == std::string::npos) break;
+        pos = i + 8;	// length of "Htalent:"
+		int endPos = text.find(':', pos);
+		if (endPos == std::string::npos) break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+
+        pos = endPos + 1;
+        if (id) talents.push_back(id);
+    }
+}
+
+//extracts all item ids in format below
+//I decided to roll my own extractor rather then use the one in ChatHandler
+//because this one works on a const string, and it handles multiple links
+//|color|linkType:key:something1:...:somethingN|h[name]|h|r
+void extractItemIds(const std::string &text, std::list<uint32> &itemIds)
+{
+    uint8 pos = 0;
+    while(true)
+    {
+        int i = text.find("Hitem:", pos);
+		if (i == std::string::npos) break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+		if (endPos == std::string::npos) break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if(id) itemIds.push_back(id);
+    }
+}
+
+bool extractGOinfo(const std::string& text, uint32 &guid, uint32 &entry, int &mapid, float &x, float &y, float &z)
+{
+   // Link format:
+   // |cFFFFFF00|Hfound:guid:entry:x:y:z:mapid:|h[name]|h|r
+   // |cFFFFFF00|Hfound:5093:1731:-9295:-270:81.874:0:|h[Copper Vein]|h|r
+  uint8 pos = 0;
+
+  // extract GO guid
+  int i = text.find("Hfound:", pos); // base H = 11
+  if (i == std::string::npos) // break if error
+	return false;
+
+  pos = i + 7; //start of window in text 11 + 7 = 18
+  int endPos = text.find(':', pos); // end of window in text 22
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string guidC = text.substr(pos, endPos - pos); // get string within window i.e guid 22 - 18 =  4
+  guid = atol(guidC.c_str()); // convert ascii to long int
+
+  // extract GO entry
+  pos = endPos + 1;
+  endPos = text.find(':', pos); // end of window in text
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string entryC = text.substr(pos, endPos - pos); // get string within window i.e entry
+  entry = atol(entryC.c_str()); // convert ascii to float
+
+  // extract GO x
+  pos = endPos + 1;
+  endPos = text.find(':', pos); // end of window in text
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string xC = text.substr(pos, endPos - pos); // get string within window i.e x
+  x = atof(xC.c_str()); // convert ascii to float
+
+  // extract GO y
+  pos = endPos + 1;
+  endPos = text.find(':', pos); // end of window in text
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string yC = text.substr(pos, endPos - pos); // get string within window i.e y
+  y = atof(yC.c_str()); // convert ascii to float
+
+  // extract GO z
+  pos = endPos + 1;
+  endPos = text.find(':', pos); // end of window in text
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string zC = text.substr(pos, endPos - pos); // get string within window i.e z
+  z = atof(zC.c_str()); // convert ascii to float
+
+  //extract GO mapid
+  pos = endPos + 1;
+  endPos = text.find(':', pos); // end of window in text
+  if (endPos == std::string::npos) //break if error
+	return false;
+  std::string mapidC = text.substr(pos, endPos - pos); // get string within window i.e mapid
+  mapid = atoi(mapidC.c_str()); // convert ascii to int
+  pos = endPos; // end
+
+  return true;
+}
+
+//extracts currency in #g#s#c format
+uint32 extractMoney(const std::string &text)
+{
+    //if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for(uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += atol(acum.c_str()) * 100 * 100;
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += atol(acum.c_str()) * 100;
+            acum = "";
+        }
+		else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if(text[i] >= '0' && text[i] <= '9')
+			acum += text[i];
+        else
+		{
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// Builds a hlink for a quest
+void MakeQuestLink(const Quest *qInfo, std::ostringstream &out)
+{
+	uint32 questId = qInfo->GetQuestId();
+	uint32 questLevel = qInfo->GetQuestLevel();
+    const std::string name = qInfo->GetTitle();
+
+	if (name.empty()) return;
+	out << "Quest |cffffffff|Hquest:" << questId << ":" << questLevel << "|h[" << name << "]|h|r";
+}
+
+// Build an hlink for spells
+void MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out, Player *player = NULL)
+{
+	LocaleConstant loc = LOCALE_enUS;
+	if (player)
+		loc = player->GetSession()->GetSessionDbcLocale();
+	out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
+}
+
+// Builds a hlink for an item, but since its
+// only a ItemPrototype, we cant fill in everything
+void PlayerbotAI::MakeItemLink(const ItemPrototype *item, std::ostringstream &out)
+{
+	// Color
+	out << "|c";
+	switch(item->Quality)
+	{
+	case ITEM_QUALITY_POOR:		out << "ff9d9d9d"; break;	//GREY
+	case ITEM_QUALITY_NORMAL:	out << "ffffffff"; break;	//WHITE
+	case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;	//GREEN
+	case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;	//BLUE
+	case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;	//PURPLE
+	case ITEM_QUALITY_LEGENDARY:out << "ffff8000"; break;	//ORANGE
+	case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;	//LIGHT YELLOW
+	case ITEM_QUALITY_HEIRLOOM:
+	default:					out << "ffff0000"; break;	//Don't know color, so red?
+	}
+	out << "|Hitem:";
+
+	// Item Id
+	out << item->ItemId << ":";
+
+	// Permanent enchantment, gems, 4 unknowns, and reporter_level
+	// ->new items wont have enchantments or gems so..
+	out << "0:0:0:0:0:0:0:0:0";
+
+	// Name
+	std::string name = item->Name1;
+	ItemLocalization(name, item->ItemId);
+	out << "|h[" << name << "]|h|r";
+}
+
+// Builds a hlink for an item, includes everything
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
+void PlayerbotAI::MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+	const ItemPrototype *proto = item->GetProto();
+	// Color
+	out << "|c";
+	switch(proto->Quality)
+	{
+	case ITEM_QUALITY_POOR:		out << "ff9d9d9d"; break;	//GREY
+	case ITEM_QUALITY_NORMAL:	out << "ffffffff"; break;	//WHITE
+	case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;	//GREEN
+	case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;	//BLUE
+	case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;	//PURPLE
+	case ITEM_QUALITY_LEGENDARY:out << "ffff8000"; break;	//ORANGE
+	case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;	//LIGHT YELLOW
+	case ITEM_QUALITY_HEIRLOOM:
+	default:					out << "ffff0000"; break;	//Don't know color, so red?
+	}
+	out << "|Hitem:";
+
+	// Item Id
+	out << proto->ItemId << ":";
+
+	// Permanent enchantment
+	out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+	// Gems
+	uint32 g1 = 0, g2 = 0, g3 = 0;
+	for(uint32 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT+MAX_GEM_SOCKETS; ++slot)
+	{
+		uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+		if (!eId) continue;
+
+		SpellItemEnchantmentEntry const* entry = sSpellItemEnchantmentStore.LookupEntry(eId);
+		if (!entry) continue;
+
+		switch(slot-SOCK_ENCHANTMENT_SLOT)
+		{
+		case 1: g1 = entry->GemID; break;
+		case 2: g2 = entry->GemID; break;
+		case 3: g3 = entry->GemID; break;
+		}
+	}
+	out << g1 << ":" << g2 << ":" << g3 << ":";
+
+	// Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
+	// Other stuff, don't know what it is
+	out << "0:0:0:0:";
+
+	// Reporter Level
+	out << "0";
+
+	// Name
+	std::string name = proto->Name1;
+	ItemLocalization(name, proto->ItemId);
+	out << "|h[" << name << "]|h|r";
+
+	// Stacked items
+	if (item->GetCount() > 1 && IncludeQuantity)
+		out << "x" << item->GetCount() << ' ';
+}
+
+
+//ChatHandler already implements some useful commands the master can call on bots
+//These commands are protected inside the ChatHandler class so this class provides access to the commands
+//we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+    public:
+        explicit PlayerbotChatHandler(Player *pMasterPlayer) : ChatHandler(pMasterPlayer), m_master(pMasterPlayer) {}
+
+        bool revive(const Player &botPlayer){ return HandleReviveCommand(botPlayer.GetName()); }
+        bool teleport(Player &botPlayer){ return botPlayer.TeleportTo(m_master->GetMapId(), m_master->GetPositionX(), m_master->GetPositionY(), m_master->GetPositionZ(), m_master->GetOrientation(), TELE_TO_GM_MODE); }
+        bool teleport(Player &botPlayer, const WorldLocation &loc){ return botPlayer.TeleportTo(loc,TELE_TO_GM_MODE); }
+        bool uninvite(const char *str){ return HandlePlayerbotRemoveCommand(str); }
+        void sysmessage(const char *str){ SendSysMessage(str); }
+        bool acceptQuest(const char *str){ return HandleQuestAdd(str); }
+        bool abandonQuest(const char *str) { return HandleQuestRemove(str); }
+
+	protected:
+		Player *m_master;
+
+};
+
+PlayerbotAI::PlayerbotAI(Player *const master, Player *const bot) :
+	m_master(master),
+	m_bot(bot),
+	m_ignoreAIUpdatesUntilTime(0),
+	m_combatOrder(ORDERS_NONE),
+	m_ScenarioType(SCENARIO_PVEEASY),
+	m_TimeDoneEating(0),
+	m_TimeDoneDrinking(0),
+	m_CurrentlyCastingSpellId(0),
+	m_IsFollowingMaster(true),
+	m_spellIdCommand(0),
+	m_targetGuidCommand(0),
+	m_classAI(NULL),
+	isLooting(false),
+	m_TimeRessurect(0),
+	m_FeastSpamTimer(0),
+	m_currVendor(NULL)
+{
+    //get class specific AI
+    switch(m_bot->getClass())
+    {
+    case CLASS_PRIEST:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotPriestAI(master, m_bot, this));
+        break;
+    case CLASS_WARRIOR:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotWarriorAI(master, m_bot, this));
+        break;
+    case CLASS_SHAMAN:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotShamanAI(master, m_bot, this));
+        break;
+    case CLASS_ROGUE:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotRogueAI(master, m_bot, this));
+        break;
+    case CLASS_PALADIN:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotPaladinAI(master, m_bot, this));
+        break;
+    case CLASS_MAGE:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotMageAI(master, m_bot, this));
+        break;
+    case CLASS_DRUID:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotDruidAI(master, m_bot, this));
+        break;
+    case CLASS_WARLOCK:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotWarlockAI(master, m_bot, this));
+        break;
+    case CLASS_HUNTER:
+        m_classAI = dynamic_cast<PlayerbotClassAI *>(new PlayerbotHunterAI(master, m_bot, this));
+        break;
+    case CLASS_DEATH_KNIGHT:
+        m_classAI = static_cast<PlayerbotClassAI *>(new PlayerbotDeathKnightAI(master, m_bot, this));
+        break;
+    }
+	if (!m_classAI) {
+		TellMaster("Failed setting classAI pointer");
+		return;
+	}
+
+	//If the player have a group, it's possible to add the bot.
+    if (master->GetGroup())
+    {
+        Group *m_group = master->GetGroup();
+        if (!m_group->IsFull() || m_group->IsMember(bot->GetGUID()))
+        {
+			bool inGroup = false;
+            //check that bot is not already in the group, ie from a server crash
+            Group::MemberSlotList const &groupSlot = master->GetGroup()->GetMemberSlots();
+            for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); ++itr)
+            {
+				if (itr->guid == bot->GetGUID())
+				{
+					inGroup = true;
+					break;
+				}
+            }
+            if (!inGroup)
+				m_group->AddMember(bot->GetGUID(), bot->GetName());
+        } else {
+            //group is full so can't add bot
+            bot->Say("Group is full!", LANG_UNIVERSAL);
+        }
+    } else {
+        Group *m_group = new Group;
+        if (!m_group->Create(master->GetGUID(), master->GetName()))
+        {
+            delete m_group;
+            return;
+        }
+        sObjectMgr->AddGroup(m_group);
+        if (!m_group->IsFull())
+			m_group->AddMember(bot->GetGUID(), bot->GetName());
+    }
+
+    //load config variables
+    m_followDistanceMin = sConfig->GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_followDistanceMax = sConfig->GetFloatDefault("Bot.FollowDistanceMax", 3.0f);
+    m_playerBotsFly = sConfig->GetIntDefault("Bot.PlayerBotsFly", 0);
+
+    SetQuestNeedItems();
+    m_needEmblemList.clear();
+    m_needEmblemList[29434] = 200; // Badge of Justice
+    m_needEmblemList[40752] = 200; // Emblem of Heroism
+    m_needEmblemList[40753] = 200; // Emblem of Valor
+    m_needEmblemList[45624] = 200; // Emblem of Conquest
+    m_needEmblemList[47241] = 200; // Emblem of Triumph
+    m_needEmblemList[49426] = 200; // Emblem of Frost
+    m_needEmblemList[44990] = 200; // Champion's Seal
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+}
+
+//finds spell ID for matching substring args
+//in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char *args, bool master) const
+{
+    if (!*args) return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart)) return 0;
+
+    //converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc;
+    if (master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId)) continue;
+
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo) continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart)) continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <=  0) ? true : false;
+
+        //if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch){}
+            else if (usesNoReagents && !foundMatchUsesNoReagents){}
+            else if (spellId > foundSpellId){}
+            else useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getSpellIdExact(const char *args, bool includePassive, bool master)
+{
+    if (!*args) return 0;
+    std::string namepart = args;
+
+    int loc;
+    if (master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = uint32(0);
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || ( !includePassive && IsPassiveSpell(spellId))) continue;
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo) continue;
+        if (pSpellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL) continue; //This is a learn spell
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty()) continue;
+        if (strcmp(name.c_str(),namepart.c_str())) continue;
+        if (pSpellInfo->Reagent[0] <=  0 && !foundMatchUsesNoReagents){ foundSpellId = spellId; foundMatchUsesNoReagents = true; }
+        else if (spellId > foundSpellId) { foundSpellId = spellId; }
+    }
+    //sLog->outDebug("PBot Class %u - Found in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str());
+    if (foundSpellId > 70000) { sLog->outDebug("CRITICAL: PBot Class %u - Weird Spell in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str()); }
+    return foundSpellId;
+}
+
+// finds quest ID for matching substring args
+uint32 PlayerbotAI::getQuestId(const char* args, bool remove) const
+{
+    if (!*args) return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart,wnamepart)) return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+    uint32 questId = 0;
+    uint32 foundQuestId = 0;
+    bool foundExactMatch = false;
+    if (!m_questsSeen.empty() && !remove)
+    {
+        for (BotQuestsSeen::const_iterator iter = m_questsSeen.begin(); iter != m_questsSeen.end(); ++iter)
+        {
+            uint32 questId = iter->first;
+            const std::string name = iter->second;
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    else if (remove)
+    {
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo) continue;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    return foundQuestId;
+}
+
+/*****************************************************************************/
+/*                           Guild Bank System                               */
+/*****************************************************************************/
+PlayerbotGuildBank::PlayerbotGuildBank(WorldSession *master /*=NULL*/) :
+	m_masterSession(master),
+	m_currTab(0),
+	m_active(false)
+{
+}
+
+void PlayerbotGuildBank::ResetMaster(WorldSession *session)
+{
+	m_masterSession = session;
+	m_currTab = 0;
+	m_active = false;
+}
+
+void PlayerbotGuildBank::Activate(WorldSession *session, uint64 guid)
+{
+	// See if there's a bot with the given guid
+	if (m_masterSession->GetPlayerbot(guid))
+		m_active = true;
+	else
+		m_active = false;
+}
+
+void PlayerbotGuildBank::HandleGuildPermissions(WorldSession *session) const
+{
+	Player *firstBot = GetPlayerbot(0);
+	if (!firstBot || !firstBot->GetPlayerbotAI()) return;
+
+	WorldPacket data(MSG_GUILD_PERMISSIONS, 4 * 15 + 1);
+
+	// Rank and Rank Rights
+	uint32 rankId = 1;							// 1 = Officer
+	uint32 rankRights = GR_RIGHT_WITHDRAW_GOLD;	// Able to withdraw gold
+    if (uint32 guildId = session->GetPlayer()->GetGuildId())
+	{	// If the player is in a guild, don't screw with other guild functions,
+		// so send the correct guild rank.  Just change the Guild Bank specific stuff.
+		// The only thing this will mess up is the ability to buy new tabs, which is
+		// controlled by rank, not bank permissions.  This is ok, because since we only
+		// mess with bank permissions, the client will never notice since they will get
+		// resent when activating the real guild bank.
+        if (Guild *pGuild = sObjectMgr->GetGuildById(guildId))   // Find guild by id
+		{
+			rankId = session->GetPlayer()->GetRank();
+			rankRights = pGuild->GetRankInfo(rankId)->GetRights();
+			rankRights |= GR_RIGHT_WITHDRAW_GOLD;
+		}
+	}
+	data << uint32(rankId);
+	data << uint32(rankRights);
+
+	// Money withdraw limit
+	data << uint32(GetWithdrawLimit(session));
+
+	// Purchased tab size
+	data << uint8(m_masterSession->GetPlayerbotsCount());
+
+	// Bank Tab Rights
+	uint32 tabRights;
+	if (firstBot->GetPlayerbotAI()->canObeyCommandFrom(*(session->GetPlayer())))
+		tabRights = GUILD_BANK_RIGHT_FULL;
+	else
+		tabRights = GUILD_BANK_RIGHT_DEPOSIT_ITEM;
+
+	// Each tab(bot)
+	for(uint8 tabId = 0; tabId < GUILD_BANK_MAX_TABS; ++tabId)
+	{
+		Player *bot = GetPlayerbot(tabId);
+
+		// Bank Tab Rights.
+		data << uint32(bot ? tabRights : 0);
+
+		// Remaining slots
+		data << uint32(bot ? GetRemainingSlots(bot) : 0);
+	}
+	session->SendPacket(&data);
+}
+
+void PlayerbotGuildBank::HandleGuildBankerActivate(WorldSession *session) const
+{
+	// If there are no Playerbots, don't do anything
+	if (m_masterSession->GetPlayerbotsCount() < 1) return;
+
+	// Build the response packet
+    WorldPacket data(SMSG_GUILD_BANK_LIST, 500);
+
+	// Tricky here, we say the bank has how much money that the Playerbot that
+	// owns the tab has.  In this case, the first Playerbot
+	Player *firstBot = m_masterSession->GetPlayerbotsBegin()->second;
+	data << uint64(firstBot->GetMoney());
+
+	// If the bot can obey the player looking at it, then you can take as
+	// many items as you want.  Otherwise you can only deposit
+	data << uint8(0);                                       // TabInfo packet must be for tabId 0
+	data << uint32(GetRemainingSlots(firstBot));			// Withdraw limit for the player
+	data << uint8(true);                                    // Tell client that this packet includes tab info
+	data << uint8(m_masterSession->GetPlayerbotsCount());	// Number of tabs
+
+	// Each tab
+	for(PlayerbotMap::const_iterator it = m_masterSession->GetPlayerbotsBegin(); it != m_masterSession->GetPlayerbotsEnd(); ++it)
+	{
+		Player *bot = it->second;
+		data << bot->GetName();		// Tab name
+		data << "";					// Tab icon
+	}
+	data << uint8(false);           // Do not send tab content
+	session->SendPacket(&data);
+}
+
+void PlayerbotGuildBank::HandleGuildBankQueryTab(WorldSession *session, uint8 tabId)
+{
+	if (tabId >= m_masterSession->GetPlayerbotsCount()) return;
+
+	Player *bot = GetPlayerbot(tabId);
+	if (!bot) return;	// Possibly resend all relevant data?
+
+	// Save which bot's inventory we're looking at
+	m_currTab = tabId;
+
+	// SendMoneyInfo
+	{
+		WorldPacket data(MSG_GUILD_BANK_MONEY_WITHDRAWN, 4);
+		data << uint32(GetWithdrawLimit(session));		// Money withdraw limit
+		session->SendPacket(&data);
+	}
+
+	// _SendBankContent
+	{
+		WorldPacket data(SMSG_GUILD_BANK_LIST, 1200);
+
+	    data << uint64(bot->GetMoney());				// Guild Moneu (Current tab's bot's money)
+		data << uint8(tabId);							// Tab Id
+		data << uint32(GetRemainingSlots(bot));			// Remaining slots for inspecting player
+		data << uint8(false);                           // Tell client that there's no tab info in this packet
+		data << uint8(GUILD_BANK_MAX_SLOTS);			// Number of slot in the bank (maybe get this to == slots in bot's bags?)
+
+		uint8 slotId = 0;
+
+		// Add all the items in the main backpack
+		for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+			WriteItem(data, slotId, bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot));
+
+		// Add items in the extra packs
+		for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+			if (const Bag *const pBag = (Bag *)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+				for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+					WriteItem(data, slotId, bot->GetItemByPos(bag, slot));
+
+		// Fill any remaining slots with NULL items
+		while (slotId < GUILD_BANK_MAX_SLOTS)
+			WriteItem(data, slotId, NULL);
+
+		// And send the packet to the player
+		session->SendPacket(&data);
+	}
+}
+
+void PlayerbotGuildBank::HandleGuildBankDepositMoney(WorldSession *session, uint32 money)
+{
+	// Remember which tab we were looking at to see which bot
+	// to give money to
+	Player *bot = GetPlayerbot(m_currTab);
+	if (!bot) return;
+
+	Player *player = session->GetPlayer();
+
+	// Take money from player, give to the bot
+	player->ModifyMoney(-int32(money));
+	bot->ModifyMoney(int32(money));
+
+	// Save the money exchange
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	player->SaveGoldToDB(trans);
+	bot->SaveGoldToDB(trans);
+	CharacterDatabase.CommitTransaction(trans);
+
+    //SendBankTabsInfo(session);
+	HandleGuildBankerActivate(session);
+
+	// _SendBankContent(session, m_currTab);
+	HandleGuildBankQueryTab(session, m_currTab);
+
+	// _SendBankMoneyUpdate(session);
+    WorldPacket data(SMSG_GUILD_BANK_LIST, 8+1+4+1+1);
+
+    data << uint64(bot->GetMoney());			// Money
+    data << uint8(m_currTab);                   // tabId
+    data << uint32(GetWithdrawLimit(session));	// Money left to withdraw
+    data << uint8(false);                       // Tell that there's no tab info in this packet
+    data << uint8(0);                           // No items
+	session->SendPacket(&data);
+}
+
+void PlayerbotGuildBank::HandleGuildBankWithdrawMoney(WorldSession *session, uint32 money)
+{
+	// Remember which bot's tab we're looking at
+	Player *bot = GetPlayerbot(m_currTab);
+	if (!bot) return;
+
+	Player *player = session->GetPlayer();
+
+	// Too much money, just take it all
+	if (money > bot->GetMoney())
+		money = bot->GetMoney();
+	if (money == 0 ) return;
+
+	// See if the player has permission to take money
+	if (GetWithdrawLimit(session) != GUILD_WITHDRAW_MONEY_UNLIMITED)
+		return;
+
+	// Take money from the bot, give to the player
+	bot->ModifyMoney(-int32(money));
+	player->ModifyMoney(int32(money));
+
+	// Save the money exchange
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	player->SaveGoldToDB(trans);
+	bot->SaveGoldToDB(trans);
+	CharacterDatabase.CommitTransaction(trans);
+
+	// SendMoneyInfo
+	{
+		WorldPacket data(MSG_GUILD_BANK_MONEY_WITHDRAWN, 4);
+		data << uint32(GetWithdrawLimit(session));
+		session->SendPacket(&data);
+	}
+
+	// SendBankTabsInfo
+	HandleGuildBankerActivate(session);
+
+	// SendBankContent
+	HandleGuildBankQueryTab(session, m_currTab);
+
+	// SendBankMoneyUpdate
+	{
+		WorldPacket data(SMSG_GUILD_BANK_LIST, 8+1+4+1+1);
+		data << uint64(bot->GetMoney());				// Money the bot has
+		data << uint8(m_currTab);						// Tab being viewed
+		data << uint32(GetRemainingSlots(bot));			// Withdraw llmit for the player
+		data << uint8(false);							// Tell that there's no tab info in this packet
+		data << uint8(0);								// No items
+		session->SendPacket(&data);
+	}
+}
+
+// Version for Guild Bank <-> Player
+void PlayerbotGuildBank::HandleGuildBankSwapItems(WorldSession *session, uint32 itemEntry, uint8 fromTabId, uint8 fromSlotId, uint8 toBagId, uint8 toSlotId, uint32 splittedAmount)
+{
+	Player *bot = GetPlayerbot(fromTabId);
+	Player *player = session->GetPlayer();
+
+	// Only allow if the player and bot can trade the items to be swapped
+	Item *const playerItem = player->GetItemByPos(toBagId, toSlotId);
+	uint16 pos;
+	Item *botItem;
+	if (itemEntry)
+	{
+		pos = GetItemPosFromGuildBankItemEntry(bot, itemEntry);
+		botItem = bot->GetItemByPos(pos);
+	} else {
+		pos = GetItemPosFromGuildBankSlotId(bot, fromSlotId);
+		botItem = NULL;
+	}
+	uint8 bag = UNPACK_HIGH(pos);
+	uint8 slot = UNPACK_LOW(pos);
+
+	// Only allow swap where the player gets an item if he is allowed to take items
+	if (botItem && GetWithdrawLimit(session, false) == 0)
+	{
+		player->SendEquipError(EQUIP_ERR_CANNOT_TRADE_THAT, botItem);
+		return;
+	}
+
+	// Make sure at least one item is being traded, and it is tradeable
+	if (!playerItem && !botItem) return;
+	if (playerItem && !playerItem->CanBeTraded())
+	{
+		player->SendEquipError(EQUIP_ERR_CANNOT_TRADE_THAT, botItem);
+		return;
+	}
+	if (botItem && !botItem->CanBeTraded())
+	{
+		player->SendEquipError(EQUIP_ERR_CANNOT_TRADE_THAT, botItem);
+		return;
+	}
+
+	// Figure out the destination slots for the items
+	bool swap = (botItem != NULL && playerItem != NULL);
+	ItemPosCountVec playerItemDest, botItemDest;
+	if (playerItem)
+	{
+		uint8 err = bot->CanStoreItem(bag, slot, playerItemDest, playerItem, swap);
+		if (err != EQUIP_ERR_OK)
+		{
+			player->SendEquipError(err, playerItem);
+			return;
+		}
+	}
+	if (botItem)
+	{
+		uint8 err = player->CanStoreItem(toBagId, toSlotId, botItemDest, botItem, swap);
+		if (err != EQUIP_ERR_OK)
+		{
+			player->SendEquipError(err, botItem);
+			return;
+		}
+	}
+
+	// Remove old items first
+	if (botItem)
+	{
+		botItem->SetUInt64Value(ITEM_FIELD_GIFTCREATOR, bot->GetGUID());
+		bot->MoveItemFromInventory(bag, slot, true);
+	}
+	if (playerItem)
+	{
+		playerItem->SetUInt64Value(ITEM_FIELD_GIFTCREATOR, player->GetGUID());
+		player->MoveItemFromInventory(toBagId, toSlotId, true);
+	}
+
+	// Put the new items in place
+	if (botItem)
+	{
+		if (botItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+			botItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, player->GetTotalPlayedTime()-(bot->GetTotalPlayedTime()-botItem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)));
+		player->MoveItemToInventory(botItemDest, botItem, true, true);
+	}
+	if (playerItem)
+	{
+		if (playerItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+			playerItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, bot->GetTotalPlayedTime()-(player->GetTotalPlayedTime()-playerItem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)));
+		bot->MoveItemToInventory(playerItemDest, playerItem, true, true);
+	}
+
+	// Save the swap
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	player->SaveInventoryAndGoldToDB(trans);
+	bot->SaveInventoryAndGoldToDB(trans);
+	CharacterDatabase.CommitTransaction(trans);
+
+	//_SendBankContentUpdate(pSrc, pDest);
+	HandleGuildBankQueryTab(session, fromTabId);
+}
+
+// Version where two items between two bots or one bot are swapped
+void PlayerbotGuildBank::HandleGuildBankSwapItems(WorldSession *session, uint8 tabId, uint8 slotId, uint8 destTabId, uint8 destSlotId, uint32 splittedAmount)
+{
+	// Swap items amoung one bot's inventory
+	if (tabId == destTabId)
+	{
+		Player *bot = GetPlayerbot(tabId);
+		if (!bot) return;
+
+		// translate a slotId to a bagId and bag's slotId
+		uint16 fromPos = GetItemPosFromGuildBankSlotId(bot, slotId);
+		uint16 toPos   = GetItemPosFromGuildBankSlotId(bot, destSlotId);
+
+		bot->SwapItem(fromPos, toPos);
+
+		//_SendBankContentUpdate(pSrc, pDest)
+		HandleGuildBankQueryTab(session, tabId);
+	}
+	// Give one bot's item to another bot
+	else
+	{
+		Player *fromBot = GetPlayerbot(tabId);
+		Player *toBot   = GetPlayerbot(destTabId);
+		Player *player  = session->GetPlayer();
+		if (!fromBot || !toBot) return;
+
+		uint16 fromPos = GetItemPosFromGuildBankSlotId(fromBot, slotId);
+		uint8 fromBag = UNPACK_HIGH(fromPos);
+		uint8 fromSlot = UNPACK_LOW(fromPos);
+
+		uint16 toPos   = GetItemPosFromGuildBankSlotId(toBot, destSlotId);
+		uint8 toBag = UNPACK_HIGH(toPos);
+		uint8 toSlot = UNPACK_LOW(toPos);
+
+		Item *fromItem = fromBot->GetItemByPos(fromPos);
+		Item *toItem   = toBot->GetItemByPos(toPos);
+
+		if (!fromItem && !toItem) return;
+		if (fromItem && !fromItem->CanBeTraded()) return;
+		if (toItem   && !toItem->CanBeTraded()) return;
+
+		// Figure out the destination slots for the items
+		bool swap = (fromItem != NULL && toItem != NULL);
+		ItemPosCountVec fromDest, toDest;
+		if (fromItem)
+		{
+			uint8 err = toBot->CanStoreItem(toBag, toSlot, fromDest, fromItem, swap);
+			if (err != EQUIP_ERR_OK)
+			{
+				player->SendEquipError(err, fromItem);
+				return;
+			}
+		}
+		if (toItem)
+		{
+			uint8 err = fromBot->CanStoreItem(fromBag, fromSlot, toDest, toItem, swap);
+			if (err != EQUIP_ERR_OK)
+			{
+				player->SendEquipError(err, toItem);
+				return;
+			}
+		}
+
+		// Remove old items first
+		if (toItem)
+		{
+			toItem->SetUInt64Value(ITEM_FIELD_GIFTCREATOR, toBot->GetGUID());
+			toBot->MoveItemFromInventory(toBag, toSlot, true);
+		}
+		if (fromItem)
+		{
+			fromItem->SetUInt64Value(ITEM_FIELD_GIFTCREATOR, fromBot->GetGUID());
+			fromBot->MoveItemFromInventory(fromBag, fromSlot, true);
+		}
+
+		// Put the new items in place
+		if (toItem)
+		{
+			if (toItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+				toItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, fromBot->GetTotalPlayedTime()-(toBot->GetTotalPlayedTime()-toItem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)));
+			fromBot->MoveItemToInventory(toDest, toItem, true, true);
+		}
+		if (fromItem)
+		{
+			if (fromItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+				fromItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, toBot->GetTotalPlayedTime()-(fromBot->GetTotalPlayedTime()-fromItem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)));
+			toBot->MoveItemToInventory(fromDest, fromItem, true, true);
+		}
+
+		// Save the swap
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		fromBot->SaveInventoryAndGoldToDB(trans);
+		toBot->SaveInventoryAndGoldToDB(trans);
+		CharacterDatabase.CommitTransaction(trans);
+
+		//_SendBankContentUpdate(pSrc, pDest);
+		HandleGuildBankQueryTab(session, m_currTab);
+		return;
+	}
+}
+
+void PlayerbotGuildBank::HandleGuildBankBuyTab(WorldSession *session, uint8 tabId)
+{
+}
+
+void PlayerbotGuildBank::HandleGuildBankUpdateTab(WorldSession *session, uint8 tabId, std::string &name, std::string &icon)
+{
+}
+
+void PlayerbotGuildBank::HandleGuildBankLogQuery(WorldSession *session, uint8 tabId) const
+{
+}
+
+// TODO: Give lots of info about the bot?
+void PlayerbotGuildBank::HandleQueryGuildBankTabText(WorldSession *session, uint8 tabId) const
+{
+	Player *bot = GetPlayerbot(tabId);
+	std::ostringstream out;
+
+	// Name
+	out << bot->GetName() << "\n";
+
+	// Level Class <Guild>
+	out << "Level " << bot->getLevel() << " ";
+	switch(bot->getClass())
+	{
+	case CLASS_WARRIOR:		out << "Warrior";		break;
+	case CLASS_PALADIN:		out << "Paladin";		break;
+	case CLASS_HUNTER:		out << "Hunter";		break;
+	case CLASS_ROGUE:		out << "Rogue";			break;
+	case CLASS_PRIEST:		out << "Priest";		break;
+	case CLASS_DEATH_KNIGHT:out << "Death Knight";	break;
+	case CLASS_SHAMAN:		out << "Shaman";		break;
+	case CLASS_MAGE:		out << "Mage";			break;
+	case CLASS_WARLOCK:		out << "Warlock";		break;
+	case CLASS_DRUID:		out << "Druid";			break;
+	default:				out << "Player";		break;
+	}
+	if (bot->GetGuildId())
+		out << " <" << bot->GetGuildName() << ">";
+	out << "\n\n";
+
+	// XP
+	out << "XP: (" << bot->GetUInt32Value(PLAYER_XP)
+		<< "/" << bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP) << ")\n";
+
+	// More to add?
+
+    WorldPacket data(MSG_QUERY_GUILD_BANK_TEXT, 1 + out.str().size() + 1);
+    data << uint8(tabId);
+    data << out.str();
+
+	session->SendPacket(&data);
+}
+
+void PlayerbotGuildBank::HandleSetGuildBankTabText(WorldSession *session, uint8 tabId, std::string &text)
+{
+	// Player tried to change the text in the tab, so resent the real info
+	HandleQueryGuildBankTabText(session, tabId);
+}
+
+// Write data about an item into the packet
+void PlayerbotGuildBank::WriteItem(WorldPacket &data, uint8 &slotId, Item *const pItem) const
+{
+	uint32 itemEntry = pItem ? pItem->GetEntry() : 0;
+
+	data << uint8(slotId);
+	data << uint32(itemEntry);
+	++slotId;
+
+	if (itemEntry)
+	{
+		data << uint32(0);									// 3.3.0 (0x00018020, 0x00018000)
+		data << uint32(pItem->GetItemRandomPropertyId());	// Random item property id
+
+		if (pItem->GetItemRandomPropertyId())
+			data << uint32(pItem->GetItemSuffixFactor());	// Suffix Factor
+
+		data << uint32(pItem->GetCount());					// ITEM_FIELD_STACK_COUNT
+		data << uint32(0);									// ?
+		data << uint8(abs(pItem->GetSpellCharges()));		// Spell charges
+
+		uint8 enchCount = 0;
+		size_t enchCountPos = data.wpos();
+
+		data << uint8(enchCount);
+		for(uint32 i = PERM_ENCHANTMENT_SLOT; i < MAX_ENCHANTMENT_SLOT; ++i)
+			if (uint32 enchId = pItem->GetEnchantmentId(EnchantmentSlot(i)))
+			{
+				data << uint8(i);		// Enchantment slot
+				data << uint32(enchId);	// Enchantment Id
+				++enchCount;
+			}
+		data.put<uint8>(enchCountPos, enchCount);
+	}
+}
+
+// Get an items position on the bot's bags, given an item entry
+uint16 PlayerbotGuildBank::GetItemPosFromGuildBankItemEntry(Player *bot, uint32 itemEntry) const
+{
+	if (!itemEntry) return PACK(NULL_BAG, NULL_SLOT);
+
+	// Look for the item in the backpack
+	for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+		if (Item *const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+			if (pItem->GetEntry() == itemEntry)
+				return PACK(INVENTORY_SLOT_BAG_0, slot);
+	// Look for the item in one of the removable bags
+	for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+		if (const Bag *const pBag = (Bag *)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+			for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+				if (Item *const pItem = bot->GetItemByPos(bag, slot))
+					if (pItem->GetEntry() == itemEntry)
+						return PACK(bag, slot);
+	return PACK(NULL_BAG, NULL_SLOT);
+}
+
+// Get an item's position in the bot's bags, given the tab and slot in the guild bank
+uint16 PlayerbotGuildBank::GetItemPosFromGuildBankSlotId(Player *bot, uint8 slotId) const
+{
+	// Run through the backpack's items
+	for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot, --slotId)
+		if (!slotId) return PACK(INVENTORY_SLOT_BAG_0, slot);
+	// Run through each removable bag
+	for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+		if (const Bag *const pBag = (Bag *)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+			for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot, --slotId)
+				if (!slotId) return PACK(bag, slot);
+	return PACK(NULL_BAG, NULL_SLOT);
+}
+
+GuildMisc PlayerbotGuildBank::GetWithdrawLimit(WorldSession *session, bool money /*=true*/) const
+{
+	Player *bot = m_masterSession->GetPlayerbotsBegin()->second;
+	if (!bot) return GuildMisc(0);
+
+	if (bot->GetPlayerbotAI()->canObeyCommandFrom(*(session->GetPlayer())))
+	{
+		if (money)
+			return GUILD_WITHDRAW_MONEY_UNLIMITED;
+		else
+			return GUILD_WITHDRAW_SLOT_UNLIMITED;
+	}
+	return GuildMisc(0);
+}
+
+uint8 PlayerbotGuildBank::GetRemainingSlots(Player *bot) const
+{
+	// Count the number of remaining slots in the bot's bags
+	uint8 count = 0;
+	// Main backpack
+	for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+		if (!bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+			++count;
+	// Removable bags
+	for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+		if (const Bag *const pBag = (Bag *)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+			for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+				if (!bot->GetItemByPos(bag, slot))
+					++count;
+	return count;
+}
+
+
+Player * PlayerbotGuildBank::GetPlayerbot(uint8 tabId) const
+{
+	for(PlayerbotMap::const_iterator it = m_masterSession->GetPlayerbotsBegin(); it != m_masterSession->GetPlayerbotsEnd(); ++it, --tabId)
+		if (!tabId)
+			return it->second;
+	return NULL;
+}
+/**************************************************************************/
+/*              END Playerbot Guild Bank System                           */
+/**************************************************************************/
+
+
+/*
+* Send a list of equipment that is in bot's inventor that is currently unequipped.
+* This is called when the master is inspecting the bot.
+*/
+void PlayerbotAI::SendNotEquipList(Player &player)
+{
+    //find all unequipped items and put them in
+    //a vector of dynamically created lists where the vector index is from 0-18
+    //and the list contains Item *that can be equipped to that slot
+    //Note: each dynamically created list in the vector must be deleted at end
+    //so NO EARLY RETURNS!
+    //see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    //is assigned to. (The first is EQUIPMENT_SLOT_HEAD = 0, and last is EQUIPMENT_SLOT_TABARD = 18)
+
+    std::list<Item *> *equip[EQUIPMENT_SLOT_END];
+    for(uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i) equip[i] = NULL;
+
+    //list out items in main backpack
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+		if (Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+		{
+			uint16 dest;
+			if (m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag()) != EQUIP_ERR_OK)
+				continue;
+
+			uint8 equipSlot = UNPACK_LOW(dest);
+			if (!(equipSlot >= EQUIPMENT_SLOT_START && equipSlot < EQUIPMENT_SLOT_END)) continue;
+
+			//create a list if one doesn't already exist
+			if (equip[equipSlot] == NULL)
+				equip[equipSlot] = new std::list<Item *>;
+			equip[equipSlot]->push_back(pItem);
+		}
+    }
+
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+		if (const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+		{
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+				if (Item *const pItem = m_bot->GetItemByPos(bag, slot))
+				{
+					uint16 dest;
+					if (m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag()) != EQUIP_ERR_OK)
+						continue;
+
+					uint8 equipSlot = UNPACK_LOW(dest);
+					if (!(equipSlot >= EQUIPMENT_SLOT_START && equipSlot < EQUIPMENT_SLOT_END)) continue;
+
+					//create a list if one doesn't already exist
+					if (equip[equipSlot] == NULL)
+						equip[equipSlot] = new std::list<Item *>;
+					equip[equipSlot]->push_back(pItem);
+				}
+            }
+        }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip:");
+    ChatHandler ch(m_master);
+
+    const std::string descr[EQUIPMENT_SLOT_END] = {"Head", "Neck", "Shoulders",
+		"Body", "Chest", "Waist", "Legs", "Feet", "Wrists", "Hands", "Ring",
+		"Ring", "Trinket", "Trinket", "Back", "Main-hand", "Off-hand", "Ranged",
+		"Tabard"};
+
+    //now send client all items that can be equipped by slot
+    for(uint8 equipSlot = EQUIPMENT_SLOT_START; equipSlot < EQUIPMENT_SLOT_END; ++equipSlot)
+    {
+        if (equip[equipSlot] == NULL) continue;
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for(std::list<Item *>::iterator it = equip[equipSlot]->begin(); it != equip[equipSlot]->end(); ++it)
+        {
+			out << " ";
+			MakeItemLink(*it, out);
+        }
+        ch.SendSysMessage(out.str().c_str());
+        delete equip[equipSlot]; //delete list of Item *
+    }
+}
+
+// Helper function for automatically selling poor quality items to the vendor
+void PlayerbotAI::_doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold)
+{
+	if (!item) return;
+	if (item->CanBeTraded() && item->GetProto()->Quality == ITEM_QUALITY_POOR)
+	{
+		int32 cost = item->GetCount() * item->GetProto()->SellPrice;
+		m_bot->ModifyMoney(cost);
+		m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+		m_bot->AddItemToBuyBackSlot(item);
+
+		++TotalSold;
+		TotalCost += cost;
+
+		report << "Sold ";
+		MakeItemLink(item, report);
+		report << " for ";
+
+		uint32 gold = uint32(cost / 10000);
+		cost -= (gold * 10000);
+		uint32 silver = uint32(cost / 100);
+		cost -= (silver * 100);
+
+		if (gold > 0)
+			report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+		if (silver > 0)
+			report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+		report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+	}
+	else if (item->GetProto()->SellPrice > 0)
+	{
+		MakeItemLink(item, canSell, false);
+		canSell << " ";
+	}
+}
+
+// Send a list of items to sell, in the form of a vendor list
+void PlayerbotAI::SendVendorList(WorldSession *session, Unit *vendor)
+{
+	// Get the items that can be sold
+	std::list<Item *> items;
+	findItemsInInvToSell(items);
+
+	// The bot has no items to sell
+	if (items.size() == 0)
+	{
+	    WorldPacket data(SMSG_LIST_INVENTORY, (8+1+1));
+		data << uint64(m_bot->GetGUID());
+	    data << uint8(0);                                   // count==0, next will be error code
+		data << uint8(0);                                   // "Vendor has no inventory"
+		session->SendPacket(&data);
+		return;
+	}
+
+	m_currVendor = vendor;
+
+	// The bot has items to sell
+	WorldPacket data(SMSG_LIST_INVENTORY, (8+1+items.size()*8*4));
+	data << uint64(m_bot->GetGUID());		// vendor (bot's) guid
+	data << uint8(items.size());			// number of items
+
+	uint8 slot = 0;
+	for(std::list<Item *>::iterator it = items.begin(); it != items.end(); ++it, ++slot)
+	{
+		Item *item = *it;
+		const ItemPrototype *proto = item->GetProto();
+
+		data << uint32(slot+1);					// vendorslot+1, client starts counting at 1...
+		data << uint32(item->GetEntry());		// item entry
+		data << uint32(proto->DisplayInfoID);
+
+		// item->GetCount.  This would show up in the upper left corner, but also makes it hard
+		// to sell stacks of items
+		data << int32(0xFFFFFFFF);
+		data << uint32(proto->SellPrice);
+		data << uint32(proto->MaxDurability);
+		// proto->BuyCount.  This is basically how many items are sold at once.  Set this to the
+		// ammount the bot actually has make you sell the whole stack at once.
+		data << uint32(item->GetCount());		// proto->BuyCount
+		data << uint32(0);						// VendorItem->ExtendedCost (for Honor Points, etc)
+		}
+	session->SendPacket(&data);
+}
+
+// Send a the trainer list that a trainer would send to the bot, but send it to the master
+void PlayerbotAI::SendTrainerList(WorldSession *session, bool sendError /*=true*/)
+{
+	Creature *unit = session->GetPlayerbotData()->currTrainer;
+
+    if (!unit)
+    {
+		if (sendError)
+			SendWhisper("Please select the trainer which I should learn from!", session);
+		return;
+    }
+
+    // trainer list loaded at check;
+    if (!unit->isCanTrainingOf(m_bot,false))
+	{
+		if (sendError)
+			SendWhisper("This trainer can not train me anything at all!", session);
+		return;
+	}
+	session->GetPlayerbotData()->currTrainee = m_bot;
+
+	// Checked for valid pointer in isCanTrainingOf
+    TrainerSpellData const* trainer_spells = unit->GetTrainerSpells();
+
+	std::string strTitle = m_bot->GetSession()->GetTrinityString(LANG_NPC_TAINER_HELLO);
+    WorldPacket data(SMSG_TRAINER_LIST, 8+4+4+trainer_spells->spellList.size()*38 + strTitle.size()+1);
+    data << uint64(unit->GetGUID());
+    data << uint32(2);	// trainer_spells->trainerType, send '2' to make the client think it's a special
+						// trainer, so it will show the spells even though the player is the wrong class
+
+    size_t count_pos = data.wpos();
+    data << uint32(trainer_spells->spellList.size());
+
+    // reputation discount
+    float fDiscountMod = m_bot->GetReputationPriceDiscount(unit);
+    bool can_learn_primary_prof = m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+    uint32 count = 0;
+
+	for (TrainerSpellMap::const_iterator itr = trainer_spells->spellList.begin(); itr != trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        bool valid = true;
+        bool primary_prof_first_rank = false;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (!tSpell->learnedSpell[i])
+                continue;
+            if (!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+            {
+                valid = false;
+                break;
+            }
+            if (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                primary_prof_first_rank = true;
+        }
+        if (!valid)
+            continue;
+
+        TrainerSpellState state = m_bot->GetTrainerSpellState(tSpell);
+
+        data << uint32(tSpell->spell);                      // learned spell (or cast-spell in profession case)
+		data << uint8(state == TRAINER_SPELL_GREEN_DISABLED ? TRAINER_SPELL_GREEN : state);
+        data << uint32(floor(tSpell->spellCost * fDiscountMod));
+
+        data << uint32(primary_prof_first_rank && can_learn_primary_prof ? true : false);
+																// primary prof. learn confirmation dialog
+        data << uint32(primary_prof_first_rank ? true : false);	// must be equal prev. field to have learn button in enabled state
+        data << uint8(tSpell->reqLevel);
+        data << uint32(tSpell->reqSkill);
+        data << uint32(tSpell->reqSkillValue);
+        //prev + req or req + 0
+        uint8 maxReq = 0;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (!tSpell->learnedSpell[i])
+                continue;
+            if (SpellChainNode const* chain_node = sSpellMgr->GetSpellChainNode(tSpell->learnedSpell[i]))
+            {
+                if (chain_node->prev)
+                {
+                    data << uint32(chain_node->prev);
+                    ++maxReq;
+                }
+            }
+            if (maxReq == 3)
+                break;
+            SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(tSpell->learnedSpell[i]);
+            for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequired.first; itr2 != spellsRequired.second && maxReq < 3; ++itr2)
+            {
+                data << uint32(itr2->second);
+                ++maxReq;
+            }
+            if (maxReq == 3)
+                break;
+        }
+        while (maxReq < 3)
+        {
+            data << uint32(0);
+            ++maxReq;
+        }
+
+        ++count;
+    }
+
+    data << strTitle;
+
+    data.put<uint32>(count_pos,count);
+    session->SendPacket(&data);
+}
+
+Player * PlayerbotAI::GetPlayerbot(const GossipMenuItem &menuItem)
+{
+	uint32 len = menuItem.m_gSender;
+	std::string name = menuItem.m_gMessage.substr(0, len);
+	if (Player *bot = sObjectMgr->GetPlayer(name.c_str()))
+		if (bot->GetPlayerbotAI())
+			return bot;
+	return NULL;
+}
+
+Player *PlayerbotAI::GetPlayerbot(uint64 guid)
+{
+	if (Player *bot = sObjectMgr->GetPlayer(guid))
+		if (bot->GetPlayerbotAI())
+			return bot;
+	return NULL;
+}
+
+
+// Scan ALL players incoming packets.  Return 'true' if no further processing is required.
+bool PlayerbotAI::HandlePlayerIncomingPacket(const WorldPacket &packet, WorldSession *session)
+{
+	// Ignore packets from Playerbots
+	if (session->GetPlayer()->GetPlayerbotAI()) return false;
+
+	PlayerbotData *data = session->GetPlayerbotData();
+
+	switch(packet.GetOpcode())
+	{
+	/***********************************************/
+	/*       Playerbot Guild Bank Simulation       */
+	/***********************************************/
+	case CMSG_GUILD_BANKER_ACTIVATE:
+		{	// Player activates the "Bank"
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+
+			if (!GetPlayerbot(guid)) return false;
+
+			data->Bank.ResetMaster(session);
+			data->Bank.Activate(session, guid);
+			if (!data->Bank.IsActive()) return false;
+
+			data->Bank.HandleGuildPermissions(session);
+			data->Bank.HandleGuildBankerActivate(session);
+			return true;
+		}
+	case CMSG_GUILD_BANK_QUERY_TAB:
+		{	// Player request info about a "tab" (the bot's inventory)
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			uint8 tabId; p >> tabId;
+
+			data->Bank.HandleGuildBankQueryTab(session, tabId);
+			return true;
+		}
+	case CMSG_GUILD_BANK_DEPOSIT_MONEY:
+		{	// Player "deposits" money (gives money to the bot)
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid;  p >> guid;
+			uint32 money; p >> money;
+
+			if (money && session->GetPlayer()->HasEnoughMoney(money))
+				data->Bank.HandleGuildBankDepositMoney(session, money);
+			return true;
+		}
+	case CMSG_GUILD_BANK_WITHDRAW_MONEY:
+		{	// Player "withdraws" money (takes money from the bot)
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid;  p >> guid;
+			uint64 money; p >> money;
+
+			data->Bank.HandleGuildBankWithdrawMoney(session, money);
+			return true;
+		}
+	case CMSG_GUILD_BANK_SWAP_ITEMS:
+		{	// Player moves items around
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			uint8 bankToBank; p >> bankToBank;
+			uint8 tabId;
+			uint8 slotId;
+			uint32 itemEntry;
+			uint32 splittedAmmount = 0;
+
+			if (bankToBank)
+			{
+				uint8 destTabId; p >> destTabId;
+				uint8 destSlotId; p >> destSlotId;
+				p.read_skip<uint32>();
+				p >> tabId;
+				p >> slotId;
+				p >> itemEntry;
+				p.read_skip<uint8>();
+				p >> splittedAmmount;
+				data->Bank.HandleGuildBankSwapItems(session, tabId, slotId, destTabId, destSlotId, splittedAmmount);
+			}
+			else
+			{
+				uint8 playerBag = NULL_BAG;
+				uint8 playerSlotId = NULL_SLOT;
+				uint8 toChar = 1;
+				uint32 autoStoreCount = 0;
+
+				p >> tabId;
+				p >> slotId;
+				p >> itemEntry;
+
+				uint8 autoStore;
+				p >> autoStore;
+				if (autoStore)
+				{
+					p >> autoStoreCount;
+					p.read_skip<uint8>();                   // ToChar (?), always and expected to be 1 (autostore only triggered in Bank -> Char)
+					p.read_skip<uint32>();                  // Always 0
+				}
+				else
+				{
+					p >> playerBag;
+					p >> playerSlotId;
+					p >> toChar;
+					p >> splittedAmmount;
+				}
+
+				// Player <-> Bank (bot)
+				// Allow to work with inventory only
+				if (!Player::IsInventoryPos(playerBag, playerSlotId) && !(playerBag == NULL_BAG && playerSlotId == NULL_SLOT))
+		            session->GetPlayer()->SendEquipError(EQUIP_ERR_NONE, NULL);
+				else
+					data->Bank.HandleGuildBankSwapItems(session, itemEntry, tabId, slotId, playerBag, playerSlotId, splittedAmmount);
+			}
+			return true;
+		}
+	case CMSG_GUILD_BANK_BUY_TAB:
+		{	// Player tries to buy a new tab
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			uint8 tabId; p >> tabId;
+			data->Bank.HandleGuildBankBuyTab(session, tabId);
+			return true;
+		}
+	case CMSG_GUILD_BANK_UPDATE_TAB:
+		{	// Player tries to change the name/icon of a tab
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			uint8 tabId; p >> tabId;
+			std::string name; p >> name;
+			std::string icon; p >> icon;
+
+			if (!name.empty() && !icon.empty())
+				data->Bank.HandleGuildBankUpdateTab(session, tabId, name, icon);
+			return true;
+		}
+	case MSG_GUILD_BANK_LOG_QUERY:
+		{	// Player wants the "Log" tab info
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint8 tabId; p >> tabId;
+			data->Bank.HandleGuildBankLogQuery(session, tabId);
+			return true;
+		}
+	case MSG_QUERY_GUILD_BANK_TEXT:
+		{	// Player want the "Info" tab text
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint8 tabId; p >> tabId;
+			data->Bank.HandleQueryGuildBankTabText(session, tabId);
+			return true;
+		}
+	case CMSG_SET_GUILD_BANK_TEXT:
+		{	// Player tries to set the "Info" tab text
+			if (!data->Bank.IsActive()) return false;
+
+			WorldPacket p(packet);
+			uint8 tabId; p >> tabId;
+			std::string text; p >> text;
+			data->Bank.HandleSetGuildBankTabText(session, tabId, text);
+			return true;
+		}
+
+	/***********************************************/
+	/*       Playerbot Trainer Interaction         */
+	/***********************************************/
+	case CMSG_TRAINER_BUY_SPELL:
+		{
+			if (!data->currTrainee) return false;
+
+			WorldPacket p(packet);
+			data->currTrainee->GetSession()->HandleTrainerBuySpellOpcode(p);
+			data->currTrainee->GetPlayerbotAI()->SendTrainerList(session);
+			return true;
+		}
+		return false;
+	case MSG_TALENT_WIPE_CONFIRM:
+		{
+			if (!data->currTrainer) return false;
+
+			// Send the packet to the bot instead
+			WorldPacket p(packet);
+			p.put<uint64>(0, data->currTrainer->GetGUID());
+			data->currTrainee->GetSession()->HandleTalentWipeConfirmOpcode(p);
+			return true;
+		}
+	/***********************************************/
+	/*       Playerbot Vendor Interaction          */
+	/***********************************************/
+	case CMSG_SELL_ITEM:
+		{	// Player is selling an item
+			// Don't allow "selling" to Playerbots
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			if (GetPlayerbot(guid)) return true;
+			return false;
+		}
+	case CMSG_BUY_ITEM_IN_SLOT:
+		{	// Player dragged an item into his/her inventory
+			// Don't allow "buying" this way from Playerbots
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			if (GetPlayerbot(guid)) return true;
+			return false;
+		}
+	case CMSG_BUY_ITEM:
+		{	// Player bought the item by right clicking on it
+			WorldPacket p(packet);
+			uint64 guid; p >> guid;
+			Player *bot = GetPlayerbot(guid);
+			if (!bot) return false;
+
+			uint32 item; p >> item;
+			p.read_skip<uint32>();		// uint32 slot, unused
+			uint32 count; p >> count;
+			//uint8 unk1; p >> unk1;	// unused
+			bot->GetPlayerbotAI()->SellItem(session, item, count);
+			return true;
+		}
+
+
+	} // switch(opcode)
+	return false;
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    /*
+    const char *oc = LookupOpcodeName(packet.GetOpcode());
+
+    std::ostringstream out;
+    out << "HandleMasterOutgoingPacket: " << oc;
+    sLog->outError(out.str().c_str());
+    */
+}
+
+// Handle packets sent from the master to the server.
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    switch(packet.GetOpcode())
+    {
+	// When player leaves a guild, tell bots to leave too?
+	case CMSG_GUILD_LEAVE:
+	{
+		return;
+	}
+
+    //If master inspects one of his bots, give the master useful info in chat window
+    //such as inventory that can be equipped
+    case CMSG_INSPECT:
+    {
+        WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint64 guid; p >> guid;
+        Player *const bot = masterSession.GetPlayerbot(guid);
+        if (!bot) return;
+
+        bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+		return;
+    }
+
+    case CMSG_PUSHQUESTTOPARTY:
+    {
+        WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint32 quest; p >> quest;
+        Player *pPlayer = masterSession.GetPlayer();
+        Quest const *pQuest = sObjectMgr->GetQuestTemplate(quest);
+
+        if(pQuest)
+            for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                uint64 guid = it->first;
+                uint32 unk1 = 0;
+
+                WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+4+4));
+                //data << guid;
+                data << pPlayer->GetGUID();
+                data << quest;
+                data << unk1;
+
+                bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(data);
+                bot->GetPlayerbotAI()->SetQuestNeedItems();
+            }
+        return;
+    }
+
+    //handle emotes from the master
+    //case CMSG_EMOTE:
+    case CMSG_TEXT_EMOTE:
+    {
+        WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint32 emoteNum; p >> emoteNum;
+
+        switch(emoteNum)
+        {
+        case TEXTEMOTE_BONK:
+        {
+            Player *const pPlayer = masterSession.GetPlayerbot(masterSession.GetPlayer()->GetSelection());
+            if (!pPlayer || !pPlayer->GetPlayerbotAI()) return;
+            PlayerbotAI *const pBot = pPlayer->GetPlayerbotAI();
+
+            ChatHandler ch(masterSession.GetPlayer());
+
+            {
+                std::ostringstream out;
+                out << "clock(): " << (getMSTime())
+                    << " m_ignoreAIUpdatesUntilTime: " << (pBot->m_ignoreAIUpdatesUntilTime);
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                    << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                ch.SendSysMessage(out.str().c_str());
+            } {
+				std::ostringstream out;
+                out << "m_IsFollowingMaster: " << pBot->m_IsFollowingMaster;
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "IsBeingTeleported(): " << pBot->m_bot->IsBeingTeleported();
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                bool tradeActive = (pBot->m_bot->GetTrader()) ? true : false;
+                out << "tradeActive: " << tradeActive;
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "IsCharmed(): " << pBot->m_bot->isCharmed();
+                ch.SendSysMessage(out.str().c_str());
+			} {
+                std::ostringstream out;
+                out << "IsInCombat(): " << pBot->m_bot->isInCombat();
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "isLooting: " << pBot->isLooting;
+                ch.SendSysMessage(out.str().c_str());
+            } {
+                std::ostringstream out;
+                out << "isPulling: " << pBot->GetClassAI()->isPulling();
+                ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        } // TEXTEMOTE_BONK
+
+        case TEXTEMOTE_EAT:
+        case TEXTEMOTE_DRINK:
+        {
+			Player *const bot = masterSession.GetPlayerbot(masterSession.GetPlayer()->GetSelection());
+            if (bot) bot->GetPlayerbotAI()->Stay();
+            else {
+	            for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+                {
+	                Player *const bot = it->second;
+                    bot->GetPlayerbotAI()->Feast();
+                }
+            }
+            return;
+        }
+
+        //emote to stay
+        case TEXTEMOTE_STAND:
+        {
+            Player *const bot = masterSession.GetPlayerbot(masterSession.GetPlayer()->GetSelection());
+            if (bot) bot->GetPlayerbotAI()->Stay();
+            else {
+	            for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+                {
+		            Player *const bot = it->second;
+                    bot->GetPlayerbotAI()->Stay();
+                }
+            }
+            return;
+        }
+
+        //if master has bot selected then only bot follows, else all bots follow
+        case TEXTEMOTE_FOLLOWME:
+        case TEXTEMOTE_WAVE:
+        {
+			Player *const bot = masterSession.GetPlayerbot(masterSession.GetPlayer()->GetSelection());
+            if (bot)
+            {
+	            bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                bot->GetPlayerbotAI()->SetLooting(false);
+            } else {
+                for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+                {
+	                Player *const bot = it->second;
+                    bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                    bot->GetPlayerbotAI()->SetLooting(false);
+                }
+            }
+            return;
+        }
+
+        default: return;
+		}
+    } // CMSG_TEXT_EMOTE
+
+    case CMSG_GROUP_UNINVITE:
+    {
+        WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        std::string member; p >> member;
+        p.clear();
+
+        WorldPacket data(CMSG_GROUP_UNINVITE, 1);
+        PlayerbotChatHandler ch(masterSession.GetPlayer());
+        std::ostringstream out;
+        out << "remove " << member;
+        ch.uninvite(out.str().c_str());
+        return;
+    }
+
+    case CMSG_REPAIR_ITEM:
+    {
+        WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint64 npcGUID; p >> npcGUID;
+
+        Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+        if (!pNpc)
+            return;
+
+        //for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+            Player *const bot = it->second;
+            if (!bot->IsInMap(static_cast<WorldObject*>(pNpc)))
+            {
+                bot->GetPlayerbotAI()->TellMaster("I'm too far away to repair items!");
+                continue;
+            } else {
+                bot->GetPlayerbotAI()->TellMaster("Repairing my items.");
+                bot->DurabilityRepairAll(false, 0.0, false);
+            }
+        }
+        return;
+    }
+
+    case CMSG_ACTIVATETAXIEXPRESS:
+    {
+        WorldPacket incP(packet);
+
+		//for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+            Player *const bot = it->second;
+            if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+            if (!bot->IsInMap(static_cast<WorldObject*>(masterSession.GetPlayer())))
+            {
+                bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                continue;
+            } else {
+                bot->GetPlayerbotAI()->Stay();  // clear any movement
+                incP.rpos(0);
+                bot->GetSession()->HandleActivateTaxiExpressOpcode(incP);
+            }
+        }
+        return;
+    }
+
+    case CMSG_ACTIVATETAXI:
+    {
+        WorldPacket incP(packet);
+
+		//for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+            Player *const bot = it->second;
+            if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+            if (!bot->IsInMap(static_cast<WorldObject *>(masterSession.GetPlayer())))
+            {
+                bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                continue;
+            } else {
+                bot->GetPlayerbotAI()->Stay();  // clear any movement
+                incP.rpos(0);
+				bot->GetSession()->HandleActivateTaxiOpcode(incP);
+            }
+        }
+        return;
+    }
+
+    // when landing from a flight path
+    case CMSG_MOVE_SPLINE_DONE:
+    {
+        WorldPacket p(packet);
+
+        //for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+            Player *const bot = it->second;
+
+            if (!bot->IsInMap(static_cast<WorldObject *>(masterSession.GetPlayer())))
+            {
+                bot->GetPlayerbotAI()->TellMaster("I'm too far away to land!");
+                continue;
+            } else {
+                p.rpos(0);  // reset reader
+                p.appendPackGUID(bot->GetGUID());
+                bot->GetSession()->HandleMoveSplineDoneOpcode(p);
+                uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+                uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                if (mountDisplayId == 0) {
+                    bot->CleanupAfterTaxiFlight();
+                    bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                }
+            }
+        }
+		return;
+    }
+
+	case CMSG_LOOT:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); // reset reader
+        uint64 cGUID; p >> cGUID;
+
+        Player *m_master = masterSession.GetPlayer();
+        Creature *cToLoot = m_master->GetMap()->GetCreature(cGUID);
+        if (!cToLoot)
+	        return;
+
+        // for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+	        Player* const bot = it->second;
+            if (!bot->IsInMap(static_cast<WorldObject *>(cToLoot)))
+            {
+	            bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                continue;
+            } else {
+                bot->GetPlayerbotAI()->AddLootGUID(cGUID);
+                bot->GetPlayerbotAI()->DoLoot();
+            }
+        }
+        return;
+    }
+
+    case CMSG_GAMEOBJ_USE:
+    {
+	    WorldPacket p(packet);
+        p.rpos(0); // reset reader
+        uint64 objGUID; p >> objGUID;
+
+		Player *m_master = masterSession.GetPlayer();
+		GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+        if (!obj) return;
+
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+			Player* const bot = it->second;
+            if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+            {
+				bot->GetPlayerbotAI()->GetNewQuests(obj);
+                bot->GetPlayerbotAI()->TurnInQuests(obj);
+				bot->GetPlayerbotAI()->GetNewQuests(obj);
+            }
+            // add other go types here, i.e.:
+            // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+        }
+		return;
+    }
+
+    case CMSG_GAMEOBJ_REPORT_USE:
+    {
+	    WorldPacket p(packet);
+        p.rpos(0); // reset reader
+        uint64 objGUID; p >> objGUID;
+
+		Player *m_master = masterSession.GetPlayer();
+        GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+        if (!obj) return;
+
+        //Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+        //if (!pNpc) return;
+
+        // for all master's bots
+		for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+			Player* const bot = it->second;
+            if (!bot->IsInMap(static_cast<WorldObject *>(obj)))
+            {
+				bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                continue;
+            } else {
+				if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+				{
+					bot->GetPlayerbotAI()->GetNewQuests(obj);
+					bot->GetPlayerbotAI()->TurnInQuests(obj);
+					bot->GetPlayerbotAI()->GetNewQuests(obj);
+				}
+                bot->GetPlayerbotAI()->AddLootGUID(objGUID);
+                bot->GetPlayerbotAI()->DoLoot();
+            }
+        }
+        return;
+	}
+
+    //if master talks to an NPC
+    case CMSG_GOSSIP_HELLO:
+    case CMSG_QUESTGIVER_HELLO:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint64 npcGUID; p >> npcGUID;
+
+        Player *m_master = masterSession.GetPlayer();
+        WorldObject* pNpc = ObjectAccessor::GetWorldObject(*m_master, npcGUID);
+        if (!pNpc) return;
+
+        // if its a flight master
+        if (pNpc->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER))
+        {
+			for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+            {
+				Player *const bot = it->second;
+                if (bot->GetSession()->SendLearnNewTaxiNode((Creature*)pNpc))
+                    bot->GetPlayerbotAI()->TellMaster("Learned a new path.");
+            }
+        }
+
+        // for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+	        Player* const bot = it->second;
+			bot->GetPlayerbotAI()->GetNewQuests(pNpc);
+            bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+			bot->GetPlayerbotAI()->GetNewQuests(pNpc);	// Do it a second time in case some new ones are there now that we turned some in
+            bot->GetPlayerbotAI()->SetQuestNeedItems();
+
+            bot->TalkedToCreature(pNpc->GetEntry(), pNpc->GetGUID());
+        }
+
+        return;
+	}
+
+    case CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); // reset reader
+        if (!masterSession.GetPlayer()->GetSelection()) return;
+
+        //for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+			Player* const bot = it->second;
+            p.rpos(0); // reset reader
+            bot->GetSession()->HandleQuestgiverStatusMultipleQuery(p);
+        }
+        return;
+    }
+
+    // if master accepts a quest, bots should also try to accept quest
+    case CMSG_QUESTGIVER_ACCEPT_QUEST:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); // reset reader
+        uint64 guid;  p >> guid;
+        uint32 quest; p >> quest;
+
+		Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+        if (qInfo)
+        {
+	        //for all master's bots
+            for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+            {
+		        Player* const bot = it->second;
+
+                if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+			        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                else if (!bot->CanTakeQuest(qInfo, false))
+                {
+					if (bot->SatisfyQuestStatus(qInfo, false))
+						bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                } else if (!bot->SatisfyQuestLog(false))
+					bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                else if (!bot->CanAddQuest(qInfo, false))
+                    bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+                else {
+					p.rpos(0); // reset reader
+                    bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                    bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+                }
+            }
+        }
+        return;
+	}
+
+    case CMSG_LIST_INVENTORY:
+    {
+        WorldPacket p1(packet);
+        p1.rpos(0); /* reset reader */
+        uint64 npcGUID; p1 >> npcGUID;
+
+        Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+        if (!pNpc) return;
+
+        // for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+            Player* const bot = it->second;
+            if (!bot->IsInMap(static_cast<WorldObject *>(pNpc)))
+            {
+				bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                continue;
+            } else {
+                uint32 TotalCost = 0;
+                uint32 TotalSold = 0;
+                std::ostringstream report, canSell;
+                canSell << "Items that are not trash and can be sold: ";
+
+				// list out items in main backpack
+                for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+                {
+					Item* const item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+					bot->GetPlayerbotAI()->_doSellItem(item, report, canSell, TotalCost, TotalSold);
+                }
+
+				// and each of our other packs
+                for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+					const Bag* const pBag = static_cast<Bag *>(bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+                    if (pBag)
+                    {
+						for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+							Item* const item = bot->GetItemByPos(bag, slot);
+							bot->GetPlayerbotAI()->_doSellItem(item, report, canSell, TotalCost, TotalSold);
+                        }
+                    }
+                }
+
+				if (TotalSold > 0) {
+                    report << "Sold total " << TotalSold << " item(s) for ";
+
+					uint32 gold = uint32(TotalCost / 10000);
+                    TotalCost -= (gold * 10000);
+                    uint32 silver = uint32(TotalCost / 100);
+                    TotalCost -= (silver * 100);
+                    if (gold > 0)
+	                    report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                    if (silver > 0)
+                        report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                    report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t";
+
+					bot->GetPlayerbotAI()->TellMaster(report.str());
+                }
+				// If the vendor GUI is enabled, don't show the list of items to sell
+				if (!sConfig->GetBoolDefault("Bot.VendorGUI", true))
+					return
+                bot->GetPlayerbotAI()->TellMaster(canSell.str());
+            }
+        }
+        return;
+    }
+
+    case CMSG_AREATRIGGER:
+    {
+        WorldPacket p1(packet);
+        p1.rpos(0); // reset reader
+        uint32 Trigger_ID; p1 >> Trigger_ID;
+
+        // for all master's bots
+        for(PlayerbotMap::const_iterator it = masterSession.GetPlayerbotsBegin(); it != masterSession.GetPlayerbotsEnd(); ++it)
+        {
+			Player* const bot = it->second;
+
+            uint32 quest_id = sObjectMgr->GetQuestForAreaTrigger(Trigger_ID);
+            // The conditions that intentionally left unchecked are:
+            // Bot is alive or not
+            // Bot is in the trigger area or not
+            if (quest_id && bot->IsActiveQuest(quest_id))
+            {
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+                if (pQuest)
+                {
+					if (bot->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
+                    {
+						bot->AreaExploredOrEventHappens(quest_id);
+                        bot->GetPlayerbotAI()->TellMaster("Quest area explored");
+                    }
+                }
+            }
+
+            if (sObjectMgr->IsTavernAreaTrigger(Trigger_ID))
+            {
+	            // set resting flag we are in the inn
+                bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                bot->InnEnter(time(NULL), bot->GetMapId() , bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ());
+                bot->SetRestType(REST_TYPE_IN_TAVERN);
+
+                if (sWorld->IsFFAPvPRealm())
+					bot->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+            }
+        }
+        return;
+	}
+
+	default:
+    {	/*
+		const char *oc = LookupOpcodeName(packet.GetOpcode());
+        ChatHandler ch(masterSession.GetPlayer());
+        ch.SendSysMessage(oc);
+
+        std::ostringstream out;
+        out << "HandleMasterIncomingPacket: " << oc;
+        sLog->outError(out.str().c_str());
+
+        return;
+		*/
+    }
+	} // end switch
+}
+
+// Handle outgoing packets from the server to the bot "client"
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket &packet)
+{
+    switch(packet.GetOpcode())
+    {
+	// Bot is invited to a guild
+	case SMSG_GUILD_INVITE:
+	{
+		WorldPacket p(packet);
+		std::string player_name; p >> player_name;
+		std::string guild_name;  p >> guild_name;
+
+		// Accept guild invites from the bot's master only
+		Player *player = sObjectMgr->GetPlayer(player_name.c_str());
+		if (player && player->GetGUID() == m_master->GetGUID())
+			m_bot->GetSession()->HandleGuildAcceptOpcode(p);	// packet not used
+		else
+			m_bot->GetSession()->HandleGuildDeclineOpcode(p);	// packet not used
+		return;
+	}
+
+	// Bot asked to sign a petition
+	// case ??
+
+	/*
+	case SMSG_TRADE_STATUS_EXTENDED:
+    {
+	    m_bot->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
+        return;
+    }
+	*/
+
+    case SMSG_DUEL_WINNER:
+	{
+		m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+        return;
+	}
+
+    case SMSG_DUEL_COMPLETE:
+	{
+		SetIgnoreUpdateTime(4);
+        m_combatOrder = ORDERS_NONE;
+        m_ScenarioType = SCENARIO_PVEEASY;
+        m_bot->GetMotionMaster()->Clear(true);
+        return;
+	}
+
+	case SMSG_DUEL_OUTOFBOUNDS:
+	{
+		m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+        return;
+	}
+
+	case SMSG_DUEL_REQUESTED:
+    {
+		SetIgnoreUpdateTime(0);
+        WorldPacket p(packet);
+        uint64 flagGuid; p >> flagGuid;
+        uint64 playerGuid; p >> playerGuid;
+
+		Player *const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+        if (canObeyCommandFrom(*pPlayer))
+        {
+			m_bot->GetMotionMaster()->Clear(true);
+            WorldPacket *const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+            *packet << flagGuid;
+            m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+            //follow target in casting range
+            float angle = rand_norm() * M_PI; //Generates random float between 0 and 3.14
+            float dist = (float)(urand(m_followDistanceMin * 10, m_followDistanceMax * 10) / 10); //Using urand to get a random float is stupid. It takes uint32, not float.
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+            m_bot->SetSelection(playerGuid);
+            SetIgnoreUpdateTime(4);
+            m_combatOrder = ORDERS_KILL;
+            m_ScenarioType = SCENARIO_DUEL;
+        }
+        return;
+    }
+
+    case SMSG_INVENTORY_CHANGE_FAILURE:
+	{
+		TellMaster("I can't use that.");
+        return;
+	}
+
+    case SMSG_SPELL_DELAYED:
+    {
+	    WorldPacket p(packet);
+        //uint64 casterGuid = extractGuid(p); //somehow the caster guid is corrupt
+        //if(casterGuid != m_bot->GetGUID()) return;
+        //uint32 delayTime; p >> delayTime;
+        //sLog->outDebug("Bot [%u] caster [%u] Spell Delayed [%u]",m_bot->GetGUIDLow(), casterGuid, delayTime);
+        //m_ignoreAIUpdatesUntilTime +=  ((((float)delayTime) / 1000.0f ) + 0.1f) * CLOCKS_PER_SEC;
+        if (m_CurrentlyCastingSpellId > 0)
+			m_ignoreAIUpdatesUntilTime += 0.5f * 1000; //Until this is handled correctly, assume, delay is the default 0.5 secs
+		return;
+    }
+
+    case SMSG_SPELL_FAILURE:
+    {
+		WorldPacket p(packet);
+        uint64 casterGuid = extractGuid(p);
+        if (casterGuid != m_bot->GetGUID()) return;
+
+        uint32 spellId; p >> spellId;
+        if (m_CurrentlyCastingSpellId == spellId)
+        {
+			SetIgnoreUpdateTime(1);
+            m_CurrentlyCastingSpellId = 0;
+        }
+        return;
+	}
+
+    //if a change in speed was detected for the master
+    //make sure we have the same mount status
+    case SMSG_FORCE_RUN_SPEED_CHANGE:
+    {
+		WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+
+        Player *tPlayer = sObjectMgr->GetPlayer(guid);
+        if (!tPlayer) return;
+        if (!m_master || !m_bot) return;
+        if (guid == m_bot->GetGUID()) return;
+        if (guid == m_master->GetGUID())
+		{
+			m_bot->GetPlayerbotAI()->UseMount();
+            SetIgnoreUpdateTime(2);
+        }
+        return;
+    }
+
+    //handle flying acknowledgement
+    case SMSG_MOVE_SET_CAN_FLY:
+    {
+	    WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+        if (guid != m_bot->GetGUID()) return;
+        m_bot->AddUnitMovementFlag(MOVEMENTFLAG_FLYING);
+        //SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+        return;
+    }
+
+    //handle dismount flying acknowledgement
+    case SMSG_MOVE_UNSET_CAN_FLY:
+    {
+		WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+        if (guid != m_bot->GetGUID()) return;
+        m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
+        //SetSpeed(MOVE_RUN, m_master->GetSpeedRate(MOVE_RUN), true);
+        return;
+    }
+
+    //If the leader role was given to the bot automatically give it to the master
+    //if the master is in the group, otherwise leave group
+    case SMSG_GROUP_SET_LEADER:
+    {
+	    WorldPacket p(packet);
+        std::string name; p >> name;
+
+        if (m_bot->GetGroup() && name == m_bot->GetName())
+        {
+	        if (m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+            {
+				p.resize(8);
+				p.clear();
+                p << m_master->GetGUID();
+                m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+            } else {
+                p.clear();
+                m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+            }
+        }
+        return;
+    }
+
+    //If the master leaves the group, then the bot leaves too
+    case SMSG_PARTY_COMMAND_RESULT:
+    {
+		WorldPacket p(packet);
+        uint32 operation; p >> operation;
+        std::string member; p >> member;
+        uint32 result; p >> result;
+        p.clear();
+        if (operation == PARTY_OP_LEAVE && member == m_master->GetName())
+			m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+        return;
+    }
+
+    //Automatically accept rez. Useful when bot dies, and a druid does a battle rez.
+    case SMSG_RESURRECT_REQUEST:
+    {
+	    WorldPacket p, incP(packet);
+        uint8 status = 1;
+        uint64 rezzer; incP >> rezzer;
+        p << rezzer;
+        p << status;
+        m_bot->GetPlayerbotAI()->SetLooting(false);
+        m_bot->GetSession()->HandleResurrectResponseOpcode(p);
+        m_IsFollowingMaster = true;
+        m_TimeRessurect = 0;
+        return;
+    }
+
+    //Handle Group invites (auto accept if master is in group, otherwise decline
+    case SMSG_GROUP_INVITE:
+    {
+		if (m_bot->GetGroupInvite())
+        {
+			const Group *const grp = m_bot->GetGroupInvite();
+            if (!grp) return;
+            Player *const inviter = sObjectMgr->GetPlayer(grp->GetLeaderGUID());
+            if (!inviter) return;
+
+			WorldPacket p;
+            if (!canObeyCommandFrom(*inviter))
+            {
+				std::string buf = "I can't accept your invite unless you first invite my master ";
+                buf += m_master->GetName();
+                buf += ".";
+                SendWhisper(buf, *inviter);
+                m_bot->GetSession()->HandleGroupDeclineOpcode(p); //packet not used
+            } else
+				m_bot->GetSession()->HandleGroupAcceptOpcode(p); //packet not used
+        }
+        return;
+	}
+
+    //Handle when another player opens the trade window with the bot
+    //also sends list of tradable items bot can trade if bot is allowed to obey commands from
+    case SMSG_TRADE_STATUS:
+    {
+		if (m_bot->GetTrader() == NULL) return;
+        WorldPacket p(packet);
+        uint32 status; p >> status;
+        p.clear();
+
+		// Player the bot is trading with accepted the trade
+        if (status == TRADE_STATUS_TRADE_ACCEPT)
+		{
+			if (!m_bot->GetTradeData()->IsAccepted() || !m_bot->GetTrader()->GetTradeData()->IsAccepted())
+				m_bot->GetSession()->HandleAcceptTradeOpcode(p); //packet not used
+        }
+		// Player initiates a trade with the bot
+		else if (status == TRADE_STATUS_BEGIN_TRADE)
+        {
+			m_bot->GetSession()->HandleBeginTradeOpcode(p); //packet not used
+			if(!canObeyCommandFrom(*(m_bot->GetTrader())))
+            {
+				//SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                return;
+            }
+
+			// First say how much money we have
+            uint32 copper = m_bot->GetMoney();
+            uint32 gold = uint32(copper / 10000);
+            copper -= (gold * 10000);
+            uint32 silver = uint32(copper / 100);
+            copper -= (silver * 100);
+
+            std::ostringstream msg;
+			msg << "I have "
+				<< "|cff00ff00" << gold << "|r|cfffffc00g|r"
+				<< "|cff00ff00" << silver << "|r|cffcdcdcds|r"
+				<< "|cff00ff00" << copper << "|r|cffffd333c|r";
+
+			// List items in main backpack
+			bool bItem = false;
+            for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+            {
+				const Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem && pItem->CanBeTraded())
+                {
+					if (!bItem)
+					{
+						msg << " and the following items:\r";
+						bItem = true;
+					}
+					msg << " ";
+					MakeItemLink(pItem, msg);
+                }
+            }
+
+			// List items in other packs
+            for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+				const Bag *const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+                if (pBag)
+                {
+					for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+						const Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem && pItem->CanBeTraded())
+                        {
+							if (!bItem)
+							{
+								msg << " and the following items:\r";
+								bItem = true;
+							}
+							msg << " ";
+							MakeItemLink(pItem, msg);
+                        }
+                    }
+                }
+            }
+
+			// List equiped items
+			bool bEquip = false;
+			for(uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+			{
+				const Item *const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+				if (item)
+				{
+					if (!bEquip)
+					{
+						if (bItem)
+							msg << "\r";
+						else
+							msg << " ";
+						msg << "and the following equiped items:\r";
+						bEquip = true;
+					}
+					msg << " ";
+					MakeItemLink(item, msg);
+				}
+			}
+			SendWhisper(msg.str(), *(m_bot->GetTrader()));
+        } // TRADE_STATUS_BEGIN
+        return;
+    } // SMSG_TRADE_STATUS
+
+    case SMSG_SPELL_GO:
+	{
+		WorldPacket p(packet);
+        uint64 castItemGuid = extractGuid(p);
+        uint64 casterGuid = extractGuid(p);
+        if (casterGuid != m_bot->GetGUID()) return;
+
+        uint32 spellId; p >> spellId;
+        uint16 castFlags; p >> castFlags;
+        uint32 msTime; p >> msTime;
+        uint8 numHit; p >> numHit;
+        if (m_CurrentlyCastingSpellId == spellId)
+        {
+			Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+            if (!pSpell) return;
+            if (pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+				SetIgnoreUpdateTime((((float)GetSpellDuration(pSpell->m_spellInfo) / 1000.0f) + 1.0f));
+            else if(pSpell->IsAutoRepeat())
+                SetIgnoreUpdateTime(6);
+            else {
+                SetIgnoreUpdateTime(0.5f);
+                m_CurrentlyCastingSpellId = 0;
+            }
+        }
+        return;
+    }
+
+    case SMSG_TEXT_EMOTE:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint64 guid;       p >> guid;
+		uint32 text_emote; p >> text_emote;
+
+        switch(text_emote)
+        {
+		//Buff anyone who bows before me. Useful for players not in bot's group
+        case TEXTEMOTE_BOW:
+        {
+			Player *pPlayer = sObjectMgr->GetPlayer(guid);
+            Player *const bot = sObjectMgr->GetPlayer(pPlayer->GetSelection());
+
+            if (bot && bot->GetGUID()==m_bot->GetGUID() &&
+                bot->GetPlayerbotAI()->GetClassAI())
+            {
+				bot->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+            }
+            return;
+        }
+
+		default:
+		{
+	        m_bot->HandleEmoteCommand(text_emote);
+            return;
+		}
+        } // end switch
+        return;
+    }
+
+    case MSG_MOVE_TELEPORT_ACK:
+	{
+		HandleTeleportAck();
+        return;
+	}
+
+	/*
+	case SMSG_QUESTGIVER_STATUS_MULTIPLE:
+    {
+        return;
+    }
+	*/
+
+    // used to communicate between bots
+    case SMSG_MESSAGECHAT:
+    {
+		WorldPacket p(packet);
+        p.rpos(0); //reset reader
+        uint8 msgtype;    p >> msgtype;
+        uint32 language;  p >> language;
+        uint64 guid;      p >> guid;
+        uint32 language2; p >> language2;
+        uint64 guid2;     p >> guid2;
+        uint32 textlen;   p >> textlen;
+        std::string msg;  p >> msg;
+
+        Player *fromPlayer = sObjectMgr->GetPlayer(guid);
+        if (fromPlayer == NULL) return;
+        HandleCommand(msg, *fromPlayer);
+    }
+
+	/*
+    case SMSG_MONSTER_MOVE:
+    case SMSG_UPDATE_WORLD_STATE:
+    case SMSG_COMPRESSED_UPDATE_OBJECT:
+    case MSG_MOVE_SET_FACING:
+    case MSG_MOVE_STOP:
+    case MSG_MOVE_HEARTBEAT:
+    case MSG_MOVE_STOP_STRAFE:
+    case MSG_MOVE_START_STRAFE_LEFT:
+    case SMSG_UPDATE_OBJECT:
+    case MSG_MOVE_START_FORWARD:
+    case SMSG_WEATHER:
+    case SMSG_POWER_UPDATE:
+    case SMSG_TIME_SYNC_REQ:
+    case SMSG_STANDSTATE_UPDATE:
+    case SMSG_PERIODICAURALOG:
+    case SMSG_AURA_UPDATE:
+	{
+		return;
+	}
+
+
+    default:
+	{
+        const char *oc = LookupOpcodeName(packet.GetOpcode());
+        TellMaster(oc);
+        sLog->outError("SMSG opcode: %s", oc);
+	}
+	*/
+    }
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    SetIgnoreUpdateTime(6);
+    m_bot->GetMotionMaster()->Clear(true);
+    if(m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8+4+4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << uint32(0);			//supposed to be flags? not used currently
+        p << uint32(time(0));	//time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if(m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit &target) const
+{
+    return (static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit &target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit &target) const
+{
+    if(target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return 100;
+    else
+        return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit &target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit &target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit &target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+
+typedef std::pair<uint32, uint8> spellEffectPair;
+typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit *player) const
+{
+    for(Unit::AuraMap::const_iterator iter = player->GetOwnedAuras().begin(); iter != player->GetOwnedAuras().end(); ++iter)
+        if(iter->second->GetId() == spellId)
+			return true;
+    return false;
+}
+bool PlayerbotAI::HasAura(const char *spellName) const
+{
+    return HasAura(spellName, m_bot);
+}
+bool PlayerbotAI::HasAura(const char *spellName, const Unit *player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return spellId ? HasAura(spellId, player) : false;
+}
+
+void PlayerbotAI::UseMount() const
+{
+    if (m_master->IsMounted() && ! m_bot->IsMounted())
+    {
+		// sLog->outError ("PlayerbotAI::UseMount: %s is mounted but %s is not", m_master->GetName(), m_bot->GetName());
+        //Player Part
+        int32 master_speed1 = 0;
+        int32 master_speed2 = 0;
+        if (!m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).empty())
+        {
+            master_speed1 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[1];
+            master_speed2 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[2];
+        }
+		//sLog->outError ("master_speed1 = %d", master_speed1);
+		//sLog->outError ("master_speed2 = %d", master_speed2);
+        //Bot Part
+        uint32 spellMount = 0;
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            uint32 spellId = itr->first;
+            if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+                continue;
+            const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                continue;
+            if (pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+            {
+                if ((pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if ((pSpellInfo->EffectBasePoints[1] == master_speed1)
+                        && (pSpellInfo->EffectBasePoints[2] == master_speed2))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if ((pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if ((pSpellInfo->EffectBasePoints[2] == master_speed2)
+                        && (pSpellInfo->EffectBasePoints[1] == master_speed1))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                {
+                    if (pSpellInfo->EffectBasePoints[1] == master_speed1 && master_speed2 <= 0) { spellMount = spellId; break; } //Has no secondary mount aura
+                    else if (spellMount == 0) { spellMount = spellId; } // default to first mount in case it doesnt have correct version
+                }
+            }
+        }
+		//sLog->outError ("spellMount = %u", spellMount);
+        if (spellMount > 0) m_bot->GetPlayerbotAI()->CastSpell(spellMount, m_bot);
+
+    }
+    else if (!m_master->IsMounted() && m_bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+} //end UseMount
+
+Item *PlayerbotAI::findItemCanUse(FindItemFn fn, bool forward /*=true*/) const
+{
+    // Test items in main backpack
+	uint8 start, stop, step;
+	if (forward)
+	{
+		start = INVENTORY_SLOT_ITEM_START;
+		stop = INVENTORY_SLOT_ITEM_END;
+		step = 1;
+	} else {
+		start = INVENTORY_SLOT_ITEM_END;
+		stop = INVENTORY_SLOT_ITEM_START;
+		step = -1;
+	}
+	for(uint8 slot = start; slot != stop; slot += step)
+    {
+		if (Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+				continue;
+			if (!fn(pItemProto))
+				continue;
+			return pItem;
+		}
+	}
+    // Test items in other removable backpacks
+	if (forward)
+	{
+		start = INVENTORY_SLOT_BAG_START;
+		stop = INVENTORY_SLOT_BAG_END;
+	} else {
+		start = INVENTORY_SLOT_BAG_END;
+		stop = INVENTORY_SLOT_BAG_START;
+	}
+
+    for(uint8 bag = start; bag != stop; bag += step)
+    {
+		if (const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag)))
+        {
+			uint8 Start, Stop;
+			if (forward)
+			{
+				Start = 0;
+				Stop = pBag->GetBagSize();
+			} else {
+				Start = pBag->GetBagSize();
+				Stop = 0;
+			}
+            for (uint8 slot = Start; slot != Stop; slot += step)
+            {
+				if (Item* const pItem = m_bot->GetItemByPos(bag, slot))
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+						continue;
+					if (!fn(pItemProto))
+						continue;
+					return pItem;
+				}
+			}
+		}
+	}
+	return NULL;
+}
+
+// fn for FindFood
+bool _isFood(const ItemPrototype *proto)
+{
+	if (proto->Class == ITEM_CLASS_CONSUMABLE)
+	{
+		if (proto->SubClass == ITEM_SUBCLASS_FOOD ||
+			proto->SubClass == ITEM_SUBCLASS_POTION ||
+			proto->SubClass == ITEM_SUBCLASS_ELIXIR)
+		{
+			if (proto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+				return true;
+		}
+	}
+	return false;
+}
+Item *PlayerbotAI::FindFood() const
+{
+	return findItemCanUse(_isFood);
+}
+/*
+    // list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+		if (Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+				continue;
+            if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                 pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                 pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                // if is FOOD
+                if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+		if (const Bag* const pBag = static_cast<Bag *(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag)))
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+				if (Item* const pItem = m_bot->GetItemByPos(bag, slot))
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+						continue;
+                    if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                         pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                         pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is FOOD
+                        if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+
+// For FindDrink
+bool _isDrink(const ItemPrototype *proto)
+{
+	if (proto->Class == ITEM_CLASS_CONSUMABLE)
+	{
+		if (proto->SubClass == ITEM_SUBCLASS_FOOD ||
+			proto->SubClass == ITEM_SUBCLASS_POTION ||
+			proto->SubClass	== ITEM_SUBCLASS_ELIXIR)
+		{
+			if (proto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+				proto->Spells[0].SpellCategory == 4)
+				return true;
+		}
+	}
+	return false;
+}
+
+Item *PlayerbotAI::FindDrink() const
+{
+	return findItemCanUse(_isDrink);
+}
+/*
+    // list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+		if (Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+				continue;
+            if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                 pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                 pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                    pItemProto->Spells[0].SpellCategory == 4)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+		if (const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+				if (Item* const pItem = m_bot->GetItemByPos(bag, slot))
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK)
+						continue;
+                    if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                         pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                         pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is WATER
+                        if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                            pItemProto->Spells[0].SpellCategory == 4)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+// For FindPotion
+bool _isPotion(const ItemPrototype *proto)
+{
+	if (proto->IsPotion()) return true;
+	return false;
+}
+
+Item *PlayerbotAI::FindPotion() const
+{
+	return findItemCanUse(_isPotion);
+}
+/*
+    // list out items in main backpack
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if (pItemProto->IsPotion())
+            {
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if (pItemProto->IsPotion())
+                    {
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+// For FindBandage
+bool _isBandage(const ItemPrototype *proto)
+{
+	if (proto->Class == ITEM_CLASS_CONSUMABLE)
+		if (proto->SubClass == ITEM_SUBCLASS_BANDAGE)
+			return true;
+	return false;
+}
+
+Item *PlayerbotAI::FindBandage() const
+{
+	return findItemCanUse(_isBandage);
+}
+/*
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+// For FindPoisonForward, FindPoisonBackward
+bool _isPoison(const ItemPrototype *proto)
+{
+	if  (proto->Class == ITEM_CLASS_CONSUMABLE)
+		if (proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER)
+			return true;
+	return false;
+}
+
+// finds poison starting from the front
+Item *PlayerbotAI::FindPoisonForward() const
+{
+	return findItemCanUse(_isPoison);
+}
+/*
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+// finds poison starting from the back
+Item *PlayerbotAI::FindPoisonBackward() const
+{
+	return findItemCanUse(_isPoison, false);
+}
+/*
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_END; slot > INVENTORY_SLOT_ITEM_START; slot--)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_GLYPH) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_END; bag > INVENTORY_SLOT_BAG_START; --bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = pBag->GetBagSize(); slot > 0  ; --slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_GLYPH) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+*/
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket *const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);
+    uint8 counter = 1;
+    *packet << counter;
+    *packet << m_CurrentlyCastingSpellId;
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    //stand up if we are done feasting
+    if(!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_TimeDoneDrinking = time(0) - 1;
+        m_TimeDoneEating = time(0) - 1;
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    //wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    SetIgnoreUpdateTime(3);
+
+    //should we drink another
+    if(m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking && ((static_cast<float>(m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item *pItem = FindDrink();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        } else {
+            // find a mage
+            if (m_FeastSpamTimer > 0) --m_FeastSpamTimer;
+            else {
+                Player *mage = GetClassAI()->FindMage(m_bot);
+                if (mage != NULL) {
+                    SendWhisper("I could use a drink.", *mage);
+                }
+                TellMaster("I need water.");
+                m_FeastSpamTimer = 100;
+            }
+        }
+    }
+
+    //should we eat another
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking  && ((static_cast<float>(m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item *pItem = FindFood();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        //TellMaster("I need food."); //Disabled, tends to be horribly spammy.
+    }
+
+    //if we are no longer eating or drinking
+    //because we are out of items or we are above 80% in both stats
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        //TellMaster("I'm ready, let's go.");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+Unit *PlayerbotAI::getNextTarget(Unit *victim)
+{
+    AttackerSet attackers = victim->getAttackers();
+    for(AttackerSet::iterator itr = attackers.begin(); itr != attackers.end(); ++itr)
+        if (*itr && m_bot->GetDistance(*itr) < 30)
+			return *itr;
+    return NULL;
+} //end getNextTarget
+
+// Come up with the next target the bot should attack
+Unit *PlayerbotAI::findNextTarget()
+{
+	if (m_bot->isDead() || isLooting) return NULL;
+
+	Group *group = m_bot->GetGroup();
+	Unit *target;
+
+	// override all others if ordered to pull
+    if (GetClassAI()->isPulling())
+	{
+		// Check master's target
+		target = ObjectAccessor::GetUnit(*m_master, m_master->GetSelection());
+		if (target && target->isInCombat() && target->IsHostileTo(m_master) && checkValidTarget(target))
+			return target;
+	}
+	GetClassAI()->StopPulling();
+
+	// Check raid target icons
+	uint64 targetGUID = group->GetTargetWithIconByGroup(m_bot->GetGUID());
+	if (targetGUID > 0)
+	{
+		target = ObjectAccessor::GetUnit(*m_master, targetGUID);
+		if (target && !target->isDead() && m_bot->IsHostileTo(target) && checkValidTarget(target))
+			return target;
+	}
+
+	// Check if someone's attacking master
+	target = getNextTarget(m_master);
+	if (checkValidTarget(target)) return target;
+
+	// Check if someone's attacking me
+	target = getNextTarget(m_bot);
+	if (checkValidTarget(target)) return target;
+
+	// Check main tank
+	Unit *tank = m_classAI->FindMainTankInRaid(m_bot);
+	if (tank)
+	{
+		target = getNextTarget(tank);
+		if (checkValidTarget(target)) return target;
+	}
+
+	// Check master's target
+	target = ObjectAccessor::GetUnit(*m_master, m_master->GetSelection());
+	if (target && target->isInCombat() && target->IsHostileTo(m_master) && checkValidTarget(target))
+		return target;
+
+	// Check other players in the group
+	for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+	{
+		Player *player = itr->getSource();
+		uint64 guid = player->GetGUID();
+		if (guid == m_master->GetGUID()) continue;
+		if (guid == m_bot->GetGUID()) continue;
+		target = getNextTarget(player);
+		if (checkValidTarget(target))
+			return target;
+		target = ObjectAccessor::GetUnit(*player, player->GetSelection());
+		if (target && target->isInCombat() && target->IsHostileTo(player) && checkValidTarget(target))
+			return target;
+	}
+
+	// Check pets
+	for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+	{
+		Creature *pet = itr->getSource()->GetPet();
+		if (!pet) continue;
+		target = getNextTarget(pet);
+		if (checkValidTarget(target))
+			return target;
+	}
+
+    ////last try to find something to attack
+    //Trinity::NearestHostileUnitInAttackDistanceCheck u_check((Creature*)m_bot, 30.0);
+    //Trinity::UnitLastSearcher<Trinity::NearestHostileUnitInAttackDistanceCheck> searcher(m_bot, target, u_check);
+    //m_bot->VisitNearbyObject(30, searcher);
+    //if(target && target->isAlive() && target->IsHostileToPlayers() && checkValidTarget(target))
+	//	return target;
+
+	return NULL;
+}
+
+// Test if the selected target is ok to attack
+bool PlayerbotAI::checkValidTarget(Unit *target)
+{
+	// If the target is a world invisible trigger (ex Glyph in UBRS)
+	if (!target || target->GetUInt32Value(UNIT_FIELD_DISPLAYID) == 11686)
+		return false;
+	// If the target is an invisible trigger (ex Vazruden in Hellfire Ramparts)
+	if (target->IsVisible())
+		return false;
+	// If the target is not attackable
+	if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+		return false;
+	return true;
+}
+
+//intelligently sets a reasonable combat order for this bot
+//based on its class / level / etc
+void PlayerbotAI::GetCombatOrders()
+{
+    if(m_bot->isDead() || isLooting) return;
+
+	Unit *thingToAttack = findNextTarget();
+
+    if(!thingToAttack)
+    {
+        if(GetClassAI() && !m_bot->isInCombat()) (GetClassAI())->DoNonCombatActions();
+        return;
+    }
+
+    //wait till it gets closer
+    //if(m_bot->GetDistance(thingToAttack) > 30) return;
+
+    //if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    //this method never gets called when the bot is in a duel and this code
+    //prevents bot from helping
+    if(thingToAttack->GetTypeId() == TYPEID_PLAYER && ((Player*)(thingToAttack))->duel)
+    {
+       SetIgnoreUpdateTime(6);
+        return;
+    }
+
+    m_bot->SetSelection(thingToAttack->GetGUID());
+    SetIgnoreUpdateTime(1);
+    m_combatOrder = ORDERS_KILL;
+
+    if(m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    m_bot->Attack(thingToAttack, true);
+
+    if(thingToAttack->GetTypeId() != TYPEID_PLAYER)
+    {
+        //add thingToAttack to loot list
+        CreatureInfo const *cInfo = ((Creature *)thingToAttack)->GetCreatureInfo();
+        if(cInfo && cInfo->lootid)
+			AddLootGUID(thingToAttack->GetGUID());
+    }
+
+    return;
+}
+
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if(isLooting) return;
+
+    Unit *const pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+
+    //if current order doesn't make sense anymore
+    //clear our orders so we can get orders in next update
+    if(!pTarget || pTarget->isDead() || !pTarget->IsInWorld() ||
+       !m_bot->IsHostileTo(pTarget) || pTarget->IsPolymorphed() || m_bot->isDead()
+       || ((!m_master->isInCombat() && !m_bot->isInCombat() && !pTarget->isInCombat()) // The mob probably is in evade mode, stop combat..
+        //|| pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)
+        && !m_bot->GetPlayerbotAI()->GetClassAI()->isPulling()))
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_bot->SetSelection(0);
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->InterruptNonMeleeSpells(true);
+		// Get a new target
+		if (findNextTarget())
+			GetCombatOrders();
+		else
+			Follow(*m_master);
+		//sLog->outError ("current target doesn't make sense so following");
+        return;
+    }
+
+    if(GetClassAI())
+    {
+        if(m_bot->HasUnitState(UNIT_STAT_CASTING))
+        {
+            return;
+        }
+
+        GetClassAI()->DoNextCombatManeuver(pTarget);
+    }
+}
+
+//this is where the AI should go
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+//HasSpellCooldown
+//IsAffectedBySpellmod
+//isMoving
+//HasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+//hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time)
+{
+    time_t currentTime = time(0);
+    uint32 currentClock = getMSTime();
+    m_bot->UpdateZone(m_bot->GetZoneId(), m_bot->GetAreaId());
+
+    if (m_playerBotsFly == 0 && m_master->isInFlight())
+    {
+        if (m_IsFollowingMaster)
+        {
+            const WorldLocation fakeloc = WorldLocation(35, -0.873190f, 52.920242f, -27.550674f, 1.655620f);
+            PlayerbotChatHandler ch(m_master);
+            if (!ch.teleport(*m_bot, fakeloc))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                return;
+            }
+            m_bot->SendUpdateToPlayer(m_master);
+		}
+        Stay();
+        return;
+    }
+
+	if (m_bot->isDead())
+	{
+		isLooting = false;
+		if (m_TimeRessurect == 0)
+		{
+			m_IsFollowingMaster = false;
+			m_TimeRessurect = currentTime + 30;
+			return;
+		}
+		else if (m_TimeRessurect > currentTime)
+			return;
+		else	// m_TimeRessurect <= currentTime
+		{
+			m_IsFollowingMaster = true;
+			m_TimeRessurect = 0;
+		}
+	}
+    if ((int64(m_ignoreAIUpdatesUntilTime) - int64(currentClock)) > int64(30000))
+	{
+		SetIgnoreUpdateTime(2);
+		return;
+	} // Fix Timer overflow and AI freeze (max limit 30 secs)
+
+	if (currentClock < m_ignoreAIUpdatesUntilTime || m_bot->IsBeingTeleported() || m_bot->GetTrader())
+		return;
+
+    //default updates occur every 1.5 seconds
+    SetIgnoreUpdateTime(1.5);
+
+	// Fake Guild bank checks.  Disable the guild bank while in combat, then re-enable after
+	if (m_master->GetSelectedPlayer() && m_master->GetSelectedPlayer()->GetGUID() == m_bot->GetGUID() && !m_bot->isInCombat())
+		m_bot->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GUILD_BANKER);
+	else
+		m_bot->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GUILD_BANKER);
+
+    // prevent cheating
+    if (!m_bot->GetGroup() || !m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+    {
+        m_master->GetSession()->LogoutPlayerbot(m_bot->GetGUID(), false);
+        return;
+    }
+
+    /*
+     * combat checks
+     */
+    if (m_master <= 0 ||
+		(
+		 (m_master->isInCombat() || m_bot->isInCombat()) &&
+		 m_bot->isDead()
+		 )
+		) return; //You're DEAD, stop thinking.
+
+    //if we are casting a spell then interrupt it
+    //make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+    Spell *const pSpell = GetCurrentSpell();
+    if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())) InterruptCurrentCastingSpell();
+
+    //direct cast command from master
+    else if (m_spellIdCommand != 0)
+    {
+        Unit *pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+        if(pTarget != NULL) CastSpell(m_spellIdCommand, pTarget);
+        m_spellIdCommand = 0;
+        m_targetGuidCommand = 0;
+    }
+
+    else if (m_combatOrder != ORDERS_NONE)
+		DoNextCombatManeuver(); //handle combat
+
+    else if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling())
+    {
+        GetCombatOrders();
+        return;
+    }
+
+	//If I'm not in combat, check to see if I should be
+	else if (!m_bot->isInCombat() || m_combatOrder == ORDERS_NONE)
+		if (findNextTarget()) GetCombatOrders();
+
+    /*
+     * Non combat checks
+     */
+
+    // are we sitting, if so feast if possible
+	//if(m_bot->getStandState() == UNIT_STAND_STATE_SIT) {
+	//	sLog->outError ("%s - sitting so feast", m_bot->GetName());
+	//}
+
+
+    // if commanded to follow master and not already following master then follow master
+    if (!m_bot->isInCombat() && m_IsFollowingMaster && m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+        Follow(*m_master);
+
+    //do class specific non combat actions
+	else if (!m_bot->isInCombat() && GetClassAI())
+        GetClassAI()->DoNonCombatActions();
+
+	if (!m_master->isInCombat())
+        DoLoot();
+
+    if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+        m_bot->SendUpdateToPlayer(m_master);
+        Feast();
+    }
+    else if (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+    //try to catch if he is falling through the world.  This happens
+    //when zoning in/out of an instance
+    if (m_IsFollowingMaster && m_bot->GetMapId() != m_master->GetMapId() ||
+		//m_bot->GetZoneId() != m_master->GetZoneId() ||
+		(abs(abs(m_bot->GetPositionX()) - abs(m_master->GetPositionX())) > 90) ||
+		(abs(abs(m_bot->GetPositionY()) - abs(m_master->GetPositionY())) > 90) ||
+		(abs(abs(m_bot->GetPositionZ()) - abs(m_master->GetPositionZ())) > 50))
+    {
+		//sLog->outError ("%s: %s is too far away so following", m_bot->GetName(), m_master->GetName());
+        Follow(*m_master);
+    }
+}
+
+void PlayerbotAI::KilledMonster(uint32 entry, uint64 guid)
+{
+	if (m_bot->isAlive())
+		AddLootGUID(guid);
+    if(m_master->isAlive() && m_IsFollowingMaster && !m_master->isInCombat())
+    {
+		if (!DoLoot())
+        {
+            float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+            float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(m_master, dist, angle);
+        }
+    }
+
+    // reset main tank every time we finish combat, just in case the
+    // original main tank died and got set to next tank.
+    //m_classAI->SetMainTank(NULL);
+}
+
+Spell *PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0) return NULL;
+	return m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+}
+
+void PlayerbotAI::TellMaster(const std::string &text)
+{
+    SendWhisper(text, m_master->GetSession());
+}
+
+bool PlayerbotAI::CanBotsFly()
+{
+    if (m_playerBotsFly == 0) return false;
+    else return true;
+}
+
+void PlayerbotAI::SendWhisper(const std::string &text, Player &player)
+{
+	SendWhisper(text, player.GetSession());
+}
+
+void PlayerbotAI::SendWhisper(const std::string &text, WorldSession *session)
+{
+	WorldPacket data(SMSG_MESSAGECHAT, 200);
+	// m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER, text, LANG_UNIVERSAL);
+	session->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player &player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+void PlayerbotAI::SetInFront(const Unit *obj)
+{
+    if(!m_bot->HasInArc(M_PI, obj))
+    {
+        m_bot->SetInFront(obj);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+}
+
+bool PlayerbotAI::CastSpell(const char *args)
+{
+    uint32 spellId = getSpellId(args);
+    return spellId ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if (!spellId) return false;
+
+    if (!m_bot->HasSpell(spellId))
+        return false;
+
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);
+}
+
+bool PlayerbotAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if (!m_bot->isAlive()) return false;
+    if (!pSpellInfo)
+    {
+        sLog->outError ("%s: Missing spell entry in CastSpell Direct", m_bot->GetName());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+    uint64 oldSel = m_bot->GetSelection();
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellCustomAttr(spellId) & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else target = m_bot;
+    }
+
+    //Make the Checks
+
+    if (!triggered && checkFirst && !CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck) ) { return false; }
+    if (m_bot->GetSelection() != target->GetGUID() ) { m_bot->SetSelection(target->GetGUID()); } //if target is different than selection apply it
+
+    m_bot->CastSpell(target, pSpellInfo, triggered); //CAST THE SPELL
+    if (m_bot->GetSelection() != oldSel ) { m_bot->SetSelection(oldSel); } // Restore if target changed to cast
+
+    // Check if the casting started..
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell) return false;
+
+    // Trigger Pseudo Global Cooldown and consider casttime
+    float GCD = 1.5f;
+    if (m_bot->getPowerType() == POWER_ENERGY) GCD = 1;
+    float psCastTime = ((float)pSpell->GetCastTime()) / 1000.0f;
+    if (psCastTime - GCD > -0.3f) GCD = 0.3f; //Global cooldown won't be an issiue for casts (0.3 secs is for safe next cast)
+    else { GCD -= psCastTime; } //Remaining GCD after cast..
+    //float psRecoveryTime = GetSpellRecoveryTime(pSpellInfo) / 1000;
+    //sLog->outDebug("Bot [%u] Start Spell [%u] Cast Time [%f]", m_bot->GetGUIDLow(), pSpellInfo->Id, psCastTime);
+    m_CurrentlyCastingSpellId = spellId;
+    //SetIgnoreUpdateTime(psCastTime + GCD);
+    SetIgnoreUpdateTime(psCastTime > GCD ? psCastTime : GCD);
+    return true;
+}
+
+bool PlayerbotAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+     //if spellId == 0, it means that the bot is not high enough level to
+    //have learned the spell
+    if (!spellId) return false;
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);
+}
+
+bool PlayerbotAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in CastCheck - Direct SpellEntry", m_bot->getClass());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellCustomAttr(spellId) & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    if (!m_bot->isAlive()) return false;
+    if (m_bot->HasSpellCooldown(spellId)) return false;
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return false;
+    if (m_bot->IsMounted()) return false;
+
+    //cast existing aura over again?
+    if (!castExistingAura && target->HasAura(spellId, m_bot->GetGUID())) return false;
+
+    //Stances-forms and equipment REQs
+    if (!skipEquipStanceCheck)
+    {
+        uint32 formMask = (GetForm() ? 1 << (GetPlayerBot()->GetShapeshiftForm() - 1) : 0);
+        //sLog->outDebug("DEBUG: Spell [%u] - Form [%X] - Need Form [%X] - Not Form [%X]", pSpellInfo->Id, formMask, pSpellInfo->Stances, pSpellInfo->StancesNot );
+        if (pSpellInfo->Stances & formMask) { return true; }
+        if (pSpellInfo->StancesNot && pSpellInfo->StancesNot & formMask) { return false; }
+        if (!m_bot->HasItemFitToSpellRequirements(pSpellInfo)) return false;
+    }
+
+    //Power Costs
+    const SpellSchoolMask pSpellSchool = GetSpellSchoolMask(pSpellInfo);
+    uint32 pPowerCost = CalculatePowerCost(pSpellInfo, m_bot, pSpellSchool);
+
+    if (skipEquipStanceCheck) { if (m_bot->GetPower((Powers)pSpellInfo->powerType) < pPowerCost) return false; } //Power check for Required PowerType (After changind stance, powertype may change, for druids)
+    else { if (m_bot->GetPower(m_bot->getPowerType()) < pPowerCost) return false; } //Power check for Current m_bot Power Type
+
+    //Distance / movement checks
+    const SpellRangeEntry * pSpellRange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
+    float curDistance = m_bot->GetDistance(target);
+    if (GetSpellCastTime(pSpellInfo) > 0 && m_bot->isMoving()) return false; //Cannot cast while moving
+
+    //The target is immune or not?
+    if (target->GetTypeId() != TYPEID_PLAYER) { if ( ((Creature*)target)->IsImmunedToSpell(pSpellInfo)) { return false; } }
+    else { if (target->IsImmunedToSpell(pSpellInfo)) { return false; } }
+
+    //target reaction checks (Has problems with dual effect spells like death coil/holy shock)
+    if (skipFriendlyCheck)
+    {
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } } //Assume hostile spell
+    }
+    else if (IsPositiveSpell(spellId))
+    {
+        if(! m_bot->IsFriendlyTo(target)) { return false; }
+        else if (pSpellRange->maxRangeFriend != 0) { if (pSpellRange->maxRangeFriend < curDistance || pSpellRange->minRangeFriend > curDistance) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false;
+    }
+    else
+    {
+        if (m_bot->IsFriendlyTo(target))  return false;
+        if (!m_bot->HasInArc(M_PI,target)) return false; //target is not in front
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false; //Out of range - Melee Range
+    }
+
+	// Hack?  When a warlock's imp is phased out, the UNIT_FLAG_NON_ATTACKABLE is set
+	if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)) return false;
+
+    return true;
+}
+
+uint8 PlayerbotAI::GetForm(Unit *pPlayer)
+{
+    if (!pPlayer) pPlayer = m_bot;
+    return (pPlayer->GetUInt32Value(UNIT_FIELD_BYTES_2) & 0xFF000000) >> (4 * 6);
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for( uint8 slot=EQUIPMENT_SLOT_START; itemIdSearchList.size()>0 && slot<EQUIPMENT_SLOT_END; slot++ ) {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if( !pItem )
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+
+//finds items in inventory and adds Item *to foundItemList
+//also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    //look for items in main bag
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem) continue;
+        for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if(pItem->GetProto()->ItemId != *it) continue;
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    //for all for items in other bags
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(!pBag) continue;
+        for(uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item *const pItem = m_bot->GetItemByPos(bag, slot);
+            if(!pItem) continue;
+            for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if(pItem->GetProto()->ItemId != *it) continue;
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::findItemsInInvToSell(std::list<Item *> &foundItemList) const
+{
+	// Look for items in main bag
+	for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+		if (Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+			if (pItem->GetProto()->SellPrice > 0)
+				foundItemList.push_back(pItem);
+
+	// Look for items in removeable bags
+	for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+		if (Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+			for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+				if (Item *const pItem = m_bot->GetItemByPos(bag, slot))
+					if (pItem->GetProto()->SellPrice > 0)
+						foundItemList.push_back(pItem);
+}
+
+void PlayerbotAI::SellItem(WorldSession *session, uint32 itemEntry, uint32 count)
+{
+	if (!m_currVendor) return;
+	if (!itemEntry) return;
+	if (count < 1) return;
+	if (!canObeyCommandFrom(*(session->GetPlayer()))) return;
+
+	Item *item = m_bot->GetItemByEntry(itemEntry);
+	if (!item) return;
+
+	std::ostringstream out;
+	out << "Sold ";
+	MakeItemLink(item, out, false);
+
+	// Get money before
+	uint32 copper = m_bot->GetMoney();
+
+	// Sell the item
+	WorldPacket data(CMSG_SELL_ITEM, 8+8+4);
+	data << uint64(m_currVendor->GetGUID());
+	data << uint64(item->GetGUID());
+	data << uint32(count);
+	m_bot->GetSession()->HandleSellItemOpcode(data);
+
+	// Calculate how much it was sold for
+	copper = m_bot->GetMoney() - copper;
+	if (copper) 	// Sold for no money, must not have actually sold it
+	{
+		uint32 gold = uint32(copper / 10000);
+		copper -= (gold * 10000);
+		uint32 silver = uint32(copper / 100);
+		copper -= (silver * 100);
+		out << " for ";
+		if (gold)
+			out << "|cff00ff00" << gold << "|r|cfffffc00g|r";
+		if (silver || gold)
+			out << "|cff00ff00" << silver << "|r|cffcdcdcds|r";
+		if (copper || silver || gold)
+			out << "|cff00ff00" << copper << "|r|cffffd333c|r";
+		SendWhisper(out.str(), session);
+	}
+
+	// Reshow the bot's inventory
+	SendVendorList(session, m_currVendor);
+}
+
+bool PlayerbotAI::HasPick()
+{
+    QueryResult result;
+
+    // list out equiped items
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if (pItem )
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto) continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto) continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug("[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto) continue;
+
+                    result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+                    if (result)
+                    {
+
+                        Field *fields = result->Fetch();
+                        uint32 tc = fields[0].GetUInt32();
+                        // sLog->outDebug("HasPick %u",tc);
+                        if(tc ==  165 || tc == 167)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+    std::ostringstream out;
+    out << "|cffffffffI do not have a pick!";
+    TellMaster( out.str().c_str() );
+    return false;
+}
+
+
+//submits packet to use an item
+void PlayerbotAI::PoisonWeapon(Item &item, uint32 _spellId, uint32 _target, EquipmentSlots weaponSlot)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = _spellId;
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    uint32 target = _target;
+    uint32 targetItemGUID = 0;
+    uint8 x = 0;
+    Item *weapon=NULL;
+    if (_spellId>0){
+
+        targetItemGUID = 16;
+        x = 135;
+        cast_count = 7;
+        weapon = GetPlayerBot()->GetItemByPos( INVENTORY_SLOT_BAG_0, weaponSlot );
+
+    }
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 4);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    if (weapon) packet->appendPackGUID(weapon->GetGUID());
+
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+} // end PoisonWeapon
+
+
+
+//submits packet to use an item
+void PlayerbotAI::UseItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = 0; //only used in combat
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    //create target data
+    //note other targets are possible but not supported at the moment
+    //see SpellCastTargets::read in Spell.cpp to see other options
+    //for setting target
+
+    uint32 target = TARGET_FLAG_SELF;
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get aroundrace condition
+
+} // end UseItem
+
+
+//submits packet to use an item
+void PlayerbotAI::EquipItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+
+    WorldPacket *const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+    *packet << bagIndex << slot;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog->outDebug( "[PlayerbotAI::TradeItem]: slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+        slot,
+        (m_bot->GetTrader()?1:0),
+        (item.IsInTrade()?1:0),
+        (item.CanBeTraded()?1:0)
+        );
+
+    if (!m_bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    int8 tradeSlot = -1;
+
+    if( (slot>=0 && slot<TRADE_SLOT_COUNT) /*&& m_bot->GetItemPosByTradeSlot(slot)==NULL_SLOT */) {
+        tradeSlot = slot;
+    } else if (!item.CanBeTraded())
+    {
+        tradeSlot = (uint8) TRADE_SLOT_NONTRADED;
+    }
+    else
+    {
+        for( uint8 i=0; i<TRADE_SLOT_TRADED_COUNT; ++i )
+        {
+			if (m_bot->GetTradeData()->GetItem(TradeSlots(i)) == NULL){
+                tradeSlot = (uint8)i;
+                break;
+			}
+        }
+    }
+
+    if( tradeSlot == -1 ) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 1+1+1);
+    *packet << uint8(tradeSlot)
+			<< uint8(item.GetBagSlot())
+            << uint8(item.GetSlot());
+    m_bot->GetSession()->QueuePacket(packet);
+
+    return true;
+}
+
+
+//submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if(copper > 0)
+    {
+        WorldPacket *const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << uint32(copper);
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::Stay()
+{
+	GetClassAI()->StopPulling();
+    if (!m_IsFollowingMaster)
+        return;
+
+    m_IsFollowingMaster = false;
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}
+
+
+bool PlayerbotAI::Follow(Player &player)
+{
+	GetClassAI()->StopPulling();
+    if (m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return false; //You're DEAD, stop thinking.
+    if (m_master->isDead()) return false;
+    if (m_master->IsBeingTeleported() || m_master->isInFlight()) return false;
+
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT && (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0))) return false; //Do no interrupt if bot is eating/drinking
+
+    m_IsFollowingMaster = true;
+
+    if (!m_bot->IsStandState()) {
+         m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+         m_bot->SendUpdateToPlayer(m_master);
+    }
+
+    if (!m_bot->isInCombat())
+    {
+        //if bot is dead and master is alive, revive bot
+        if (m_master->isAlive() && !m_bot->isAlive())
+        {
+            SetIgnoreUpdateTime(6);
+            isLooting = false;
+            PlayerbotChatHandler ch(m_master);
+            if (!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return false;
+            }
+        }
+
+        if (!m_bot->isDead() && !m_bot->IsBeingTeleported() && !player.isDead() &&
+            (m_bot->GetMapId() != player.GetMapId()
+            || m_bot->GetZoneId() != player.GetZoneId()
+            || m_bot->GetAreaId() != player.GetAreaId()
+            || m_bot->GetPhaseMask() != player.GetPhaseMask())
+            || m_bot->GetDistance(player) > 255)
+            {
+                SetIgnoreUpdateTime(6);
+                isLooting = false;
+                PlayerbotChatHandler ch(m_master);
+                if (!ch.teleport(*m_bot))
+                {
+                    ch.sysmessage(".. could not be teleported ..");
+                    return false;
+                }
+        }
+    }
+
+    if (m_bot->isAlive() && !isLooting)
+    {
+        float angle = M_PI/2 + rand_norm()*M_PI ; //Generates random float between 90 and 270 degrees
+        float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); // Using urand to get a random float is stupid.
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+
+        return true;
+    }
+    return false;
+}
+
+//handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string &text, Player &fromPlayer)
+{
+    //ignore any messages from Addons
+    if (text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos)
+		return;
+
+    //if message is not from a player in the masters account ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {	/*
+		std::ostringstream out;
+		out << "I can't talk to you.  Please speak to my master, ";
+		out << m_master->GetName() << ".";
+        SendWhisper(out.str(), *fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+		*/
+		return;
+    }
+
+	// Give a drink to players
+    else if (text == "I could use a drink." && m_bot->getClass() == CLASS_MAGE)
+    {
+		if (const Item *pItem = FindDrink())
+		{
+			WorldPacket data(CMSG_INITIATE_TRADE, 8);
+            data << uint64(fromPlayer.GetGUID());
+            m_bot->GetSession()->HandleInitiateTradeOpcode(data);
+            SendWhisper("Here is a tasty treat for you", fromPlayer);
+        }
+    }
+
+    // accept food/drink from mage
+    else if (text == "Here is a tasty treat for you")
+    {
+        m_bot->Say("Thank you for this treat", LANG_UNIVERSAL);
+        SendWhisper("Thank you for this treat.", fromPlayer);
+    }
+
+    // trade opened so send items over
+    else if (text == "Thank you for this treat")
+    {
+        if (m_bot->getClass() != CLASS_MAGE) return;
+
+        const Item *pItem = FindDrink();
+        if (!pItem) return;
+
+        bool trade = TradeItem(*pItem, 2);
+        if (trade)
+		{
+            m_bot->Say("Enjoy the refreshing drink.", LANG_UNIVERSAL);
+
+			WorldPacket* const packet = new WorldPacket(CMSG_ACCEPT_TRADE, 3);
+			m_bot->GetSession()->QueuePacket(packet);  // packet is not used
+        }
+		else
+            m_bot->Say("I cannot trade with you.", LANG_UNIVERSAL);
+    }
+
+	// Command to tell a mage to make a stack of 20 waters for each caster and
+	// a stack of 20 foods for each member in the group
+	else if (text == "stock up")
+	{
+		// Make it so
+	}
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID() &&
+        fromPlayer.GetPlayerbotAI() == NULL)
+    {
+		bool dontTrade = false;
+		std::string itemStr;
+		if (text.size() > 2 && text.substr(0, 2) == "t " ||
+			text.size() > 6 && text.substr(0, 6) == "trade ")
+		{
+			itemStr = text.substr(text.find(" ") + 1);
+			dontTrade = true;
+		}
+		else
+			itemStr = text;
+
+        uint32 copper = extractMoney(itemStr);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(itemStr, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            findItemsInEquip(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+			{
+				if (dontTrade)
+				{
+					TradeItem(**it, TRADE_SLOT_NONTRADED);
+					break;
+				}
+				else
+                TradeItem(**it);
+        }
+    }
+    }
+
+    else if(text == "follow" || text == "come")
+        Follow(*m_master);
+
+    else if(text == "stay" || text == "stop")
+        Stay();
+
+    //handle cast command
+    else if(text.size() > 2 && text.substr(0, 2) == "c " ||
+			text.size() > 5 && text.substr(0, 5) == "cast ")
+    {
+		uint32 spellId = 0;
+        std::string spellStr = text.substr(text.find(" ") + 1);
+
+        if (spellStr.find("Hspell:"))
+        {
+			spellStr = spellStr.substr(spellStr.find("|h[") + 3);
+            spellStr = spellStr.substr(0, spellStr.find("]"));
+        }
+		else
+            spellId = (uint32)atol(spellStr.c_str());
+
+        //try and get spell ID by name
+        if (spellId == 0) spellId = getSpellId(spellStr.c_str(), true);
+
+        uint64 castOnGuid = fromPlayer.GetSelection();
+        if (castOnGuid == 0) castOnGuid = m_bot->GetGUID();
+        if (spellId != 0)
+        {
+			m_spellIdCommand = spellId;
+            m_targetGuidCommand = castOnGuid;
+        }
+    }
+
+    //use items
+    else if(text.size() > 2 && text.substr(0, 2) == "u " ||
+			text.size() > 4 && text.substr(0, 4) == "use ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) UseItem(**it);
+    }
+
+    // poison mainhand weapon
+    else if(text.size() > 2 && text.substr(0, 2) == "p " ||
+			text.size() >= 8 && text.substr(0, 8) == "poison m")
+    {
+
+        Item *poison = FindPoisonForward();
+        if (!poison)
+		{
+            std::string msg = "No poison found for mainhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+    }
+
+    // poison offhand weapon
+    else if(text.size() >= 8 && text.substr(0, 8) == "poison o")
+    {
+
+        Item *poison = FindPoisonBackward();
+        if (poison == NULL)
+		{
+            std::string msg = "No poison found for offhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+    }
+
+    //equip items
+    else if(text.size() > 2 && text.substr(0, 2) == "e " ||
+		    text.size() > 6 && text.substr(0, 6) == "equip ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) EquipItem(**it);
+
+		// Resend the updated info to the inspecting player
+		WorldPacket data(CMSG_INSPECT, 8);
+		data << uint64(m_bot->GetGUID());
+		fromPlayer.GetSession()->HandleInspectOpcode(data);
+    }
+
+	// Train talents
+	else if (text.size() > 6 && text.substr(0, 6) == "learn " ||
+		     text.size() > 2 && text.substr(0, 2) == "l ")
+	{
+		std::list<uint32> talents;
+		extractTalentIds(text, talents);
+
+		for(std::list<uint32>::iterator it = talents.begin(); it != talents.end(); ++it)
+		{
+			TalentEntry const *talentInfo = sTalentStore.LookupEntry(*it);
+			if (!talentInfo) continue;
+
+			TalentTabEntry const *talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+			if (!talentTabInfo) continue;
+
+		    // find current max talent rank (0~5)
+			uint8 learnRank = 0; // 0 = not learned any rank
+			for(int8 rank = MAX_TALENT_RANK - 1; rank >= 0; --rank)
+			{
+				if (talentInfo->RankID[rank] && m_bot->HasSpell(talentInfo->RankID[rank]))
+				{
+					learnRank = rank + 1;
+					break;
+				}
+			}
+
+			// Learn the talent
+			WorldPacket data(CMSG_LEARN_TALENT, 3 + 3);
+			data << uint32(*it);					// TalentId
+			data << uint32(learnRank);				// Requested rank
+			m_bot->GetSession()->HandleLearnTalentOpcode(data);
+		}
+
+		// Resend the updated info to the inspecting player
+		WorldPacket data(CMSG_INSPECT, 8);
+		data << uint64(m_bot->GetGUID());
+		fromPlayer.GetSession()->HandleInspectOpcode(data);
+	}
+
+    else if(text == "spells")
+    {
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+        std::string alreadySeenList = ",";
+
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+                continue;
+
+            const SpellEntry *const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if(!pSpellInfo)
+                continue;
+
+            //|| name.find("Teleport") != -1
+
+            std::string comp = ",";
+            comp.append(pSpellInfo->SpellName[loc]);
+            comp.append(",");
+
+            if(!(ignoreList.find(comp) == std::string::npos &&
+                alreadySeenList.find(comp) == std::string::npos))
+                continue;
+
+            alreadySeenList += pSpellInfo->SpellName[loc];
+            alreadySeenList += ",";
+
+            if(IsPositiveSpell(spellId))
+				MakeSpellLink(pSpellInfo, posOut, &fromPlayer);
+            else
+				MakeSpellLink(pSpellInfo, negOut, &fromPlayer);
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("Here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+	else if ((text.size() > 3 && text.substr(0, 3) == "qd ") ||
+		     (text.size() > 14 && text.substr(0, 14) == "quest details "))
+	{	// Quest details
+		std::string questLink;
+		if (text[1] == 'd')
+			questLink = text.substr(3);
+		else
+			questLink = text.substr(14);
+
+		std::ostringstream out;
+		out << "Quest " << questLink.c_str() << ": ";
+
+		std::string questIdStr = questLink.substr(questLink.find("Hquest:") + 7);
+		questIdStr = questIdStr.substr(0, questIdStr.find(":"));
+		uint32 questId = atol(questIdStr.c_str());
+		if (questId)
+		{
+			QuestStatusMap::iterator it = m_bot->getQuestStatusMap().find(questId);
+			if (it != m_bot->getQuestStatusMap().end())
+			{
+				QuestStatusData *pData = &(it->second);
+				const Quest *pQuest = sObjectMgr->GetQuestTemplate(questId);
+				if (pData && pQuest)
+				{
+					switch(pData->m_status)
+					{
+					case QUEST_STATUS_NONE:
+						out << "I don't have this quest.";
+						break;
+					case QUEST_STATUS_COMPLETE:
+						out << "I'm finished with this quest.";
+						if (!pData == QUEST_STATUS_COMPLETE)
+						{
+							out << "  I haven't received the reward yet, and here are the details of the quest:\r";
+							out << pQuest->GetCompletedText();
+							out << "\r--\r";
+							out << pQuest->GetDetails();
+							out << "\r--\r";
+							out << pQuest->GetEndText();
+							out << "\r--\r";
+							out << pQuest->GetObjectives();
+						}
+						break;
+					case QUEST_STATUS_FAILED:
+						out << "I have failed this quest.\r";
+						out << pQuest->GetObjectives();
+						break;
+					case QUEST_STATUS_INCOMPLETE:
+						out << "I'm still working on this quest.\r";
+						out << pQuest->GetObjectives();
+						break;
+					default:
+						out << "I don't have that quest.";
+						break;
+					}
+					TellMaster(out.str());
+				}
+			}
+		}
+	} // qd quest details
+
+	else if ((text.size() > 6 && text.substr(0, 6) == "quest ") ||
+			 (text.size() > 2 && text.substr(0, 2) == "q "))
+	{
+		std::string questLink;
+		if (text[1] == ' ')		// q <hlink>
+			questLink = text.substr(2);
+		else					// quest <hlink>
+			questLink = text.substr(6);
+		std::ostringstream out;
+		out << "Quest " << questLink.c_str() << ": ";
+
+		std::string questIdStr = questLink.substr(questLink.find("Hquest:") + 7);
+		questIdStr = questIdStr.substr(0, questIdStr.find(":"));
+		uint32 questId = atol(questIdStr.c_str());
+		if (questId != 0)
+		{
+			QuestStatusMap::iterator itr = m_bot->getQuestStatusMap().find(questId);
+			if (itr != m_bot->getQuestStatusMap().end())
+			{
+				QuestStatusData *pData = &(itr->second);
+				const Quest *pQuest = sObjectMgr->GetQuestTemplate(questId);
+				if (pData && pQuest)
+				{
+					switch(pData->m_status)
+					{
+					case QUEST_STATUS_NONE:
+						out << "I don't have this quest.";
+						break;
+					case QUEST_STATUS_COMPLETE:
+						out << "I'm finished with this quest.";
+						break;
+					case QUEST_STATUS_UNAVAILABLE:
+						out << "This quest is unavailable for me.";
+						break;
+					case QUEST_STATUS_AVAILABLE:
+						out << "This quest is available for me.";
+						break;
+					case QUEST_STATUS_FAILED:
+						out << "I have failed this quest.";
+						break;
+					case QUEST_STATUS_INCOMPLETE:
+					{
+						out << "I'm still working on this quest.";
+
+						// Run through each needed item
+						bool first = true;
+						for(uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
+						{
+							if (pQuest->ReqItemCount[i] == 0) continue;
+							if (first)
+							{
+								out << "  I need:";
+								first = false;
+							}
+							out << "\r(" << pData->m_itemcount[i] << "/" << pQuest->ReqItemCount[i] << ") ";
+							const ItemPrototype *item = sObjectMgr->GetItemPrototype(pQuest->ReqItemId[i]);
+							MakeItemLink(item, out);
+						}
+						// Run through creatures needed to kill
+						for(uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+						{
+							if (pQuest->ReqCreatureOrGOCount[i] == 0) continue;
+							if (first)
+							{
+								out << "  I need:";
+								first = false;
+							}
+							out << "\r(" << pData->m_creatureOrGOcount[i] << "/" << pQuest->ReqCreatureOrGOCount[i] << ") ";
+							int32 id = pQuest->ReqCreatureOrGOId[i];
+							if (id > 0)
+							{
+								// Creature
+								const CreatureInfo *creature = sObjectMgr->GetCreatureTemplate(id);
+								out << creature->Name;
+							}
+							else
+							{
+								// GameObject
+								const GameObjectInfo *go = sObjectMgr->GetGameObjectInfo(-id);
+								out << go->name;
+							}
+						}
+						break;
+					}
+					default:
+						out << "I don't know the status of this quest.";
+						break;
+					}
+				}
+				else
+					out << "I can't find this quest.";
+			}
+			else
+				out << "I can't find this quest.";
+		}
+		else
+			out << "I can't find this quest.";
+		SendWhisper(out.str(), fromPlayer);
+	} // "quest "
+
+    else if (text.size() > 7 && text.substr(0,7) == "accept ")
+    {
+	    // .addquest #entry'
+	    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+		std::string questLink = text.substr(7);	// lop off "accept "
+		if (questLink.find("|Hquest"))
+		{
+			if (questLink.find("|c"))
+				questLink = questLink.substr(questLink.find("|c"));
+			else
+				questLink = questLink.substr(questLink.find("|Hquest"));
+			questLink = questLink.substr(0, questLink.find("]|h|r") + 5);
+			PlayerbotChatHandler ch(m_master);
+
+	        std::ostringstream out;
+			out << "Quest " << questLink.c_str();
+
+			uint64 oldSel = 0;
+			if (m_master->GetSelection())
+				oldSel = m_master->GetSelection();
+			m_master->SetSelection(m_bot->GetGUID());
+	        if (ch.acceptQuest(questLink.c_str()))
+		    {
+			    out << " accepted.";
+				SendWhisper(out.str(), fromPlayer);
+	        }
+		    else
+			{
+				out << " not accepted.";
+				SendWhisper(out.str(), fromPlayer);
+		    }
+			if (oldSel > 0)
+				m_master->SetSelection(oldSel);
+		}
+    }
+
+    else if (text.size() > 8 && text.substr(0,8) == "abandon ")
+    {
+        uint32 questId = 0;
+        std::string questLink = text.substr(8);							// lop off "abandon "
+		if (questLink.find("|Hquest"))
+		{
+			if (questLink.find("|c"))
+				questLink = questLink.substr(questLink.find("|c"));
+			else
+				questLink = questLink.substr(questLink.find("|Hquest"));
+			questLink = questLink.substr(0, questLink.find("]|h|r") + 5);	// lop off anythin after "]|h|r"
+
+	        std::ostringstream out;
+		    out << "Quest " << questLink;
+
+			PlayerbotChatHandler ch(m_master);
+			uint64 oldSel = 0;
+			if (m_master->GetSelection())
+				oldSel = m_master->GetSelection();
+			m_master->SetSelection(m_bot->GetGUID());
+			if (ch.abandonQuest(questLink.c_str()))
+			{
+				out << " abandoned.";
+				SendWhisper(out.str(), fromPlayer);
+			}
+            else
+			{
+				out << " not abandoned.";
+				SendWhisper(out.str(), fromPlayer);
+			}
+			if (oldSel > 0)
+				m_master->SetSelection(oldSel);
+		}
+    }
+
+    else if (text == "q" || text == "quests")
+    {
+        std::ostringstream out;
+		bool first = true;
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo)
+                continue;
+            QuestStatusData *qData = &iter->second;
+
+			switch(qData->m_status)
+			{
+			case QUEST_STATUS_COMPLETE:
+				if (!qData == QUEST_STATUS_COMPLETE)
+				{
+					if (first) first = false;
+					else out << "\r";
+					MakeQuestLink(qInfo, out);
+					out << " complete";
+				}
+				break;
+			case QUEST_STATUS_INCOMPLETE:
+				if (first) first = false;
+				else out << "\r";
+				MakeQuestLink(qInfo, out);
+				out << " incomplete";
+				break;
+			case QUEST_STATUS_FAILED:
+				if (first) first = false;
+				else out << "\r";
+				MakeQuestLink(qInfo, out);
+				out << " failed";
+				break;
+			}
+        }
+        if (!out.str().empty())
+			SendWhisper(out.str(), fromPlayer);
+    }
+
+    else if (text == "train")
+    {
+         Unit *unit = fromPlayer.GetSelectedUnit();
+
+         if (!unit)
+         {
+			 SendWhisper("Please select the trainer which I should learn from!", fromPlayer);
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             SendWhisper("This is not a trainer!", fromPlayer);
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+			 SendWhisper("This trainer can not train me anything at all!", fromPlayer);
+             return;
+         }
+
+         CreatureInfo const *ci = creature->GetCreatureInfo();
+
+         if (!ci)
+         {
+			 SendWhisper("This trainer can not train me anything at all!", fromPlayer);
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+			 SendWhisper("No training spells can be found from this trainer", fromPlayer);
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "I have learned the following spells:\r";
+         uint32 totalCost = 0;
+         uint32 totalSpellLearnt = 0;
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+				if (!tSpell->learnedSpell[i])
+					continue;
+				if (!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+				{
+					valid = false;
+					break;
+				}
+                if (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+					primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+                 continue;
+			 if (primary_prof_first_rank && !can_learn_primary_prof)
+				 continue;
+             uint32 spellId = tSpell->spell;
+
+			 const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+                 continue;
+             uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+
+             // check money requirement
+             if(m_bot->GetMoney() < cost )
+                 continue;
+
+             m_bot->ModifyMoney(-int32(cost));
+
+             // learn explicitly or cast explicitly
+             if(tSpell->IsCastable())
+                 //FIXME: prof. spell entry in trainer list not marked gray until list re-open.
+                 m_bot->CastSpell(m_bot,tSpell->spell,true);
+             else
+                 m_bot->learnSpell(spellId,false);
+             ++totalSpellLearnt;
+             totalCost += cost;
+
+			 MakeSpellLink(pSpellInfo, msg, &fromPlayer);
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             if (gold > 0)
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             if (silver > 0)
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\r";
+         }
+
+         uint32 gold = uint32(totalCost / 10000);
+         totalCost -= (gold * 10000);
+         uint32 silver = uint32(totalCost / 100);
+         totalCost -= (silver * 100);
+         msg << "Total of " << totalSpellLearnt << "  spell";
+		 if (totalSpellLearnt != 1) msg << "s";
+		 msg << " learned, ";
+
+         if (gold > 0)
+             msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+         if (silver > 0)
+             msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+         msg << totalCost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t spent.";
+
+		 SendWhisper(msg.str(), fromPlayer);
+
+         m_bot->GetPlayerbotAI()->GetClassAI()->LoadSpells();
+
+    }
+    else if (text == "train list")
+    {
+         Unit *unit = fromPlayer.GetSelectedUnit();
+
+         if (!unit)
+         {
+			 SendWhisper("Please select the trainer which I should learn  from!", fromPlayer);
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+			 SendWhisper("This is not a trainer!", fromPlayer);
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             SendWhisper("This trainer can not train me anything at all!", fromPlayer);
+             return;
+         }
+
+         CreatureInfo const *ci = creature->GetCreatureInfo();
+
+         if (!ci)
+         {
+			 SendWhisper("This trainer can not train me anything at all!", fromPlayer);
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+			 SendWhisper("No training spells can be found from this trainer", fromPlayer);
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "The spells I can learn and their costs are:\r";
+         uint32 totalCost = 0;
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+                 continue;
+			 if (primary_prof_first_rank && !can_learn_primary_prof)
+				 continue;
+             uint32 spellId = tSpell->spell;
+             const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+                 continue;
+             uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+             totalCost += cost;
+
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+			 MakeSpellLink(pSpellInfo, msg, &fromPlayer);
+             if (gold > 0)
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             if (silver > 0)
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\r";
+         }
+         uint32 moneyDiff = m_bot->GetMoney() - totalCost;
+         if (moneyDiff >= 0)
+         {
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             if (gold > 0)
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             if (silver > 0)
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t left.";
+         }
+         else
+         {
+             moneyDiff *= -1;
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             msg << "I need ";
+             if (gold > 0)
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             if (silver > 0)
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t more to learn all the  spells!";
+         }
+		 SendWhisper(msg.str(), fromPlayer);
+    }
+
+	// Test method
+	else if (text == "test")
+	{
+		// Send talent info window
+		WorldPacket data(SMSG_TALENTS_INFO, 50);
+		data << uint8(0);		// Is this data for a pet?
+		m_bot->BuildPlayerTalentsInfoData(&data);
+		fromPlayer.GetSession()->SendPacket(&data);
+		return;
+	}
+
+	// Sell method that brings up a merchant window for the bot
+	else if (text == "sell")
+	{
+        Unit *unit = fromPlayer.GetSelectedUnit();
+
+        if (!unit)
+        {
+			SendWhisper("Please show me who I should trade with!", fromPlayer);
+            return;
+        }
+        if (!unit->isVendor())
+        {
+			SendWhisper("This person does not want to trade with me!", fromPlayer);
+            return;
+        }
+        if (!m_bot->IsInMap((WorldObject*) unit))
+        {
+			SendWhisper("I'm too far away to sell items!", fromPlayer);
+            return;
+        }
+
+		SendVendorList(fromPlayer.GetSession(), unit);
+		return;
+	}
+	// Sell method, reports back how much each item is sold for.
+	else if(text.size() > 4 && text.substr(0, 4) == "sell")
+    {
+        Unit *unit = fromPlayer.GetSelectedUnit();
+
+        if (!unit)
+        {
+			SendWhisper("Please show me who I should trade with!", fromPlayer);
+            return;
+        }
+        if (!unit->isVendor())
+        {
+			SendWhisper("This person does not want to trade with me!", fromPlayer);
+            return;
+        }
+        if (!m_bot->IsInMap(static_cast<WorldObject *>(unit)))
+        {
+			SendWhisper("I'm too far away to sell items!", fromPlayer);
+            return;
+        }
+
+        uint32 TotalCost = 0;
+        uint32 TotalSold = 0;
+        std::ostringstream report;
+
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        {
+			Item *item = *it;
+			if (item->GetProto()->SellPrice <= 0)
+				continue;
+
+			// Before money
+			uint32 cost = m_bot->GetMoney();
+
+			// Sell the item
+			WorldPacket data(CMSG_SELL_ITEM, 8+8+4);
+			data << uint64(unit->GetGUID());
+			data << uint64(item->GetGUID());
+			data << uint32(item->GetCount());
+			m_bot->GetSession()->HandleSellItemOpcode(data);
+
+			// Old sell item:
+			/*
+            int32 cost = item->GetCount() * item->GetProto()->SellPrice;
+            m_bot->ModifyMoney(cost);
+            m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+			*/
+
+			// Delta money
+			cost -= m_bot->GetMoney();
+
+			// Must not have actually sold it...
+			if (cost == 0)
+				continue;
+
+			++TotalSold;
+			TotalCost += cost;
+
+            if (item->GetCount() > 0)
+			{
+				report << "Sold ";
+				MakeItemLink(item, report);
+                report << " for ";
+
+                uint32 gold = uint32(cost / 10000);
+                cost -= gold * 10000;
+                uint32 silver = uint32(cost / 100);
+                cost -= silver * 100;
+
+                if (gold > 0)
+					report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                if (silver > 0)
+                    report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\r";
+            }
+        }
+        if (TotalSold > 0) {
+            report << "Sold total " << TotalSold << " item";
+			if (TotalSold != 1) report << "s";
+			report << " for ";
+
+            uint32 gold = uint32(TotalCost / 10000);
+            TotalCost -= gold * 10000;
+            uint32 silver = uint32(TotalCost / 100);
+            TotalCost -= silver * 100;
+
+            if (gold > 0)
+                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+            if (silver > 0)
+                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t.";
+			SendWhisper(report.str(), fromPlayer);
+        }
+    }
+
+	else if (text.size() > 2 && text.substr(0, 2) == "g " ||
+			 text.size() > 4 && text.substr(0, 4) == "get ")
+	{
+		uint32 guid;
+		float x, y, z;
+		uint32 entry;
+		int mapid;
+
+		if (extractGOinfo(text, guid, entry, mapid, x, y, z))
+		{
+			sLog->outDebug("find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+			m_lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+			GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+			if (!go)
+			{
+				m_bot->Say("I can't find it.", LANG_UNIVERSAL);
+				m_lootCurrent = 0;
+				return;
+			}
+			if (!go->isSpawned())
+			{
+				m_bot->Say("It is not there anymore.", LANG_UNIVERSAL);
+				return;
+			}
+
+			m_bot->UpdateGroundPositionZ(x, y, z);
+			m_bot->GetMotionMaster()->MovePoint(mapid, x, y, z);
+			m_bot->SetPosition(x, y, z, m_bot->GetOrientation());
+			m_bot->SendLoot(m_lootCurrent, LOOT_CORPSE);
+			Loot *loot = &go->loot;
+			uint32 lootNum = loot->GetMaxSlotInLootFor(m_bot);
+
+			sLog->outDebug("[PlayerbotAI]: GetGOType %u - %s looting: '%s' got %d items", go->GetGoType(), m_bot->GetName(), go->GetGOInfo()->name, loot->GetMaxSlotInLootFor(m_bot));
+			for(uint32 l = 0; l < lootNum; ++l)
+			{
+				QuestItem *qitem = 0, *ffaitem = 0, *conditem = 0;
+				LootItem *item = loot->LootItemInSlot(l, m_bot, &qitem, &ffaitem, &conditem);
+				if (!item)
+					continue;
+
+				if (!qitem && item->is_blocked)
+				{
+					m_bot->SendLootRelease(m_lootCurrent);
+					continue;
+				}
+
+				if (needItem(item->itemid))
+				{
+					ItemPosCountVec dest;
+					if (m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+					{
+						Item * newitem = m_bot->StoreNewItem(dest, item->itemid, true, item->randomPropertyId);
+						if (qitem)
+						{
+							qitem->is_looted = true;
+							if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
+								m_bot->SendNotifyLootItemRemoved(l);
+							else
+								loot->NotifyQuestItemRemoved(qitem->index);
+						}
+						else
+						{
+							if (ffaitem)
+							{
+								ffaitem->is_looted = true;
+								m_bot->SendNotifyLootItemRemoved(l);
+							}
+							else
+							{
+								if (conditem)
+									conditem->is_looted = true;
+								loot->NotifyItemRemoved(l);
+							}
+						}
+						if (!item->freeforall)
+							item->is_looted = true;
+						--loot->unlootedCount;
+						m_bot->SendNewItem(newitem, uint32(item->count), false, false, true);
+					    m_bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+					}
+				}
+				uint32 lockId = go->GetGOInfo()->GetLockId();
+				LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+				if(lockInfo)
+				{
+					uint32 skillId = SkillByLockType(LockType(lockInfo->Index[0]));
+					switch(skillId)
+					{
+					case SKILL_MINING:
+						if (m_bot->HasSkill(SKILL_MINING) && HasPick()) // Has skill & suitable pick
+		                {
+							ItemPosCountVec dest;
+				            if (m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+					        {
+								Item* pItem = m_bot->StoreNewItem(dest, item->itemid, true, item->randomPropertyId);
+							    uint32 reqSkillValue = lockInfo->Skill[0];
+								uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_MINING);
+								if (SkillValue >= reqSkillValue)
+								{
+									m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+		                            m_bot->UpdateGatherSkill(SKILL_MINING, SkillValue, reqSkillValue);
+			                        --loot->unlootedCount;
+				                }
+					        }
+						}
+						break;
+					case SKILL_HERBALISM:
+						if (m_bot->HasSkill(SKILL_HERBALISM)) // Has skill
+						{
+							ItemPosCountVec dest;
+	                        if (m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+							{
+								Item* pItem = m_bot->StoreNewItem(dest, item->itemid, true, item->randomPropertyId);
+				                uint32 reqSkillValue = lockInfo->Skill[0];
+					            uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_HERBALISM);
+						        if (SkillValue >= reqSkillValue)
+							    {
+								    m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+									m_bot->UpdateGatherSkill(SKILL_HERBALISM, SkillValue, reqSkillValue);
+									--loot->unlootedCount;
+								}
+							}
+						}
+						break;
+					}
+				}
+			}
+			// release loot
+			m_bot->GetSession()->DoLootRelease(m_lootCurrent);
+
+			// clear movement target, take next target on next update
+			m_bot->GetMotionMaster()->Clear();
+			m_bot->GetMotionMaster()->MoveIdle();
+			sLog->outDebug("[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent);
+			SetQuestNeedItems();
+		}
+		else
+			SendWhisper("I have no info on that object", fromPlayer);
+	} // "get"
+
+	else if (text == "survey")
+	{
+		float distance = 100.0f;
+		uint32 count = 0;
+		std::ostringstream detectout;
+
+		QueryResult result = WorldDatabase.PQuery("SELECT guid, id, position_x, position_y, position_z, map, "
+			"(POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ "
+			"FROM gameobject WHERE map='%u' AND (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) <= '%f' ORDER BY order_",
+			m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(),
+			m_bot->GetMapId(), m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), distance*distance);
+
+		if (result)
+		{
+			do
+			{
+				Field *fields = result->Fetch();
+				uint32 guid = fields[0].GetUInt32();
+				uint32 entry = fields[1].GetUInt32();
+				float x = fields[2].GetFloat();
+				float y = fields[3].GetFloat();
+				float z = fields[4].GetFloat();
+				int mapid = fields[5].GetUInt16();
+
+				GameObjectInfo const * gInfo = ObjectMgr::GetGameObjectInfo(entry);
+
+				if(!gInfo)
+					continue;
+
+				uint64 objGuid = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+				GameObject *go = m_bot->GetMap()->GetGameObject(objGuid);
+				if (!go || (go && !go->isSpawned())) continue;
+
+				if(count < 12) // count, limits number of links
+					detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry << ":" << x << ":" << y << ":" << z  << ":" << mapid  << ":" <<  "|h[" << gInfo->name << "]|h|r";
+				++count;
+			} while (result->NextRow());
+		}
+		SendWhisper(detectout.str().c_str(), fromPlayer);
+	} // "survey"
+
+    else if (text == "pull")
+    {
+        m_bot->GetPlayerbotAI()->GetClassAI()->Pull();
+    }
+
+    else if(text == "help")
+    {
+        std::string msg;
+		msg =  "The commands I respond to are:\r";
+		msg += " follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se,\r";
+		msg += " (q)uests, (q)uest <hlink>, accept <quest-hlink>, abandon <quest-hlink>,\r";
+		msg += " train, train list, (l)earn <talent-hlink>";
+		if (m_bot->getClass() == CLASS_ROGUE)
+			msg += ", poison [main |off].";
+		else
+			msg += ".";
+
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty())
+		{
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.m_qId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    ! m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                {
+                    for (uint8 rewardIdx=0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemPrototype const * const pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+                            std::ostringstream out;
+							m_bot->GetPlayerbotAI()->MakeItemLink(pRewardItem, out);
+							out << " rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+void PlayerbotAI::SetLooting(bool looting)
+{
+    isLooting = looting;
+}
+
+bool PlayerbotAI::needItem(uint32 guid)
+{
+	return m_needItemList[guid] > 0;
+}
+
+bool PlayerbotAI::hasLootFor(uint64 guid)
+{
+	Loot *loot;
+
+	// First populate the loot
+	if (IS_GAMEOBJECT_GUID(guid))
+	{
+		// Looting a GameObject
+		GameObject *go = m_bot->GetMap()->GetGameObject(guid);
+
+		loot = &go->loot;
+		uint32 lootid = go->GetGOInfo()->GetLootId();
+
+		// Hack
+		if ((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
+			if (Battleground *bg = m_bot->GetBattleground())
+				if (bg->GetTypeID(true) == BATTLEGROUND_AV)
+					if (!(((BattlegroundAV*)bg)->PlayerCanDoMineQuest(go->GetEntry(), m_bot->GetTeam())))
+						return false;
+		if (lootid)
+		{
+			// Fill the loot with items
+			loot->clear();
+
+			loot->FillLoot(lootid, LootTemplates_Gameobject, m_bot, true, false, go->GetLootMode());
+		}
+	}
+    else if (IS_ITEM_GUID(guid))
+    {
+        Item *item = m_bot->GetItemByGuid(guid);
+
+        if (!item)
+            return false;
+
+        loot = &item->loot;
+
+        if (!item->m_lootGenerated)
+        {
+            item->m_lootGenerated = true;
+            loot->clear();
+
+            //switch (loot_type)
+            //{
+            //    case LOOT_DISENCHANTING:
+            //        loot->FillLoot(item->GetProto()->DisenchantID, LootTemplates_Disenchant, this,true);
+            //        break;
+            //    case LOOT_PROSPECTING:
+            //        loot->FillLoot(item->GetEntry(), LootTemplates_Prospecting, this,true);
+            //        break;
+            //    case LOOT_MILLING:
+            //        loot->FillLoot(item->GetEntry(), LootTemplates_Milling, this,true);
+            //        break;
+            //    default:
+					loot->FillLoot(item->GetEntry(), LootTemplates_Item, m_bot, true);
+                    loot->generateMoneyLoot(item->GetProto()->MinMoneyLoot,item->GetProto()->MaxMoneyLoot);
+            //        break;
+            //}
+        }
+    }
+    else if (IS_CORPSE_GUID(guid))                          // remove insignia
+    {
+        Corpse *bones = ObjectAccessor::GetCorpse(*m_bot, guid);
+
+        if (!bones)
+            return false;
+
+        loot = &bones->loot;
+
+        if (!bones->lootForBody)
+        {
+            bones->lootForBody = true;
+            uint32 pLevel = bones->loot.gold;
+            bones->loot.clear();
+            if (Battleground *bg = m_bot->GetBattleground())
+                if (bg->GetTypeID(true) == BATTLEGROUND_AV)
+                    loot->FillLoot(1, LootTemplates_Creature, m_bot, true);
+            // It may need a better formula
+            // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
+            bones->loot.gold = uint32(urand(50, 150) * 0.016f * pow(float(pLevel)/5.76f, 2.5f) * sWorld->getRate(RATE_DROP_MONEY));
+        }
+    }
+    else
+    {
+        Creature *creature = m_bot->GetMap()->GetCreature(guid);
+
+        // must be in range and creature must be alive for pickpocket and must be dead for another loot
+        if (!creature || !creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
+            return false;
+
+        loot = &creature->loot;
+
+		// the player whose group may loot the corpse
+        Player *recipient = creature->GetLootRecipient();
+        if (!recipient)
+            return false;
+
+        if (!creature->lootForBody)
+        {
+            creature->lootForBody = true;
+
+            // for creature, loot is filled when creature is killed.
+        }
+	}
+
+	// Now that loot is filled, see if there are items for the bot
+	if (loot->hasItemForBot(m_bot))
+		return true;
+	if (m_bot->isAllowedToLoot(loot))
+		return true;
+	return false;
+}
+
+void PlayerbotAI::AddLootGUID(uint64 guid) {
+	if (hasLootFor(guid))
+		m_lootCreature.push_back(guid);
+}
+
+bool PlayerbotAI::DoLoot()
+{
+    if(!m_lootCurrent && m_lootCreature.empty())
+    {
+        sLog->outDebug("[PlayerbotAI]: %s reset loot list / go back to idle", m_bot->GetName());
+		//SetQuestNeedItems();
+        isLooting = false;
+        return false;
+    }
+
+    if(m_bot->isDead())
+    {
+        isLooting = false;
+        return false;
+    }
+
+    if(!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootCreature.front();
+
+        if(!m_lootCurrent)
+        {
+            //sLog->outError("PlayerbotAI::DoLoot() error location #1, please report this error immediately!");
+            return false;
+        }
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+		if(c && !c->isDead() && !c->IsDamageEnoughForLootingAndReward())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        sLog->outDebug("[PlayerbotAI]: %s got loot target 0x%08X", m_bot->GetName(), m_lootCurrent);
+        Position pos;
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE * 3)){ //Verify if the bot it close to a loot.
+
+            m_lootCreature.pop_front();
+            object->GetPosition(&pos);
+            m_bot->GetMotionMaster()->MovePoint(object->GetMapId(), (const Position &)(pos));
+
+        } else { //Rotate the loot to vary if one is not near the bot.
+
+            m_lootobjtemp = m_lootCreature.front();
+            m_lootCreature.pop_front();
+            m_lootCreature.push_back(m_lootobjtemp);
+            m_lootCurrent = 0;
+        }
+        return true;
+
+    } else {
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && !c->isDead() && !c->IsDamageEnoughForLootingAndReward())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE))
+        {
+			// Check to see if there's anything the bot is allowed to loot
+            Loot *loot;
+            if (c)
+                loot = &c->loot;
+            else
+                loot = &o->loot;
+            assert(loot);
+
+			//if (!loot->hasItemForBot(m_bot) || !m_bot->isAllowedToLoot(loot))
+			//{
+			//	TellMaster("Cant loot...");
+			//	m_lootCurrent = 0;
+			//	isLooting = false;
+			//	return false;
+			//}
+            //check for needed items
+            m_bot->SendLoot(m_lootCurrent, LOOT_CORPSE);
+
+            uint32 lootNum = loot->GetMaxSlotInLootFor(m_bot);
+			sLog->outDebug("[PlayerbotAI]: %s loot target 0x%08X got %d items", m_bot->GetName(), m_lootCurrent, loot->GetMaxSlotInLootFor(m_bot));
+
+            for(uint32 l = 0; l < lootNum; ++l)
+            {
+                QuestItem *qitem = 0, *ffaitem = 0, *conditem = 0;
+                LootItem *item = loot->LootItemInSlot(l, m_bot, &qitem, &ffaitem, &conditem);
+                if(!item)
+					continue;
+                if(!qitem && item->is_blocked)
+                {
+                    m_bot->SendLootRelease(m_bot->GetLootGUID());
+                    continue;
+                }
+
+                if(m_needItemList[item->itemid] > 0)
+                {
+					sLog->outDebug("[PlayerbotAI]: %s LOOT needed item 0x%04X", m_bot->GetName(), item->itemid);
+                    ItemPosCountVec dest;
+                    if(m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+                    {
+                        Item *newitem = m_bot->StoreNewItem(dest, item->itemid,true, item->randomPropertyId);
+                        if(qitem)
+                        {
+                            qitem->is_looted = true;
+                            if(item->freeforall ||loot->GetPlayerQuestItems().size() == 1)
+                                m_bot->SendNotifyLootItemRemoved(l);
+                            else
+                                loot->NotifyQuestItemRemoved(qitem->index);
+                        }
+                        else if(ffaitem)
+                        {
+                            ffaitem->is_looted = true;
+                            m_bot->SendNotifyLootItemRemoved(l);
+                        } else {
+                            if(conditem) conditem->is_looted = true;
+                            loot->NotifyItemRemoved(l);
+                        }
+                        if(!item->freeforall) item->is_looted = true;
+                        --(loot->unlootedCount);
+                        m_bot->SendNewItem(newitem, uint32(item->count), false,false, true);
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+
+                        std::ostringstream outt;
+                        PlayerbotChatHandler ch(m_master);
+                        outt << m_bot->GetName() << " needs " << --m_needItemList[item->itemid] << " more.";
+                        ch.sysmessage(outt.str().c_str());
+                        m_ignoreAIUpdatesUntilTime = time(0);
+                    }
+                }
+				else
+					m_bot->SendLootRelease(m_bot->GetLootGUID());
+            }
+            //release loot
+            if(uint64 lguid = m_bot->GetLootGUID() && m_bot->GetSession())
+                m_bot->GetSession()->DoLootRelease(lguid);
+            else if(!m_bot->GetSession())
+                sLog->outDebug("[PlayerbotAI]: %s has no session. Cannot releaseloot!", m_bot->GetName());
+
+            //clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            sLog->outDebug("[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent);
+            m_lootCurrent = 0;
+            m_ignoreAIUpdatesUntilTime = time(0);
+            isLooting = false;
+        } else { //keep moving till we get there
+            Position pos;
+
+            if (c) {
+                c->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(c->GetMapId(), (const Position &)(pos));
+            } else {
+                o->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(o->GetMapId(), (const Position &)(pos));
+            }
+
+        }
+    }
+    return false;
+} //end DoLoot
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    //reset values first
+    m_needItemList.clear();
+    m_lootCreature.clear();
+    m_lootCurrent = 0;
+
+    //run through accepted quests, get quest infoand data
+    for(QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+    {
+        const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+        if(!qInfo) continue;
+        QuestStatusData *qData = &iter->second;
+
+        //only check quest if it is incomplete
+        if(qData->m_status != QUEST_STATUS_INCOMPLETE) continue;
+
+        //check for items we not have enough of
+        for(uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if(!qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i]-qData->m_itemcount[i]) <= 0) continue;
+            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i]-qData->m_itemcount[i]);
+        }
+    }
+}//end SetQuestNeedItems
+
+//Localization support
+void PlayerbotAI::ItemLocalization(std::string &itemName, const uint32 itemID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if(pItemInfo)
+    {
+        if((int)pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if(Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::QuestLocalization(std::string &questTitle, const uint32 questID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if(pQuestInfo)
+    {
+        if((int)pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if(Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::TurnInQuests(WorldObject *pNpc)
+{
+    uint64 npcGUID = pNpc->GetGUID();
+    if (!m_bot->IsInMap(static_cast<WorldObject *>(pNpc)))
+        m_bot->GetPlayerbotAI()->TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(npcGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(npcGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.m_qId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (! m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, pNpc, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemPrototype const *pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: ";
+							MakeItemLink(pRewardItem, out);
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: ";
+							MakeItemLink(pRewardItem, out);
+                        }
+                    }
+
+                    // else multiple rewards - let master pick
+                    else {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i=0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemPrototype const * const pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[i]);
+                            m_bot->GetPlayerbotAI()->MakeItemLink(pRewardItem, out);
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE) {
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+	        //else if (status == QUEST_STATUS_AVAILABLE){
+	        //    out << "|cff00ff00Quest available:|r "
+	        //        << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+	        //}
+
+            if (! out.str().empty())
+                m_bot->GetPlayerbotAI()->TellMaster(out.str());
+        }
+    }
+} // TurnInQuests
+
+void PlayerbotAI::GetNewQuests(WorldObject *pNpc)
+{
+	ChatHandler ch(m_master->GetSession());
+    uint64 npcGUID = pNpc->GetGUID();
+    if (!m_bot->IsInMap(static_cast<WorldObject *>(pNpc)))
+		return;
+    else
+    {
+        m_bot->SetSelection(npcGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(npcGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+		std::ostringstream out;
+        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.m_qId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::string questTitle  = pQuest->GetTitle();
+            QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+			// If quest is a new one
+			if (status == QUEST_STATUS_NONE)
+			{
+                if (m_bot->CanAddQuest(pQuest, true))
+                {
+                    m_bot->AddQuest(pQuest, pNpc);
+                    if (m_bot->CanCompleteQuest(questID))
+                        m_bot->CompleteQuest(questID);
+                }
+				out << "|cff00ff00Accepted Quest:|r" << " |cff808080|Hquest:" << questID << ":" << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+			}
+			else if (status == QUEST_STATUS_AVAILABLE)
+			{
+				out << "|cff00ff00Quest Available:|r" << " |cff808080|Hquest:" << questID << ":" << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+			}
+		}
+        if (! out.str().empty())
+            m_bot->GetPlayerbotAI()->TellMaster(out.str());
+    }
+} // GetNewQuests
+
+void PlayerbotAI::SetCombatOrder (CombatOrderType orders)
+{
+	m_combatOrder = orders;
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotAI.h b/src/server/game/AI/BotAI/PlayerbotAI.h
new file mode 100644
index 0000000..15d4492
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotAI.h
@@ -0,0 +1,367 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+#include "Guild.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+struct GossipMenuItem;
+enum GuildMisc;
+
+enum ScenarioType
+{
+    SCENARIO_PVEEASY,
+    SCENARIO_PVEHARD,
+    SCENARIO_DUEL,
+    SCENARIO_PVPEASY,
+    SCENARIO_PVPHARD
+};
+
+//masters orders that should be obeyed by the AI during the updteAI routine
+//the master will auto set the target of the bot
+enum CombatOrderType
+{
+    ORDERS_NONE,
+    ORDERS_KILL,
+    ORDERS_CC,
+    ORDERS_HEAL,
+    ORDERS_TANK,
+    ORDERS_PROTECT,
+    ORDERS_REGEN
+};
+
+typedef std::set<Unit *> AttackerInfoList;
+
+// Guild Bank emulation, for easy access to Playerbots' items and money
+class PlayerbotGuildBank
+{
+public:
+	PlayerbotGuildBank(WorldSession *master = NULL);
+	void ResetMaster(WorldSession *session);
+	void Activate(WorldSession *session, uint64 guid);
+	void DeActivate() { m_active = false; }
+	bool IsActive() const { return m_active; }
+
+	// Guild bank emulation for ease of inventory management
+	void HandleGuildPermissions(WorldSession *session) const;
+	void HandleGuildBankerActivate(WorldSession *session) const;
+	void HandleGuildBankQueryTab(WorldSession *session, uint8 tabId);
+	void HandleGuildBankDepositMoney(WorldSession *session, uint32 money);
+	void HandleGuildBankWithdrawMoney(WorldSession *session, uint32 money);
+	void HandleGuildBankSwapItems(WorldSession *session, uint32 itemEntry, uint8 fromTabId, uint8 fromSlotId, uint8 toBagId, uint8 toSlotId, uint32 splittedAmount);
+	void HandleGuildBankSwapItems(WorldSession *session, uint8 tabId, uint8 slotId, uint8 destTabId, uint8 destSlotId, uint32 splittedAmount);
+	void HandleGuildBankBuyTab(WorldSession *session, uint8 tabId);
+	void HandleGuildBankUpdateTab(WorldSession *session, uint8 tabId, std::string &name, std::string &icon);
+	void HandleGuildBankLogQuery(WorldSession *session, uint8 tabId) const;
+	void HandleQueryGuildBankTabText(WorldSession *session, uint8 tabId) const;
+	void HandleSetGuildBankTabText(WorldSession *session, uint8 tabId, std::string &text);
+
+private:
+	// Utility functions
+	void WriteItem(WorldPacket &data, uint8 &slotId, Item *const pItem) const;
+	uint16 GetItemPosFromGuildBankItemEntry(Player *bot, uint32 itemEntry) const;
+	uint16 GetItemPosFromGuildBankSlotId(Player *bot, uint8 slotId) const;
+	GuildMisc GetWithdrawLimit(WorldSession *session, bool money = true) const;
+	uint8 GetRemainingSlots(Player *bot) const;
+	Player *GetPlayerbot(uint8 tabId) const;
+
+	WorldSession	*m_masterSession;
+	uint8			m_currTab;
+	bool			m_active;
+};
+
+// Class to encapsulate all the data members to be used in other classes
+// (WorldSession, Player, etc).  This way we don't have to rebuild the PCH and
+// a ton of other things every time we change data store by Playerbot
+class PlayerbotData
+{
+public:
+	PlayerbotData() : currTrainer(NULL), currTrainee(NULL) { }
+
+	Creature			*currTrainer;
+	Player				*currTrainee;
+	PlayerbotGuildBank	Bank;
+	PlayerbotMap		Bots;
+	PlayerbotLoginList	LoginCallbacks;
+};
+
+typedef bool (*FindItemFn)(const ItemPrototype *);
+
+class PlayerbotAI
+{
+public:
+    //******* Stuff the outside world calls ****************************
+    PlayerbotAI(Player *const master, Player *const bot);
+    virtual ~PlayerbotAI();
+
+    //This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    //This is called from ChatHandler.cpp when there is an incoming message to the bot
+    //from a whisper or from the party channel
+    void HandleCommand(const std::string &text, Player &fromPlayer);
+
+    //This is called by WorldSession.pm
+    //It provides a view of packets normally sent to the client.
+    //Since there is no client at the other end, the packets are dropped of course.
+    //For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket &packet);
+
+    //This is called whenever the master sends a packet to the server.
+    //These packets can be viewed, but not edited.
+    //It allows bot creators to craft AI in response to a master's actions.
+    //For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    //Notice: that this is static which means it is called once for all bots of the master.
+    static void HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession);
+    static void HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession);
+	static bool HandlePlayerIncomingPacket(const WorldPacket &packet, WorldSession *session);
+
+    //Returns what kind of situation we are in so the AI can react accordingly
+    ScenarioType GetScenarioType() { return m_ScenarioType; }
+
+    PlayerbotClassAI *GetClassAI() { return m_classAI; }
+
+	/*********************************************************************/
+	/*                    Helper / Utility Functions                     */
+	/*********************************************************************/
+	// Utility function to extract a Player object using data encoded in a menu item.  The
+	// bot's name is appended to the front (Bot: menu text), and the length of the bot's name
+	// is stored in uiSender (m_gSender).  Using this info we can get the Player pointer for the
+	// bot that added that gossip menu item to the gossip menu.
+	static Player * GetPlayerbot(const GossipMenuItem &menuItem);
+	static Player * GetPlayerbot(uint64 guid);
+
+    //finds spell ID for matching substring args
+    //in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char *args, bool master=false) const;
+    //Main PlayerBot spell finding function Returns ONLY exact matches including Upper/Lower case differentiation.
+    uint32 getSpellIdExact(const char *args, bool includePassive=false, bool master=false);
+
+    // finds quest ID for matching substring args
+    uint32 getQuestId(const char* args, bool remove) const;
+
+    // finds items in equipment and adds Item* to foundItemList
+    // also removes found item IDs from itemIdSearchList when found
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+	//finds items in bots inventory that it can sell
+	void findItemsInInvToSell(std::list<Item *> &foundItemList) const;
+
+	//Sells the given item to the vendor stored in m_currVendor
+	void SellItem(WorldSession *session, uint32 itemEntry, uint32 count);
+
+    //currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player &player) const;
+
+    //get current casting spell (will return NULL if no spell!)
+    Spell *GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit *player) const;
+    bool HasAura(const char *spellName, const Unit *player) const;
+    bool HasAura(const char *spellName) const;
+    void HandleTeleportAck();
+
+    bool HasPick();
+
+    uint8 GetHealthPercent(const Unit &target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit &target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit &target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit &target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit &target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit &target) const;
+    uint8 GetRunicPower() const;
+
+    Item *FindFood() const;
+    Item *FindDrink() const;
+    Item *FindPotion() const;
+    Item *FindBandage() const;
+    Item *FindPoisonForward() const;    // finds poison starting from the front
+    Item *FindPoisonBackward() const;   // finds poison starting from the back
+
+    void UseMount() const;
+
+    //******* Actions ****************************************
+    //Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string &text);
+    void SendWhisper(const std::string &text, Player &player);
+	void SendWhisper(const std::string &text, WorldSession *session);
+    bool CastSpell(const char *args);
+    //Player bots main spell cast function, if checkFirst > performs canCast() first, if castExistingAura > performs the cast even if the aura exists on target,
+    //if skipFriendlyCheck > do not perform spell positive/negative and target friendly/hostile checks (Useful for dual purpose spells like holy shock)
+    virtual bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    virtual bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    //Simple Checks to determine if the bot can cast the spell or not...
+    //Mana/Stance/EquipmentRequirement/Distance/TargetInFront/OverwriteOrStackExistingAura/FriendlyFire checks
+    virtual bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    virtual bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    //Gets the current form/stance of player
+    uint8 GetForm(Unit *pPlayer=NULL);
+    void UseItem(Item &item);
+    void PoisonWeapon(Item &item, uint32 spellid=0, uint32 target=0, EquipmentSlots weapon=EQUIPMENT_SLOT_MAINHAND);
+    void EquipItem(Item &item);
+    void Stay();
+    bool Follow(Player &player);
+    void SendNotEquipList(Player &player);
+    void Feast();
+    void SetLooting(bool looting);
+    void InterruptCurrentCastingSpell();
+    void GetCombatOrders();
+    void DoNextCombatManeuver();
+    void KilledMonster(uint32 entry, uint64 guid);
+    void ItemLocalization(std::string &itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string &questTitle, const uint32 questID) const;
+
+    uint32 GetAttackerCount(){ return m_attackerInfo.size(); }
+	void SetIgnoreUpdateTime(float t){m_ignoreAIUpdatesUntilTime=getMSTime() + (t * 1000); };
+
+    Player *GetPlayerBot() { return m_bot; }
+	Player *GetMaster() { return m_master; }
+    void SetInFront(const Unit *obj);
+
+    bool CanBotsFly();  // take the flight path?
+    uint32 GetStartMapID() { return m_startMapID; };
+    uint32 GetStartZoneID() { return m_startZoneID; };
+    uint32 GetStartAreaID() { return m_startAreaID; };
+    uint32 GetStartPhase() { return m_startPhase; };
+    uint32 GetStartDifficulty() { return m_startDifficulty; };
+    uint32 GetStartInstanceID() { return m_startInstanceID; };
+    float GetStartX() { return m_startX; };
+    float GetStartY() { return m_startY; };
+    float GetStartZ() { return m_startZ; };
+    float GetStartO() { return m_startO; };
+
+    void SetStartMapID(uint32 mapID) { m_startMapID = mapID; };
+    void SetStartZoneID(uint32 zoneID) { m_startZoneID = zoneID; };
+    void SetStartAreaID(uint32 areaID) { m_startAreaID = areaID; };
+    void SetStartPhase(uint32 phase) { m_startPhase = phase; };
+    void SetStartDifficulty(uint32 difficulty) { m_startDifficulty = difficulty; };
+    void SetStartInstanceID(uint32 instanceID) { m_startInstanceID = instanceID; };
+    void SetStartX(float x) { m_startX = x; };
+    void SetStartY(float y) { m_startY = y; };
+    void SetStartZ(float z) { m_startZ = z; };
+    void SetStartO(float o) { m_startO = o; };
+
+    void AddLootGUID(uint64 guid);
+	bool needItem(uint32 id);
+    void SetCombatOrder (CombatOrderType orders);
+
+	void SendTrainerList(WorldSession *session, bool sendError = true);
+	void SendVendorList(WorldSession *session, Unit *vendor);
+
+private:
+
+    //****** Closed Actions ********************************
+    //These actions may only be called at special times.
+    //Trade methods are only applicable when the trade window is open
+    //and are only called from within HandleCommand.
+    // submits packet to trade an item (trade window must already be open)
+
+    // default slot is -1 which means trade slots 0 to 5. if slot is set
+    // to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+    // 'Will not be traded' slot.
+    bool TradeItem(const Item& item, int8 slot=-1);
+    bool TradeCopper(uint32 copper);
+
+	void _doSellItem(Item* const item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold);
+
+	// Find an item that fits the function
+	Item * findItemCanUse(FindItemFn fn, bool forward = true) const;
+
+    //it is safe to keep these back reference pointers because m_bot
+    //owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player *const m_master;
+    Player *const m_bot;
+    PlayerbotClassAI *m_classAI;
+	Unit *m_currVendor;
+
+	void MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+	void MakeItemLink(const ItemPrototype *item, std::ostringstream &out);
+
+    //ignores AI updates until time specified
+    //no need to waste CPU cycles during casting etc
+    uint32 m_ignoreAIUpdatesUntilTime;
+
+    CombatOrderType m_combatOrder;
+
+    ScenarioType m_ScenarioType;
+    typedef std::set<Unit *> AttackerSet;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    time_t m_TimeRessurect;
+    uint32 m_CurrentlyCastingSpellId;
+    bool m_IsFollowingMaster;
+
+    //if master commands bot to do something, store here until updateAI
+    //can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+
+    //finds who to attack next
+	Unit *findNextTarget();
+	bool checkValidTarget(Unit *target);
+    Unit *getNextTarget(Unit *victim);
+
+    /* -- Loot routines by runsttren */
+    bool DoLoot();
+	bool hasLootFor(uint64 guid);
+    void SetQuestNeedItems();
+
+    void TurnInQuests( WorldObject *questgiver );
+	void GetNewQuests( WorldObject *questgiver );
+
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::list<uint64> BotLootCreature;
+    typedef std::map<uint32, std::string> BotQuestsSeen;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needItemList;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needEmblemList;
+
+    //list of quests recently seen that we can accept
+    BotQuestsSeen m_questsSeen;
+
+    //list of creatures we recently attacked and want to loot
+    BotLootCreature m_lootCreature; //list of creatures
+    uint64 m_lootCurrent; //current remains of interest
+    uint64 m_lootobjtemp;
+    bool isLooting;
+    AttackerInfoList m_attackerInfo;
+
+    float m_followDistanceMin, m_followDistanceMax;
+    int m_playerBotsFly;
+
+    uint32 m_startMapID;
+    uint32 m_startZoneID;
+    uint32 m_startAreaID;
+    uint32 m_startPhase;
+    uint32 m_startDifficulty;
+    uint32 m_startInstanceID;
+    float m_startX;
+    float m_startY;
+    float m_startZ;
+    float m_startO;
+
+    uint32 m_FeastSpamTimer;
+};
+
+//41911 2 3 4
+//UNIT_NPC_FLAGS
+//UNIT_NPC_FLAG_GUILD_BANKER
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotClassAI.cpp b/src/server/game/AI/BotAI/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..383202b
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotClassAI.cpp
@@ -0,0 +1,601 @@
+/*
+Name :    PlayerbotClassAI.cpp
+Notes:    Does not really work with peldor's own classbot AIs
+        Contains many improvements and hacks to overcome some difficulites
+Known
+Problems:    - Contains hardcoded values,  for an example check group heal, individual heal decision
+            - ai->getSpellIdExact func, *although works more accurately* is probably slower and hackish
+            - FindMainTankRaid func, includes a db query making it a resource hog
+            - canCast func, does not check for every possible problem, can cause AI stuck.. Should be inside PlayerbotAI class
+            - castSpell func is redundant and should be placed in PlayerbotAI class, sets private variable m_ai->m_CurrentlyCastingSpellId which is made public as a hack..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+#include "Spell.h"
+#include "Group.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai): m_master(master), m_bot(bot), m_ai(ai), rezSpamTimer(0)
+{
+    threatThreshold = 75;            // Threat % threshold for dps to lower tps
+    offensiveSpellThreshold = 70;    // Mana % threshold for healers to use offensive spells
+
+    // first aid
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // RACIALS
+    R_ARCANE_TORRENT = ai->getSpellIdExact("Arcane Torrent");
+    R_BERSERKING = ai->getSpellIdExact("Berserking");
+    R_BLOOD_FURY = ai->getSpellIdExact("Blood Fury");
+    R_CANNIBALIZE = ai->getSpellIdExact("Cannibalize");
+    R_ESCAPE_ARTIST = ai->getSpellIdExact("Escape Artist");
+    R_EVERY_MAN_FOR_HIMSELF = ai->getSpellIdExact("Every Man for Himself");
+    R_GIFT_OF_NAARU = ai->getSpellIdExact("Gift of the Naaru");
+    R_SHADOWMELD = ai->getSpellIdExact("Shadowmeld");
+    R_STONEFORM = ai->getSpellIdExact("Stoneform");
+    R_WAR_STOMP = ai->getSpellIdExact("War Stomp");
+    R_WILL_OF_FORSAKEN = ai->getSpellIdExact("Will of the Forsaken");
+
+    mainTank = NULL;
+    m_pulling = false;
+}
+PlayerbotClassAI::~PlayerbotClassAI(){}
+
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *){}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::LoadSpells(){}
+
+void PlayerbotClassAI::Pull(){}
+
+bool PlayerbotClassAI::BuffPlayer(Unit *target){ return false; }
+
+bool PlayerbotClassAI::FindMount(){ return true; }
+
+bool PlayerbotClassAI::Unmount(){ return true; }
+
+bool PlayerbotClassAI::HealTarget (Unit *target, uint8 hp){ return false; }
+
+bool PlayerbotClassAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal){ return false; }
+
+bool PlayerbotClassAI::CureTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::RezTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::IsMounted(){ return m_bot->IsMounted(); }
+
+bool PlayerbotClassAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(spellId, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered); }
+bool PlayerbotClassAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);}
+
+bool PlayerbotClassAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(spellId, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::listAuras(Unit *u)
+{
+    int loc = 0;
+    Unit *target = u;
+    typedef std::pair<uint32, uint8> spellEffectPair;
+    typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        sLog->outDebug("aura = %u %s", spellInfo->Id, name.c_str());
+    }
+    return true;
+};//end listAuras
+
+bool PlayerbotClassAI::HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    const SpellEntry *const pSpellInfo = GetSpellStore()->LookupEntry (spellId);
+    if(!pSpellInfo) return false;
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    const std::string name = pSpellInfo->SpellName[loc];
+    if(name.length() == 0) return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName(Unit *target, std::string spell, uint64 casterGuid)
+{
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    typedef std::pair<uint32, uint8>spellEffectPair;
+    typedef std::multimap<spellEffectPair, Aura*>AuraMap;
+
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        if(!spell.compare(name))
+        //if(!strcmp(name.c_str(),spell.c_str()))
+        {
+            if(casterGuid == 0) //don't care who casted it
+                return true;
+            else if(casterGuid == itr->second->GetCasterGUID()) //only if correct caster casted it
+                return true;
+        }
+    }
+    return false;
+};
+
+bool PlayerbotClassAI::castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (dispelSpell == 0 || !dTarget ) return false;
+    //if (!canCast(dispelSpell, dTarget, true)) return false; //Needless cpu cycles wasted, usually a playerbot can cast a dispell
+    const SpellEntry *dSpell = GetSpellStore()->LookupEntry(dispelSpell);
+    if (!dSpell) return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (dSpell->Effect[i] != (uint32)SPELL_EFFECT_DISPEL) continue;
+        uint32 dispel_type = dSpell->EffectMiscValue[i];
+        uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
+        Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura * aura = itr->second;
+            AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+            if (!aurApp)
+                continue;
+
+            if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+            {
+                if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                {
+                    bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                    // do not remove positive auras if friendly target
+                    //               negative auras if non-friendly target
+                    if(positive == dTarget->IsFriendlyTo(GetPlayerBot()))
+                        continue;
+                }
+                // If there is a successfull match return, else continue searching.
+                if (CastSpell(dSpell, dTarget, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck)) { return true; }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::castSelfCCBreakers (uint32 castList[])
+{
+    uint32 dispelSpell = 0;
+    Player *dTarget = GetPlayerBot();
+
+
+            /*dispelSpell = (uint32) R_ESCAPE_ARTIST; // this is script effect,
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                if ( ( aura->GetSpellProto()->Mechanic == MECHANIC_SNARE ) || ( aura->GetSpellProto()->Mechanic == MECHANIC_ROOT ) )
+                {
+                    if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                        // do not remove positive auras if friendly target
+                        //               negative auras if non-friendly target
+                        if(positive == dTarget->IsFriendlyTo(caster))
+                            continue;
+                    }
+                    return castSpell(dispelSpell, dTarget);
+                }
+            }
+            return false; */
+
+        // racial abilities
+    /* if( GetPlayerBot()->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT,0 ) && castSpell( ARCANE_TORRENT,pTarget ) ) {
+         //GetPlayerBot()->Say("Arcane Torrent!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_HUMAN && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( EVERY_MAN_FOR_HIMSELF, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("EVERY MAN FOR HIMSELF!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_UNDEAD_PLAYER && (GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( WILL_OF_THE_FORSAKEN, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("WILL OF THE FORSAKEN!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_DWARF && GetPlayerBot()->HasAuraState( AURA_STATE_DEADLY_POISON ) && castSpell( STONEFORM, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("STONEFORM!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_GNOME && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED )) && castSpell( ESCAPE_ARTIST, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("ESCAPE ARTIST!", LANG_UNIVERSAL);
+    } */
+
+    for (uint8 j = 0; j <  sizeof (castList); j++)
+    {
+        dispelSpell = castList[j];
+        if (dispelSpell == 0 || !dTarget->HasSpell(dispelSpell) || !CanCast(dispelSpell, dTarget, true)) continue;
+        SpellEntry const *dSpell = GetSpellStore()->LookupEntry(dispelSpell);
+        if (!dSpell) continue;
+
+        for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (dSpell->Effect[i] != (uint32)SPELL_EFFECT_DISPEL && dSpell->Effect[i] != (uint32)SPELL_EFFECT_APPLY_AURA) continue;
+            if (dSpell->Effect[i] == (uint32)SPELL_EFFECT_APPLY_AURA && (
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_MECHANIC_IMMUNITY) ||
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_DISPEL_IMMUNITY)
+                )) continue;
+
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp) continue;
+
+                if (aura->GetSpellProto() && (
+                    (dSpell->Effect[i] == (uint32)SPELL_EFFECT_DISPEL  && ((1<<aura->GetSpellProto()->Dispel) & GetDispellMask(DispelType(dSpell->EffectMiscValue[i]))) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_MECHANIC_IMMUNITY && ( GetAllSpellMechanicMask(aura->GetSpellProto()) & ( 1 << dSpell->EffectMiscValue[i]) ) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_DISPEL_IMMUNITY && ( (1<<aura->GetSpellProto()->Dispel) & GetDispellMask(DispelType(dSpell->EffectMiscValue[i])) ) )
+                    ) )
+                {
+                    if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+                        if(positive)continue;
+                    }
+                    return CastSpell(dispelSpell, dTarget, false);
+                }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::DoSupportRaid(Player *gPlayer, float radius, bool dResurrect, bool dGroupHeal, bool dHeal, bool dCure, bool dBuff)
+{
+    bool needHeal = false;
+    if (dGroupHeal || dHeal)
+    {
+        uint8 cntNeedHeal = 0;
+        uint8 raidHPPercent = GetHealthPercentRaid(gPlayer, cntNeedHeal);
+        if (dGroupHeal && raidHPPercent <=90 && cntNeedHeal > 1)
+        {
+            if (HealGroup(gPlayer, raidHPPercent, cntNeedHeal)) return true;
+        }
+        if (raidHPPercent < 60 ) needHeal = true;
+    }
+    //std::list<Unit*> unitList;
+    //gPlayer->GetRaidMember(unitList,30);
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->getSource();
+        if(!tPlayer || gPlayer->IsHostileTo(tPlayer)) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        if(!m_bot->IsWithinDistInMap(tPlayer, radius)) { continue; }
+        if(tPlayer->isDead()) // May be we can rez
+        {
+            if(!dResurrect) continue;
+            if(needHeal) continue; //First heal others needing heal
+            if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+            if(tPlayer->IsNonMeleeSpellCasted(true)) continue; //Already rez
+            if(RezTarget(tPlayer)) { return true; }
+            else continue;
+        }
+		Creature* pet = tPlayer->GetPet();
+		if (dHeal)
+        {
+            uint8 tarHPPercent = tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+            if (tarHPPercent < 100 && HealTarget(tPlayer, tarHPPercent)) return true;
+			if (pet && !needHeal)
+			{
+				// Heal pets, but after others that need healing
+				tarHPPercent = pet->GetHealth()*100 / pet->GetMaxHealth();
+				if (tarHPPercent < 100 && HealTarget(pet, tarHPPercent)) return true;
+			}
+        }
+        if (needHeal && dHeal) continue; //First heal others needing heal
+        if (dCure && CureTarget(tPlayer)) return true;
+		if (dCure && pet && CureTarget(pet)) return true;
+        if (dBuff && BuffPlayer(tPlayer)) return true;
+		if (dBuff && pet && BuffPlayer(pet)) return true;
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::TakePosition(Unit *followTarget, BotRole bRole, float bDist, float bMinDist, float bMaxDist, float bAngle, Unit *faceTarget)
+{
+    bool doFollow = true;
+    bool omitAngle = false;
+    bool angleIsAutoSet = false;
+    if (!bAngle) angleIsAutoSet = true;
+    if (bAngle < 0) bAngle += 2 * M_PI;
+    //if (bAngle > 2 * M_PI) bAngle -= 2 * M_PI; //Do not send values higher than 2 PI, lower than -2 PI
+    bool rval = false;
+    if (followTarget == NULL) { followTarget = GetMaster(); if (followTarget == NULL) { return false; } }
+    if (faceTarget == NULL) { faceTarget = followTarget; }
+    if (bRole == BOT_ROLE_NONE) { bRole = ( (m_role == BOT_ROLE_NONE) ? BOT_ROLE_DPS_MELEE : m_role);  }
+    //Default values
+    Unit *pVictim = followTarget->getVictim();
+    if (pVictim && pVictim->GetGUID() == m_bot->GetGUID()) //if target is attacking me
+    {
+        if (bRole == BOT_ROLE_TANK || bRole == BOT_ROLE_OFFTANK || bRole == BOT_ROLE_DPS_MELEE)
+        {
+            //Move to target
+            if (!bDist || bDist > 0.7f) bDist = 0.7f;
+            if (bMinDist < 0 || bMinDist > 1) bMinDist = 0;
+            if (bMaxDist <= 0 || bMaxDist > MELEE_RANGE) bMaxDist = MELEE_RANGE;
+            bAngle = 0;
+        }
+        else {doFollow = false;} //Do not move, creature will come
+    }
+    else
+    {
+        // calculating distance to follow
+        switch (bRole)
+        {
+            case BOT_ROLE_TANK:
+            case BOT_ROLE_OFFTANK:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0; bMaxDist = MELEE_RANGE; bAngle = 0;}
+                break;
+            case BOT_ROLE_HEALER:
+            case BOT_ROLE_SUPPORT:
+                if (!bDist) { bDist = urand(12, 14); bMinDist = 10; bMaxDist = 18; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            case BOT_ROLE_DPS_RANGED:
+                if (!bDist) { bDist = urand(18, 24); bMinDist = 10;  bMaxDist = 26; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            default:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0.1f; bMaxDist = MELEE_RANGE; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+        }
+    }
+    //Do not try to go behind if ranged and creature is not boss like
+    if (bDist > MELEE_RANGE && followTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        const CreatureInfo *cInfo = ((Creature*) followTarget)->GetCreatureInfo();
+        if (!cInfo || cInfo->rank != 3) { omitAngle = true; }
+    }
+
+    //Move
+    if (doFollow)
+    {
+        float curDist = m_bot->GetDistance(followTarget);
+        if (m_pulling ||
+            (!m_bot->isMoving() &&
+            ((curDist > bMaxDist || curDist < bMinDist)  //Outside range boundries
+            || (!omitAngle && ((!followTarget->HasInArc(M_PI,m_bot)) ^ (bAngle > 0.5f * M_PI && bAngle < 1.5f * M_PI)))) )//is at right position front/behind?
+            )
+        {
+            //m_bot->GetMotionMaster()->Clear();
+            //sLog->outError("Bot[%u] is moving, curDist[%f], bDist[%f], bminDist[%f], bMaxDist[%f], bAngle[%f], InFront[%u]", m_bot->GetGUIDLow(), curDist, bDist,bMinDist, bMaxDist, bAngle, followTarget->HasInArc(M_PI,m_bot));
+            if (angleIsAutoSet && omitAngle) { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist); }
+            else { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist, bAngle); }
+            rval |= true;
+        }
+    }
+    //Face your faceTarget
+    if (!m_bot->HasInArc(M_PI/16, faceTarget) && !m_bot->isMoving() ) { m_bot->SetFacingToObject(faceTarget); rval |= true; }
+    return rval;
+}
+
+uint8 PlayerbotClassAI::GetThreatPercent(Unit *pTarget, Unit *pFrom)
+{
+    uint8 tPercent = 0;
+    Unit *pVictim = pTarget->getVictim();
+    if (!pVictim) return 100; //Not Attacking anyone yet, somehow..
+    if (!pFrom) { pFrom = m_bot; }
+    if (pVictim->GetGUID() == pFrom->GetGUID()) return 100; //I'm already being attacked, too late for alert, kill it..
+    //if (m_tank->GetGUID() == m_bot->GetGUID()) {} //If I am not tank and there is a target
+
+    ThreatManager &pthreatManager = pTarget->getThreatManager();
+    float maxThreat = pthreatManager.getThreat(pTarget->getVictim()) ;
+    if (maxThreat <= 0) { return 100; } //0 threat
+    float curThreat = pthreatManager.getThreat(pFrom);
+    return (curThreat * 100 / maxThreat);
+}
+//Gets if the unit is under attack by # of attackers
+bool PlayerbotClassAI::isUnderAttack(Unit *pAttacked,const uint8 &minNumberOfAttackers)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return false; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() >= minNumberOfAttackers) { return true; }
+    return false;
+}
+
+//Gets the first found attacker of Unit
+Unit *PlayerbotClassAI::GetAttackerOf(Unit *pAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return NULL; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+    return (*fAttackerSet.begin());
+}
+//Gets the first found attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+Unit *PlayerbotClassAI::GetNearestAttackerOf(Unit *pAttacked, bool nearestToAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) return NULL;}
+
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+
+    Unit *nearestTo = m_bot;
+    if (nearestToAttacked) { nearestTo = pAttacked; }
+
+    Unit *curAtt = NULL;
+    float minDist = 30;
+
+
+    for (Unit::AttackerSet::const_iterator itr = fAttackerSet.begin(); itr != fAttackerSet.end(); ++itr)
+    {
+        Unit *tAtt = (*itr);
+        if (!tAtt) break; // Something is wrong.. How can a non existing mob attack?
+        if (tAtt->isDead()) break;
+        if (m_bot->GetDistance(tAtt) >= minDist) continue; //Get the nearest one
+        curAtt = tAtt;
+        minDist = tAtt->GetDistance(nearestTo);
+    }
+    return curAtt;
+
+}
+
+uint8 PlayerbotClassAI::GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing)
+{
+    uint8 validMemberCount=0;
+    uint16 totalHPPercent=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if(!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = sObjectMgr->GetPlayer((*itr)->GetGUID());
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isDead()) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+        uint8 fndHPPercent =  tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+        totalHPPercent+=fndHPPercent;
+        validMemberCount++;
+        if (fndHPPercent < 100) countNeedHealing++;
+
+        //const std::string myname = GetPlayerBot()->GetName();
+        //const std::string hisname = tPlayer->GetName();
+        //sLog->outDebug("me = %s, checked= %s %u [%u / %u]", myname.c_str(), hisname.c_str(), fndHPPercent, tPlayer->GetHealth(), tPlayer->GetMaxHealth());
+
+      }
+    }
+    if (validMemberCount == 0) return 100;
+    return totalHPPercent / validMemberCount;
+}
+
+Unit *PlayerbotClassAI::DoSelectLowestHpFriendly(float range, uint32 MinHPDiff)
+{
+    Unit *pUnit = NULL;
+    Trinity::MostHPMissingInRange u_check(GetPlayerBot(), range, MinHPDiff);
+    Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange> searcher(GetPlayerBot(), pUnit, u_check);
+
+    GetPlayerBot()->VisitNearbyObject(range, searcher);
+
+    return pUnit;
+}
+
+void PlayerbotClassAI::SetMainTank(Unit *tank)
+{
+    mainTank = tank;
+}
+
+// is Resource heavy, do not spam or use heavily in loop
+Unit *PlayerbotClassAI::FindMainTankInRaid(Player *gPlayer)
+{
+    // check if original main tank is still alive. No point regetting main
+    // tank b/c chances are slim that it will not get reset in the middle of a fight.
+    // But if main tank dies, try to find next best canidate
+    if (mainTank!=NULL && mainTank->isAlive()) {
+        return mainTank;
+    }
+
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, pGroup->GetGUID());
+        if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = sObjectMgr->GetPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                mainTank = pPlayer;
+                return pPlayer;
+            }
+        }
+    }
+
+
+    // if could not find tank try assuming
+    // Assume the one with highest health is the main tank
+    uint32 maxhpfound=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if (!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = sObjectMgr->GetPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isDead()) continue;
+        if (GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if (GetPlayerBot()->GetDistance(tPlayer) > 50) continue;
+        if (tPlayer->GetMaxHealth() > maxhpfound) { maxhpfound = tPlayer->GetMaxHealth(); pPlayer=tPlayer; }
+        // Also check pets
+        if ( (tPlayer->getClass() == (uint8) CLASS_HUNTER || tPlayer->getClass() == (uint8) CLASS_WARLOCK) && IS_PET_GUID(tPlayer->GetPetGUID()) )
+        {
+            Pet* tpet = ObjectAccessor::GetPet(*tPlayer, tPlayer->GetPetGUID());
+            if (!tpet || !tpet->IsInWorld() || !tpet->isDead()) continue;
+            if (tpet->GetArmor() > tPlayer->GetArmor()) //Probably a tanking capable pet..
+            {
+                if (tpet->GetMaxHealth() > maxhpfound) { maxhpfound = tpet->GetMaxHealth(); pPlayer=tpet; }
+                else if (tPlayer->GetGUID() == pPlayer->GetGUID()) {pPlayer = tpet;} //set pet as tank instead of owner
+            }
+        }
+      }
+    }
+
+    mainTank = pPlayer;
+    return pPlayer;
+}
+
+Unit *PlayerbotClassAI::FindMainAssistInRaid(Player *gPlayer)
+{
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINASSIST, pGroup->GetGUID());
+          if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = sObjectMgr->GetPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                return pPlayer;
+            }
+        }
+    }
+
+    // default to main tank
+    return FindMainTankInRaid(gPlayer);
+}
+
+Player * PlayerbotClassAI::FindMage(Player *gPlayer)
+{
+    Group::MemberSlotList const &groupSlot = gPlayer->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *tPlayer = sObjectMgr->GetPlayer(itr->guid);
+
+        if(tPlayer == NULL) continue;
+        if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+
+        if (tPlayer->getClass() == CLASS_MAGE) return tPlayer;
+    }
+    return NULL;
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotClassAI.h b/src/server/game/AI/BotAI/PlayerbotClassAI.h
new file mode 100644
index 0000000..a0a0588
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotClassAI.h
@@ -0,0 +1,158 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "SpellAuras.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+
+
+class Player;
+class PlayerbotAI;
+class Aura;
+
+        enum BotRole
+        {
+            BOT_ROLE_NONE,
+            BOT_ROLE_TANK,
+            BOT_ROLE_OFFTANK,
+            BOT_ROLE_DPS_RANGED,
+            BOT_ROLE_DPS_MELEE,
+            BOT_ROLE_SUPPORT,
+            BOT_ROLE_HEALER
+        };
+
+class PlayerbotClassAI
+{
+public:
+    PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+    virtual ~PlayerbotClassAI();
+
+    //all combat actions go here
+    virtual void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    virtual void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    virtual bool BuffPlayer(Unit *target);
+
+    //Heals the target based off its HP
+    virtual bool HealTarget (Unit *target, uint8 hp);
+
+    //Heals the group based off its HP
+    virtual bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+    //Cure the target
+    virtual bool CureTarget (Unit *target);
+
+    //Resurrect the target (OBSOLETE - Check individual ClassAIs instead)
+    virtual bool RezTarget(Unit *target);
+
+    //find any specific mount spells, ie druids = cat, shaman = ghost wolf etc (OBSOLETE)
+    virtual bool FindMount();
+
+    virtual bool Unmount();
+
+    virtual bool IsMounted();
+
+    virtual void LoadSpells();
+
+    virtual void Pull();
+	void StopPulling() { m_pulling = false; }
+
+    //Utilities
+    Player *GetMaster (){ return m_master; }
+    Player *GetPlayerBot(){ return m_bot; }
+    PlayerbotAI *GetAI (){ return m_ai; }
+
+    bool isPulling() { return m_pulling; }
+    bool TakePosition(Unit *followTarget, BotRole bRole=BOT_ROLE_NONE, float bDist=0, float bMinDist=0, float bMaxDist=0, float bAngle=0, Unit *faceTarget=NULL);
+    //Gets the threat done by bot / threat max (percent) to the target.
+    uint8 GetThreatPercent(Unit *pTarget, Unit *pFrom = NULL);
+    //Gets if the unit is under attack by # of attackers
+    bool isUnderAttack(Unit *pAttacked=NULL,const uint8 &minNumberOfAttackers=1);
+    //Gets the first found attacker of Unit
+    Unit *GetAttackerOf(Unit *pAttacked=NULL);
+    //Gets the nearest attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+    Unit *GetNearestAttackerOf(Unit *pAttacked=NULL, bool nearestToAttacked=false);
+    //Calculates Average Raid Health condition as Percentage, ref value is the Count of units need healing..
+    uint8 GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing);
+
+    // Called when the main tank is set from raid ui
+    void SetMainTank (Unit *tank);
+
+    //Finds the possible MainTank in Raid including Hunter/Warlock pets.. Makes the assumption based on - max maxHealth..
+    Unit *FindMainTankInRaid(Player *gPlayer);
+
+    //Finds the possible MainAssist in Raid.  Defaults to Main Tank if it cannot find one.
+    Unit *FindMainAssistInRaid(Player *gPlayer);
+
+    Player *FindMage(Player *gPlayer);
+    //Finds the lowest hp creature around that is friendly with the caster.
+    Unit *DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+
+
+protected:
+    bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+
+    //Debug method to list the auras currently active.
+    //Use to find what spells were casted
+    bool listAuras(Unit *unit);
+
+    //More generalized method than HasAura().  It looks for
+    //any rank of the spell and it doesn't care which
+    //spell effect you want.  If it has the spell aura than
+    //it returns true
+    bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+    bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+
+    //The following functions return true only a match is found and the bot successfully casted a spell to resolve the problem
+    //If the result is false, either a match is not found, or the ClassAI could not cast or refused to cast a spell for some reason..
+
+    //Combination of all Healer roles, scans the party and decides if group healing > individual healing > Rez > curing > buffing is needed
+    //and directs any matches found to individual ClassAIs
+    //Main Raid scan function for Healer/Support types..
+    bool DoSupportRaid(Player *gPlayer, float radius=30, bool dResurrect=true, bool dGroupHeal=true, bool dHeal=true, bool dCure=true, bool dBuff=true);
+    //Find matching debuffs on target to provided Spell, and call castSpell() with provided parameters
+    bool castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    //Cast matching debuffs on self with probided SpellId list.. Mainly Used for Racial spells.. List is used to prevent extra loops for each spell..
+    bool castSelfCCBreakers (uint32 castList[]);
+
+    typedef std::set<Unit *> AttackerSet;
+
+    uint8 rezSpamTimer;
+    uint32 foodDrinkSpamTimer;
+    static const uint32 foodDrinkSpamCount = 100;
+
+    BotRole m_role;
+    bool m_pulling;
+    uint32 threatThreshold, offensiveSpellThreshold;
+
+    // RACIAL SPELLS
+    uint32 R_ARCANE_TORRENT, R_BERSERKING, R_BLOOD_FURY, R_CANNIBALIZE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_GIFT_OF_NAARU, R_SHADOWMELD, R_STONEFORM, R_WAR_STOMP, R_WILL_OF_FORSAKEN;
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+    uint32 SHOOT;
+
+private:
+    Player *m_master;
+    Player *m_bot;
+    PlayerbotAI *m_ai;
+    Unit *mainTank;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..8e8de08
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,325 @@
+/*
+Name : PlayerbotDeathknightAI.cpp
+Complete: maybe around 65%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Death grip casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn
+Version : 0.40
+*/
+
+#include "PlayerbotDeathKnightAI.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+void PlayerbotDeathKnightAI::LoadSpells(){
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // Unholy
+    PLAGUE_STRIKE = ai->getSpellIdExact("Plague Strike");
+    DEATH_STRIKE = ai->getSpellIdExact("Death Strike");
+    SCOURGE_STRIKE  = ai->getSpellIdExact("Scourge Strike");
+
+    // Frost
+    ICY_TOUCH = ai->getSpellIdExact("Icy Touch");
+    OBLITERATE = ai->getSpellIdExact("Obliterate");
+
+    // Blood
+    BLOOD_STRIKE = ai->getSpellIdExact("Blood Strike");
+    HEART_STRIKE  = ai->getSpellIdExact("Heart Strike");
+    RUNE_TAP = ai->getSpellIdExact("Rune Tap");
+    DARK_COMMAND = ai->getSpellIdExact("Dark Command");
+
+    // AOE
+    HOWLING_BLAST = ai->getSpellIdExact("Howling Blast");
+    BLOOD_BOIL = ai->getSpellIdExact("Blood Boil");
+    PESTILENCE = ai->getSpellIdExact("Pestilence");
+    CORPSE_EXPLOSION = ai->getSpellIdExact("Corpse Explosion");
+    DEATH_AND_DECAY = ai->getSpellIdExact("Death and Decay");
+
+    // Rune attacks
+    FROST_STRIKE = ai->getSpellIdExact("Frost Strike");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+    RUNE_STRIKE = ai->getSpellIdExact("Rune Strike");
+
+    // CC Interrupt
+    DEATH_GRIP = ai->getSpellIdExact("Death Grip");
+    CHAINS_OF_ICE = ai->getSpellIdExact("Chains of Ice");
+    MIND_FREEZE = ai->getSpellIdExact("Mind Freeze");
+    HUNGERING_COLD = ai->getSpellIdExact("Hungering Cold");
+    STRANGULATE = ai->getSpellIdExact("Strangulate");
+
+    // Debuffs
+    FROST_FEVER = 55095; //ai->getSpellIdExact("Frost Fever",true);
+    BLOOD_PLAGUE = 55078; //ai->getSpellIdExact("Blood Plague",true);
+    CRYPT_FEVER = ai->getSpellIdExact("Crypt Fever",true);
+    EBON_PLAGUE = ai->getSpellIdExact("Ebon Plague",true);
+    MARK_OF_BLOOD = ai->getSpellIdExact("Mark of Blood");
+
+    // Buffs
+    HORN_OF_WINTER = ai->getSpellIdExact("Horn of Winter");
+    BONE_SHIELD = ai->getSpellIdExact("Bone Shield");
+    VAMPIRIC_BLOOD = ai->getSpellIdExact("Vampiric Blood");
+    HYSTERIA = ai->getSpellIdExact("Hysteria");
+    UNBREAKABLE_ARMOR = ai->getSpellIdExact("Unbreakable Armor");
+    ANTI_MAGIC_SHELL = ai->getSpellIdExact("Anti Magic Shell");
+    ANTI_MAGIC_ZONE = ai->getSpellIdExact("Anti Magic Zone");
+    ICEBOUND_FORTITUDE = ai->getSpellIdExact("Icebound Fortitude");
+    EMPOWER_WEAPON = ai->getSpellIdExact("Empower Rune Weapon");
+    LICHBORNE = ai->getSpellIdExact("Lichborne");
+
+    // Summons
+    RAISE_DEAD = ai->getSpellIdExact("Raise Dead");
+    ARMY_OF_THE_DEAD = ai->getSpellIdExact("Army of the Dead");
+    SUMMON_GARGOYLE = ai->getSpellIdExact("Summon Gargoyle");
+    GHOUL_FRENZY = ai->getSpellIdExact("Ghoul Frenzy");
+    DEATH_PACT = ai->getSpellIdExact("Death Pact");
+    DANCING_WEAPON = ai->getSpellIdExact("Dancing Rune Weapon");
+
+    // Presences
+    BLOOD_PRESENCE = ai->getSpellIdExact("Blood Presence");
+    FROST_PRESENCE = ai->getSpellIdExact("Frost Presence");
+    UNHOLY_PRESENCE  = ai->getSpellIdExact("Unholy Presence");
+
+    // Talent
+    TALENT_BLOOD = HEART_STRIKE;
+    TALENT_FROST = FROST_STRIKE;
+    TALENT_UNHOLY = SCOURGE_STRIKE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BLOOD) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    if (TALENT_UNHOLY) talentCounter++;
+    if (talentCounter > 1) { TALENT_BLOOD = 0; TALENT_FROST = 0; TALENT_UNHOLY = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    std::ostringstream out;
+
+
+    if (!m_pulling)
+    {
+        m_role = BOT_ROLE_DPS_MELEE;
+        #pragma region Choose Role/Presence
+
+        // Choose Presence
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_TANK; return; }
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_OFFTANK; return; }
+        }
+        else if (TALENT_UNHOLY)
+        {
+            if (CastSpell(UNHOLY_PRESENCE,m_bot)) return;
+        }
+        else if (CastSpell(BLOOD_PRESENCE,m_bot)) return;
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[6] = { LICHBORNE, ICEBOUND_FORTITUDE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+
+   if (m_pulling) {
+        if (GetAI()->CastSpell(DEATH_GRIP,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+
+            if (m_bot->GetPet()) pet->SetReactState (REACT_DEFENSIVE);
+         }
+          return;
+    }
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() < 80 && ai->GetHealthPercent() > 20 && CastSpell(VAMPIRIC_BLOOD,m_bot)) { }  //NO GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(RUNE_TAP,m_bot)) { } //NO GCD
+    if (CanCast(DEATH_STRIKE,pTarget,true) && ai->GetHealthPercent() < 90 &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) ||pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(DEATH_STRIKE,pTarget,false) ) {return;}
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (pet && ai->GetHealthPercent() < 50 && CastSpell(DEATH_PACT,m_bot)) { return; }
+    if (pet && ai->GetHealthPercent() < 60 && CastSpell(MARK_OF_BLOOD,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 65 && CastSpell(ICEBOUND_FORTITUDE,m_bot)) { } //No GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(UNBREAKABLE_ARMOR,m_bot)) { return; }
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (CastSpell(MIND_FREEZE,pTarget)) {} // No GCD
+        if (CastSpell(STRANGULATE,pTarget)) { return; }
+        if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        if (CastSpell(ANTI_MAGIC_ZONE,m_bot)) { return; }
+        if (CastSpell(ANTI_MAGIC_SHELL,m_bot)) {} //NO GCD
+    }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(DEATH_GRIP,pTarget)) return;
+        if (CastSpell(CHAINS_OF_ICE,pTarget)) return;
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt && CastSpell(DARK_COMMAND, curAtt))  { }     //No gcd
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DARK_COMMAND, pTarget) )  { } // No gcd
+    }
+
+    // If not in Frost Presence slow down due to threat
+    if (pThreat > threatThreshold && !m_bot->HasAura(FROST_PRESENCE) && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //DK has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+    //Dps up
+    if (CastSpell(EMPOWER_WEAPON,m_bot)) {} //NO GCD
+    if (ai->GetHealthPercent() > 90 && CastSpell(HYSTERIA,m_bot)) {} //NO GCD
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // Use up excess Runic Power
+    if (ai->GetRunicPower() > 60 && CastSpell(FROST_STRIKE,pTarget)) { return; }
+    else if (ai->GetRunicPower() > 60 && CastSpell(DEATH_COIL,pTarget,true,true,true)) { return; }
+    if ((isUnderAttack() || ai->GetRunicPower() > 70) && CastSpell(RUNE_STRIKE,pTarget)) {} //Next attack spell
+
+    // Build Diseases
+    if (!pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && CastSpell(ICY_TOUCH,pTarget)) { return; }
+    if (!pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) && CastSpell(PLAGUE_STRIKE,pTarget)) { return; }
+
+    // Use AOEs summons
+    if (isUnderAttack(m_tank,4) && CastSpell(DEATH_AND_DECAY,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(HOWLING_BLAST,pTarget)) { return; }
+    if (CanCast(PESTILENCE,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(PESTILENCE,pTarget,false)) { return; }
+    if (CanCast(BLOOD_BOIL,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) || pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(BLOOD_BOIL,pTarget,false)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if (isUnderAttack(m_tank,6) && CastSpell(ARMY_OF_THE_DEAD,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(SUMMON_GARGOYLE,pTarget)) { return; } //This should be somewhat different
+
+    // Use standard damage spells
+    if (CastSpell(HEART_STRIKE,pTarget,true,true)) { return; }
+    if (CastSpell(BLOOD_STRIKE,pTarget)) { return; }
+    if (TALENT_FROST && CastSpell(OBLITERATE,pTarget)) { return; }
+    else if (TALENT_UNHOLY && CastSpell(SCOURGE_STRIKE,pTarget)) { return; }
+    else if (CastSpell(DEATH_STRIKE,pTarget)) { return; }
+    #pragma endregion
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(RUNE_TAP,m_bot)) { return; } //no gcd but lets give the others a time to heal
+    if (ai->GetHealthPercent() < 30) { ai->Feast(); }
+    //Item* fItem = ai->FindBandage();
+    /*if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    } */
+} // end DoNonCombatActions
+
+void PlayerbotDeathKnightAI::Pull()
+{
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if (GetPlayerBot()->GetPet()) GetPlayerBot()->GetPet()->SetReactState (REACT_PASSIVE);
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.h b/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..732dd92
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotDeathKnightAI.h
@@ -0,0 +1,60 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotDeathKnightAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotDeathKnightAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDeathKnightAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        void Pull();
+
+    private:
+        // Unholy
+        uint32 PLAGUE_STRIKE, DEATH_STRIKE, SCOURGE_STRIKE;
+
+        // Frost
+        uint32 ICY_TOUCH, OBLITERATE;
+
+        // Blood
+        uint32 BLOOD_STRIKE, HEART_STRIKE, RUNE_TAP, DARK_COMMAND;
+
+        // AOE
+        uint32 HOWLING_BLAST, BLOOD_BOIL, PESTILENCE, CORPSE_EXPLOSION, DEATH_AND_DECAY;
+
+        // Rune attacks
+        uint32 FROST_STRIKE, DEATH_COIL, RUNE_STRIKE;
+
+        // CC Interrupt
+        uint32 DEATH_GRIP, CHAINS_OF_ICE, MIND_FREEZE, HUNGERING_COLD, STRANGULATE;
+
+        // Debuffs
+        uint32 FROST_FEVER, BLOOD_PLAGUE, CRYPT_FEVER, EBON_PLAGUE, MARK_OF_BLOOD;
+
+        // Buffs
+        uint32 HORN_OF_WINTER, BONE_SHIELD, VAMPIRIC_BLOOD, HYSTERIA, UNBREAKABLE_ARMOR, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, ICEBOUND_FORTITUDE, EMPOWER_WEAPON, LICHBORNE;
+
+        // Summons
+        uint32 RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, GHOUL_FRENZY, DEATH_PACT, DANCING_WEAPON;
+
+        // Presences
+        uint32 BLOOD_PRESENCE, FROST_PRESENCE, UNHOLY_PRESENCE;
+
+        // Talent
+        uint32 TALENT_BLOOD, TALENT_FROST, TALENT_UNHOLY;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotDruidAI.cpp b/src/server/game/AI/BotAI/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..e756376
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotDruidAI.cpp
@@ -0,0 +1,674 @@
+/*
+Name : PlayerbotDruidAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is a combination of Feral/balance type..
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Tree of life form transition is late and may never occur, due to healing bots attacking priority at full mana.
+                - Boomkin's support roles are not fully covered.. For example -> off healing
+                - Situations needing Abolish Disease casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn, Natsukawa
+Version : 0.40
+*/
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI(){}
+
+void PlayerbotDruidAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+#pragma region SpellId Fill
+    // Balance Spells
+    MOONFIRE = ai->getSpellIdExact("Moonfire"); //attacks
+    WRATH = ai->getSpellIdExact("Wrath");
+    STARFIRE = ai->getSpellIdExact("Starfire");
+    STARFALL = ai->getSpellIdExact("Starfall");
+    FORCE_OF_NATURE = ai->getSpellIdExact("Force of Nature");
+    TYPHOON = ai->getSpellIdExact("Typhoon");
+    HURRICANE = ai->getSpellIdExact("Hurricane");
+    INSECT_SWARM = ai->getSpellIdExact("Insect Swarm");
+
+    CYCLONE = ai->getSpellIdExact("Cyclone");
+    ROOTS = ai->getSpellIdExact("Entangling Roots");
+    NATURES_GRASP = ai->getSpellIdExact("Nature's Grasp");
+
+    HIBERNATE = ai->getSpellIdExact("Hibernate");
+    FAERIE_FIRE = ai->getSpellIdExact("Faerie Fire");
+
+
+    // Bear Form Spells
+    MAUL = ai->getSpellIdExact("Maul");
+    BASH = ai->getSpellIdExact("Bash");
+    LACERATE = ai->getSpellIdExact("Lacerate");
+    MANGLE_BEAR = ai->getSpellIdExact("Mangle (Bear)");
+    SWIPE_BEAR = ai->getSpellIdExact("Swipe (Bear)");
+
+    DEMORALIZING_ROAR = ai->getSpellIdExact("Demoralizing Roar");
+    GROWL = ai->getSpellIdExact("Growl");
+    CHALLENGING_ROAR = ai->getSpellIdExact("Challenging Roar");
+
+    ENRAGE = ai->getSpellIdExact("Enrage");
+    FERAL_CHARGE_BEAR = ai->getSpellIdExact("Feral Charge - Bear");
+    FRENZIED_REGENERATION = ai->getSpellIdExact("Frenzied Regeneration");
+
+
+    //Cat Attack type's
+    RAKE = ai->getSpellIdExact("Rake"); //40 energy
+    CLAW = ai->getSpellIdExact("Claw"); //45
+    MANGLE_CAT = ai->getSpellIdExact("Mangle (Cat)"); //45
+    SHRED = ai->getSpellIdExact("Shred");
+
+    RIP = ai->getSpellIdExact("Rip"); //30
+    FEROCIOUS_BITE = ai->getSpellIdExact("Ferocious Bite"); //35
+    SAVAGE_ROAR = ai->getSpellIdExact("Savage Roar");
+    MAIM = ai->getSpellIdExact("Maim"); //35
+
+    FERAL_CHARGE_CAT = ai->getSpellIdExact("Feral Charge - Cat");
+    COWER = ai->getSpellIdExact("Cower"); //20
+    TIGERS_FURY = ai->getSpellIdExact("Tiger's Fury");
+
+    // Feral General
+    BERSERK = ai->getSpellIdExact("Berserk");
+    FAERIE_FIRE_FERAL = ai->getSpellIdExact("Faerie Fire (Feral)"); //debuffs
+
+    //buffs
+    MARK_OF_THE_WILD = ai->getSpellIdExact("Mark of the Wild"); //buffs
+    GIFT_OF_THE_WILD = ai->getSpellIdExact("Gift of the Wild");
+    THORNS = ai->getSpellIdExact("Thorns");
+    SURVIVAL_INSTINCTS = ai->getSpellIdExact("Survival Instincts");
+
+    // Restoration Spells
+    LIFEBLOOM = ai->getSpellIdExact("Lifebloom");
+    REJUVENATION = ai->getSpellIdExact("Rejuvenation"); //heals
+    REGROWTH = ai->getSpellIdExact("Regrowth");
+    NOURISH = ai->getSpellIdExact("Nourish");
+    SWIFTMEND = ai->getSpellIdExact("Swiftmend");
+    HEALING_TOUCH = ai->getSpellIdExact("Healing Touch");
+    INNERVATE = ai->getSpellIdExact("Innervate");
+    WILD_GROWTH = ai->getSpellIdExact("Wild Growth");
+    TRANQUILITY = ai->getSpellIdExact("Tranquility");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    CURE_POISON = ai->getSpellIdExact("Abolish Poison");
+    if (!CURE_POISON) CURE_POISON = ai->getSpellIdExact("Cure Poison");
+
+    REBIRTH    = ai->getSpellIdExact("Rebirth");
+    REVIVE = ai->getSpellIdExact("Revive");
+
+    BARKSKIN = ai->getSpellIdExact("Barkskin");
+
+    //Druid Forms
+    BEAR_FORM = ai->getSpellIdExact("Dire Bear Form");
+    if (!BEAR_FORM) BEAR_FORM = ai->getSpellIdExact("Bear Form");
+    CAT_FORM = ai->getSpellIdExact("Cat Form");
+    MOONKIN_FORM = ai->getSpellIdExact("Moonkin Form");
+    TREE_OF_LIFE_FORM = ai->getSpellIdExact("Tree of Life"); //33891;//learning spell has higher id..
+    AQUATIC_FORM = ai->getSpellIdExact("Aquatic Form");
+    TRAVEL_FORM = ai->getSpellIdExact("Travel Form");
+    FLIGHT_FORM = ai->getSpellIdExact("Swift Flight Form");
+    if (!FLIGHT_FORM) FLIGHT_FORM = ai->getSpellIdExact("Flight Form");
+
+
+    TALENT_BALANCE    = MOONKIN_FORM;
+    TALENT_RESTO    = SWIFTMEND;
+    TALENT_FERAL    = MANGLE_CAT;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BALANCE) talentCounter++;
+    if (TALENT_FERAL) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    if (talentCounter > 1) { TALENT_BALANCE = 0; TALENT_RESTO = 0; TALENT_FERAL = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    #pragma region Select behaviour
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_FERAL && BEAR_FORM) { m_role = BOT_ROLE_TANK; } //Just Keep Tanking dont even change forms for healing
+        else
+        {
+            if (TALENT_BALANCE) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <30 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 25 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+            else //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 15 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+        }
+    }
+    else if (isUnderAttack() && !( ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_TREE)  ) // if i am under attack
+    {
+        // Keep being in Cat Form if you can reduce threat
+        if (ai->GetForm() == FORM_CAT && CastSpell(COWER,pTarget)) {return; }
+        else if (TALENT_RESTO && ai->GetManaPercent() > 10 ) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_FERAL && CAT_FORM) { // If has any feral forms at all
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 30 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else{ m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_BALANCE) {
+        if ((ai->GetHealthPercent() <= 50 || masterHP <40 ) && (ai->GetManaPercent() >= 10)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else if (TALENT_RESTO)    { m_role = BOT_ROLE_SUPPORT; }
+    else
+    {
+        // Unknown build or low level : Do not change forms rapidly..
+        if ( (ai->GetManaPercent() < 30 && BEAR_FORM) || ( (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) && ai->GetManaPercent() < 70 )  ) m_role = BOT_ROLE_DPS_MELEE;
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+
+    if (!isUnderAttack() && m_tank->GetGUID() != m_bot->GetGUID())
+    {
+        // Select Attacking target
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {} //if my target is attacking me continue
+        else
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+    // Return to normal form from non combat forms
+    if (ai->GetForm() == FORM_NONE || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_TREE || ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR )  { } //Those are valid incombat auras
+    else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //return to caster form
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            //ai->TellMaster("DruidCombat");
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                //We have little mana probably cant change form
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; }
+                else if(m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) {  return;}
+                else if(DoSupportRaid(GetMaster(),false,false,false)) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+            }
+
+            if (CAT_FORM) { if (ChangeForm(CAT_FORM)) { return; } }
+            else if (BEAR_FORM) { if (ChangeForm(BEAR_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) {  } //Normal Form
+
+            TakePosition(pTarget);
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_OFFTANK:
+        case BOT_ROLE_TANK: // It is a tank druid or a defending druid
+
+            // Do what you must before getting attacked...
+            if (ai->GetForm() == FORM_NONE)
+            {
+                // Non tank stuff to avoid
+                if (m_tank->GetGUID() != m_bot->GetGUID())
+                {
+                    if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+                    if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+                    if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+                    //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+                }
+                // Things to do wheter Tank or not
+                if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; } //We have little mana probably cant change form
+            }
+            TakePosition(pTarget);
+
+            if (ChangeForm(BEAR_FORM)) { return; }
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_ROAR, curAtt)) { return; }
+                    if (CastSpell(GROWL, curAtt))  { return; }
+                }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(GROWL, pTarget) )  { return; }
+            }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot)) { return; }
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                if(DoSupportRaid(GetMaster())) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            }
+
+            if (MOONKIN_FORM) { if (ChangeForm(MOONKIN_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //Normal Form
+
+            TakePosition(pTarget);
+
+            // BUFF UP
+            if(DoSupportRaid(GetMaster(),false,false,false)) return;
+            else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE,m_bot)) { return; }
+            //Get to tree form only if you will no longer cast attack spells
+            if( TREE_OF_LIFE_FORM && (ai->GetManaPercent() < offensiveSpellThreshold || isUnderAttack()) )
+            {
+                 if (ChangeForm(TREE_OF_LIFE_FORM)) { return; }
+            }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { }  //Normal Form no gcd
+
+            TakePosition(pTarget);
+
+            //RezGroup(REBIRTH, GetMaster());
+            if (DoSupportRaid(GetMaster())) { return; }
+            if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(30, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+
+    #pragma region DruidCommon
+    // Common Dps and protection routine
+    if (ai->GetHealthPercent() <= 70 && CastSpell(BARKSKIN,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(NATURES_GRASP,m_bot)) { return; }
+
+    if (ai->GetForm() == FORM_CAT)
+    {
+        // If at threat limit, use Cower to reduce threat
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+        {
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+            {
+                m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                return;
+            }
+            else
+            {
+                if (CastSpell(COWER,pTarget)) { return; } //Lets see if we can manage
+                else { return; } //use no spells and wait threat to be reduced
+            }
+        }
+        if (CastSpell(FERAL_CHARGE_CAT,pTarget)) { return; }
+        if (m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(MAIM, pTarget)) { return; }
+
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if (isUnderAttack() && CastSpell(NATURES_GRASP, m_bot)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (CastSpell(RAKE, pTarget)) { return; }
+            if (CastSpell(MANGLE_CAT, pTarget)) { return; }
+            if (!pTarget->HasInArc(M_PI,m_bot) && CastSpell(SHRED, pTarget)) { return; }
+            if (ai->GetEnergyAmount() > 65 && CastSpell(MANGLE_CAT, pTarget)) { return; } //Spam mangle if cannot cast shred
+            if (ai->GetEnergyAmount() > 65 && CastSpell(CLAW, pTarget) ) { return; } //Spam Claw if there is no mangle
+            // if (CanCast(COWER, pTarget) && CastSpell(COWER, pTarget)) { return; } //if still nothing, use COWER to reduce threat
+        }
+        else
+        {
+            if (CastSpell(SAVAGE_ROAR)) { return; }
+            if (CastSpell(RIP, pTarget)) { return; }
+            if (ai->GetEnergyAmount() >= 65 && CastSpell(FEROCIOUS_BITE, pTarget)) { return; } //maxhit for feracious bite
+        }
+        if (CastSpell(TIGERS_FURY, m_bot)) { return; } //if nothing is ready yet, use tigers fury
+    }
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        if (CastSpell(FERAL_CHARGE_BEAR,pTarget)) { return; }
+        if (CastSpell(BASH, pTarget,true,true)) { return; } //Need check for immunity
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (CastSpell(DEMORALIZING_ROAR, pTarget)) { return; }
+        if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 50 && CastSpell(ENRAGE, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if ( ( ai->GetHealthPercent() <= 30 || (ai->GetHealthPercent() < 85 && m_tank->GetGUID() != m_bot->GetGUID())  )
+            && CastSpell(FRENZIED_REGENERATION)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+        if (CastSpell(MANGLE_BEAR, pTarget)) { return; }
+        if ((ai->GetRageAmount() > 70 || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(SWIPE_BEAR, pTarget)) { return; }
+        if (ai->GetRageAmount() > 50 && CastSpell(MAUL, pTarget)) {} // Low Priority, Next Attack effect
+        if (ai->GetRageAmount() > 60 && CastSpell(LACERATE, pTarget)) { return; } //Currently applies only 1
+    }
+    else
+    {
+        //Defensive stuff
+        if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+        {
+            if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+            if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+            if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+        }
+
+        if (CastSpell(FAERIE_FIRE, pTarget)) { return; }
+
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        // Continue attacking if theres excess mana (for healers)
+        if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+        if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //only balance no gcd
+
+        if (m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(STARFIRE, pTarget)) { return; }
+        if (CastSpell(INSECT_SWARM, pTarget)) { return; }
+        if (CastSpell(TYPHOON, pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HURRICANE, pTarget)) { ai->SetIgnoreUpdateTime(8); return; }
+        if (isUnderAttack(m_tank,5) && CastSpell(FORCE_OF_NATURE, m_bot)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(STARFALL, pTarget)) { return; }
+        if (CastSpell(MOONFIRE, pTarget)) { return; }
+        if (CastSpell(WRATH, pTarget)) { return; }
+        if (CastSpell(STARFIRE, pTarget)) { return; }
+    }
+
+    // If there is nothing else to do buff UP
+    if (m_role == BOT_ROLE_DPS_MELEE) //Those already healed and buffed or should never buff in combat
+    {
+        if (DoSupportRaid(GetMaster(),false,false,false)) { return; }
+        if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+    }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+} //end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(GetMaster())) { return; }
+    if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (INNERVATE, m_bot)) { return; } //Need mana fast
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() &&
+        (ai->GetForm() != FORM_CAT && ai->GetForm() != FORM_MOONKIN && ai->GetForm() != FORM_DIREBEAR && ai->GetForm() != FORM_BEAR)
+        && CastSpell(REGROWTH,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    if(!target || target->isDead()) { return false; }
+
+    if (CanCast(THORNS,target,0,0,1) && !HasAuraName(target, THORNS)) {
+        // Decide if it is worth to change form
+        if( /*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+            else { return false; }
+        }
+        return CastSpell(THORNS, target, false);
+    }
+    if (CanCast(MARK_OF_THE_WILD,target,0,0,1) && !HasAuraName(target, GIFT_OF_THE_WILD) && !HasAuraName(target, MARK_OF_THE_WILD)) {
+        // Decide if it is worth to change form
+        if(/*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+            else return false;
+        }
+        return CastSpell(MARK_OF_THE_WILD, target, false);
+    }
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target, uint8 hp)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp < 75 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    // if(m_bot->HasAura(TRAVEL_FORM)) ChangeForm(1);
+
+    if(hp < 60 && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEALING_TOUCH, target)) { return true; }
+    if(hp < 90 && CastSpell(LIFEBLOOM, target)) { return true; }
+    if(hp < 80 && CastSpell(REJUVENATION, target)) { return true; }
+    if(hp < 60 && CastSpell(REGROWTH, target)) { return true; }
+    if(hp < 70 && CanCast(NOURISH,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,LIFEBLOOM,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(NOURISH, target, false); }
+    if(hp < 50 && CanCast(SWIFTMEND,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(SWIFTMEND, target, false); }
+    if(hp < 40 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) { } // NO gcd
+    if(hp < 40 && CastSpell(HEALING_TOUCH, target)) { return true; }
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    if (countNeedHeal < 2) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp > 70) { return false; }
+        if (!CanCast(TRANQUILITY,target,0,0,1) && !WILD_GROWTH) { return false; }
+        if (!WILD_GROWTH && hp > 35) { return false; }
+        if (hp < 65 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    if (hp < 36 && m_bot->isInCombat() && CanCast(TRANQUILITY,target))
+    {
+            bool sc = CastSpell(TRANQUILITY, target, false);
+            if (sc) GetAI()->SetIgnoreUpdateTime(10);
+            return sc;
+    }
+    if (hp < 75 && CastSpell(WILD_GROWTH,target)) { return true; }
+    return false;
+}
+
+bool PlayerbotDruidAI::CureTarget(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+    // Decide if it is worth to change form (they cange forms even if theres nothing to cure..)
+    if (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        //if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+        //else { return false; }
+        return false;
+    }
+    if (castDispel(CURE_POISON, target)) { return true; }
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+
+    if (m_bot->isInCombat())
+    {
+        if (!CanCast(REBIRTH,target)) return false;
+        Unit *m_tank = FindMainTankInRaid(m_bot);
+        if (!m_tank) m_tank = m_bot;
+        if (target->GetGUID() != m_tank->GetGUID() &&
+            (target->getClass() != (uint8) CLASS_PRIEST || target->getClass() != (uint8) CLASS_DRUID || target->getClass() != (uint8) CLASS_PALADIN) ) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REBIRTH, target);
+    }
+    else
+    {
+        if (!CanCast(REVIVE,target)) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REVIVE, target);
+    }
+    return false;
+}
+
+/*bool PlayerbotDruidAI::FindMount() {
+    if (TRAVEL_FORM) {
+        if (GetPlayerBot())    CastSpell(TRAVEL_FORM, GetPlayerBot());
+        return true;
+    } else return false;
+}
+
+bool PlayerbotDruidAI::Unmount() {
+    GetPlayerBot()->RemoveAurasDueToSpell(TRAVEL_FORM);
+    return true;
+}
+
+bool PlayerbotDruidAI::IsMounted() {
+    return GetPlayerBot()->IsMounted() || HasAuraName(GetPlayerBot(), TRAVEL_FORM);
+} */
+
+bool PlayerbotDruidAI::ChangeForm(uint32 form)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!form) return false;
+
+    if (form == 1 && ai->GetForm() == FORM_NONE) return false;
+
+    if (form != 1)
+    {
+        if (!CanCast(form,m_bot,0,0,1)) return false;
+        if (m_bot->HasAura(form)) { return false; }
+    }
+
+    if (ai->GetForm() == FORM_TREE) m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_FORM);
+    else if (ai->GetForm() == FORM_CAT) m_bot->RemoveAurasDueToSpell(CAT_FORM);
+    else if (ai->GetForm() == FORM_MOONKIN) m_bot->RemoveAurasDueToSpell(MOONKIN_FORM);
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) m_bot->RemoveAurasDueToSpell(BEAR_FORM);
+    else if (ai->GetForm() == FORM_TRAVEL) m_bot->RemoveAurasDueToSpell(TRAVEL_FORM);
+    else if (ai->GetForm() == FORM_FLIGHT || ai->GetForm() == FORM_FLIGHT_EPIC)    m_bot->RemoveAurasDueToSpell(FLIGHT_FORM);
+    else if (ai->GetForm() == FORM_AQUA) m_bot->RemoveAurasDueToSpell(AQUATIC_FORM);
+
+    if (form == 1) { return true; }
+
+    return CastSpell(form,m_bot,false);
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotDruidAI.h b/src/server/game/AI/BotAI/PlayerbotDruidAI.h
new file mode 100644
index 0000000..91d79ee
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotDruidAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotDruidAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDruidAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget(Unit *target);
+
+        // find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        /* virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+        //Change Form
+        bool ChangeForm(uint32 form);
+
+    private:
+
+        // BALANCE Attacks
+        uint32 MOONFIRE, WRATH, STARFALL, STARFIRE, TYPHOON, HURRICANE, FORCE_OF_NATURE, INSECT_SWARM, CYCLONE, ROOTS, NATURES_GRASP, HIBERNATE, FAERIE_FIRE;
+
+        // RESTORATION Spells
+        uint32 LIFEBLOOM, REJUVENATION, REGROWTH, NOURISH, SWIFTMEND, HEALING_TOUCH, NATURES_SWIFTNESS, INNERVATE, WILD_GROWTH, TRANQUILITY, REBIRTH, REVIVE, CURE_POISON, BARKSKIN;
+
+        // BEAR SPELLS
+        uint32 MAUL, BASH, LACERATE, MANGLE_BEAR, SWIPE_BEAR, DEMORALIZING_ROAR, GROWL, CHALLENGING_ROAR , ENRAGE, FERAL_CHARGE_BEAR, FRENZIED_REGENERATION;
+
+        // CAT SPELLS
+        uint32 CLAW, RAKE, SHRED, MANGLE_CAT, RIP, FEROCIOUS_BITE, SAVAGE_ROAR, MAIM, FERAL_CHARGE_CAT, COWER, TIGERS_FURY;
+
+        // FERAL General
+        uint32 BERSERK, FAERIE_FIRE_FERAL;
+
+        // BUFFS
+        uint32 MARK_OF_THE_WILD, GIFT_OF_THE_WILD, THORNS, SURVIVAL_INSTINCTS;
+
+        // FORMS
+        uint32 CAT_FORM, BEAR_FORM, MOONKIN_FORM, TREE_OF_LIFE_FORM, TRAVEL_FORM, FLIGHT_FORM, AQUATIC_FORM;
+
+        // Key TALENT SPELLS
+        uint32 TALENT_BALANCE, TALENT_RESTO, TALENT_FERAL;
+
+};
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotHunterAI.cpp b/src/server/game/AI/BotAI/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..1dedfe9
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotHunterAI.cpp
@@ -0,0 +1,561 @@
+/*
+Name : PlayerbotHunterAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - AI always assumes pet is the tank if there are no higher hp people in group than the hunter..
+                - Possible threat build / reduce race between pet and hunter if attacking to same target.. Needs checking
+                - Possible target changing loop between pet and hunter if attacking to same target and getting aggro repeatedly.. Needs checking
+                - Disarm and Nature resist aspect, Disengage, Scorpid sting are not used right now..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotHunterAI.h"
+
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    m_petSummonFailed = false;
+    LoadSpells();
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+void PlayerbotHunterAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // PET CONTROL
+    PET_SUMMON = ai->getSpellIdExact("Call Pet");
+    PET_DISMISS = ai->getSpellIdExact("Dismiss Pet");
+    PET_REVIVE = ai->getSpellIdExact("Revive Pet");
+    PET_MEND = ai->getSpellIdExact("Mend Pet");
+    PET_FEED = 1539; //ai->getSpellIdExact("Feed Pet");
+    KILL_COMMAND = ai->getSpellIdExact("Kill Command");
+    INTIMIDATION = ai->getSpellIdExact("Intimidation");
+    BESTIAL_WRATH = ai->getSpellIdExact("Bestial Wrath");
+
+    // PET SPELL (master does not have these spells anymore)
+    GROWL = ai->getSpellIdExact("Growl");
+    COWER = ai->getSpellIdExact("Cower");
+    BAD_ATTITUDE = ai->getSpellIdExact("Bad Attitude");
+    SONIC_BLAST = ai->getSpellIdExact("Sonic Blast");
+    NETHER_SHOCK = ai->getSpellIdExact("Nether Shock");
+    DEMORALIZING_SCREECH = ai->getSpellIdExact("Demoralizing Screech");
+
+    // RANGED ATTACK
+    AUTO_SHOT = ai->getSpellIdExact("Auto Shot");
+    ARCANE_SHOT = ai->getSpellIdExact("Arcane Shot");
+    EXPLOSIVE_SHOT = ai->getSpellIdExact("Explosive Shot");
+    STEADY_SHOT = ai->getSpellIdExact("Steady Shot");
+    AIMED_SHOT = ai->getSpellIdExact("Aimed Shot");
+    SCATTER_SHOT = ai->getSpellIdExact("Scatter Shot");
+    KILL_SHOT = ai->getSpellIdExact("Kill Shot");
+    CHIMERA_SHOT = ai->getSpellIdExact("Chimera Shot");
+    CONCUSSIVE_SHOT = ai->getSpellIdExact("Concussive Shot");
+    DISTRACTING_SHOT = ai->getSpellIdExact("Distracting Shot");
+    SILENCING_SHOT = ai->getSpellIdExact("Silencing Shot");
+
+    // STINGS
+    SERPENT_STING = ai->getSpellIdExact("Serpent Sting");
+    SCORPID_STING = ai->getSpellIdExact("Scorpid Sting");
+    WYVERN_STING = ai->getSpellIdExact("Wyvern Sting");
+    VIPER_STING = ai->getSpellIdExact("Viper Sting");
+
+    // DEBUFF
+    HUNTERS_MARK = ai->getSpellIdExact("Hunter's Mark");
+    SCARE_BEAST = ai->getSpellIdExact("Scare Beast");
+
+    //AOE
+    VOLLEY = ai->getSpellIdExact("Volley");
+    MULTI_SHOT = ai->getSpellIdExact("Multi Shot");
+
+    //MELEE
+    RAPTOR_STRIKE = ai->getSpellIdExact("Raptor Strike");
+    WING_CLIP = ai->getSpellIdExact("Wing Clip");
+    MONGOOSE_BITE = ai->getSpellIdExact("Mongoose Bite");
+    COUNTERATTACK = ai->getSpellIdExact("Counterattack");
+
+    //TRAP
+    FREEZING_TRAP = ai->getSpellIdExact("Freezing Trap");
+    IMMOLATION_TRAP = ai->getSpellIdExact("Immolation Trap");
+    FROST_TRAP = ai->getSpellIdExact("Frost Trap");
+    EXPLOSIVE_TRAP = ai->getSpellIdExact("Explosive Trap");
+    SNAKE_TRAP = ai->getSpellIdExact("Snake Trap");
+    ARCANE_TRAP = ai->getSpellIdExact("Arcane Trap");
+    FREEZING_ARROW = ai->getSpellIdExact("Freezing Arrow");
+    BLACK_ARROW = ai->getSpellIdExact("Black Arrow");
+
+    //BUFF
+    TRUESHOT_AURA = ai->getSpellIdExact("Trueshot Aura");
+    DETERRENCE = ai->getSpellIdExact("Deterrence");
+    FEIGN_DEATH = ai->getSpellIdExact("Feign Death");
+    DISENGAGE = ai->getSpellIdExact("Disengage");
+    RAPID_FIRE = ai->getSpellIdExact("Rapid Fire");
+    READINESS = ai->getSpellIdExact("Readiness");
+    MISDIRECTION = ai->getSpellIdExact("Misdirection");
+
+    //ASPECT
+    ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Dragonhawk");
+    ASPECT_OF_THE_MONKEY = ASPECT_OF_THE_HAWK;
+    if (!ASPECT_OF_THE_HAWK) ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Hawk");
+    if (!ASPECT_OF_THE_MONKEY) ASPECT_OF_THE_MONKEY = ai->getSpellIdExact("Aspect of the Monkey");
+    ASPECT_OF_THE_VIPER = ai->getSpellIdExact("Aspect of the Viper");
+
+    TALENT_MM = TRUESHOT_AURA;
+    TALENT_BM = BESTIAL_WRATH;
+    TALENT_SURVIVAL = WYVERN_STING;
+
+    uint8 talentCounter = 0;
+    if (TALENT_MM) talentCounter++;
+    if (TALENT_BM) talentCounter++;
+    if (TALENT_SURVIVAL) talentCounter++;
+    if (talentCounter > 1) { TALENT_MM = 0; TALENT_BM = 0; TALENT_SURVIVAL = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')",bot->GetGUIDLow(),PET_SAVE_AS_CURRENT,PET_SAVE_NOT_IN_SLOT);
+
+    if(result)
+        return true; //hunter has current pet
+    else
+        return false; //hunter either has no pet or stabled
+}// end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+ //   switch (ai->GetScenarioType())
+//    {
+//        case PlayerbotAI::SCENARIO_DUEL:
+ //           ai->CastSpell(RAPTOR_STRIKE);
+ //           return;
+//    }
+
+    // ------- Non Duel combat ----------
+
+
+    #pragma region Choose Target
+    // Choose Target
+    if (isUnderAttack()) // I am under attack
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+        else //Have to select nearest target
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+
+        //Heal pet
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( PET_MEND>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(PET_MEND,m_bot) )) { return; }
+
+        // Set pet to attack hunter's attacker > its own attackers > hunter's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help hunter if she's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and hunter has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= hunter) takes aggro back)
+            //Hunter should help her pet whether main tank or not, unless she's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,true);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,false);
+            if (CastSpell(INTIMIDATION,m_bot)) { return; }
+        }
+        else
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,false);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,true); //Autocast cower
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            if (CastSpell(KILL_COMMAND,m_bot)) { }
+            else if (CastSpell(BESTIAL_WRATH,m_bot)) { }
+        }
+        // NETHERSHOCK DEMORALIZINGSCREECH
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    #pragma region Evasive manuevers
+    // Do evasive manuevers if under attack
+    if (isUnderAttack())
+    {
+        if (m_tank->GetGUID() == m_bot->GetGUID()) { } // i am tank and my pet is probably dead, so i have to face the attackers
+        else if (CastSpell(FEIGN_DEATH,m_bot)) { return; } //avoid attack
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+        else if (CastSpell(CONCUSSIVE_SHOT,pTarget)) { return; }
+        else if (CastSpell(WYVERN_STING,pTarget)) { return; }
+        else if (CastSpell(SCATTER_SHOT,pTarget)) { return; }
+        else if (CastSpell(FREEZING_ARROW,pTarget)) { return; }
+        else if (CastSpell(MISDIRECTION,m_tank)) { return; }
+        else if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget) ) { return; } //no gcd but is cast
+        else if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && CastSpell(SCARE_BEAST,pTarget)) { return; }
+        else if (pDist <= 2 && CastSpell(FREEZING_TRAP,pTarget)) { return; }
+    }
+    #pragma endregion
+
+    //Select combat mode
+    m_role = BOT_ROLE_DPS_RANGED;
+    if ((isUnderAttack()  && pDist <= ATTACK_DISTANCE) || !m_bot->GetUInt32Value(PLAYER_AMMO_ID) ) { m_role = BOT_ROLE_DPS_MELEE; }
+
+    TakePosition(pTarget);
+
+    #pragma region Buff / Protect
+    //Buff UP
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot) ) {  } //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot) ) { } //no GCD
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+    if (CastSpell(RAPID_FIRE,m_bot)) { return; }
+    if (CastSpell(HUNTERS_MARK,pTarget)) { return; }
+    if ((ai->GetHealthPercent() < 80 || ai->GetManaPercent() < 60 ) && CastSpell(READINESS,m_bot)) { } //no gcd
+
+
+    //Protect yourself if needed
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot) ) { } //no gcd
+    if (ai->GetHealthPercent() < 20 && CastSpell(DETERRENCE,m_bot)) {} //No GCD
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return;  }
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ( pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 20 ) && CastSpell(R_ARCANE_TORRENT, pTarget) ) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCING_SHOT, pTarget) ) { return; }
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(WING_CLIP,pTarget)) return;
+        if (CastSpell(CONCUSSIVE_SHOT,pTarget)) return;
+        if (CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+    }
+    #pragma endregion
+
+    //Do combat
+    switch (m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            if (AUTO_SHOT) { m_bot->InterruptNonMeleeSpells( true, AUTO_SHOT ); } //Stop autoshot
+            if (CastSpell(ASPECT_OF_THE_MONKEY,m_bot)) { return; } //Get Monkey aspect
+
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+            // Threat control
+            if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+            else
+            {
+                if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                {
+                    m_bot->SetSelection(pet->getVictim()->GetGUID());
+                    return;
+                }
+                else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                {
+                    m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                    return;
+                }
+                else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                else { return; } // No more threat reducing spells, just slow down
+            }
+
+            if (CastSpell(RAPTOR_STRIKE,pTarget,true,true)) {} //No gcd
+            if (CastSpell(MONGOOSE_BITE,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            else if (CastSpell(COUNTERATTACK,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            if (CastSpell(WING_CLIP,pTarget)) { return; }
+            if (isUnderAttack(m_tank,6) && CastSpell(SNAKE_TRAP,m_bot)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(EXPLOSIVE_TRAP,m_bot)) { return; }
+            if (CastSpell(IMMOLATION_TRAP,m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if (m_pulling) {
+                if (GetAI()->CastSpell(CONCUSSIVE_SHOT,pTarget) ||
+                    GetAI()->CastSpell(AUTO_SHOT,pTarget)) {
+                    m_pulling = false;
+                    GetAI()->SetCombatOrder(ORDERS_NONE);
+                    GetAI()->Follow(*GetMaster());
+                    GetAI()->SetIgnoreUpdateTime(2);
+
+                    if(HasPet(GetPlayerBot()))
+                        m_bot->GetPet()->SetReactState(REACT_DEFENSIVE);
+                }
+                return;
+            }
+            if (AUTO_SHOT && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT)) { ai->CastSpell(AUTO_SHOT,pTarget); } //Start autoshot
+            if (!(ai->GetManaPercent() < 85 && m_bot->HasAura(ASPECT_OF_THE_VIPER)) && CastSpell(ASPECT_OF_THE_HAWK,m_bot)) { return; } //Get Hawk aspect
+            if ((ai->GetManaPercent() < 25) && CastSpell(ASPECT_OF_THE_VIPER,m_bot,true,false,true)) { return; } //Build up mana
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt && CastSpell(DISTRACTING_SHOT, curAtt))  { return; }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DISTRACTING_SHOT, pTarget) )  { return; }
+            }
+            // If i am not tank, transfer threat to tank or pet..
+            else
+            {
+                if (CastSpell(MISDIRECTION,m_tank)) { return; }
+                if (pet && pet->isAlive() && CastSpell(MISDIRECTION,pet)) { return; }
+
+                // Threat control
+                if (pThreat < threatThreshold || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+                else
+                {
+                    if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                    {
+                        m_bot->SetSelection(pet->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                    {
+                        m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                    else { return; } // No more threat reducing spells, just slow down
+                }
+            }
+
+            // DO dps
+            if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(KILL_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(MULTI_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(VOLLEY,pTarget)) { GetAI()->SetIgnoreUpdateTime(7); return; }
+            if (CanCast(CHIMERA_SHOT,pTarget) &&
+                (pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) || pTarget->HasAura(SERPENT_STING,m_bot->GetGUID()) )
+                && CastSpell(CHIMERA_SHOT,pTarget,false) ) { return; }
+            if (ai->GetManaPercent() < 60 && ai->GetManaPercent(*pTarget) > 4 && CastSpell(VIPER_STING,pTarget)) { return; }
+            if (!pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) && CastSpell(SERPENT_STING,pTarget)) { return; }
+            if (CastSpell(ARCANE_SHOT,pTarget)) { return; }
+            if (CastSpell(BLACK_ARROW,pTarget)) { return; }
+            if (CastSpell(EXPLOSIVE_SHOT,pTarget)) { return; }
+            if (CastSpell(STEADY_SHOT,pTarget)) { return; }
+            break;
+        #pragma endregion
+    }
+
+    /*// drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }*/
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    // buff group
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 20 || ai->GetHealthPercent() < 30) { ai->Feast(); }
+
+    #pragma region Check Pet
+    // check for pet
+    if( PET_SUMMON>0 && !m_petSummonFailed && HasPet(m_bot) )
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if( !pet )
+        {
+            // summon pet
+            if( PET_SUMMON>0 && ai->CastSpell(PET_SUMMON,m_bot) )
+                ai->TellMaster( "summoning pet." );
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster( "summon pet failed!" );
+            }
+        }
+        else if( pet->getDeathState() != ALIVE )
+        {
+            // revive pet
+            if( PET_REVIVE>0 && ai->GetManaPercent()>=80 && ai->CastSpell(PET_REVIVE,m_bot) )
+                ai->TellMaster( "reviving pet." );
+        }
+        else if( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        {
+            // heal pet when health lower 50%
+            if( PET_MEND>0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND,0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,m_bot) )
+                ai->TellMaster( "healing pet." );
+        }
+        else if(pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit*)m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto )
+                        continue;
+                    if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster,51284,true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                        ai->TellMaster( "feeding pet." );
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                {
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemPrototype* const pItemProto = pItem->GetProto();
+                            if (!pItemProto )
+                                continue;
+                            if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster,51284,true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                                ai->TellMaster( "feeding pet." );
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            if( pet->HasAura(PET_MEND, 0) && !pet->HasAura(PET_FEED, 0))
+
+                ai->TellMaster( "..no pet food!" );
+                ai->SetIgnoreUpdateTime(7);
+        }
+    #pragma endregion
+    }
+} // end DoNonCombatActions
+
+void PlayerbotHunterAI::Pull()
+{
+    if (!AUTO_SHOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if(GetPlayerBot()->GetPet())
+        GetPlayerBot()->GetPet()->SetReactState(REACT_PASSIVE);
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotHunterAI.h b/src/server/game/AI/BotAI/PlayerbotHunterAI.h
new file mode 100644
index 0000000..da496c2
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotHunterAI.h
@@ -0,0 +1,68 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotHunterAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotHunterAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotHunterAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        bool HasPet(Player* bot);
+
+        virtual void Pull();
+
+        //buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+        //Hunter
+        bool m_petSummonFailed;
+        bool m_petFeedPetFailed;
+
+        // PET CONTROL
+        uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, KILL_COMMAND, INTIMIDATION, BESTIAL_WRATH;
+
+        // PET SPELL
+        uint32 GROWL, COWER, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH;
+
+        // RANGED ATTACK
+        uint32 AUTO_SHOT, ARCANE_SHOT, EXPLOSIVE_SHOT, STEADY_SHOT, AIMED_SHOT, SCATTER_SHOT, KILL_SHOT, CHIMERA_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, SILENCING_SHOT;
+
+        // STINGS
+        uint32 SERPENT_STING, SCORPID_STING, WYVERN_STING, VIPER_STING;
+
+        // DEBUFF
+        uint32 HUNTERS_MARK, SCARE_BEAST;
+
+        //AOE
+        uint32 VOLLEY, MULTI_SHOT;
+
+        //MELEE
+        uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, COUNTERATTACK;
+
+        //TRAP
+        uint32 FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, SNAKE_TRAP, ARCANE_TRAP, FREEZING_ARROW, BLACK_ARROW;
+
+        //BUFF
+        uint32 TRUESHOT_AURA, DETERRENCE, FEIGN_DEATH, DISENGAGE, RAPID_FIRE, READINESS, MISDIRECTION;
+
+        //ASPECT
+        uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, ASPECT_OF_THE_VIPER;
+
+        uint32 TALENT_MM, TALENT_BM, TALENT_SURVIVAL;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotMageAI.cpp b/src/server/game/AI/BotAI/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..0554680
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotMageAI.cpp
@@ -0,0 +1,387 @@
+#include "PlayerbotMageAI.h"
+class PlayerbotAI;
+PlayerbotMageAI::PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai){\
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotMageAI::~PlayerbotMageAI(){}
+
+void PlayerbotMageAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //arcane
+    ARCANE_MISSILES = ai->getSpellIdExact("Arcane Missiles");
+    ARCANE_EXPLOSION = ai->getSpellIdExact("Arcane Explosion");
+    ARCANE_BLAST = ai->getSpellIdExact("Arcane Blast");
+    ARCANE_BARRAGE = ai->getSpellIdExact("Arcane Barrage");
+
+
+    //fire
+    FIREBALL = ai->getSpellIdExact("Fireball");
+    FROSTFIRE_BOLT = ai->getSpellIdExact("Frostfire Bolt");
+    FIRE_BLAST = ai->getSpellIdExact("Fire Blast");
+    FLAMESTRIKE = ai->getSpellIdExact("Flamestrike");
+    BLAST_WAVE = ai->getSpellIdExact("Blastwave");
+    SCORCH = ai->getSpellIdExact("Scorch");
+    PYROBLAST = ai->getSpellIdExact("Pyroblast");
+    LIVING_BOMB = ai->getSpellIdExact("Living Bomb");
+
+
+    //cold
+    FROSTBOLT = ai->getSpellIdExact("Frostbolt");
+    FROST_NOVA = ai->getSpellIdExact("Frost Nova");
+    ICE_LANCE = ai->getSpellIdExact("Ice Lance");
+    BLIZZARD = ai->getSpellIdExact("Blizzard");
+    CONE_OF_COLD = ai->getSpellIdExact("Cone of Cold");
+
+    WATER_ELEMENTAL = ai->getSpellIdExact("Summon Water Elemental");
+
+
+    // buffs
+    FROST_ARMOR = ai->getSpellIdExact("Ice Armor");
+    if (!FROST_ARMOR) FROST_ARMOR = ai->getSpellIdExact("Frost Armor");
+    MAGE_ARMOR = ai->getSpellIdExact("Mage Armor");
+    MOLTEN_ARMOR = ai->getSpellIdExact("Molten Armor");
+    FIRE_WARD = ai->getSpellIdExact("Fire Ward");
+    FROST_WARD = ai->getSpellIdExact("Frost Ward");
+    MANA_SHIELD = ai->getSpellIdExact("Mana Shield");
+    ICE_BARRIER = ai->getSpellIdExact("Ice Barrier");
+    POM = ai->getSpellIdExact("Presence of Mind");
+    FOCUS_MAGIC = ai->getSpellIdExact("Focus Magic");
+    ARCANE_POWER = ai->getSpellIdExact("Arance Power");
+    COMBUSTION = ai->getSpellIdExact("Combustion");
+    ICY_VEINS = ai->getSpellIdExact("Icy Veins");
+
+    ARCANE_INTELLECT = ai->getSpellIdExact("Arcane Intellect");
+    ARCANE_BRILLIANCE = ai->getSpellIdExact("Arcane Brilliance");
+    DALARAN_INTELLECT = ai->getSpellIdExact("Dalaran Intellect");
+    DALARAN_BRILLIANCE = ai->getSpellIdExact("Dalaran Brilliance");
+    DAMPEN_MAGIC = ai->getSpellIdExact("Dampen Magic");
+    AMPLIFY_MAGIC = ai->getSpellIdExact("Amplify Magic");
+
+
+    //CC
+    POLYMORPH = ai->getSpellIdExact("Polymorph");
+    DRAGONS_BREATH = ai->getSpellIdExact("Dragon's Breath");
+    DEEP_FREEZE = ai->getSpellIdExact("Deep Freeze");
+
+
+    //other
+    CONJURE_REFRESHMENT = ai->getSpellIdExact("Conjure Refreshment");
+    CONJURE_WATER = ai->getSpellIdExact("Conjure Water");
+    CONJURE_FOOD = ai->getSpellIdExact("Conjure Food");
+    CONJURE_MANA_GEM = ai->getSpellIdExact("Conjure Mana Gem");
+    MIRROR_IMAGE = ai->getSpellIdExact("Mirror Image");
+    BLINK = ai->getSpellIdExact("Blink");
+    ICE_BLOCK = ai->getSpellIdExact("Ice Block");
+    INVISIBILITY = ai->getSpellIdExact("Invisibility");
+    EVOCATION = ai->getSpellIdExact("Evocation");
+    REMOVE_CURSE = ai->getSpellIdExact("Remove Curse");
+    COUNTER_SPELL = ai->getSpellIdExact("Counterspell");
+    SLOW = ai->getSpellIdExact("Slow");
+
+    //Special
+    P_BRAIN_FREEZE = 57761; //Brain Freeze proc
+    P_FIRESTARTER = 54741; //Firestarter proc
+    P_HOT_STREAK = 48108; //Hot Sreak proc
+    P_ARCANE_BLAST = 36032; //Arcane blast proc
+	P_MISSILE_BARRAGE = 54490; //Missle Barrage proc
+	P_FINGERS_OF_FROST = 44545; //Fingers of Frost proc
+	IMP_SCORCH = 12873; //IMP SCORCH
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_ARCANE = ARCANE_BARRAGE;
+    TALENT_FIRE = COMBUSTION;
+    TALENT_FROST = ICE_BARRIER;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARCANE) talentCounter++;
+    if (TALENT_FIRE) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ARCANE = 0; TALENT_FIRE = 0; TALENT_FROST = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents (MAGE is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (isUnderAttack())
+    {
+        // Keep hitting but reduce threat
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        //if (CastSpell(INVISIBILITY, m_bot)) { return; }
+        if (ai->GetHealthPercent(*pTarget) > 50 && CastSpell(POLYMORPH)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist > 5 && CastSpell(FROST_NOVA, pTarget)) { return; }
+    if (DEEP_FREEZE && pTarget->isFrozen() && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(DRAGONS_BREATH, pTarget)) { return; }
+    if ((isUnderAttack() || ai->GetHealthPercent() < 75 && !HasAuraName(m_bot, MANA_SHIELD))  && ai->GetManaPercent() > 40 && CastSpell(MANA_SHIELD,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if ((ai->GetHealthPercent() < 65 || ai->GetManaPercent() < 5) && CastSpell(ICE_BLOCK,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(ICE_BARRIER, pTarget)) { return; }
+    if (ai->GetManaPercent() < 30 && CastSpell (EVOCATION, m_bot)) { return; }
+
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pThreat < threatThreshold && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTER_SPELL, pTarget)) { return; } //High threat
+	if (!m_bot->HasAura(MOLTEN_ARMOR) && CastSpell(MOLTEN_ARMOR,m_bot)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 96) { return; } // dont dps too early
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_NOVA,pTarget)) return;
+        if (CastSpell(FROSTBOLT,pTarget)) return;
+    }
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(INVISIBILITY,m_bot)) { return; } //Lets see if we can manage
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+    // buff up
+    if (CastSpell(ICY_VEINS,m_bot)) {} //nogcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(POM,m_bot)) {} //nogcd
+
+	if (TALENT_ARCANE)
+	{
+		if (CastSpell(ARCANE_POWER,m_bot)) {} //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(BLIZZARD,pTarget)) { return; }
+		}
+		//DPS
+		if (ARCANE_BLAST)
+        {
+            Aura *abaura = m_bot->GetAura(P_ARCANE_BLAST);
+            if (abaura && abaura->GetStackAmount() >= 3)
+			{
+				if (m_bot->HasAura(P_MISSILE_BARRAGE) && CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+				else if (CastSpell(ARCANE_BARRAGE,pTarget)) { return; }
+			}
+        }
+        if (CastSpell(ARCANE_BARRAGE,pTarget) ) { return; }
+
+	}
+	if (TALENT_FIRE)
+	{
+		if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(FLAMESTRIKE,pTarget)) { return; }
+			if (CastSpell(BLAST_WAVE,pTarget)) { return; }
+			if (CastSpell(LIVING_BOMB,pTarget)) { return; }
+			if (CastSpell(DRAGONS_BREATH,pTarget)) { return; }
+		}
+
+		//DPS
+		if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget)) { return; }
+		if (!pTarget->HasAura(LIVING_BOMB,m_bot->GetGUID()) && CastSpell(LIVING_BOMB,pTarget)) { return; }
+		//if (!pTarget->HasAura(IMP_SCORCH) && CastSpell(SCORCH,pTarget)) { return; }
+		if (CastSpell(FIREBALL,pTarget)) { return; }
+	}
+	if (TALENT_FROST)
+	{
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+        if (CastSpell(WATER_ELEMENTAL,m_bot)) { return; }
+
+        uint64 pet_guid = m_bot->GetPetGUID();
+        if (pet_guid>0){
+            Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+            Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+            if (unit!=NULL){
+				if (!unit->isInCombat()) {
+                    m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_ATTACK, ACT_COMMAND, pTarget->GetGUID());
+				}
+            }
+        }
+
+        //if (CastSpell(33395, pTarget)) // pet freeze spell
+        //    sLog.outError ("successfully casted freeze");
+
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(BLIZZARD,pTarget)) { return; }
+        }
+
+        //DPS
+        if (m_bot->HasAura(P_FINGERS_OF_FROST) && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+        if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FROSTFIRE_BOLT,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget,true,true)) { return; }
+
+    }
+
+    // Defaults especialy for lower levels
+    if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FIREBALL,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_FIRESTARTER) && CastSpell(FLAMESTRIKE,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(POM) && (CastSpell(PYROBLAST,pTarget,1,1) || CastSpell(FIREBALL,pTarget,1,1) || CastSpell(FROSTBOLT,pTarget,1,1))) { return; }
+        if (pTarget->isFrozen() && CastSpell(ICE_LANCE,pTarget)) { return; }
+        if (m_bot->isMoving() && (CastSpell(FIRE_BLAST,pTarget,1,1) || CastSpell(ARCANE_BARRAGE,pTarget) || CastSpell(ICE_LANCE,pTarget))) { return; }
+        if (CastSpell(FIREBALL,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget)) { return; }
+        if (CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+
+    // drink potion
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+    // if we get down here, it means we are out of mana, so use wand
+    CastSpell(SHOOT, pTarget);
+
+} //end DoNextCombatManeuver
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    // make sure pet stays by your side
+    uint64 pet_guid = m_bot->GetPetGUID();
+    if (pet_guid>0){
+        Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+        Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+        if (unit!=NULL){
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_FOLLOW, ACT_COMMAND, 0);
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, REACT_DEFENSIVE, ACT_REACTION, 0);
+        }
+    }
+
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    //Own Buffs
+    if (MOLTEN_ARMOR) { if ( CastSpell(MOLTEN_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(MAGE_ARMOR,m_bot)) { return; }
+    if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+    if (!HasAuraName(m_bot, MANA_SHIELD)) CastSpell (MANA_SHIELD);
+
+    //conjure food & water
+    Item *pItem = ai->FindDrink();
+	if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_WATER, m_bot)) { return; }
+        return;
+    }
+    pItem = ai->FindFood();
+    if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_FOOD, m_bot)) { return; }
+        return;
+    }
+    //Conjure mana gem??
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8)RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && CastSpell (EVOCATION, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+} //end DoNonCombatActions
+
+
+bool PlayerbotMageAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    //if (target->getClass() == CLASS_WARRIOR || target->getClass() == CLASS_DEATH_KNIGHT || target->getClass() == CLASS_ROGUE) return false;
+
+    if (!HasAuraName(target, ARCANE_INTELLECT) &&
+		!HasAuraName(target, ARCANE_BRILLIANCE) &&
+		!HasAuraName(target, DALARAN_INTELLECT) &&
+		!HasAuraName(target, DALARAN_BRILLIANCE))
+    {
+        if (CastSpell(ARCANE_BRILLIANCE, target)) return true;
+        if (CastSpell(ARCANE_INTELLECT, target)) return true;
+    }
+    return false;
+}
+bool PlayerbotMageAI::CureTarget(Unit *target)
+{
+	//Cures the target
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_CURSE, target)) return true;
+    return false;
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotMageAI.h b/src/server/game/AI/BotAI/PlayerbotMageAI.h
new file mode 100644
index 0000000..7ddfc1d
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotMageAI.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMAGEAI_H
+#define _PLAYERBOTMAGEAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_SCORCH,
+    SPELL_POM,
+    SPELL_ARCANE_POWER,
+    SPELL_FIREBALL,
+    SPELL_MISSILES,
+    SPELL_FROSTBOLT
+};
+
+//class Player;
+
+class PlayerbotMageAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotMageAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        typedef std::set<Unit *> AttackerSet;
+    private:
+        //arcane
+        uint32 ARCANE_MISSILES, ARCANE_EXPLOSION, ARCANE_BLAST, ARCANE_BARRAGE;
+
+        //fire
+        uint32 FIREBALL, FROSTFIRE_BOLT, FIRE_BLAST, FLAMESTRIKE, BLAST_WAVE, SCORCH, PYROBLAST, LIVING_BOMB;
+
+        //cold
+        uint32 FROSTBOLT, FROST_NOVA, ICE_LANCE, BLIZZARD, CONE_OF_COLD, WATER_ELEMENTAL;
+
+        // buffs
+        uint32 FROST_ARMOR, ICE_ARMOR, MAGE_ARMOR, MOLTEN_ARMOR, FIRE_WARD, FROST_WARD, MANA_SHIELD, ICE_BARRIER, POM, FOCUS_MAGIC, ARCANE_POWER, COMBUSTION, ICY_VEINS,
+            ARCANE_INTELLECT, ARCANE_BRILLIANCE, DALARAN_INTELLECT, DALARAN_BRILLIANCE, DAMPEN_MAGIC, AMPLIFY_MAGIC;
+
+        //CC
+        uint32 POLYMORPH, DRAGONS_BREATH, DEEP_FREEZE;
+
+        //other
+        uint32 CONJURE_REFRESHMENT, CONJURE_WATER, CONJURE_FOOD, CONJURE_MANA_GEM, MIRROR_IMAGE, BLINK, ICE_BLOCK, INVISIBILITY, EVOCATION, REMOVE_CURSE, COUNTER_SPELL, SLOW, SHOOT;
+
+        //special
+        uint32 P_BRAIN_FREEZE, P_FIRESTARTER, P_HOT_STREAK, P_ARCANE_BLAST, P_MISSILE_BARRAGE, P_FINGERS_OF_FROST, IMP_SCORCH;
+
+
+        uint32 TALENT_ARCANE, TALENT_FIRE, TALENT_FROST;
+
+};
+
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotPaladinAI.cpp b/src/server/game/AI/BotAI/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..baf65f7
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotPaladinAI.cpp
@@ -0,0 +1,564 @@
+#include "PlayerbotPaladinAI.h"
+
+enum BUFFS_ORDER {
+	BUFF_CASTER    = 0,		// Mage, Warlock
+	BUFF_HEALER,			// Priest
+	BUFF_RANGED,			// Hunter
+	BUFF_DPS,				// Rogue
+	BUFF_MELEE_DPS,			// Warrior, Death Knight
+	BUFF_MELEE_TANK,
+	BUFF_SUPPORT_HEAL,		// Druid, Palladin, Shaman
+	BUFF_SUPPORT_DPS,
+	BUFF_SUPPORT_TANK,
+	BUFF_DEFAULT,			// Other
+	BUFF_CLASS_MAX
+};
+
+enum BUFFS
+{
+	BUFF_GBOW = 0,
+	BUFF_GBOK,
+	BUFF_GBOS,
+	BUFF_GBOM,
+	BUFF_BOW,
+	BUFF_BOK,
+	BUFF_BOS,
+	BUFF_BOM,
+	BUFF_SPELL_MAX
+};
+
+static uint8 buffs[BUFF_CLASS_MAX][BUFF_SPELL_MAX] = {
+	{BUFF_GBOW, BUFF_GBOK, BUFF_GBOS, BUFF_BOW, BUFF_BOK, BUFF_BOS, BUFF_GBOM, BUFF_BOM},	// Caster
+	{BUFF_GBOK, BUFF_GBOW, BUFF_GBOS, BUFF_BOK, BUFF_BOW, BUFF_BOS, BUFF_GBOM, BUFF_BOM},	// Healer
+	{BUFF_GBOM, BUFF_GBOW, BUFF_GBOS, BUFF_BOM, BUFF_BOW, BUFF_BOS, BUFF_GBOK, BUFF_BOK},	// Hunter
+	{BUFF_GBOM, BUFF_GBOK, BUFF_GBOS, BUFF_BOM, BUFF_BOW, BUFF_BOS, BUFF_GBOK, BUFF_BOK},	// Rogue
+	{BUFF_GBOS, BUFF_GBOK, BUFF_GBOM, BUFF_BOS, BUFF_BOK, BUFF_BOM, BUFF_GBOW, BUFF_BOW},	// DPS
+	{BUFF_GBOK, BUFF_GBOM, BUFF_GBOS, BUFF_BOK, BUFF_BOM, BUFF_BOS, BUFF_GBOW, BUFF_BOW},	// Tank
+	{BUFF_GBOW, BUFF_GBOK, BUFF_GBOS, BUFF_BOW, BUFF_BOK, BUFF_BOS, BUFF_GBOM, BUFF_BOM},	// Support Healer
+	{BUFF_GBOS, BUFF_GBOK, BUFF_GBOM, BUFF_GBOW, BUFF_BOS, BUFF_BOK, BUFF_BOM, BUFF_BOW},	// Support DPS
+	{BUFF_GBOK, BUFF_GBOM, BUFF_GBOW, BUFF_GBOS, BUFF_BOK, BUFF_BOM, BUFF_BOW, BUFF_BOS},	// Support Tank
+	{BUFF_GBOK, BUFF_GBOM, BUFF_GBOW, BUFF_GBOS, BUFF_BOK, BUFF_BOM, BUFF_BOW, BUFF_BOS}	// Other
+};
+
+class PlayerbotAI;
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPaladinAI::~PlayerbotPaladinAI(){}
+
+void PlayerbotPaladinAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    FLASH_OF_LIGHT = ai->getSpellIdExact("Flash of Light");
+    HOLY_LIGHT = ai->getSpellIdExact("Holy Light");
+    HOLY_SHOCK = ai->getSpellIdExact("Holy Shock");
+    CLEANSE = ai->getSpellIdExact("Cleanse");
+    if (!CLEANSE) CLEANSE = ai->getSpellIdExact("Purify");
+    LOH = ai->getSpellIdExact("Lay on Hands");
+    SACRED_SHIELD = ai->getSpellIdExact("Sacred Shield");
+    BEACON_OF_LIGHT = ai->getSpellIdExact("Beacon of Light");
+    DIVINE_FAVOR = ai->getSpellIdExact("Divine Favor");
+    REDEMPTION = ai->getSpellIdExact("Redemption");
+
+    //Damages
+    JOL = ai->getSpellIdExact("Judgement of Light");
+    JOW = ai->getSpellIdExact("Judgement of Wisdom");
+	JOJ = ai->getSpellIdExact("Judgement of Justice");
+    HAMMER_OF_WRATH = ai->getSpellIdExact("Hammer of Wrath");
+    EXORCISM = ai->getSpellIdExact("Exorcism");
+    HOLY_WRATH = ai->getSpellIdExact("Holy Wrath");
+    CONSECRATION = ai->getSpellIdExact("Consecration");
+    AVENGERS_SHIELD = ai->getSpellIdExact("Avenger's Shield");
+    SHIELD_OF_RIGHTEOUSNESS = ai->getSpellIdExact("Shield of Righteousness");
+    HOTR = ai->getSpellIdExact("Hammer of the Righteous");
+    CRUSADER_STRIKE = ai->getSpellIdExact("Crusader Strike");
+    DIVINE_STORM = ai->getSpellIdExact("Divine Storm");
+
+    //CC
+    HAMMER_OF_JUSTICE = ai->getSpellIdExact("Hammer of Justice");
+    REPENTANCE = ai->getSpellIdExact("Repentance");
+
+    //Self buffs
+    SOL = ai->getSpellIdExact("Seal of Light");
+    SOW = ai->getSpellIdExact("Seal of Wisdom");
+    SOR = ai->getSpellIdExact("Seal of Righteousness");
+    SOC = ai->getSpellIdExact("Seal of Command");
+	SOV = ai->getSpellIdExact("Seal of Vengeance");
+	if (!SOV) SOV = ai->getSpellIdExact("Seal of Corruption");
+    DIVINE_PLEA = ai->getSpellIdExact("Divine Plea");
+    HOLY_SHIELD = ai->getSpellIdExact("Holy Shield");
+    RIGHTEOUS_FURY = ai->getSpellIdExact("Righteous Fury");
+    DIVINE_SHIELD = ai->getSpellIdExact("Divine Shield");
+    if (!DIVINE_SHIELD) DIVINE_SHIELD = ai->getSpellIdExact("Divine Protection");
+    AVENGING_WRATH = ai->getSpellIdExact("Avenging Wrath");
+
+    //AURAS
+    DEVOTION_AURA = ai->getSpellIdExact("Devotion Aura");
+    RETRIBUTION_AURA = ai->getSpellIdExact("Retribution Aura");
+    CONCENTRATION_AURA = ai->getSpellIdExact("Concentration Aura");
+    FIRE_AURA = ai->getSpellIdExact("Fire Resistance Aura");
+    FROST_AURA = ai->getSpellIdExact("Frost Resistance Aura");
+    SHADOW_AURA = ai->getSpellIdExact("Shadow Resistance Aura");
+    CRUSADER_AURA = ai->getSpellIdExact("Crusader Aura");
+
+    //Blessings
+    BOW = ai->getSpellIdExact("Blessing of Wisdom");
+    BOM = ai->getSpellIdExact("Blessing of Might");
+    BOS = ai->getSpellIdExact("Blessing of Sanctuary");
+    BOK = ai->getSpellIdExact("Blessing of Kings");
+    GBOW = ai->getSpellIdExact("Greater Blessing of Wisdom");
+    GBOM = ai->getSpellIdExact("Greater Blessing of Might");
+    GBOS = ai->getSpellIdExact("Greater Blessing of Sanctuary");
+    GBOK = ai->getSpellIdExact("Greater Blessing of Kings");
+
+    //Hands
+    HOF = ai->getSpellIdExact("Hand of Freedom");
+    HOR = ai->getSpellIdExact("Hand of Reckoning");
+    HOS = ai->getSpellIdExact("Hand of Salvation");
+    HOP = ai->getSpellIdExact("Hand of Protection");
+    DIVINE_SACRIFICE = ai->getSpellIdExact("Divine Sacrifice");
+
+    //Taunt
+    RIGHTEOUS_DEFENSE = ai->getSpellIdExact("Righteous Defense");
+
+    FORBEARANCE = 25771;
+	AOW = 53488;
+
+    TALENT_RETRI = CRUSADER_STRIKE;
+    TALENT_PROT = HOLY_SHIELD;
+    TALENT_HOLY = HOLY_SHOCK;
+
+    uint8 talentCounter = 0;
+    if (TALENT_RETRI) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_RETRI = 0; TALENT_PROT = 0; TALENT_HOLY = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    // Fill mana if needed
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ai->GetManaPercent() < 20 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (ai->GetManaPercent() < 30 && CastSpell (DIVINE_PLEA, m_bot)) { return; }
+
+    // If hp is too low divine shield
+    if (ai->GetHealthPercent() < 20 && (!m_bot->HasAura(DIVINE_SHIELD) || !m_bot->HasAura(HOP) || !m_bot->HasAura(SACRED_SHIELD)))
+    {
+        if (!m_bot->HasAura(FORBEARANCE))
+        {
+            if (CastSpell(DIVINE_SHIELD,m_bot)) { return; }
+            if (CastSpell(HOP,m_bot)) { return; }
+        }
+        else if (CastSpell(SACRED_SHIELD,m_bot)) { return; }
+    }
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && !TALENT_PROT && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(HOS,m_bot,true,true)) { }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_PROT) { m_role=BOT_ROLE_TANK; } //Just Keep Tanking
+        else
+        {
+            if (TALENT_RETRI) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else { m_role = BOT_ROLE_TANK; } //have no shield but can tank if you think so
+            }
+            else if (TALENT_HOLY) //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50))m_role = BOT_ROLE_SUPPORT;
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else m_role = BOT_ROLE_TANK;
+            }
+            else { m_role = BOT_ROLE_TANK; } //Unknown build or low level
+        }
+    }
+    else if (TALENT_RETRI) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_PROT) {
+        if ((ai->GetHealthPercent() <= 30 || masterHP <40 ) && (ai->GetManaPercent() >= 20)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_HOLY) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+	//takepos
+    if (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) TakePosition(pTarget,BOT_ROLE_DPS_MELEE,0.5f);
+    else TakePosition(pTarget,m_role);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+
+            ChangeAura(CONCENTRATION_AURA);
+            if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) {    if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if(SOL && ai->GetHealthPercent() < 40) { if(CastSpell(SOL,m_bot)) { return; } }
+            else if(CastSpell(SOR, m_bot)) { return; }
+
+            if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) { } // no gcd
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            if (ai->GetManaPercent() <= 80 && CastSpell(JOW,pTarget,true,true)) { return; }
+
+            // Use Spells only if mana is sufficient..
+            if(ai->GetManaPercent() < offensiveSpellThreshold ) return;
+
+        break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+
+            ChangeAura(DEVOTION_AURA);
+            if (CastSpell(RIGHTEOUS_FURY,m_bot)) { return; }
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) { if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if (SOL && ai->GetHealthPercent() < 40) { if (CastSpell(SOL,m_bot)) { return; } }
+            else if (CastSpell(SOR,m_bot)) { return; }
+
+            // We are tank/offtank threat is not an issiue;
+            // Use taunts only if helping target is not main tank..
+            // Taunt if needed (Only for master)
+            if(GetMaster()->GetGUID() != m_tank->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(RIGHTEOUS_DEFENSE, GetMaster())) { return; }
+                    if (CastSpell(HOR, curAtt,true,true))  { } //No GCD
+                }
+            }
+            // My target is not attacking me, taunt..
+            if ( m_tank->GetGUID() == m_bot->GetGUID() && pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(HOR, pTarget,true,true) )  { } //NO GCD
+
+            // Tank specials
+            if (TALENT_PROT && ai->GetManaPercent() < 90 && CastSpell (DIVINE_PLEA, m_bot)) { return; } //Prot paladin always uses this..
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(HOLY_SHIELD,m_bot)) { return; }
+            if (CastSpell(AVENGERS_SHIELD,pTarget,true,true)) { return; }
+            if (CastSpell(HOTR,pTarget,true,true)) { return; }
+            if (CastSpell(HOLY_WRATH,pTarget,true,true)){ return; }
+            if (CastSpell(CONSECRATION,pTarget)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_DWARF && CastSpell(R_STONEFORM,m_bot)) { return; }
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+
+        break;
+		#pragma endregion
+
+		#pragma region BOT_ROLE_DPS_MELEE
+		case BOT_ROLE_DPS_MELEE:
+
+			ChangeAura(RETRIBUTION_AURA);
+			if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+			if (CastSpell(SOV,m_bot)) { return; }
+
+			if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+			if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) {} //no gcd
+			if (CastSpell(JOW,pTarget)) { return; }
+			if (CastSpell(DIVINE_STORM, pTarget)) { return; }
+			if (CastSpell(CRUSADER_STRIKE, pTarget)) { return; }
+			if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget)) { return; }
+			if (CastSpell(CONSECRATION,pTarget)) { return; }
+			if (m_bot->HasAura(AOW) && CastSpell(EXORCISM,pTarget)) { return; }
+			if (CastSpell(HOLY_WRATH,pTarget)) { return; }
+
+		break;
+        #pragma endregion
+
+    }
+    #pragma region PaladinCommon
+    // Shared dps spells
+    if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID && pTarget->IsNonMeleeSpellCasted(true) && CastSpell (REPENTANCE, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+
+    // If at threat limit, stop
+    if(pThreat > threatThreshold && !TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(HOS,m_bot)) { return; } //Lets see if we can manage with HOS
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+    // Continue attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget,true,true)) { return; } //no gcd but cast
+    if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+    if (CanCast(JOW,pTarget,true) &&
+        ( ( ai->GetManaPercent() <= 70 && ai->GetHealthPercent() > 90)
+        || ( ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 75)
+        || ( ai->GetManaPercent() <= 20 && ai->GetHealthPercent() > 20) )
+        && CastSpell(JOW,pTarget,false)) { return; }
+    else if (CastSpell(JOL,pTarget),true,true) { return; }
+    if (CastSpell(SHIELD_OF_RIGHTEOUSNESS,pTarget,true,true)) { return; }
+    if (CastSpell (DIVINE_STORM, pTarget,true,true)) { return; }
+    if (CastSpell (CRUSADER_STRIKE, pTarget,true,true)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no GCD but cast
+    if (isUnderAttack(m_tank,4) && CastSpell(HOLY_WRATH,pTarget,true,true)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(CONSECRATION,pTarget)) { return; }
+    if (CastSpell(HOLY_SHOCK,pTarget,true,true)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 60 && OwnPartyHP < 65 && DoSupportRaid(m_bot)) { return; } //if there is spare time and mana, do healz and other stuff..
+    else if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 30 && DoSupportRaid(m_bot,30,false,false,false,true,false)) { return; }
+    if (CastSpell(EXORCISM,pTarget,true,true)) { return; }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_OF_LIGHT,m_bot)) { return; }
+    if (ai->GetManaPercent() < 70) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(LOH, target)) { return true; }
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(SACRED_SHIELD,target)) { return true; }
+    if(hp < 15 && m_bot->isInCombat() && CastSpell(HOP,target)) { return true; }
+    if(hp < 20 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+    if(hp < 30 && CastSpell(HOLY_SHOCK,target,true,true,true)) { return true; }
+    if(hp < 30 && m_bot->isInCombat() && CanCast(DIVINE_FAVOR,m_bot,true) && CanCast(HOLY_LIGHT,target,true) ) { CastSpell(DIVINE_FAVOR, m_bot,false); return CastSpell(HOLY_LIGHT,target,false); } //No gcd
+    if(hp < 30 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD but has cast
+    if(hp < 65 && CastSpell(HOLY_LIGHT,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 95 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPaladinAI::CureTarget(Unit *target)
+{
+    if (!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE, target)) { return true; }
+    return false;
+
+} //end CureTarget
+
+bool PlayerbotPaladinAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+	// Figure out why BOM overrides Battle Shout, and vice versa
+	// 6673 - Battle Shout, spell group 1003
+	// 19740 - BOM, spell group 1002
+
+    // Check if target already has a blessing by me..
+    if (HasAuraName(target,BOW,m_bot->GetGUID()) ||
+    HasAuraName(target,BOK,m_bot->GetGUID()) ||
+    HasAuraName(target,BOM,m_bot->GetGUID()) ||
+    HasAuraName(target,BOS,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOW,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOK,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOM,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOS,m_bot->GetGUID())
+    ) return false;
+
+#pragma region Choose Buff > Class
+	uint8 order;
+    switch(target->getClass())
+    {
+		case CLASS_MAGE:
+        case CLASS_WARLOCK:
+			order = BUFF_CASTER;
+            break;
+        case CLASS_PRIEST:
+			order = BUFF_HEALER;
+            break;
+        case CLASS_HUNTER:
+			order = BUFF_RANGED;
+            break;
+        case CLASS_ROGUE:
+			order = BUFF_DPS;
+            break;
+        case CLASS_WARRIOR:
+        case CLASS_DEATH_KNIGHT:
+            if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+				order = BUFF_MELEE_DPS;
+            else
+				order = BUFF_MELEE_TANK;
+            break;
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (target->GetMaxPower(target->getPowerType()) > target->GetMaxHealth())
+				order = BUFF_SUPPORT_HEAL;
+            else if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+				order = BUFF_SUPPORT_DPS;
+            else
+				order = BUFF_SUPPORT_TANK;
+            break;
+        default:
+			order = BUFF_DEFAULT;
+            break;
+    }
+
+	for(uint8 i = 0; i < 8; ++i)
+	{
+		uint32 spell;
+		switch(buffs[order][i])
+		{
+		case BUFF_GBOW: spell = GBOW; break;
+		case BUFF_GBOK: spell = GBOK; break;
+		case BUFF_GBOS: spell = GBOS; break;
+		case BUFF_GBOM: spell = GBOM; break;
+		case BUFF_BOW:  spell = BOW;  break;
+		case BUFF_BOK:  spell = BOK;  break;
+		case BUFF_BOS:  spell = BOS;  break;
+		case BUFF_BOM:  spell = BOM;  break;
+		};
+		// TODO: make it skip characters that are phased out (aka, imp)
+		if (CanCast(spell,target) && !HasAuraName(target,spell) && CastSpell(spell,target,false))
+			return true;
+	}
+#pragma endregion
+
+    return false;
+}
+
+
+bool PlayerbotPaladinAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(REDEMPTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(REDEMPTION, target, false);
+}
+
+bool PlayerbotPaladinAI::ChangeAura(uint32 aura)
+{
+    Player *m_bot = GetPlayerBot();
+    if(!aura) return false;
+
+    if(!CanCast(aura,m_bot)) return false;
+
+    if(m_bot->HasAura(aura))
+    {
+        if (aura == DEVOTION_AURA)
+        {
+            if (ChangeAura(FIRE_AURA)) return true;
+            if (ChangeAura(FROST_AURA)) return true;
+            if (ChangeAura(SHADOW_AURA)) return true;
+            return true;
+        }
+        else return ChangeAura(DEVOTION_AURA);
+    }
+    return CastSpell(aura,m_bot,false);
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotPaladinAI.h b/src/server/game/AI/BotAI/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..60d4123
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotPaladinAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTPALADINAI_H
+#define _PLAYERBOTPALADINAI_H
+
+#include "PlayerbotClassAI.h"
+#include "SharedDefines.h"
+
+class PlayerbotPaladinAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotPaladinAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeAura(uint32 aura);
+
+    private:
+        //heals
+        uint32 FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, REZZ, CLEANSE, LOH, SACRED_SHIELD, BEACON_OF_LIGHT, DIVINE_FAVOR, REDEMPTION;
+
+        //Damages
+        uint32 JOL, JOW, JOJ, HAMMER_OF_WRATH, EXORCISM, HOLY_WRATH, CONSECRATION, AVENGERS_SHIELD, SHIELD_OF_RIGHTEOUSNESS, HOTR, CRUSADER_STRIKE, DIVINE_STORM;
+
+        //CC
+        uint32 HAMMER_OF_JUSTICE, REPENTANCE;
+
+        //Self buffs
+        uint32 SOL, SOW, SOR, SOC, SOV, DIVINE_PLEA, HOLY_SHIELD, RIGHTEOUS_FURY, DIVINE_SHIELD, AVENGING_WRATH;
+
+        //AURAS
+        uint32 DEVOTION_AURA, RETRIBUTION_AURA, CONCENTRATION_AURA, FIRE_AURA, FROST_AURA, SHADOW_AURA, CRUSADER_AURA ;
+
+        //Blessings
+        uint32 BOW, BOM, BOS, BOK, GBOW, GBOM, GBOS, GBOK;
+
+        //Hands
+        uint32 HOF, HOR, HOS, HOP, DIVINE_SACRIFICE;
+
+        //Taunt
+        uint32 RIGHTEOUS_DEFENSE;
+
+        uint32 FORBEARANCE;
+
+        uint32 TALENT_HOLY, TALENT_PROT, TALENT_RETRI;
+
+		//procs
+		uint32 AOW;
+
+};
+
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotPriestAI.cpp b/src/server/game/AI/BotAI/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..10c2450
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotPriestAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotPriest.cpp
+Complete: maybe around 55%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Holy And Disc builds do not cast any offensive spells requiring cast time..(To compensate for the fact that Healing decision is not that intelligent)
+                - Priest breaks her own CCs.. Need a check for bots to not attack CC ed mobs..
+                - Wand usage is not very smooth..
+
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+PlayerbotPriestAI::PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPriestAI::~PlayerbotPriestAI(){}
+
+void PlayerbotPriestAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    RENEW = ai->getSpellIdExact("Renew");
+    FLASH_HEAL = ai->getSpellIdExact("Flash Heal");
+    if (!FLASH_HEAL) FLASH_HEAL = ai->getSpellIdExact("Lesser Heal");
+    HEAL = ai->getSpellIdExact("Greater Heal");
+    if (!HEAL) HEAL = ai->getSpellIdExact("Heal");
+    if (!HEAL) HEAL = FLASH_HEAL;
+    BINDING_HEAL = ai->getSpellIdExact("Binding Heal");
+    PO_MENDING = ai->getSpellIdExact("Prayer of Mending");
+    DESPERATE_PRAYER = ai->getSpellIdExact("Desperate Prayer");
+    PO_HEALING = ai->getSpellIdExact("Prayer of Healing");
+    CIRCLE_OF_HEALING = ai->getSpellIdExact("Circle of Healing");
+    DIVINE_HYMN = ai->getSpellIdExact("Divine Hymn");
+    RESURRECTION = ai->getSpellIdExact("Resurrection");
+    HYMN_OF_HOPE = ai->getSpellIdExact("Hymn of Hope");
+    CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    if (!CURE_DISEASE) CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    DISPEL_MAGIC = ai->getSpellIdExact("Dispel Magic");
+    MASS_DISPEL = ai->getSpellIdExact("Mass Dispel");
+
+    //Holy Offensive
+    SMITE = ai->getSpellIdExact("Smite");
+    HOLY_FIRE = ai->getSpellIdExact("Holy Fire");
+    PENANCE = ai->getSpellIdExact("Penance");
+    HOLY_NOVA = ai->getSpellIdExact("Holy Nova");
+
+    //Shadow Offensive
+    MIND_BLAST = ai->getSpellIdExact("Mind Blast");
+    SW_PAIN = ai->getSpellIdExact("Shadow Word: Pain");
+    DEVOURING_PLAGUE = ai->getSpellIdExact("Devouring Plague");
+    MIND_FLAY = ai->getSpellIdExact("Mind Flay");
+    VAMPIRIC_EMBRACE = ai->getSpellIdExact("Vampiric Embrace");
+    VAMPIRIC_TOUCH = ai->getSpellIdExact("Vampiric Touch");
+    SW_DEATH = ai->getSpellIdExact("Shadow Word: Death");
+    MIND_SEAR = ai->getSpellIdExact("Mind Sear");
+    MANA_BURN = ai->getSpellIdExact("Mana Burn");
+    SHADOWFIEND = ai->getSpellIdExact("Shadowfiend");
+
+    //CC - Breaker
+    PSYCHIC_SCREAM = ai->getSpellIdExact("Psychic Scream");
+    PSYCHIC_HORROR = ai->getSpellIdExact("Psychic Horror");
+    MIND_SOOTHE = ai->getSpellIdExact("Mind Soothe");
+    SHACKLE_UNDEAD = ai->getSpellIdExact("Shackle Undead");
+    SILENCE = ai->getSpellIdExact("Silence");
+    MIND_CONTROL = ai->getSpellIdExact("Mind Control");
+
+    //buffs
+    PW_SHIELD = ai->getSpellIdExact("Power Word: Shield");
+    INNER_FIRE = ai->getSpellIdExact("Inner Fire");
+    GUARDIAN_SPIRIT = ai->getSpellIdExact("Guardian Spirit");
+    FADE = ai->getSpellIdExact("Fade");
+    INNER_FOCUS = ai->getSpellIdExact("Inner Focus");
+    POWER_INFUSION = ai->getSpellIdExact("Power Infusion");
+    PAIN_SUPPRESSION = ai->getSpellIdExact("Pain Suppression");
+    SHADOWFORM = ai->getSpellIdExact("Shadowform");
+    DISPERSION = ai->getSpellIdExact("Dispersion");
+    LIGHTWELL = ai->getSpellIdExact("Lightwell");
+
+    PW_FORTITUDE = ai->getSpellIdExact("Power Word: Fortitude");
+    DIVINE_SPIRIT = ai->getSpellIdExact("Divine Spirit");
+    SHADOW_PROTECTION = ai->getSpellIdExact("Shadow Protection");
+    PO_FORTITUDE = ai->getSpellIdExact("Prayer of Fortitude");
+    PO_SPIRIT = ai->getSpellIdExact("Prayer of Spirit");
+    PO_SHADOW_PROTECTION = ai->getSpellIdExact("Prayer of Shadow Protection");
+    FEAR_WARD = ai->getSpellIdExact("Fear Ward");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DISC = PAIN_SUPPRESSION;
+    TALENT_HOLY = CIRCLE_OF_HEALING;
+    TALENT_SHADOW = SHADOWFORM;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DISC) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    if (TALENT_SHADOW) talentCounter++;
+    if (talentCounter > 1) { TALENT_DISC = 0; TALENT_HOLY = 0; TALENT_SHADOW = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    /*
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, pTarget) && ai->GetHealthPercent() < 60 && CastSpell(HEAL)) ||
+            CastSpell(PAIN) ||
+            (ai->GetHealthPercent() < 80 && CastSpell(RENEW)) ||
+            (m_bot->GetDistance(pTarget) <= 5 && CastSpell(SCREAM)) ||
+            CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && CastSpell(FLASH_HEAL)) ||
+            CastSpell(SMITE);
+            return;
+    }*/
+
+
+    //------- Non Duel combat ----------
+
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[6] = { DISPEL_MAGIC, CURE_DISEASE, DISPERSION, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        m_role = BOT_ROLE_DPS_RANGED;
+    }
+    else if (TALENT_SHADOW) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 30)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else { m_role = BOT_ROLE_SUPPORT; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(FADE,m_bot)) { return; }
+        else if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+
+    if (m_role == BOT_ROLE_DPS_RANGED && CastSpell(SHADOWFORM,m_bot)) { return; }
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetForm() == FORM_SHADOW) { m_bot->RemoveAurasDueToSpell(SHADOWFORM); }
+
+    //Buff
+    if (CastSpell(INNER_FIRE,m_bot)) { } //nogcd
+    if (CastSpell(POWER_INFUSION,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+
+    if (ai->GetForm() != FORM_SHADOW)
+    {
+        if (PO_MENDING && ai->GetHealthPercent(*m_tank) < 90 && !HasAuraName(m_tank, "Prayer of Mending") && CastSpell(PO_MENDING,m_tank)) { return; } //MEND tank first
+        if (DoSupportRaid(m_bot)) { return; }
+        //heal pets and bots
+        Unit *target = DoSelectLowestHpFriendly(30, 1000);
+        if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+    }
+    if (ai->GetForm() == FORM_SPIRITOFREDEMPTION) { return; } //You're dead..
+
+
+    //PROTECT
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (PSYCHIC_HORROR && CastSpell(PSYCHIC_HORROR, pTarget)) { return; }
+        if (PSYCHIC_SCREAM && CastSpell(PSYCHIC_SCREAM, pTarget)) { return; }
+        if (SHACKLE_UNDEAD && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_UNDEAD && CastSpell(SHACKLE_UNDEAD, pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (ai->GetHealthPercent() < 20 && CastSpell(DESPERATE_PRAYER)) { return; }
+    if (ai->GetHealthPercent() < 30 && CastSpell(PW_SHIELD)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (ai->GetHealthPercent() < 60 && CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() < 10 && CastSpell(DISPERSION,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (HYMN_OF_HOPE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCE, pTarget)) { return; }
+
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; } //Lets see if we can manage
+            else if (CastSpell(FADE,m_bot)) { return; }
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+    //WAND
+    if (ai->GetManaPercent() < 5 ||
+        (m_role != BOT_ROLE_DPS_RANGED && SHOOT && !m_bot->FindCurrentSpellBySpellId(SHOOT) && ai->CastSpell(SHOOT,pTarget) )
+        ) { return; } //Start autoshot
+
+    // Continue spell attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (CastSpell(VAMPIRIC_EMBRACE,pTarget)) { return; }
+    if (CastSpell(VAMPIRIC_TOUCH,pTarget)) { return; }
+    if (CastSpell(DEVOURING_PLAGUE,pTarget)) { return; }
+    if (CastSpell(SW_PAIN,pTarget)) { return; }
+
+    if (ai->GetForm() == FORM_SHADOW)
+    {
+        if (castDispel(DISPEL_MAGIC, pTarget)) { return; } //Dispel buffs if any
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(MIND_FLAY,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+    }
+
+    if (ai->GetForm() == FORM_NONE && m_role == BOT_ROLE_DPS_RANGED)
+    {
+        if (CastSpell(PENANCE,pTarget)) { return; }
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(HOLY_FIRE,pTarget)) { return; }
+        if (CastSpell(SMITE,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HOLY_NOVA,pTarget)) { return; }
+    }
+
+     // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+} //end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Own Buffs
+    if (CastSpell(INNER_FIRE,m_bot)) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_HEAL,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+
+bool PlayerbotPriestAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && m_bot->isInCombat() && CastSpell(GUARDIAN_SPIRIT,target)) { } //nogcd
+    if (hp < 30 && CastSpell(PENANCE,target,true,false,true)) { return true; } //Channeling Dual purpose
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(PW_SHIELD,target)) { return true; } //Check weakened soul
+    if (hp < 80 && hp > 50 && GetAI()->GetHealthPercent() < 80 && CastSpell (BINDING_HEAL,target)) { return true; }
+    if (hp < 85 && CastSpell(RENEW,target)) { return true; }
+    if (hp < 40 && GetPlayerBot()->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD, but has cast
+    if (hp < 55 && hp > 35 && CastSpell(HEAL,target)) { return true; }
+    if (hp < 75 && CastSpell(FLASH_HEAL,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPriestAI::HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    // if (hp < 75 && CastSpell(PO_MENDING, rTarget)) { return true; } //save this for tank
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(DIVINE_HYMN, rTarget)) { /*GetAI()->SetIgnoreUpdateTime(9);*/ return true; }
+    if (hp < 70 && CastSpell(CIRCLE_OF_HEALING, rTarget)) { return true; }
+    if (hp < 75 && hp > 30 && countNeedHeal > 4 && CastSpell(PO_HEALING)) { return true; }
+    if (hp < 65 && CastSpell(HOLY_NOVA, rTarget, true, false, true)) { return true; }
+
+    return false;
+}
+
+//Cures the target
+bool PlayerbotPriestAI::CureTarget(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_MAGIC, target, true, false, true)) return true;
+    if (castDispel(CURE_DISEASE, target)) return true;
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+    return false;
+}
+
+bool PlayerbotPriestAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(RESURRECTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+   // msg += " with ";
+   // msg += *REZZSpell->SpellName;
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(RESURRECTION, target,false);
+}
+
+bool PlayerbotPriestAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+
+    return (
+        (!HasAuraName(target, PW_FORTITUDE) && !HasAuraName(target, PO_FORTITUDE) && CastSpell (PW_FORTITUDE, target)) ||
+        (!HasAuraName(target, SHADOW_PROTECTION) && !HasAuraName(target, PO_SHADOW_PROTECTION) && CastSpell(SHADOW_PROTECTION, target)) ||
+        (!HasAuraName(target, DIVINE_SPIRIT) && !HasAuraName(target, PO_SPIRIT) && CastSpell (DIVINE_SPIRIT, target)) ||
+        (!HasAuraName(target, FEAR_WARD) && CastSpell (FEAR_WARD, target))
+         );
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotPriestAI.h b/src/server/game/AI/BotAI/PlayerbotPriestAI.h
new file mode 100644
index 0000000..13678bb
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotPriestAI.h
@@ -0,0 +1,59 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotPriestAI : public PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+    virtual ~PlayerbotPriestAI();
+
+    virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    //Heals the target based off its HP
+    bool HealTarget(Unit *target, uint8 hp);
+
+    bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+    //Cures the target
+    bool CureTarget(Unit *target);
+
+    bool RezTarget (Unit *target);
+
+private:
+    //heals
+    uint32 RENEW, FLASH_HEAL, HEAL, BINDING_HEAL, PO_MENDING, DESPERATE_PRAYER, PO_HEALING, CIRCLE_OF_HEALING, DIVINE_HYMN, RESURRECTION, HYMN_OF_HOPE, CURE_DISEASE, DISPEL_MAGIC, MASS_DISPEL;
+
+    //Holy Offensive
+    uint32 SMITE, HOLY_FIRE, PENANCE, HOLY_NOVA;
+
+    //Shadow Offensive
+    uint32 MIND_BLAST, SW_PAIN, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_EMBRACE, VAMPIRIC_TOUCH, SW_DEATH, MIND_SEAR, MANA_BURN, SHADOWFIEND;
+
+    //CC - Breaker
+    uint32 PSYCHIC_SCREAM, PSYCHIC_HORROR, MIND_SOOTHE, SHACKLE_UNDEAD, SILENCE, MIND_CONTROL;
+
+    //buffs
+    uint32 PW_SHIELD, INNER_FIRE, GUARDIAN_SPIRIT, FADE, INNER_FOCUS, POWER_INFUSION, PAIN_SUPPRESSION, SHADOWFORM, DISPERSION, LIGHTWELL,
+        PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION, PO_FORTITUDE, PO_SPIRIT, PO_SHADOW_PROTECTION, FEAR_WARD;
+
+    uint32 SHOOT;
+
+    uint32 TALENT_DISC, TALENT_HOLY, TALENT_SHADOW;
+};
+
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotRogueAI.cpp b/src/server/game/AI/BotAI/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..d8c3d48
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotRogueAI.cpp
@@ -0,0 +1,266 @@
+#include "PlayerbotRogueAI.h"
+#include "Spell.h"
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotRogueAI::~PlayerbotRogueAI(){}
+
+void PlayerbotRogueAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //Damage spells
+    BACKSTAB = ai->getSpellIdExact("Backstab");
+    SINISTER_STRIKE = ai->getSpellIdExact("Sinister Strike");
+    MUTILATE = ai->getSpellIdExact("Mutilate");
+    HEMORRHAGE = ai->getSpellIdExact("Hemorrhage");
+    GHOSTLY_STRIKE = ai->getSpellIdExact("Ghostly Strike");
+    RIPOSTE = ai->getSpellIdExact("Riposte");
+    SHIV = ai->getSpellIdExact("Shiv");
+    FAN_OF_KNIVES = ai->getSpellIdExact("Fan of Knives");
+
+    //Finishing Moves
+    EVISCERATE = ai->getSpellIdExact("Eviscerate");
+    RUPTURE = ai->getSpellIdExact("Rupture");
+    KIDNEY_SHOT = ai->getSpellIdExact("Kidney Shot");
+    ENVENOM = ai->getSpellIdExact("Envenom");
+    SLICE_AND_DICE = ai->getSpellIdExact("Slice and Dice");
+    EXPOSE_ARMOR = ai->getSpellIdExact("Expose Armor");
+    DEADLY_THROW = ai->getSpellIdExact("Deadly Throw");
+
+    //Buffs
+    STEALTH = ai->getSpellIdExact("Stealth");
+    VANISH = ai->getSpellIdExact("Vanish");
+    EVASION = ai->getSpellIdExact("Evasion");
+    CLOAK_OF_SHADOWS = ai->getSpellIdExact("Cloak of Shadows");
+    SPRINT = ai->getSpellIdExact("Sprint");
+    COLD_BLOOD = ai->getSpellIdExact("Cold Blood");
+    HUNGER_FOR_BLOOD = ai->getSpellIdExact("Hunger for Blood");
+    BLADE_FLURRY = ai->getSpellIdExact("Blade Flurry");
+    ADRENALINE_RUSH = ai->getSpellIdExact("Adrenaline Rush");
+    KILLING_SPREE = ai->getSpellIdExact("Killing Spree");
+    SHADOW_DANCE = ai->getSpellIdExact("Shadow Dance");
+
+    //Openers
+    CHEAP_SHOT = ai->getSpellIdExact("Cheap Shot");
+    GARROTE = ai->getSpellIdExact("Garrote");
+    AMBUSH = ai->getSpellIdExact("Ambush");
+
+    //Others
+    GOUGE = ai->getSpellIdExact("Gouge");
+    BLIND = ai->getSpellIdExact("Blind");
+    DISMANTLE = ai->getSpellIdExact("Dismantle");
+    SAP = ai->getSpellIdExact("Sap");
+    KICK = ai->getSpellIdExact("Kick");
+    PREPARATION = ai->getSpellIdExact("Preparation");
+    PREMEDITATION = ai->getSpellIdExact("Premeditation");
+    SHADOWSTEP = ai->getSpellIdExact("Shadowstep");
+    FEINT = ai->getSpellIdExact("Feint");
+    TRICKS_OF_THE_TRADE = ai->getSpellIdExact("Tricks of the Trade");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+    THROW = ai->getSpellIdExact("Throw");
+
+    TALENT_ASSASSINATION = MUTILATE;
+    TALENT_COMBAT = ADRENALINE_RUSH;
+    TALENT_SUBTELTY = PREMEDITATION;
+
+    //uint8 talentCounter = 0;
+    //if (TALENT_ASSASSINATION) talentCounter++;
+    //if (TALENT_COMBAT) talentCounter++;
+    //if (TALENT_SUBTELTY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ASSASSINATION = 0; TALENT_COMBAT = 0; TALENT_SUBTELTY = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (ROGUE is always MELEE DPS)
+    m_role = BOT_ROLE_DPS_MELEE;
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        else if (CastSpell(VANISH,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    // wait until we actually reach our target b4 we actually do anything
+    if (m_bot->GetDistance(pTarget)>10.0 &&
+        !m_bot->HasAura(STEALTH) &&
+        !m_bot->isInCombat() && CastSpell(STEALTH))
+    { return; }
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    // wait until we actually reach our target b4 we actually do anything
+    /*if (GetPlayerBot()->GetDistance(pTarget)>10.0 &&
+        !HasAuraName(GetPlayerBot(),STEALTH) &&
+        !GetPlayerBot()->isInCombat() && CastSpell(STEALTH))
+    { return; }*/
+
+    //Buff
+    if (CastSpell(PREMEDITATION,m_bot)) { return; }
+    if (CastSpell(COLD_BLOOD,m_bot)) { } //no gcd
+
+    //PROTECT UP
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        if (CastSpell(FEINT,m_bot)) { return; }
+        if (CastSpell(VANISH,m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist <= MELEE_RANGE && ai->GetHealthPercent() <= 85 && CastSpell(EVASION, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 55 && CastSpell(CLOAK_OF_SHADOWS, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 65 && CastSpell(GOUGE, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 45 && CastSpell(BLIND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(KICK, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(GOUGE, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && m_bot->GetComboPoints() >= 1 && CastSpell(KIDNEY_SHOT, pTarget)) { return; }
+
+    //Transfer threat
+    if (m_tank->GetGUID() != m_bot->GetGUID() && CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+	if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // sometimes we lose attack
+    if (!m_bot->isInCombat()) {
+        m_bot->Attack(pTarget, true);
+    }
+
+	if(TALENT_ASSASSINATION)
+	{
+		if (!m_bot->HasAura(HUNGER_FOR_BLOOD) && CastSpell(HUNGER_FOR_BLOOD,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+		    if (CastSpell(MUTILATE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+
+		}
+	}
+
+    if(TALENT_COMBAT)
+	{
+		if (CastSpell(BLADE_FLURRY,m_bot)) { return; }
+		if (ai->GetEnergyAmount() < 20 && CastSpell(ADRENALINE_RUSH,m_bot)) { return; }
+		if (!CastSpell(ADRENALINE_RUSH) && CastSpell(KILLING_SPREE,m_bot,1,0,1)) { return; }
+		if (m_bot->GetComboPoints() > 5)
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+		}
+	}
+
+    if(TALENT_SUBTELTY)
+	{
+		if (CastSpell(PREMEDITATION,m_bot)) {}
+		if (CastSpell(SHADOW_DANCE,m_bot)) {}
+		if (!CastSpell(SHADOW_DANCE,m_bot) && CastSpell(PREPARATION,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+			if (m_bot->HasAura(SHADOW_DANCE) && !pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(AMBUSH, pTarget)) { return; } }
+			if (CastSpell(GHOSTLY_STRIKE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+           if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) { return; }
+			if (CastSpell(SHADOWSTEP,pTarget)) { }
+		}
+	}
+
+    // defaults if not high enough do specialized attacks
+    if (m_bot->GetComboPoints() < 5) {
+        if (!pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(BACKSTAB, pTarget)) { return; } }
+        if (!MUTILATE &&CastSpell(SINISTER_STRIKE,pTarget)) { return; } // Dont cast if we have mutilate, save energy for it
+    } else {
+        if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) {  return; }
+		if (CastSpell(ENVENOM,pTarget)) { return; }
+        if (CastSpell(EVISCERATE,pTarget)) { return; }
+    }
+} //end DoNextCombatManeuver
+
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (ChangeWeaponEnchants()) { return; }
+} //end DoNonCombatActions
+
+bool PlayerbotRogueAI::ChangeWeaponEnchants()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    Item *weap;
+    Item *poison;
+
+    weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonForward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+        return true;
+    }
+    weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonBackward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+        return true;
+    }
+    return false;
+}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotRogueAI.h b/src/server/game/AI/BotAI/PlayerbotRogueAI.h
new file mode 100644
index 0000000..e979a4b
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotRogueAI.h
@@ -0,0 +1,41 @@
+#ifndef _PLAYERBOTROGUEAI_H
+#define _PLAYERBOTROGUEAI_H
+
+#include "PlayerbotClassAI.h"
+#include "TargetedMovementGenerator.h"
+
+class PlayerbotRogueAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotRogueAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool ChangeWeaponEnchants();
+
+    private:
+        //Damage spells
+        uint32 BACKSTAB, SINISTER_STRIKE, MUTILATE, HEMORRHAGE, GHOSTLY_STRIKE, RIPOSTE, SHIV, FAN_OF_KNIVES;
+        //Finishing Moves
+        uint32 EVISCERATE, RUPTURE, KIDNEY_SHOT, ENVENOM, SLICE_AND_DICE, EXPOSE_ARMOR, DEADLY_THROW;
+        //Buffs
+        uint32 STEALTH, VANISH, EVASION, CLOAK_OF_SHADOWS, SPRINT, COLD_BLOOD, HUNGER_FOR_BLOOD, BLADE_FLURRY, ADRENALINE_RUSH, KILLING_SPREE, SHADOW_DANCE;
+        //Openers
+        uint32 CHEAP_SHOT, GARROTE, AMBUSH;
+        //Others
+        uint32 GOUGE, BLIND, DISMANTLE, SAP, KICK, PREPARATION, PREMEDITATION, SHADOWSTEP, FEINT, TRICKS_OF_THE_TRADE;
+
+        uint32 TALENT_ASSASSINATION, TALENT_COMBAT, TALENT_SUBTELTY;
+
+        uint32 THROW;
+
+};
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotShamanAI.cpp b/src/server/game/AI/BotAI/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..3914aa8
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotShamanAI.cpp
@@ -0,0 +1,555 @@
+#include "PlayerbotShamanAI.h"
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotShamanAI::~PlayerbotShamanAI(){}
+
+void PlayerbotShamanAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //totems
+    HEALING_STREAM_TOTEM = ai->getSpellIdExact("Healing Stream Totem");
+    MANA_SPRING_TOTEM = ai->getSpellIdExact("Mana Spring Totem");
+    MANA_TIDE_TOTEM = ai->getSpellIdExact("Mana Tide Totem");
+    CLEANSING_TOTEM = ai->getSpellIdExact("Cleansing Totem");
+    FIRE_RESISTANCE_TOTEM = ai->getSpellIdExact("Fire Resistance Totem");
+
+    WINDFURY_TOTEM = ai->getSpellIdExact("Windfury Totem");
+    WRATH_OF_AIR_TOTEM = ai->getSpellIdExact("Wrath of Air Totem");
+    GROUNDING_TOTEM = ai->getSpellIdExact("Grounding Totem");
+    NATURE_RESISTANCE_TOTEM = ai->getSpellIdExact("Nature Resistance Totem");
+
+    STRENGTH_OF_EARTH_TOTEM = ai->getSpellIdExact("Strength of Earth Totem");
+    EARTHBIND_TOTEM = ai->getSpellIdExact("Earthbind Totem");
+    STONESKIN_TOTEM = ai->getSpellIdExact("Stoneskin Totem");
+    STONECLAW_TOTEM = ai->getSpellIdExact("Stoneclaw Totem");
+    TREMOR_TOTEM = ai->getSpellIdExact("Tremor Totem");
+    EARTH_ELEMENTAL_TOTEM = ai->getSpellIdExact("Earth Elemental Totem");
+
+    FLAMETONGUE_TOTEM = ai->getSpellIdExact("Flametongue Totem");
+    TOTEM_OF_WRATH = ai->getSpellIdExact("Totem of Wrath");
+    SEARING_TOTEM = ai->getSpellIdExact("Searing Totem");
+    MAGMA_TOTEM = ai->getSpellIdExact("Magma Totem");
+    FIRE_ELEMENTAL_TOTEM = ai->getSpellIdExact("Fire Elemental Totem");
+    FROST_RESISTANCE_TOTEM = ai->getSpellIdExact("Frost Resistance Totem");
+
+    TOTEMIC_RECALL = ai->getSpellIdExact("Totemic Recall");
+    CALL_OF_THE_ELEMENTS = ai->getSpellIdExact("Call of the Elements");
+    CALL_OF_THE_ANCESTORS = ai->getSpellIdExact("Call of the Ancestors");
+    CALL_OF_THE_SPIRITS = ai->getSpellIdExact("Call of the Spirits");
+
+    //restoration
+    HEAL = ai->getSpellIdExact("Healing Wave");
+    LESSER_HEAL = ai->getSpellIdExact("Lesser Healing Wave");
+    CHAIN_HEAL = ai->getSpellIdExact("Chain Heal");
+    RIPTIDE = ai->getSpellIdExact("Riptide");
+    ANCESTRAL_SPIRIT = ai->getSpellIdExact("Ancestral Spirit");
+    CLEANSE_SPIRIT = ai->getSpellIdExact("Cleanse Spirit");
+    if (CLEANSE_SPIRIT) CLEANSE_SPIRIT = ai->getSpellIdExact("Cure Toxins");
+
+    //offensive spells
+    LIGHTNING_BOLT = ai->getSpellIdExact("Lightning Bolt");
+    CHAIN_LIGHTNING = ai->getSpellIdExact("Chain Lightning");
+    FIRE_NOVA = ai->getSpellIdExact("Fire Nova");
+    THUNDERSTORM = ai->getSpellIdExact("Thunderstorm");
+    LAVA_BURST = ai->getSpellIdExact("Lava Burst");
+    EARTH_SHOCK = ai->getSpellIdExact("Earth Shock");
+    WIND_SHEAR = ai->getSpellIdExact("Wind Shear");
+    FLAME_SHOCK = ai->getSpellIdExact("Flame Shock");
+    FROST_SHOCK = ai->getSpellIdExact("Frost Shock");
+    PURGE = ai->getSpellIdExact("Purge");
+    HEX  = ai->getSpellIdExact("Hex");
+
+    //buffs
+    LIGHTNING_SHIELD = ai->getSpellIdExact("Lightning Shield");
+    WATER_SHIELD = ai->getSpellIdExact("Water Shield");
+    EARTH_SHIELD = ai->getSpellIdExact("Earth Shield");
+    HEROISM = ai->getSpellIdExact("Heroism");
+    if (HEROISM) HEROISM = ai->getSpellIdExact("Bloodlust");
+    ELEMENTAL_MASTERY = ai->getSpellIdExact("Elemental Mastery");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    WINDFURY_WEAPON = ai->getSpellIdExact("Windfury Weapon");
+    FLAMETONGUE_WEAPON = ai->getSpellIdExact("Flametongue Weapon");
+    FROSTBRAND_WEAPON = ai->getSpellIdExact("Frostbrand Weapon");
+    ROCKBITER_WEAPON = ai->getSpellIdExact("Rockbiter Weapon");
+    EARTHLIVING_WEAPON = ai->getSpellIdExact("Earthliving Weapon");
+
+    WATER_BREATHING = ai->getSpellIdExact("Water Breathing");
+    WATER_WALKING = ai->getSpellIdExact("Water Walking");
+
+    //melee
+    LAVA_LASH = ai->getSpellIdExact("Lava Lash");
+    STORMSTRIKE = ai->getSpellIdExact("Stormstrike");
+    SHAMANISTIC_RAGE = ai->getSpellIdExact("Shamanistic Rage");
+    FERAL_SPIRIT = ai->getSpellIdExact("Feral Spirit");
+
+    GHOST_WOLF = ai->getSpellIdExact("Ghost Wolf");
+
+    EXHAUSTION = 57723; // heroism debuff
+    SATED = 57724; // bloodlust debuff
+    //MAELSTROM_WEAPON = 0; // We want the triggered aura, not the talent spell
+    uint32 mwtrigger = ai->getSpellIdExact("Maelstrom Weapon",true);
+    if (mwtrigger)
+    {
+        SpellEntry const *mwtSpell = GetSpellStore()->LookupEntry(mwtrigger);
+        if (mwtSpell && mwtSpell->EffectTriggerSpell[0] > 0) MAELSTROM_WEAPON = mwtSpell->EffectTriggerSpell[0];
+    }
+
+    TALENT_ELEMENTAL = ELEMENTAL_MASTERY;
+    TALENT_ENHANCEMENT = STORMSTRIKE;
+    TALENT_RESTO = EARTH_SHIELD;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ELEMENTAL) talentCounter++;
+    if (TALENT_ENHANCEMENT) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ELEMENTAL = 0; TALENT_ENHANCEMENT = 0; TALENT_RESTO = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            ((ai->GetHealthPercent() < 80 && CastSpell(LESSER_HEAL)) ||
+            CastSpell(LIGHTNING_BOLT, pTarget));
+            return;
+    }
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) { m_role=BOT_ROLE_TANK; } // Hey! I am Main Tank
+    else if (TALENT_ENHANCEMENT) { m_role = BOT_ROLE_DPS_MELEE; }
+    else if (TALENT_ELEMENTAL) { m_role = BOT_ROLE_DPS_RANGED; }
+    else if (TALENT_RESTO) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack()  )
+    {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    // Choose Weapon Enchant
+    if (ChangeWeaponEnchants()) return;
+
+	if (TALENT_ELEMENTAL){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+	if (TALENT_ENHANCEMENT){ if (!m_bot->HasAura(LIGHTNING_SHIELD) && CastSpell(LIGHTNING_SHIELD,m_bot)) { return; }}
+	if (TALENT_RESTO){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+    // Choose shield
+	/*
+    if (EARTH_SHIELD && ai->GetHealthPercent() < 80 && isUnderAttack()) { if (CastSpell(EARTH_SHIELD,m_bot)) { return; } }
+    else if (WATER_SHIELD && ai->GetManaPercent() < 40) { if (CastSpell(WATER_SHIELD,m_bot)) { return; } }
+    else if (LIGHTNING_SHIELD &&
+        ( isUnderAttack() || m_tank->GetGUID() == m_bot->GetGUID() )  && !(m_bot->HasAura(WATER_SHIELD) && ai->GetManaPercent() < 80)
+        ) { if (CastSpell(LIGHTNING_SHIELD,m_bot)) { return; } }
+    else if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+	*/
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+             if (!TALENT_ELEMENTAL && !TALENT_RESTO) { TakePosition(pTarget); }
+            else { TakePosition(pTarget,BOT_ROLE_DPS_RANGED); } // mob will come to you sooner or later no need to hurry
+
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 70 && DoSupportRaid(m_bot)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(40, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+    #pragma region ShamanCommon
+
+
+    //Defensive Stuff
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (pDist > 5 && CastSpell(FROST_SHOCK, pTarget)) { return; }
+        if ((pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST || pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID) && CastSpell(HEX, pTarget)) { return; } // no gcd
+        if (CastSpell(WIND_SHEAR, pTarget)) { } // no gcd
+    }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(WIND_SHEAR, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_SHOCK,pTarget)) return;
+    }
+
+
+    //Buff and restores
+    if ( ( (ai->GetHealthPercent() < 60 && isUnderAttack()) ||
+        (ai->GetManaPercent() < 30) ) && CastSpell(SHAMANISTIC_RAGE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+    if (!m_bot->HasAura(HEROISM) && !m_bot->HasAura(EXHAUSTION) && !m_bot->HasAura(SATED) && CastSpell(HEROISM,m_bot)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //healers keep it for healing no gcd
+    else if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+
+    // If at threat limit, use WIND_SHEAR to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(WIND_SHEAR,pTarget)) { return; } //Lets see if we can manage
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+	if (TALENT_ELEMENTAL)
+	{
+		if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+		if (!pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+		if (CastSpell(LAVA_BURST,pTarget)) { return; }
+		if (CastSpell(CHAIN_LIGHTNING,pTarget)) { return; }
+		if (CastSpell(LIGHTNING_BOLT,pTarget)) { return; }
+	}
+
+    //dps
+    if (MAELSTROM_WEAPON)
+    {
+        Aura *maelaura = m_bot->GetAura(MAELSTROM_WEAPON);
+        if (maelaura && maelaura->GetStackAmount() == 5)
+        {
+            if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CHAIN_LIGHTNING,pTarget,true,true)) { return; }
+            if (CastSpell(LIGHTNING_BOLT,pTarget,true,true)) { return; }
+        }
+    }
+	if (CastSpell(FLAME_SHOCK,pTarget)) { return; }
+    if (CastSpell(STORMSTRIKE,pTarget,true,true)) { return; }
+
+    //if (!TALENT_ENHANCEMENT && CanCast(LAVA_BURST,pTarget,true) && pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(LAVA_BURST,pTarget,false)) { return; }
+	if (CastSpell(FERAL_SPIRIT,m_bot)) { return; }
+    if (CanCast(EARTH_SHOCK,pTarget,true) && (pTarget->HasAura(STORMSTRIKE,m_bot->GetGUID()) || pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) ) && CastSpell(EARTH_SHOCK,pTarget)) { return; }
+    //if (CanCast(FLAME_SHOCK,pTarget) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+	if (CastSpell(LAVA_LASH,pTarget,true,true)) { return; }
+	if (CastSpell(FIRE_NOVA,pTarget)) { return; }
+    //if ((isUnderAttack(m_tank,4) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(FIRE_NOVA,pTarget)) { return; }
+    if (ai->GetManaPercent() > 60 && castDispel(PURGE,pTarget)) { return; } //PURGE but dont overpurge
+
+    #pragma endregion
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+
+} //end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //Buffs
+    if (ChangeWeaponEnchants()) { return; }
+    if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+    if (CastSpell(EARTH_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(LESSER_HEAL,m_bot)) { return; }
+	if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+bool PlayerbotShamanAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 30 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) {} // NO gcd
+    if(hp < 60 && CanCast(HEAL,target,true) && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEAL, target, false)) { return true; }
+    if(hp < 30 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) {} // no GCD
+    if(hp < 65 && CanCast(EARTH_SHIELD,target) && !m_bot->HasAura(EARTH_SHIELD,m_bot->GetGUID()) && CastSpell(EARTH_SHIELD,target,false)) { return true; }
+    if(hp < 65 && CastSpell(HEAL,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotShamanAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    if (hp < 65 && RIPTIDE && rTarget->HasAura(RIPTIDE,m_bot->GetGUID()) && CastSpell(CHAIN_HEAL, rTarget)) { return true; }
+    if (hp < 85 && CastSpell(RIPTIDE, rTarget)) { return true; }
+    if (hp < 75 && CastSpell(CHAIN_HEAL, rTarget,true,true)) { return true; }
+
+    return false;
+}
+
+bool PlayerbotShamanAI::CureTarget(Unit *target)
+//Cures the target
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE_SPIRIT, target)) return true;
+
+    return false;
+}
+
+bool PlayerbotShamanAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(ANCESTRAL_SPIRIT,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(ANCESTRAL_SPIRIT, target,false);
+}
+
+bool PlayerbotShamanAI::BuffPlayer(Unit *target)
+{
+    //std::string msg = "Mana totem, coming right up.";
+    //GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    //if(!HasAuraName(GetPlayerBot(), "Mana Spring")) { CastSpell(MANA_SPRING_TOTEM, GetPlayerBot()); } return true;
+    return false;
+}
+#pragma region Change Totems
+bool PlayerbotShamanAI::ChangeTotems(uint32 mode)
+{
+    uint32 earth=0, fire=0, water=0, air=0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+    Unit *pTarget = m_bot->GetSelectedUnit();
+    Unit *pVictim = NULL;
+    if (m_bot->GetSelectedUnit()->IsFriendlyTo(m_bot)) pTarget = NULL;
+    if (pTarget) pVictim = pTarget->getVictim();
+
+    //Defaults
+    if (!HasAuraName(m_bot,"Horn of Winter") )earth = STRENGTH_OF_EARTH_TOTEM;
+    if (!earth) earth = STONESKIN_TOTEM;
+    if (!earth) earth = EARTHBIND_TOTEM;
+    fire = TOTEM_OF_WRATH;
+    if (!fire) fire = FLAMETONGUE_TOTEM;
+    if (!fire) fire = SEARING_TOTEM;
+    water = MANA_SPRING_TOTEM;
+    if (!water) water = HEALING_STREAM_TOTEM;
+    if (TALENT_ELEMENTAL || TALENT_RESTO) air = WRATH_OF_AIR_TOTEM;
+    else air = WINDFURY_TOTEM;
+
+    //Target reactive stuff
+    if (pTarget)
+    {
+        if (GROUNDING_TOTEM && pTarget->IsNonMeleeSpellCasted(true)) air = GROUNDING_TOTEM;
+    }
+
+    if (STONESKIN_TOTEM && isUnderAttack()) earth = STONESKIN_TOTEM;
+
+    uint32 totz[4] = {earth, fire, water, air};
+
+    for (int i = 0; i < 4; i++)
+    {
+        if (!totz[i]) continue;
+        SpellEntry const *tSpell = GetSpellStore()->LookupEntry(totz[i]);
+        if (!tSpell) continue;
+        uint32 tEntry = (uint32) tSpell->EffectMiscValue[0];
+        if (!tEntry) continue;
+        CreatureInfo const *totemEntry = GetCreatureTemplateStore(tEntry);
+        if (!tEntry) continue;
+
+        if (CanCast(totz[i], m_bot) && !m_bot->FindNearestCreature(tEntry,30)) { return CastSpell(totz[i],m_bot,false); }
+    }
+    return false;
+}
+#pragma endregion
+#pragma region ChangeWeaponEnchants
+bool PlayerbotShamanAI::ChangeWeaponEnchants()
+{
+    uint32 mhEnch = 0, ohEnch = 0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+
+    // Choose Weapon Enchant
+    if (TALENT_RESTO) { mhEnch = EARTHLIVING_WEAPON; }
+    else if (TALENT_ELEMENTAL){ mhEnch = FLAMETONGUE_WEAPON; }
+    else
+    {
+        if (WINDFURY_WEAPON)
+        {
+            mhEnch = WINDFURY_WEAPON;
+            if (m_bot->haveOffhandWeapon())
+            {
+                if (LAVA_LASH) ohEnch = FLAMETONGUE_WEAPON;
+                else ohEnch = WINDFURY_WEAPON;
+            }
+		}
+    else if (FLAMETONGUE_WEAPON)
+    {
+        mhEnch = FLAMETONGUE_WEAPON;
+        if (m_bot->haveOffhandWeapon()) ohEnch = FLAMETONGUE_WEAPON;
+    }
+
+    }
+
+    Item* weap;
+    uint32 enchant_id = 0;
+    SpellEntry const *tSpell;
+    bool castedsomething = false;
+
+    if (mhEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+        if (weap)
+        {
+            tSpell = GetSpellStore()->LookupEntry(mhEnch);
+            if (tSpell && tSpell->EffectMiscValue[0] > 0)
+            {
+                enchant_id = (uint32) tSpell->EffectMiscValue[0];
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+
+    if (ohEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+        if (weap)
+        {
+            tSpell = GetSpellStore()->LookupEntry(ohEnch);
+            if (tSpell && tSpell->EffectMiscValue[0] > 0)
+            {
+                enchant_id = (uint32) tSpell->EffectMiscValue[0];
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+    return castedsomething;
+
+}
+#pragma endregion
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotShamanAI.h b/src/server/game/AI/BotAI/PlayerbotShamanAI.h
new file mode 100644
index 0000000..019585e
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotShamanAI.h
@@ -0,0 +1,75 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotShamanAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotShamanAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeTotems(uint32 mode);
+
+        bool ChangeWeaponEnchants();
+
+        /*//find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+    private:
+
+        //totems
+        uint32 HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, MANA_TIDE_TOTEM, CLEANSING_TOTEM, FIRE_RESISTANCE_TOTEM; //water
+        uint32 WINDFURY_TOTEM, WRATH_OF_AIR_TOTEM, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM;  //air
+        uint32 STRENGTH_OF_EARTH_TOTEM, EARTHBIND_TOTEM, STONESKIN_TOTEM, STONECLAW_TOTEM, TREMOR_TOTEM, EARTH_ELEMENTAL_TOTEM ; //earth
+        uint32 FLAMETONGUE_TOTEM, TOTEM_OF_WRATH, SEARING_TOTEM, MAGMA_TOTEM, FIRE_ELEMENTAL_TOTEM, FROST_RESISTANCE_TOTEM; //fire
+        uint32 TOTEMIC_RECALL, CALL_OF_THE_ELEMENTS, CALL_OF_THE_ANCESTORS, CALL_OF_THE_SPIRITS;
+
+        //restoration
+        uint32 HEAL, LESSER_HEAL, CHAIN_HEAL, RIPTIDE, ANCESTRAL_SPIRIT, CLEANSE_SPIRIT;
+
+        //offensive spells
+        uint32 LIGHTNING_BOLT, CHAIN_LIGHTNING, FIRE_NOVA, THUNDERSTORM, LAVA_BURST, EARTH_SHOCK, WIND_SHEAR, FLAME_SHOCK, FROST_SHOCK, PURGE, HEX ;
+
+        //buffs
+        uint32 LIGHTNING_SHIELD, WATER_SHIELD, EARTH_SHIELD, HEROISM, ELEMENTAL_MASTERY, NATURES_SWIFTNESS,
+            WINDFURY_WEAPON, FLAMETONGUE_WEAPON, FROSTBRAND_WEAPON, ROCKBITER_WEAPON, EARTHLIVING_WEAPON,
+            WATER_BREATHING, WATER_WALKING ;
+
+        //mellee
+        uint32 LAVA_LASH, STORMSTRIKE, SHAMANISTIC_RAGE, FERAL_SPIRIT;
+
+        uint32 GHOST_WOLF;
+
+        //special
+        uint32 EXHAUSTION, SATED, MAELSTROM_WEAPON;
+
+        uint32 TALENT_ELEMENTAL, TALENT_ENHANCEMENT, TALENT_RESTO;
+
+};
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotWarlockAI.cpp b/src/server/game/AI/BotAI/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..aa0e271
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotWarlockAI.cpp
@@ -0,0 +1,409 @@
+/*
+Name : PlayerbotWarlockAI.cpp
+Complete: maybe around 60%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Curse checks are slow, later all curses should be looked up in one loop
+                - Need a function to lookup pet known spells for better pet handling
+                - Warlock do not summon other pets than Fel hunter/Imp
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarlockAI::~PlayerbotWarlockAI(){}
+
+void PlayerbotWarlockAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //CURSES
+    CURSE_OF_ELEMENTS = ai->getSpellIdExact("Curse of Elements");
+    CURSE_OF_WEAKNESS = ai->getSpellIdExact("Curse of Weakness");
+    CURSE_OF_AGONY = ai->getSpellIdExact("Curse of Agony");
+    CURSE_OF_RECKLESSNESS = ai->getSpellIdExact("Curse of Recklessness");
+    CURSE_OF_TONGUES = ai->getSpellIdExact("Curse of Tongues");
+    CURSE_OF_DOOM = ai->getSpellIdExact("Curse of Doom");
+    CURSE_OF_EXHAUSTION = ai->getSpellIdExact("Curse of Exhaustion");
+
+
+    //AFFLICTION
+    CORRUPTION = ai->getSpellIdExact("Corruption");
+    DRAIN_SOUL = ai->getSpellIdExact("Drain Soul");
+    DRAIN_LIFE = ai->getSpellIdExact("Drain Life");
+    DRAIN_MANA = ai->getSpellIdExact("Drain Mana");
+    SIPHON_LIFE = ai->getSpellIdExact("Siphon Life");
+    UNSTABLE_AFFLICTION = ai->getSpellIdExact("Unstable Affliction");
+    HAUNT = ai->getSpellIdExact("Haunt");
+    SEED_OF_CORRUPTION = ai->getSpellIdExact("Seed of Corruption");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+
+
+    //DESTRUCTION
+    SHADOW_BOLT = ai->getSpellIdExact("Shadow Bolt");
+    IMMOLATE = ai->getSpellIdExact("Immolate");
+    INCINERATE = ai->getSpellIdExact("Incinerate");
+    SEARING_PAIN = ai->getSpellIdExact("Searing Pain");
+    CONFLAGRATE = ai->getSpellIdExact("Conflagrate");
+    SOUL_FIRE = ai->getSpellIdExact("Soul Fire");
+    SHADOWBURN = ai->getSpellIdExact("Shadowburn");
+    SHADOWFURY = ai->getSpellIdExact("Shadowfury");
+    CHAOS_BOLT = ai->getSpellIdExact("Chaos Bolt");
+    SHADOWFLAME = ai->getSpellIdExact("Shadowflame");
+    RAIN_OF_FIRE = ai->getSpellIdExact("Rain of Fire");
+    HELLFIRE = ai->getSpellIdExact("Hellfire");
+
+
+    //DEMONOLOGY
+    DEMON_ARMOR = ai->getSpellIdExact("Demon Armor");
+    if (!DEMON_ARMOR) DEMON_ARMOR = ai->getSpellIdExact("Demon Skin");
+    FEL_ARMOR = ai->getSpellIdExact("Fel Armor");
+    SOULSHATTER = ai->getSpellIdExact("Soulshatter");
+    HEALTH_FUNNEL = ai->getSpellIdExact("Health Funnel");
+    DARK_PACT = ai->getSpellIdExact("Dark Pact");
+    SOUL_LINK = ai->getSpellIdExact("Soul Link");
+    DEMONIC_EMPOWERMENT = ai->getSpellIdExact("Demonic Empowerment");
+    METAMORPHOSIS = ai->getSpellIdExact("Metamorphosis"); //Original is learn spell
+    SUMMON_IMP = ai->getSpellIdExact("Summon Imp");
+    SUMMON_VOIDWALKER = ai->getSpellIdExact("Summon Voidwalker");
+    SUMMON_SUCCUBUS = ai->getSpellIdExact("Summon Succubus");
+    SUMMON_FELHUNTER = ai->getSpellIdExact("Summon Felhunter");
+    SUMMON_FELGUARD = ai->getSpellIdExact("Summon Felguard");
+
+
+    //CC
+    FEAR = ai->getSpellIdExact("Fear");
+    HOWL_OF_TERROR = ai->getSpellIdExact("Howl of Terror");
+    BANISH = ai->getSpellIdExact("Banish");
+    ENSLAVE_DEMON = ai->getSpellIdExact("Enslave Demon");
+
+
+    //Buff
+    UNENDING_BREATH = ai->getSpellIdExact("Unending Breath");
+    DETECT_INVISIBILITY = ai->getSpellIdExact("Detect Invisibility");
+    SHADOW_WARD = ai->getSpellIdExact("Shadow Ward");
+
+
+    //Other
+    LIFE_TAP = ai->getSpellIdExact("Life Tap");
+    CREATE_SOULSTONE = ai->getSpellIdExact("Create Soulstone");
+
+
+    SOUL_SHARD = 6265; //Soul Shard Item id
+    P_BACKLASH = 34936; //Backlash proc
+    P_NIGHTFALL= 17941; //Nightfall proc
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DEMONOLOGY = SUMMON_FELGUARD;
+    TALENT_AFFLICTION = UNSTABLE_AFFLICTION;
+    TALENT_DESTRUCTION = CONFLAGRATE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DEMONOLOGY) talentCounter++;
+    if (TALENT_AFFLICTION) talentCounter++;
+    if (TALENT_DESTRUCTION) talentCounter++;
+    if (talentCounter > 1) { TALENT_DEMONOLOGY = 0; TALENT_AFFLICTION = 0; TALENT_DESTRUCTION = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+    /*switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            if(SHADOW_BOLT > 0) CastSpell(SHADOW_BOLT);
+            return;
+    }*/
+
+    //------- Non Duel combat ----------
+
+    //ai->Follow(*GetMaster()); //don't want to melee mob
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (WARLOCK is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+        //if (pet->HasSpell(BLOOD_PACT) && ); //Cast Blood Pact
+
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( HEALTH_FUNNEL>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(HEALTH_FUNNEL,m_bot) )) { return; } //Heal pet
+
+        // Set pet to attack warlock's attacker > its own attackers > warlock's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help warlock if he's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and warlock has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= warlock) takes aggro back)
+            //Warlock should help her pet whether main tank or not, unless he's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            //need pet tanking spells
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+        }
+        else
+        {
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            //if (CastSpell(KILL_COMMAND,m_bot)) { }
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    //Buff
+    if (isUnderAttack()) { if (CastSpell (DEMON_ARMOR, m_bot)) { return; } }
+    else if (FEL_ARMOR) { if (CastSpell(FEL_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (CastSpell(METAMORPHOSIS,m_bot)) { return; }
+    if (CastSpell(DEMONIC_EMPOWERMENT,m_bot)) { return; }
+
+    //Protect
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(SOULSHATTER, m_bot)) { return; }
+        if (pTarget->GetCreatureType() == CREATURE_TYPE_DEMON && CastSpell(BANISH,pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && CastSpell(FEAR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(HOWL_OF_TERROR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(SHADOWFURY, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    //Void Walker shield?
+    if (ai->GetHealthPercent() < 70 && CastSpell(DEATH_COIL,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 70 && CastSpell(DRAIN_LIFE,pTarget)) { return; }
+    if (ai->GetManaPercent() < 70 && ai->GetManaPercent(*pTarget) > 10 && CastSpell(DRAIN_MANA,pTarget)) { return; }
+    if (ai->GetManaPercent() < 50 && pet && ai->GetManaPercent(*pet) > 50 && CastSpell(DARK_PACT,pet,1,0,1)) { return; }
+    if (ai->GetManaPercent() < 30 && ai->GetHealthPercent() > 60 && CastSpell(LIFE_TAP,m_bot,1,0,1)) { return; }
+    //Use Health stone
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(CURSE_OF_TONGUES, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(CURSE_OF_EXHAUSTION,pTarget)) return;
+    }
+
+    // Threat control
+    if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() ) { } //Continue attack
+    else
+    {
+        if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+        {
+            m_bot->SetSelection(pet->getVictim()->GetGUID());
+            return;
+        }
+        else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+        else { return; } // No more threat reducing spells, just slow down
+    }
+
+
+
+    //Urgent DPS
+    if ((m_bot->HasAura(P_NIGHTFALL) || m_bot->HasAura(P_BACKLASH)) && CastSpell(SHADOW_BOLT,pTarget)) { return; }
+    if (INCINERATE && pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) && CastSpell(INCINERATE,pTarget)) { return; }
+    if (CONFLAGRATE && (pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) || pTarget->HasAura(SHADOWFLAME,m_bot->GetGUID())) && CastSpell(CONFLAGRATE,pTarget)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) < 2 && CastSpell(SHADOWBURN,pTarget)) { return; }
+    if (ai->GetHealthPercent(*pTarget) < 5 && m_bot->GetItemCount(SOUL_SHARD) < 20 && CastSpell(DRAIN_SOUL,pTarget)) { return; }
+
+    //Dps up
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(HAUNT,pTarget)) { return; }
+
+    //AOE
+    if (isUnderAttack(m_tank,4) && CastSpell(SHADOWFLAME,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(RAIN_OF_FIRE,pTarget)) { return; }
+
+    //Dps Main
+    if(CURSE_OF_ELEMENTS) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_ELEMENTS, pTarget)) { return; } } //curse of elements trumps any other curses
+    else if (CURSE_OF_AGONY) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_AGONY, pTarget)) { return; } }
+
+    if (SEED_OF_CORRUPTION && isUnderAttack(m_tank,4)) { if (CastSpell(SEED_OF_CORRUPTION,pTarget)) { return;} }
+    else if (CastSpell(CORRUPTION,pTarget)) { return; }
+
+    if (CastSpell(CHAOS_BOLT,pTarget)) { return; }
+
+    if (UNSTABLE_AFFLICTION) { if (CastSpell(UNSTABLE_AFFLICTION,pTarget)) { return; } }
+    else if (CastSpell(IMMOLATE,pTarget)) { return; }
+
+    if (CastSpell(SHADOW_BOLT,pTarget)) { return; }
+
+
+
+
+    //Use healthstone??
+    // drink poition
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,false,false,false,false,true)) { return; }
+
+    //Own Buffs
+    if (CastSpell (FEL_ARMOR, m_bot)) { return; }
+    if (!FEL_ARMOR && CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (SOUL_LINK && m_bot->GetPet() && !m_bot->HasAuraType(SPELL_AURA_SPLIT_DAMAGE_PCT) && CastSpell(SOUL_LINK,m_bot)) { return; }
+
+    if(m_bot->GetPet() == NULL) {
+        if (SUMMON_FELGUARD)
+            CastSpell(SUMMON_FELGUARD, m_bot);
+        else
+            CastSpell(SUMMON_IMP, m_bot);
+    } else {
+    m_bot->GetPet()->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+    m_bot->GetPet()->GetCharmInfo()->SetIsCommandAttack(false);
+    }
+
+    //Create Healthstone?
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && ai->GetHealthPercent() > 60 && CastSpell (LIFE_TAP, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+
+
+} //end DoNonCombatActions
+
+bool PlayerbotWarlockAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (!HasAuraName(target, DETECT_INVISIBILITY) && CastSpell(DETECT_INVISIBILITY, target)) { return true; }
+    if (!HasAuraName(target, UNENDING_BREATH) && CastSpell(UNENDING_BREATH, target)) { return true; }
+    return false;
+}
+
+uint32 PlayerbotWarlockAI::CheckCurse(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead() || !target || target->isDead() ) { return 0; }
+    uint64 mGuid = m_bot->GetGUID();
+
+    if (CURSE_OF_ELEMENTS && target->HasAura(CURSE_OF_ELEMENTS,mGuid)) { return CURSE_OF_ELEMENTS; }
+    if (CURSE_OF_AGONY && target->HasAura(CURSE_OF_AGONY,mGuid)) { return CURSE_OF_AGONY; }
+    if (CURSE_OF_TONGUES && target->HasAura(CURSE_OF_TONGUES,mGuid)) { return CURSE_OF_TONGUES; }
+    if (CURSE_OF_WEAKNESS && target->HasAura(CURSE_OF_WEAKNESS,mGuid)) { return CURSE_OF_WEAKNESS; }
+    if (CURSE_OF_DOOM && target->HasAura(CURSE_OF_DOOM,mGuid)) { return CURSE_OF_DOOM; }
+    if (CURSE_OF_RECKLESSNESS && target->HasAura(CURSE_OF_RECKLESSNESS,mGuid)) { return CURSE_OF_RECKLESSNESS; }
+    if (CURSE_OF_EXHAUSTION && target->HasAura(CURSE_OF_EXHAUSTION,mGuid)) { return CURSE_OF_EXHAUSTION; }
+    return 0;
+}
+
+//void PlayerbotWarlockAI::BuffPlayer(Player *target){}
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotWarlockAI.h b/src/server/game/AI/BotAI/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..fa5fc00
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotWarlockAI.h
@@ -0,0 +1,55 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotWarlockAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarlockAI();
+
+        virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    uint32 CheckCurse(Unit *target);
+
+  private:
+    //CURSES
+    uint32 CURSE_OF_ELEMENTS, CURSE_OF_WEAKNESS, CURSE_OF_AGONY, CURSE_OF_RECKLESSNESS, CURSE_OF_TONGUES, CURSE_OF_DOOM, CURSE_OF_EXHAUSTION;
+
+    //AFFLICTION
+    uint32 CORRUPTION, DRAIN_SOUL, DRAIN_LIFE, DRAIN_MANA, SIPHON_LIFE, UNSTABLE_AFFLICTION, HAUNT, SEED_OF_CORRUPTION, DEATH_COIL;
+
+    //DESTRUCTION
+    uint32 SHADOW_BOLT, IMMOLATE, INCINERATE, SEARING_PAIN, CONFLAGRATE, SOUL_FIRE, SHADOWBURN, SHADOWFURY, CHAOS_BOLT, SHADOWFLAME, RAIN_OF_FIRE, HELLFIRE;
+
+    //DEMONOLOGY
+    uint32 DEMON_ARMOR, FEL_ARMOR, SOULSHATTER, HEALTH_FUNNEL, DARK_PACT, SOUL_LINK, DEMONIC_EMPOWERMENT, METAMORPHOSIS, SUMMON_IMP, SUMMON_VOIDWALKER, SUMMON_SUCCUBUS, SUMMON_FELHUNTER, SUMMON_FELGUARD;
+
+    //CC
+    uint32 FEAR, HOWL_OF_TERROR, BANISH, ENSLAVE_DEMON;
+
+    //Buff
+    uint32 UNENDING_BREATH, DETECT_INVISIBILITY, SHADOW_WARD;
+
+    //Other
+    uint32 LIFE_TAP, CREATE_SOULSTONE;
+
+    //Special
+    uint32 SOUL_SHARD, P_BACKLASH, P_NIGHTFALL, SHOOT;
+
+    uint32 TALENT_DEMONOLOGY, TALENT_AFFLICTION, TALENT_DESTRUCTION;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotWarriorAI.cpp b/src/server/game/AI/BotAI/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..ae3b251
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotWarriorAI.cpp
@@ -0,0 +1,429 @@
+/*
+Name : PlayerbotWarrior.cpp
+Complete: maybe around 75%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Intervene casting : limited / non-existant..
+                - Intervene / Piercing Howl / Hamstring are not used..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotWarriorAI.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI(){}
+
+void PlayerbotWarriorAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+   #pragma region SpellId Fill
+    //Defensive Stance
+    SHIELD_WALL = ai->getSpellIdExact("Shield Wall");
+    REVENGE = ai->getSpellIdExact("Revenge");
+    SHIELD_BLOCK = ai->getSpellIdExact("Shield Block");
+    DISARM = ai->getSpellIdExact("Disarm");
+    INTERVENE = ai->getSpellIdExact("Intervene");
+
+    //Berserker Stance
+    RECKLESSNESS = ai->getSpellIdExact("Recklessness");
+    WHIRLWIND = ai->getSpellIdExact("Whirlwind");
+    PUMMEL = ai->getSpellIdExact("Pummel");
+    INTERCEPT = ai->getSpellIdExact("Intercept");
+
+    //Battle Stance
+    RETALIATION = ai->getSpellIdExact("Retaliation");
+    CHARGE = ai->getSpellIdExact("Charge");
+    OVERPOWER = ai->getSpellIdExact("Overpower");
+    SHATTERING_THROW = ai->getSpellIdExact("Shattering Throw");
+
+    //Mixed Attacks
+    REND = ai->getSpellIdExact("Rend");                                // 1 2
+    THUNDER_CLAP = ai->getSpellIdExact("Thunder Clap");
+    SPELL_REFLECTION = ai->getSpellIdExact("Spell Reflection");
+    SHIELD_BASH = ai->getSpellIdExact("Shield Bash");
+    EXECUTE = ai->getSpellIdExact("Execute");                        // 1 3
+    HAMSTRING = ai->getSpellIdExact("Hamstring");
+    SWEEPING_STRIKES = ai->getSpellIdExact("Sweeping Strikes");
+    VICTORY_RUSH = ai->getSpellIdExact("Victory Rush");
+
+
+    //General attacks
+    HEROIC_STRIKE = ai->getSpellIdExact("Heroic Strike");
+    MORTAL_STRIKE = ai->getSpellIdExact("Mortal Strike");
+    BLOODTHIRST = ai->getSpellIdExact("Bloodthirst");
+    SHIELD_SLAM = ai->getSpellIdExact("Shield Slam");
+    SHOCKWAVE = ai->getSpellIdExact("Shockwave");
+    SLAM = ai->getSpellIdExact("Slam");
+    CLEAVE = ai->getSpellIdExact("Cleave");
+    BLADESTORM = ai->getSpellIdExact("Bladestorm");
+    HEROIC_THROW = ai->getSpellIdExact("Heroic Throw");
+    CONCUSSION_BLOW = ai->getSpellIdExact("Concussion Blow");
+    SUNDER_ARMOR = ai->getSpellIdExact("Sunder Armor");
+    DEMORALIZING_SHOUT = ai->getSpellIdExact("Demoralizing Shout");
+    INTIMIDATING_SHOUT = ai->getSpellIdExact("Intimidating Shout");
+    PIERCING_HOWL = ai->getSpellIdExact("Piercing Howl");
+    DEVASTATE = ai->getSpellIdExact("Devastate");
+
+
+    //buffs
+    COMMANDING_SHOUT = ai->getSpellIdExact("Commanding Shout");
+    BATTLE_SHOUT = ai->getSpellIdExact("Battle Shout");
+    VIGILANCE = ai->getSpellIdExact("Vigilance");
+    BERSERKER_RAGE = ai->getSpellIdExact("Berserker Rage");
+    ENRAGED_REGENERATION = ai->getSpellIdExact("Enraged Regeneration");
+    BLOODRAGE = ai->getSpellIdExact("Bloodrage");
+    LAST_STAND = ai->getSpellIdExact("Last Stand");
+    HEROIC_FURY = ai->getSpellIdExact("Heroic Fury");
+    DEATH_WISH = ai->getSpellIdExact("Death Wish");
+
+
+    //Stances
+    DEFENSIVE_STANCE = ai->getSpellIdExact("Defensive Stance");
+    BATTLE_STANCE = ai->getSpellIdExact("Battle Stance");
+    BERSERKER_STANCE = ai->getSpellIdExact("Berserker Stance");
+
+
+    //Taunts
+    TAUNT = ai->getSpellIdExact("Taunt");
+    CHALLENGING_SHOUT = ai->getSpellIdExact("Challenging Shout");
+    MOCKING_BLOW = ai->getSpellIdExact("Mocking Blow");
+
+    //Special
+    SLAMM = 46916; //Instant Slam (Blood Surge)
+
+    TALENT_ARMS = MORTAL_STRIKE;
+    TALENT_FURY = BLOODTHIRST;
+    TALENT_PROT = DEVASTATE;
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARMS) talentCounter++;
+    if (TALENT_FURY) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (talentCounter > 1) { TALENT_ARMS = 0; TALENT_FURY = 0; TALENT_PROT = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    if (!m_pulling){
+        #pragma region Choose Role / Stance
+
+        m_role = BOT_ROLE_DPS_MELEE;
+
+        // Choose Stance
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_TANK; return; }  //m_bot->GetShield(true)
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CanCast(R_SHADOWMELD,m_bot) && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (m_bot->GetShield(true)) { if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_OFFTANK; return; } }
+            else if (ChangeStance(BATTLE_STANCE)) { return; }
+        }
+        else if (ai->GetHealthPercent() > 90)
+        {
+            if (ChangeStance(BERSERKER_STANCE)) { return; }
+        }
+        else if (ai->GetForm() != FORM_BERSERKERSTANCE || ai->GetHealthPercent() < 70 ) { if (ChangeStance(BATTLE_STANCE)) { return; } }
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[7] = { HEROIC_FURY, BERSERKER_RAGE, BLADESTORM, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (m_pulling) {
+		uint32 spell = CHARGE;
+		if (m_role == BOT_ROLE_DPS_RANGED)
+			spell = SHOOT;
+        if (GetAI()->CastSpell(spell, pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+         }
+         return;
+    }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() <= 85 && CastSpell(SHIELD_BLOCK, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 45 && CastSpell(SHIELD_WALL, m_bot)) { return; }
+    if (ai->GetHealthPercent() < 55 &&
+        (m_bot->HasAura(BERSERKER_RAGE) || m_bot->HasAura(BLOODRAGE) || m_bot->HasAura(DEATH_WISH)) //There are other spells that count as enrage
+        && CastSpell(ENRAGED_REGENERATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 25 && CastSpell(INTIMIDATING_SHOUT, m_bot)) { return; }
+    if (ai->GetHealthPercent() <= 75 && CastSpell(LAST_STAND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(SPELL_REFLECTION,pTarget)) { return; }
+        if (m_bot->HasAura(SPELL_REFLECTION))
+        {
+            if (CastSpell(SHIELD_BASH,pTarget)) {} // No GCD
+            else if (CastSpell(PUMMEL,pTarget)) { return; }
+            else if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        }
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt)
+        {
+            if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_SHOUT, curAtt)) { return; }
+            if (CastSpell(TAUNT, curAtt,true,true))  { return; }
+            if (CastSpell(VIGILANCE, GetMaster())) { return; }
+            if (CastSpell(TAUNT, curAtt))  { return; }
+            if (CastSpell(MOCKING_BLOW, curAtt)) { return; }
+        }
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID())
+        {
+            if (CastSpell(VIGILANCE, pVictim)) { return; }
+            if (CastSpell(TAUNT, pTarget))  { return; }
+            if (CastSpell(MOCKING_BLOW, pTarget)) { return; }
+        }
+    }
+
+    // If not in Defensive Stance slow down due to threat
+    if (pThreat > threatThreshold && ai->GetForm() != FORM_DEFENSIVESTANCE && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //Warrior has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+
+    //Ranged Stuff (Openers)
+    if (CastSpell(CHARGE,pTarget)) { } //no GCD
+    else if (CastSpell(INTERCEPT,pTarget)) { } //no GCD
+    if (pDist > MELEE_RANGE && ai->GetForm() == FORM_DEFENSIVESTANCE && CastSpell(HEROIC_THROW,pTarget)) { return; } //High threat
+    if (pDist > MELEE_RANGE && CastSpell(SHATTERING_THROW,pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(HAMSTRING,pTarget)) return;
+        if (CastSpell(PIERCING_HOWL,pTarget)) return;
+    }
+
+
+    //Dps up
+    if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 20 && CastSpell(BLOODRAGE,m_bot))  { return; }
+    if (isUnderAttack() && CastSpell(RETALIATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 90 && CastSpell(DEATH_WISH,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 80 && CastSpell(RECKLESSNESS,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    //Tank only stuff
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 85) && CastSpell(THUNDER_CLAP)) { return; } //High threat
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 75) && CastSpell(HEROIC_STRIKE)) {} //nogcd high threat
+
+    //Finishing Move / Timed moves
+    if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(EXECUTE,pTarget)) { return; }
+    if (CastSpell(VICTORY_RUSH,pTarget)) { return; }
+
+    //AOE
+    if (CastSpell(SHOCKWAVE,pTarget)) { return; }
+    if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CLEAVE,pTarget)) {} //no GCD
+    if (isUnderAttack(m_tank,3) && CastSpell(SWEEPING_STRIKES,m_bot)) {} //no GCD
+    if (isUnderAttack(m_tank,4) && CastSpell(BLADESTORM,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(WHIRLWIND,pTarget)) { return; }
+
+    //Main dps
+    if (m_bot->HasAura(SLAMM) && CastSpell(SLAM,pTarget)) { return; }  //instant slam only
+    if (CastSpell(REVENGE,pTarget)) { return; } //Def stance only
+    if (CastSpell(OVERPOWER,pTarget)) { return; }
+    if (CastSpell(SHIELD_SLAM,pTarget)) { return; }
+    if (CastSpell(BLOODTHIRST,pTarget)) { return; }
+    if (CastSpell(MORTAL_STRIKE,pTarget)) { return; }
+
+
+    //Support/Debuff
+    if (CastSpell(DEMORALIZING_SHOUT,pTarget)) { return; }
+    if (DEVASTATE) { if (CastSpell(DEVASTATE,pTarget,1,1)) { return; } }  //High threat
+    else if (CastSpell(SUNDER_ARMOR)) { return; } //Only 1 - High threat
+    if (CastSpell(CONCUSSION_BLOW,pTarget)) { return; }
+    if (CastSpell(REND,pTarget)) { return; }
+    if (CastSpell(DISARM,pTarget)) { return; }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+    if (GetMaster()->isAlive() && CastSpell(VIGILANCE, GetMaster())) { return; }
+
+    //want to start off in battle stance so we can CHARGE
+    //if(ai->GetRageAmount() < 20 && ai->GetForm() != FORM_BATTLESTANCE && ChangeStance(BATTLE_STANCE)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 75) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotWarriorAI::ChangeStance(uint32 stance)
+{
+    if (stance == 0) return false;
+    if (CastSpell(stance, GetPlayerBot())) { return true; }
+    return false;
+}
+
+void PlayerbotWarriorAI::Pull()
+{
+	// Can pull either with ranged weapon or by charging
+	if (!SHOOT && !CHARGE) return;
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+	// Set the correct method to pull
+	switch(m_role)
+	{
+	// Charge for melee types
+	case BOT_ROLE_TANK:
+	case BOT_ROLE_OFFTANK:
+	case BOT_ROLE_DPS_MELEE:
+		if (!CHARGE)
+			m_role = BOT_ROLE_DPS_RANGED;
+		break;
+	// Shoot for other types
+	default:
+		// BOT_ROLE_NONE
+		// BOT_ROLE_DPS_RANGED
+		// BOT_ROLE_SUPPORT
+		// BOT_ROLE_HEALER
+		if (!SHOOT)
+			m_role = BOT_ROLE_DPS_MELEE;
+		break;
+	}
+
+	if (m_role == BOT_ROLE_DPS_RANGED)
+	{
+	    // check ammo
+		uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+		if (!ammo_id) {
+			GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+			if (!CHARGE)
+				return;
+			m_role = BOT_ROLE_DPS_MELEE;
+		}
+	}
+
+	m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+}
+
+/*
+void PlayerbotWarriorAI::BreakCC(const uint32 diff)
+{
+    if(pvpTrinket_cd < diff && GCD < diff)
+    {
+        if(m_creature->HasAuraType(SPELL_AURA_MOD_ROOT) ||
+        m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE) || //dragons breath/blind/poly
+        m_creature->HasAura(8983)                       || //Druid bash rank 3
+        m_creature->HasAura(27006)                      || //Druid pounce rank 4
+        m_creature->HasAura(33786)                      || //Druid cyclone
+        m_creature->HasAura(22570, 1)                   || //Druid maim
+        m_creature->HasAura(10308)                      || //Paladin hammer of justice rank 4
+        m_creature->HasAura(30414, 1)                   || //Warlock shadowfury rank 3
+        m_creature->HasAura(6215)                       || //Warlock fear rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(17928)                      || //Warlock howlofterror rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(10890)                      || //Priest psychic scream rank 4 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(14902)                      || //Rogue Cheap shot
+        m_creature->HasAura(8643)                       || //Rogue Kidney shot Rank 2
+        m_creature->HasAura(38764, 2)                   || //Rogue Gouge Rank 6 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(12809))                        //Warrior concussion blow
+        {
+            doCast(m_creature, PVPTRINKET); //I think it would be better to instead of applying individual spells that apply the
+            pvpTrinket_cd = PVPTRINKET_CD;  //effect SPELL_AURA_MOD_STUN, just add that type and start removing bad choices e.g. impact.
+        }
+
+        if(m_creature->HasAura(11297) && m_creature->GetDistance(m_creature->getVictim()) < 10)
+        {      //if warrior sapped and creature is less then 10 yards from war, cast pvp trinket and attempt to demo shout him out of stealth
+            doCast(m_creature, PVPTRINKET);
+            pvpTrinket_cd = PVPTRINKET_CD;
+            castDemoralizingShout = true;
+        }
+    }
+} //BreakCC
+*/
\ No newline at end of file
diff --git a/src/server/game/AI/BotAI/PlayerbotWarriorAI.h b/src/server/game/AI/BotAI/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..76d64ed
--- /dev/null
+++ b/src/server/game/AI/BotAI/PlayerbotWarriorAI.h
@@ -0,0 +1,57 @@
+#ifndef _PLAYERBOTWARRIORAI_H
+#define _PLAYERBOTWARRIORAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotWarriorAI : public PlayerbotClassAI
+{
+    public:
+        PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarriorAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        virtual void Pull();
+
+    private:
+        //Defensive Stance
+        uint32 SHIELD_WALL, REVENGE, SHIELD_BLOCK, DISARM, INTERVENE;
+
+        //Berserker Stance
+        uint32 RECKLESSNESS, WHIRLWIND, PUMMEL, INTERCEPT;
+
+        //Battle Stance
+        uint32 RETALIATION, CHARGE, OVERPOWER, SHATTERING_THROW;
+
+        //Mixed Attacks                                              //1 3
+        uint32 REND, THUNDER_CLAP, SPELL_REFLECTION, SHIELD_BASH, EXECUTE, HAMSTRING, SWEEPING_STRIKES, VICTORY_RUSH;
+
+        //General attacks
+        uint32 HEROIC_STRIKE, MORTAL_STRIKE, BLOODTHIRST, SHIELD_SLAM, SHOCKWAVE, SLAM, CLEAVE, BLADESTORM, HEROIC_THROW, CONCUSSION_BLOW, SUNDER_ARMOR, DEMORALIZING_SHOUT, INTIMIDATING_SHOUT, PIERCING_HOWL, DEVASTATE;
+
+        //buffs
+        uint32 COMMANDING_SHOUT, BATTLE_SHOUT, VIGILANCE, BERSERKER_RAGE, ENRAGED_REGENERATION, BLOODRAGE, LAST_STAND, HEROIC_FURY, DEATH_WISH;
+
+        //Stances
+        uint32 DEFENSIVE_STANCE, BATTLE_STANCE, BERSERKER_STANCE;
+
+        //Taunts
+        uint32 TAUNT, CHALLENGING_SHOUT, MOCKING_BLOW;
+
+        //Special
+        uint32 SLAMM;
+
+        uint32 TALENT_ARMS, TALENT_FURY, TALENT_PROT;
+
+        bool ChangeStance(uint32 stance);
+
+
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 323a3ac..62fbe69 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -127,6 +127,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/BotAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 30fe5de..cd4c3d8 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -351,6 +351,15 @@ ChatCommand * ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                                "", NULL }
     };
 
+	static ChatCommand playerbotCommandTable[] =
+	{
+		{ "add",			SEC_PLAYER,			false,	OldHandler<&ChatHandler::HandlePlayerbotAddCommand>,		"", NULL },
+		{ "login",			SEC_PLAYER,			false,	OldHandler<&ChatHandler::HandlePlayerbotAddCommand>,		"", NULL },
+		{ "remove",			SEC_PLAYER,			false,	OldHandler<&ChatHandler::HandlePlayerbotRemoveCommand>,		"", NULL },
+		{ "logout",			SEC_PLAYER,			false,	OldHandler<&ChatHandler::HandlePlayerbotRemoveCommand>,		"", NULL },
+		{ NULL,				0,					false,	NULL,														"", NULL }
+	};
+
     static ChatCommand commandTable[] =
     {
         { "character",      SEC_GAMEMASTER,     true,  NULL,                                           "", characterCommandTable},
@@ -437,6 +446,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+		{ "bot",			SEC_GAMEMASTER,		false, NULL,													"", playerbotCommandTable },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 486987d..4f9ff92 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -131,6 +131,10 @@ class ChatHandler
         bool ShowHelpForCommand(ChatCommand *table, const char* cmd);
         bool ShowHelpForSubCommands(ChatCommand *table, char const* cmd, char const* subcmd);
 
+		// Playerbot
+		bool HandlePlayerbotAddCommand(const char* args);
+		bool HandlePlayerbotRemoveCommand(const char* args);
+
         bool HandleNameAnnounceCommand(const char* args);
         bool HandleGMNameAnnounceCommand(const char* args);
         bool HandleGMAnnounceCommand(const char* args);
@@ -342,9 +346,9 @@ class ChatHandler
 
         //! Development Commands
 
-        /*bool HandleQuestAdd(const char * args);
+        bool HandleQuestAdd(const char * args);
         bool HandleQuestRemove(const char * args);
-        bool HandleQuestComplete(const char * args);*/
+        //bool HandleQuestComplete(const char * args);
 
         //bool HandleSet32Bit(const char* args);
         bool HandleSaveAllCommand(const char* args);
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 5deed67..277189d 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -29,6 +29,70 @@
 #include "revision.h"
 #include "Util.h"
 
+// Playerbot
+bool ChatHandler::HandlePlayerbotAddCommand(const char *args)
+{
+	std::string name = args;
+	if (!normalizePlayerName(name))
+		return false;
+
+	if (name == "All")
+	{
+		std::list<std::string> names;
+		m_session->GetPlayer()->GetCharacterList(names);
+
+		for(std::list<std::string>::iterator itr = names.begin(); itr != names.end(); ++itr)
+			HandlePlayerbotAddCommand(itr->c_str());
+	}
+	else
+	{
+		uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+		if (!guid || guid == m_session->GetPlayer()->GetGUID())
+		{
+			SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+		if (accountId != m_session->GetAccountId())
+		{
+			SendSysMessage("You may only add players from your account.");
+			SetSentErrorMessage(true);
+			return false;
+		}
+
+		if (m_session->GetPlayerbot(guid))
+			return false;
+		m_session->AddPlayerbot(guid);
+	}
+	return true;
+}
+
+bool ChatHandler::HandlePlayerbotRemoveCommand(const char *args)
+{
+	std::string name = args;
+	if (!normalizePlayerName(name))
+		return false;
+
+	if (name == "All")
+	{
+		std::list<std::string> names;
+		for(PlayerbotMap::const_iterator itr = m_session->GetPlayerbotsBegin(); itr != m_session->GetPlayerbotsEnd(); ++itr)
+			names.push_back(itr->second->GetName());
+		for(std::list<std::string>::iterator itr = names.begin(); itr != names.end(); ++itr)
+			HandlePlayerbotRemoveCommand(itr->c_str());
+	}
+	else
+	{
+		uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+		if (!m_session->GetPlayerbot(guid))
+			return false;
+		m_session->LogoutPlayerbot(guid, true);
+	}
+	return true;
+}
+
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
     char* cmd = strtok((char*)args, " ");
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index d5acf4b..c2f21fc 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -270,9 +270,10 @@ bool ChatHandler::HandleSummonCommand(const char* args)
                 target->UnbindInstance(pMap->GetInstanceId(), target->GetDungeonDifficulty(), true);
 
             // we are in instance, and can summon only player in our group with us as lead
-            if (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
+            if (!target->IsPlayerbot() &&
+                (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
                 (target->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()) ||
-                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()))
+                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID())))
                 // the last check is a bit excessive, but let it be, just in case
             {
                 PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST,nameLink.c_str());
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index 4043aa9..e11e3d2 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -62,6 +62,112 @@
 #include "Group.h"
 #include "ChannelMgr.h"
 
+// Playerbot - added this back in, since we need it
+bool ChatHandler::HandleQuestAdd(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .addquest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND,entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // check item starting quest (it can work incorrectly if added without item in inventory)
+    for (uint32 id = 0; id < sItemStorage.MaxEntry; id++)
+    {
+        ItemPrototype const *pProto = sItemStorage.LookupEntry<ItemPrototype>(id);
+        if (!pProto)
+            continue;
+
+        if (pProto->StartQuest == entry)
+        {
+            PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, entry, pProto->ItemId);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    // ok, normal (creature/GO starting) quest
+    if (player->CanAddQuest(pQuest, true))
+    {
+        player->AddQuest(pQuest, NULL);
+
+        if (player->CanCompleteQuest(entry))
+            player->CompleteQuest(entry);
+    }
+
+    return true;
+}
+
+// Playerbot - added this back in, since we need it
+bool ChatHandler::HandleQuestRemove(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = player->GetQuestSlotQuestId(slot);
+        if (quest == entry)
+        {
+            player->SetQuestSlot(slot,0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will updated in DB at next save)
+    player->SetQuestStatus(entry, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+    // player->getQuestStatusMap()[entry].m_QuestStatus = false;
+
+    // SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
 bool ChatHandler::HandleMaxSkillCommand(const char* /*args*/)
 {
     Player* SelectedPlayer = getSelectedPlayer();
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 1963201..e50fcc1 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -69,6 +69,10 @@
 #include "LFGMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include <cmath>
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
+
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -389,7 +393,7 @@ UpdateMask Player::updateVisualBits;
 #ifdef _MSC_VER
 #pragma warning(disable:4355)
 #endif
-Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this)
+Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this), m_PlayerbotAI(NULL)
 {
 #ifdef _MSC_VER
 #pragma warning(default:4355)
@@ -651,10 +655,62 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+	// Playerbot
+	if (m_PlayerbotAI)
+	{
+		delete m_PlayerbotAI;
+		m_PlayerbotAI = NULL;
+	}
 
     sWorld->DecreasePlayerCount();
 }
 
+// Playerbot - fill "names" will the names of players in the account not logged in
+void Player::GetCharacterList(std::list<std::string> &names)
+{
+	QueryResult results = CharacterDatabase.PQuery(
+		"SELECT name FROM characters WHERE account='%u' AND online=0",
+	m_session->GetAccountId());
+	if (!results) return;
+	do
+	{
+		Field *fields = results->Fetch();
+		std::string name = fields[0].GetString();
+		if (name == GetName()) continue;
+		names.push_back(name);
+	} while (results->NextRow());
+	return;
+}
+
+// Playerbot - Assign an AI to a Playerbot
+void Player::SetPlayerbotAI(PlayerbotAI *ai)
+{
+	if (!ai) return;
+	if (GetPlayerbotAI()) return;
+	if (!IsPlayerbot()) return;
+	m_PlayerbotAI = ai;
+	m_SaveOrgLocation = sConfig->GetBoolDefault("Bot.SaveOrgLocation", false);
+}
+
+// Playerbot - Return a Player object for a guid
+Player *Player::GetObjPlayer(uint64 guid)
+{
+	return sObjectMgr->GetPlayer(guid);
+}
+
+// Playerbot - return maximum allowed playerbots
+uint8 Player::GetMaxPlayerbots()
+{
+	return sConfig->GetIntDefault("Bot.MaxPlayerbots", 9);
+}
+
+// Playerbot - create a bot
+void Player::CreatePlayerbot(std::string name)
+{
+	uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+	m_session->AddPlayerbot(guid);
+}
+
 void Player::CleanupsBeforeDelete(bool finalCleanup)
 {
     TradeCancel(false);
@@ -1525,6 +1581,10 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    // Playerbot
+    if (m_PlayerbotAI)
+        m_PlayerbotAI->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -1780,7 +1840,8 @@ void Player::SendTeleportPacket(Position &oldPos)
     WorldPacket data2(MSG_MOVE_TELEPORT, 38);
     data2.append(GetPackGUID());
     BuildMovementPacket(&data2);
-    Relocate(&oldPos);
+    if (!this->IsPlayerbot())
+	    Relocate(&oldPos);
     SendMessageToSet(&data2, false);
 }
 
@@ -1830,6 +1891,14 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    // Playerbot: if this user has bots, tell them to stop following the master,
+    // so they don't try to follow the master after the master teleports
+    for(PlayerbotMap::const_iterator itr = GetSession()->GetPlayerbotsBegin(); itr != GetSession()->GetPlayerbotsEnd(); ++itr)
+    {
+        Player *bot = itr->second;
+        bot->GetMotionMaster()->Clear();
+    }
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -2444,7 +2513,7 @@ Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
                     return NULL;
 
     // not too far
-    if (!unit->IsWithinDistInMap(this,INTERACTION_DISTANCE))
+    if (!unit->IsWithinDistInMap(this,INTERACTION_DISTANCE) && !IsPlayerbot())
         return NULL;
 
     return unit;
@@ -2632,6 +2701,16 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+		// Playerbot - if you remove yourself from a group, logout Playerbots
+		Player *player = sObjectMgr->GetPlayer(guid);
+		if (player)
+		{
+			WorldSession *session = player->GetSession();
+			while (session->GetPlayerbotsCount())
+				session->LogoutPlayerbot(session->GetPlayerbotsBegin()->first, true);
+			if (!player->GetGroup() || group->GetMembersCount() == 0)
+				return;
+		}
         if (group->RemoveMember(guid, method, kicker, reason) <= 1)
         {
             // group->Disband(); already disbanded in RemoveMember
@@ -6856,6 +6935,11 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, int32 honor, bool pvpt
         {
             Player *pVictim = uVictim->ToPlayer();
 
+            // Playerbot: killing your own Playerbot is not honorable
+            if (pVictim->IsPlayerbot() && (!sWorld->getBoolConfig(CONFIG_HONOR_FROM_PLAYERBOTS) ||
+                pVictim->GetPlayerbotAI()->GetClassAI()->GetMaster() == this))
+                return false;
+
             if (GetTeam() == pVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                 return false;
 
@@ -12971,6 +13055,12 @@ void Player::SendBuyError(uint8 msg, Creature* pCreature, uint32 item, uint32 pa
 
 void Player::SendSellError(uint8 msg, Creature* pCreature, uint64 guid, uint32 param)
 {
+	// For Vendor interaction with Playerbots, send the SellError to the master
+	if (GetPlayerbotAI())
+	{
+		GetPlayerbotAI()->GetMaster()->SendSellError(msg, pCreature, guid, param);
+		return;
+	}
     sLog->outDebug("WORLD: Sent SMSG_SELL_ITEM");
     WorldPacket data(SMSG_SELL_ITEM,(8+8+(param?4:0)+1));  // last check 2.0.10
     data << uint64(pCreature ? pCreature->GetGUID() : 0);
@@ -13793,6 +13883,134 @@ void Player::PrepareGossipMenu(WorldObject *pSource, uint32 menuId, bool showQue
             pMenu->GetGossipMenu().AddGossipMenuItemData(itr->second.action_menu_id, itr->second.action_poi_id, itr->second.action_script_id);
         }
     }
+
+	// Now go through the options again, but add ones in for your playerbots as necessary
+	for(PlayerbotMap::const_iterator it = m_session->GetPlayerbotsBegin(); it != m_session->GetPlayerbotsEnd(); ++it)
+	{
+		Player *bot = it->second;
+		if (!bot) continue;
+
+		for(GossipMenuItemsMap::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
+		{
+			bool bCanTalk = true;
+			if (!sConditionMgr->IsPlayerMeetToConditions(bot, itr->second.conditions))
+            continue;
+
+			if (pSource->GetTypeId() == TYPEID_UNIT)
+			{
+				if (!(itr->second.npc_option_npcflag & npcflags))
+					continue;
+
+				// Right now, we'll just add Gossip options from Vendors and Trainers
+				switch(itr->second.option_id)
+				{
+					case GOSSIP_OPTION_VENDOR:
+						if (sConfig->GetBoolDefault("Bot.VendorGUI", true))
+						{
+							VendorItemData const* vItems = pCreature->GetVendorItems();
+							if (!vItems || vItems->Empty())
+								bCanTalk = false;
+						}
+						else
+							bCanTalk = false;
+						break;
+					case GOSSIP_OPTION_TRAINER:
+						// Test if the bot can be trained
+						if (sConfig->GetBoolDefault("Bot.TrainerGUI", false))
+						{
+							if (!pCreature->isCanTrainingOf(bot, false))
+								bCanTalk = false;
+						}
+						else
+							bCanTalk = false;
+						break;
+					case GOSSIP_OPTION_UNLEARNTALENTS:
+						if (sConfig->GetBoolDefault("Bot.TrainerGUI", false))
+						{
+							if (!pCreature->isCanTrainingAndResetTalentsOf(bot))
+								bCanTalk = false;
+						}
+						else
+							bCanTalk = false;
+						break;
+					case GOSSIP_OPTION_INNKEEPER:
+						break;		// Let you set the bot's soulstone
+					case GOSSIP_OPTION_UNLEARNPETTALENTS:
+						if (sConfig->GetBoolDefault("Bot.TrainerGUI", false))
+							if (!bot->GetPet() ||
+								bot->GetPet()->getPetType() != HUNTER_PET ||
+								bot->GetPet()->m_spells.size() <= 1 ||
+								pCreature->GetCreatureInfo()->trainer_type != TRAINER_TYPE_PETS ||
+								pCreature->GetCreatureInfo()->trainer_class != CLASS_HUNTER)
+								bCanTalk = false;
+						break;
+					case GOSSIP_OPTION_LEARNDUALSPEC:
+						//if (!(bot->GetSpecsCount() == 1 && pCreature->isCanTrainingAndResetTalentsOf(bot) && !(bot->getLevel() < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))))
+					case GOSSIP_OPTION_ARMORER:
+					case GOSSIP_OPTION_SPIRITHEALER:
+					case GOSSIP_OPTION_TAXIVENDOR:
+					case GOSSIP_OPTION_BATTLEFIELD:
+					case GOSSIP_OPTION_STABLEPET:
+					case GOSSIP_OPTION_QUESTGIVER:
+					case GOSSIP_OPTION_GOSSIP:
+					case GOSSIP_OPTION_SPIRITGUIDE:
+					case GOSSIP_OPTION_BANKER:
+					case GOSSIP_OPTION_PETITIONER:
+					case GOSSIP_OPTION_TABARDDESIGNER:
+					case GOSSIP_OPTION_AUCTIONEER:
+					case GOSSIP_OPTION_OUTDOORPVP:
+					default:
+						bCanTalk = false;
+						break;
+				} // switch
+			} // TYPEID_UNIT
+			else
+				bCanTalk = false;
+			/*
+			else if (pSource->GetTypeId() == TYPEID_GAMEOBJECT)
+			{
+				GameObject *pGo = (GameObject*)pSource;
+
+				switch(itr->second.option_id)
+				{
+					case GOSSIP_OPTION_QUESTGIVER:
+						if (pGo->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+							PrepareQuestMenu(pSource->GetGUID());
+						bCanTalk = false;
+						break;
+					case GOSSIP_OPTION_GOSSIP:
+						if (pGo->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && pGo->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
+							bCanTalk = false;
+						break;
+					default:
+						bCanTalk = false;
+						break;
+				}
+			}
+			*/
+
+			if (bCanTalk)
+			{
+				std::string strOptionText = itr->second.option_text;
+	            std::string strBoxText = itr->second.box_text;
+
+				int loc_idx = GetSession()->GetSessionDbLocaleIndex();
+				if (loc_idx >= 0)
+				{
+					uint32 idxEntry = MAKE_PAIR32(menuId, itr->second.id);
+					if (GossipMenuItemsLocale const *no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+					{
+						sObjectMgr->GetLocaleString(no->OptionText, loc_idx, strOptionText);
+						sObjectMgr->GetLocaleString(no->BoxText, loc_idx, strBoxText);
+					}
+				}
+				strOptionText = std::string(bot->GetName()) + ": " + strOptionText;
+
+				pMenu->GetGossipMenu().AddMenuItem(itr->second.option_icon, strOptionText, std::string(bot->GetName()).length(), itr->second.option_id, strBoxText, itr->second.box_money, itr->second.box_coded);
+				pMenu->GetGossipMenu().AddGossipMenuItemData(itr->second.action_menu_id, itr->second.action_poi_id, itr->second.action_script_id);
+			}
+		} // for for GossipMenuItems
+	} // for for Playerbots
 }
 
 void Player::SendPreparedGossip(WorldObject *pSource)
@@ -13844,6 +14062,9 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
     uint32 gossipOptionId = gossipmenu.GetItem(gossipListId).m_gOptionId;
     uint64 guid = pSource->GetGUID();
 
+	// PlayerbotAI
+	Player *bot = PlayerbotAI::GetPlayerbot(gossipmenu.GetItem(gossipListId));
+
     if (pSource->GetTypeId() == TYPEID_GAMEOBJECT)
     {
         if (gossipOptionId > GOSSIP_OPTION_QUESTGIVER)
@@ -13890,13 +14111,26 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
             break;
         case GOSSIP_OPTION_VENDOR:
         case GOSSIP_OPTION_ARMORER:
-            GetSession()->SendListInventory(guid);
+			if (bot)
+				bot->GetPlayerbotAI()->SendVendorList(GetSession(), pSource->ToUnit());
+			else
+	            GetSession()->SendListInventory(guid);
             break;
         case GOSSIP_OPTION_STABLEPET:
             GetSession()->SendStablePet(guid);
             break;
         case GOSSIP_OPTION_TRAINER:
-            GetSession()->SendTrainerList(guid);
+			if (bot)
+			{
+				GetSession()->GetPlayerbotData()->currTrainer = pSource->ToCreature();
+				bot->GetPlayerbotAI()->SendTrainerList(GetSession());
+			}
+			else
+			{
+				GetSession()->GetPlayerbotData()->currTrainer = NULL;
+				GetSession()->GetPlayerbotData()->currTrainee = NULL;
+	            GetSession()->SendTrainerList(guid);
+			}
             break;
         case GOSSIP_OPTION_LEARNDUALSPEC:
             if (GetSpecsCount() == 1 && !(getLevel() < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL)))
@@ -13922,19 +14156,35 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
             }
             break;
         case GOSSIP_OPTION_UNLEARNTALENTS:
+			if (bot)
+			{
+				GetSession()->GetPlayerbotData()->currTrainer = pSource->ToCreature();
+				GetSession()->GetPlayerbotData()->currTrainee = bot;
+			}
+			else
+			{
+				GetSession()->GetPlayerbotData()->currTrainer = NULL;
+				GetSession()->GetPlayerbotData()->currTrainee = NULL;
+			}
             PlayerTalkClass->CloseGossip();
             pSource->ToCreature()->CastSpell(this, 46331, true); // Trainer: Untrain Talents
             break;
         case GOSSIP_OPTION_UNLEARNPETTALENTS:
             PlayerTalkClass->CloseGossip();
-            ResetPetTalents();
+			if (bot)
+				bot->ResetPetTalents();
+			else
+				ResetPetTalents();
             break;
         case GOSSIP_OPTION_TAXIVENDOR:
             GetSession()->SendTaxiMenu((pSource->ToCreature()));
             break;
         case GOSSIP_OPTION_INNKEEPER:
             PlayerTalkClass->CloseGossip();
-            SetBindPoint(guid);
+			if (bot)
+				bot->SetBindPoint(guid);
+			else
+				SetBindPoint(guid);
             break;
         case GOSSIP_OPTION_BANKER:
             GetSession()->SendShowBank(guid);
@@ -15477,6 +15727,13 @@ void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
                             m_QuestStatusSave[questid] = true;
 
                             SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curkillcount, addkillcount);
+
+							// Playerbot
+							if (m_PlayerbotAI)
+							{
+								ChatHandler ch(m_PlayerbotAI->GetClassAI()->GetMaster());
+								ch.PSendSysMessage("%s needs %u more.", GetName(), reqkillcount-curkillcount);
+							}
                         }
                         if (CanCompleteQuest(questid))
                             CompleteQuest(questid);
@@ -15488,6 +15745,9 @@ void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
             }
         }
     }
+    // Playerbot
+    if (m_PlayerbotAI)
+        m_PlayerbotAI->KilledMonster(entry, guid);
 }
 
 void Player::CastedCreatureOrGO(uint32 entry, uint64 guid, uint32 spell_id)
@@ -16734,6 +16994,32 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     return true;
 }
 
+bool Player::isAllowedToLoot(Loot *loot)
+{
+	Group *thisGroup = GetGroup();
+	switch(thisGroup->GetLootMethod())
+	{
+	case FREE_FOR_ALL:
+		return true;
+	case ROUND_ROBIN:
+		if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
+			return true;
+		return false;
+	case MASTER_LOOT:
+		if (thisGroup->GetLooterGuid() == GetGUID())
+			return true;
+		return false;
+	case GROUP_LOOT:
+	case NEED_BEFORE_GREED:
+		if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
+			return true;
+		if (loot->hasOverThresholdItem())
+			return true;
+		return false;
+	}
+	return false;
+}
+
 bool Player::isAllowedToLoot(const Creature* creature)
 {
     if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
@@ -17938,25 +18224,38 @@ void Player::SaveToDB()
         << GetUInt32Value(PLAYER_BYTES_2) << ", "
         << GetUInt32Value(PLAYER_FLAGS) << ", ";
 
-    if (!IsBeingTeleported())
-    {
-        ss << GetMapId() << ", "
-        << (uint32)GetInstanceId() << ", "
-        << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
-        << finiteAlways(GetPositionX()) << ", "
-        << finiteAlways(GetPositionY()) << ", "
-        << finiteAlways(GetPositionZ()) << ", "
-        << finiteAlways(GetOrientation()) << ", ";
-    }
-    else
-    {
-        ss << GetTeleportDest().GetMapId() << ", "
-        << (uint32)0 << ", "
-        << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
-        << finiteAlways(GetTeleportDest().GetPositionX()) << ", "
-        << finiteAlways(GetTeleportDest().GetPositionY()) << ", "
-        << finiteAlways(GetTeleportDest().GetPositionZ()) << ", "
-        << finiteAlways(GetTeleportDest().GetOrientation()) << ", ";
+	if (IsPlayerbot() && m_SaveOrgLocation)
+	{
+		ss << m_PlayerbotAI->GetStartMapID() << ", "
+           << uint32(m_PlayerbotAI->GetStartInstanceID()) << ", "
+           << uint32(m_PlayerbotAI->GetStartDifficulty()) << ", "
+           << finiteAlways(m_PlayerbotAI->GetStartX()) << ", "
+           << finiteAlways(m_PlayerbotAI->GetStartY()) << ", "
+           << finiteAlways(m_PlayerbotAI->GetStartZ()) << ", "
+           << finiteAlways(m_PlayerbotAI->GetStartO()) << ", ";
+	}
+	else
+	{
+		if (!IsBeingTeleported())
+		{
+	        ss << GetMapId() << ", "
+              << (uint32)GetInstanceId() << ", "
+              << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
+              << finiteAlways(GetPositionX()) << ", "
+              << finiteAlways(GetPositionY()) << ", "
+              << finiteAlways(GetPositionZ()) << ", "
+              << finiteAlways(GetOrientation()) << ", ";
+		}
+		else
+		{
+	        ss << GetTeleportDest().GetMapId() << ", "
+              << (uint32)0 << ", "
+              << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
+              << finiteAlways(GetTeleportDest().GetPositionX()) << ", "
+              << finiteAlways(GetTeleportDest().GetPositionY()) << ", "
+              << finiteAlways(GetTeleportDest().GetPositionZ()) << ", "
+              << finiteAlways(GetTeleportDest().GetOrientation()) << ", ";
+		}
     }
 
     ss << m_taxi << ", ";                                   // string with TaxiMaskSize numbers
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index caabac6..04f70d6 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -51,6 +51,7 @@ class PlayerMenu;
 class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
+class PlayerbotAI;
 
 typedef std::deque<Mail*> PlayerMails;
 
@@ -995,6 +996,21 @@ class Player : public Unit, public GridObject<Player>
         explicit Player (WorldSession *session);
         ~Player ();
 
+		// Playerbot
+	public:
+		void CreatePlayerbot(std::string name);
+		uint8 GetMaxPlayerbots();
+		Player *GetObjPlayer(uint64 guid);
+		void GetCharacterList(std::list<std::string> &names);
+		void SetPlayerbotAI(PlayerbotAI *ai);
+		PlayerbotAI *GetPlayerbotAI() { return m_PlayerbotAI; }
+		bool IsPlayerbot() { return (GetSession()->GetRemoteAddress() == "bot"); }
+	private:
+		PlayerbotAI *m_PlayerbotAI;
+		bool		m_SaveOrgLocation;
+	public:
+		// END Playerbot
+
         void CleanupsBeforeDelete(bool finalCleanup = true);
 
         static UpdateMask updateVisualBits;
@@ -2343,6 +2359,7 @@ class Player : public Unit, public GridObject<Player>
         void ResetMap();
 
         bool isAllowedToLoot(const Creature* creature);
+		bool isAllowedToLoot(Loot *loot);
 
         DeclinedName const* GetDeclinedNames() const { return m_declinedname; }
         uint8 GetRunesState() const { return m_runes->runeState; }
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 6c56c9c..f7af6b2 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -33,6 +33,10 @@
 #include "MapInstanced.h"
 #include "Util.h"
 #include "LFGMgr.h"
+// Playerbot
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -92,6 +96,24 @@ Group::~Group()
     delete[] m_subGroupsCounts;
 }
 
+// Playerbot
+uint64 Group::GetTargetWithIconByGroup(uint64 guid)
+{
+	uint64 targetGUID;
+	switch(GetMemberGroup(guid))
+	{
+	case 0: targetGUID = m_targetIcons[STAR]; break;
+	case 1: targetGUID = m_targetIcons[CIRCLE]; break;
+	case 2: targetGUID = m_targetIcons[DIAMOND]; break;
+	case 3: targetGUID = m_targetIcons[TRIANGLE]; break;
+	case 4: targetGUID = m_targetIcons[MOON]; break;
+	case 5: targetGUID = m_targetIcons[SQUARE]; break;
+	case 6: targetGUID = m_targetIcons[CROSS]; break;
+	default:targetGUID = m_targetIcons[STAR]; break;
+	}
+	return targetGUID;
+}
+
 bool Group::Create(const uint64 &guid, const char * name)
 {
     uint32 lowguid = sObjectMgr->GenerateLowGuid(HIGHGUID_GROUP);
@@ -104,7 +126,7 @@ bool Group::Create(const uint64 &guid, const char * name)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
-    m_lootMethod = GROUP_LOOT;
+    m_lootMethod = static_cast<LootMethod>(sConfig->GetIntDefault("Bot.LootMethod", MASTER_LOOT));
     m_lootThreshold = ITEM_QUALITY_UNCOMMON;
     m_looterGuid = guid;
 
@@ -364,6 +386,17 @@ bool Group::AddMember(const uint64 &guid, const char* name)
 uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = GROUP_REMOVEMETHOD_DEFAULT */, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
 {
     BroadcastGroupUpdate();
+    // Playerbot
+    {
+        Player *player = sObjectMgr->GetPlayer(guid);
+        if (player && !player->IsPlayerbot())
+        {
+            // Log out any Playerbots owned by this player
+            WorldSession *session = player->GetSession();
+            while (session->GetPlayerbotsCount() > 0)
+                session->LogoutPlayerbot(session->GetPlayerbotsBegin()->first, true);
+        }
+    }
 
     sScriptMgr->OnGroupRemoveMember(this, guid, method, kicker, reason);
 
@@ -423,6 +456,20 @@ uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = G
 
 void Group::ChangeLeader(const uint64 &guid)
 {
+    // Playerbot: keep looping until we find a valid player and not a bot
+    Player *player = sObjectMgr->GetPlayer(guid);
+    if (!player)
+    {
+        for(member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+        {
+            if (sObjectMgr->GetPlayer(itr->guid))
+            {
+                _setLeader(itr->guid);
+                return;
+            }
+        }
+        return;
+    }
     member_citerator slot = _getMemberCSlot(guid);
 
     if (slot == m_memberSlots.end())
@@ -1438,6 +1485,20 @@ bool Group::_setMainTank(const uint64 &guid, const bool &apply)
     if (!isBGGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    // Playerbot: acknowledge setting of main tank
+    Player *player = sObjectMgr->GetPlayer(guid);
+    if (player->GetPlayerbotAI() != NULL)
+    {
+        if (apply)
+        {
+            player->HandleEmoteCommand(EMOTE_ONESHOT_ROAR);
+        }
+        else
+        {
+            player->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+        }
+    }
+
     return true;
 }
 
@@ -1453,6 +1514,20 @@ bool Group::_setMainAssistant(const uint64 &guid, const bool &apply)
     if (!isBGGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    // Tell all the Playerbots who is the main tank now
+    if (apply)
+    {
+        for(GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *player = itr->getSource();
+            if (player->IsPlayerbot())
+            {
+                PlayerbotAI *ai = player->GetPlayerbotAI();
+                ai->GetClassAI()->SetMainTank(sObjectMgr->GetPlayer(guid));
+            }
+        }
+    }
+
     return true;
 }
 
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index d7fb7c7..26b7ab6 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -111,6 +111,17 @@ enum GroupUpdateFlags
     GROUP_UPDATE_FULL                   = 0x0007FFFF,       // all known flags
 };
 
+enum TARGETICON
+{
+    STAR        = 0,
+    CIRCLE      = 1,
+    DIAMOND     = 2,
+    TRIANGLE    = 3,
+    MOON        = 4,
+    SQUARE      = 5,
+    CROSS       = 6,
+    SKULL       = 7,
+};
 #define GROUP_UPDATE_FLAGS_COUNT          20
                                                                 // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19
 static const uint8 GroupUpdateLength[GROUP_UPDATE_FLAGS_COUNT] = { 0, 2, 2, 2, 1, 2, 2, 2, 2, 4, 8, 8, 1, 2, 2, 2, 1, 2, 2, 8};
@@ -175,6 +186,10 @@ class Group
         Group();
         ~Group();
 
+		// Playerbot
+		uint64 GetTargetWithIconByGroup(uint64 guid);
+		void SetTargetIcon(uint8 id, uint64 guid);
+
         // group manipulation methods
         bool   Create(const uint64 &guid, const char * name);
         bool   LoadGroupFromDB(const uint32 &guid, QueryResult result, bool loadMembers = true);
diff --git a/src/server/game/Guilds/Guild.h b/src/server/game/Guilds/Guild.h
index a115cfa..367f9de 100755
--- a/src/server/game/Guilds/Guild.h
+++ b/src/server/game/Guilds/Guild.h
@@ -689,8 +689,10 @@ protected:
 
 private:
     inline uint8 _GetRanksSize() const { return uint8(m_ranks.size()); }
+public:		// Playerbot
     inline const RankInfo *GetRankInfo(uint8 rankId) const { return rankId < _GetRanksSize() ? &m_ranks[rankId] : NULL; }
     inline RankInfo *GetRankInfo(uint8 rankId) { return rankId < _GetRanksSize() ? &m_ranks[rankId] : NULL; }
+private:
     inline bool _HasRankRight(Player* player, uint32 right) const { return (_GetRankRights(player->GetRank()) & right) != GR_RIGHT_EMPTY; }
     inline uint8 _GetLowestRankId() const { return uint8(m_ranks.size() - 1); }
 
diff --git a/src/server/game/Loot/LootMgr.cpp b/src/server/game/Loot/LootMgr.cpp
index 46953d4..71d7652 100755
--- a/src/server/game/Loot/LootMgr.cpp
+++ b/src/server/game/Loot/LootMgr.cpp
@@ -24,6 +24,7 @@
 #include "SharedDefines.h"
 #include "SpellMgr.h"
 #include "Group.h"
+#include "PlayerbotAI.h"
 
 static Rates const qualityToRate[MAX_ITEM_QUALITY] = {
     RATE_DROP_ITEM_POOR,                                    // ITEM_QUALITY_POOR
@@ -728,6 +729,29 @@ uint32 Loot::GetMaxSlotInLootFor(Player* player) const
     return items.size() + (itr != PlayerQuestItems.end() ?  itr->second->size() : 0);
 }
 
+// return true if there is any FFA, quest or conditional item for a bot.
+bool Loot::hasItemForBot(Player *player) const
+{
+	PlayerbotAI *bot = player->GetPlayerbotAI();
+	if (!bot) return false;
+
+	for(LootItemList::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+	{
+		if (bot->needItem(itr->itemid))
+			return true;
+		if (itr->freeforall)
+			return true;
+	}
+	for(LootItemList::const_iterator itr = quest_items.begin(); itr != quest_items.end(); ++itr)
+	{
+		if (bot->needItem(itr->itemid))
+			return true;
+		if (itr->freeforall)
+			return true;
+	}
+	return false;
+}
+
 // return true if there is any FFA, quest or conditional item for the player.
 bool Loot::hasItemFor(Player* player) const
 {
@@ -770,6 +794,18 @@ bool Loot::hasItemFor(Player* player) const
         }
     }
 
+	// If one of the player's bots can loot it, return true.  This will allow the "sparklies" to show
+	// up and allow you to activate the object, then your bots will loot it.
+	if (!player->IsPlayerbot())
+	{
+		WorldSession *session = player->GetSession();
+		for(PlayerbotMap::const_iterator it = session->GetPlayerbotsBegin(); it != session->GetPlayerbotsEnd(); ++it)
+		{
+			if (hasItemForBot(it->second))
+				return true;
+		}
+	}
+
     return false;
 }
 
diff --git a/src/server/game/Loot/LootMgr.h b/src/server/game/Loot/LootMgr.h
index aeb4cdb..e7fb2b3 100755
--- a/src/server/game/Loot/LootMgr.h
+++ b/src/server/game/Loot/LootMgr.h
@@ -277,7 +277,7 @@ struct Loot
     QuestItemMap const& GetPlayerFFAItems() const { return PlayerFFAItems; }
     QuestItemMap const& GetPlayerNonQuestNonFFAConditionalItems() const { return PlayerNonQuestNonFFAConditionalItems; }
 
-    std::vector<LootItem> items;
+    LootItemList items;
     uint32 gold;
     uint8 unlootedCount;
     uint64 roundRobinPlayer;                                // GUID of the player having the Round-Robin ownership for the loot. If 0, round robin owner has released.
@@ -333,6 +333,7 @@ struct Loot
 
     LootItem* LootItemInSlot(uint32 lootslot, Player* player, QuestItem** qitem = NULL, QuestItem** ffaitem = NULL, QuestItem** conditem = NULL);
     uint32 GetMaxSlotInLootFor(Player* player) const;
+	bool hasItemForBot(Player *bot) const;
     bool hasItemFor(Player* player) const;
     bool hasOverThresholdItem() const;
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index b754c87..7f3bcb4 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2208,7 +2208,9 @@ void InstanceMap::InitVisibilityDistance()
 */
 bool InstanceMap::CanEnter(Player *player)
 {
-    if (player->GetMapRef().getTarget() == this)
+    // Playerbots calls this twice, first by TeleportTO and again by WorldSession
+    // Don't want to error since we know we are already there
+    if (player->GetMapRef().getTarget() == this && !player->IsPlayerbot())
     {
         sLog->outError("InstanceMap::CanEnter - player %s(%u) already in map %d,%d,%d!", player->GetName(), player->GetGUIDLow(), GetId(), GetInstanceId(), GetSpawnMode());
         ASSERT(false);
@@ -2307,15 +2309,22 @@ bool InstanceMap::Add(Player *player)
                 Group *pGroup = player->GetGroup();
                 if (pGroup)
                 {
+                    // Playerbot
+                    bool isBot = player->IsPlayerbot();
                     // solo saves should be reset when entering a group
                     InstanceGroupBind *groupBind = pGroup->GetBoundInstance(this);
                     if (playerBind)
                     {
-                        sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(pGroup->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
-                        if (groupBind) sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
-                        //ASSERT(false);
-                        return false;
-                    }
+                        // Playerbot
+                        if (isBot)
+                            player->UnbindInstance(mapSave->GetMapId(), mapSave->GetDifficulty(), true);
+                        else
+						{
+                            sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(pGroup->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
+                            if (groupBind) sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
+                            //ASSERT(false);
+                            return false;
+                        }
                     // bind to the group or keep using the group save
                     if (!groupBind)
                         pGroup->BindToInstance(mapSave, false);
@@ -2376,6 +2385,7 @@ bool InstanceMap::Add(Player *player)
         i_data->OnPlayerEnter(player);
 
     return true;
+    }
 }
 
 void InstanceMap::Update(const uint32& t_diff)
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
index 3f4a853..48dc0ee 100755
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -1542,6 +1542,7 @@ enum TextEmotes
     TEXTEMOTE_FLIRT                = 328,
     TEXTEMOTE_JOKE                 = 329,
     TEXTEMOTE_COMMEND              = 243,
+	TEXTEMOTE_FOLLOWME			   = 324,
     TEXTEMOTE_WINK                 = 363,
     TEXTEMOTE_PAT                  = 364,
     TEXTEMOTE_SERIOUS              = 365,
@@ -2893,9 +2894,10 @@ enum XPColorChar
 
 enum RemoveMethod
 {
-    GROUP_REMOVEMETHOD_DEFAULT = 0,
-    GROUP_REMOVEMETHOD_KICK    = 1,
-    GROUP_REMOVEMETHOD_LEAVE   = 2,
+    GROUP_REMOVEMETHOD_DEFAULT      = 0,
+    GROUP_REMOVEMETHOD_KICK         = 1,
+    GROUP_REMOVEMETHOD_LEAVE        = 2,
+    GROUP_REMOVEMETHOD_PLAYERBOT    = 3,
 };
 
 #endif
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 37358c7..63c1e81 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -96,9 +96,9 @@ enum QuestStatus
 {
     QUEST_STATUS_NONE           = 0,
     QUEST_STATUS_COMPLETE       = 1,
-    //QUEST_STATUS_UNAVAILABLE    = 2,
+    QUEST_STATUS_UNAVAILABLE    = 2,
     QUEST_STATUS_INCOMPLETE     = 3,
-    //QUEST_STATUS_AVAILABLE      = 4,
+    QUEST_STATUS_AVAILABLE      = 4,
     QUEST_STATUS_FAILED         = 5,
     MAX_QUEST_STATUS
 };
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index 80682ff..e279c9c 100755
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -40,6 +40,8 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "Battleground.h"
+#include "PlayerbotAI.h"
+#include "Config.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -193,6 +195,110 @@ bool LoginQueryHolder::Initialize()
     return res;
 }
 
+void WorldSession::HandlePlayerbotLogin(LoginQueryHolder *holder)
+{
+	if (!holder) return;
+
+	if (!holder->GetAccountId())
+	{
+		delete holder;
+		return;
+	}
+
+	WorldSession *master = sWorld->FindSession(holder->GetAccountId());
+	if (!master)
+	{
+		delete holder;
+		return;
+	}
+	WorldSession *botSession = new WorldSession(holder->GetAccountId(), NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0);
+	if (!botSession)
+	{
+		delete holder;
+		return;
+	}
+	botSession->m_Address = "bot";
+
+	uint64 guid = holder->GetGuid();
+	if (!guid)
+	{
+		delete holder;
+		delete botSession;
+		return;
+	}
+
+	Group *group = master->GetPlayer()->GetGroup();
+	if (group && group->IsFull() && !group->IsMember(guid))
+	{
+		delete holder;
+		delete botSession;
+		ChatHandler ch(master);
+		ch.SendSysMessage("Bot removed because group is full.");
+		return;
+	}
+
+	botSession->HandlePlayerLogin(holder);
+	Player *bot = botSession->GetPlayer();
+
+	if (!bot)
+	{
+		delete botSession;
+		// holder deleted by HandlePlayerLogin
+		return;
+	}
+
+	PlayerbotAI *ai = new PlayerbotAI(master->GetPlayer(), bot);
+	bot->SetPlayerbotAI(ai);
+
+	// Set some initial data
+	ai->SetStartDifficulty(bot->GetDungeonDifficulty());
+	ai->SetStartInstanceID(bot->GetInstanceId());
+	ai->SetStartMapID(bot->GetMapId());
+	ai->SetStartZoneID(bot->GetZoneId());
+	ai->SetStartAreaID(bot->GetAreaId());
+	ai->SetStartO(bot->GetOrientation());
+	ai->SetStartX(bot->GetPositionX());
+	ai->SetStartY(bot->GetPositionY());
+	ai->SetStartZ(bot->GetPositionZ());
+
+	// Tell the master's WorldSession that it owns this Playerbot
+	master->m_PlayerbotData->Bots[guid] = bot;
+
+	// If bot is in a group and the master isn't, leave the group
+	if (bot->GetGroup() &&
+		(!master->GetPlayer()->GetGroup() ||
+		 !master->GetPlayer()->GetGroup()->IsMember(guid)))
+		 bot->RemoveFromGroup(GROUP_REMOVEMETHOD_PLAYERBOT);
+}
+
+void WorldSession::AddPlayerbot(uint64 guid)
+{
+	// Is bot already added?
+	if (GetPlayerbot(guid)) return;
+
+	ChatHandler ch(GetPlayer());
+
+	// Check if max Playerbots is exceeded
+	uint8 maxPlayerbots = sConfig->GetIntDefault("Bot.MaxPlayerbots", 9);
+	if (GetPlayerbotsCount() >= maxPlayerbots)
+	{
+		ch.PSendSysMessage("You have reached the maximum (%d) allowed Playerbots.", maxPlayerbots);
+		return;
+	}
+
+	LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), guid);
+	if (!holder->Initialize())
+	{
+		delete holder;
+		return;
+	}
+
+	m_PlayerbotData->LoginCallbacks.push_back(CharacterDatabase.DelayQueryHolder((SQLQueryHolder *)holder));
+}
+
+
+
+
 void WorldSession::HandleCharEnum(QueryResult result)
 {
     WorldPacket data(SMSG_CHAR_ENUM, 100);                  // we guess size
diff --git a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
index 9981dfe..e1444ac 100755
--- a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
@@ -38,6 +38,7 @@
 #include "SpellAuraEffects.h"
 #include "Util.h"
 #include "ScriptMgr.h"
+#include "PlayerbotAI.h"
 
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
@@ -290,7 +291,15 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
                 return;
             }
 
-            GetPlayer()->Whisper(msg, lang, player->GetGUID());
+            // Playerbot: handle whispered commands to bots
+            if (player->GetPlayerbotAI())
+            {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                GetPlayer()->Whisper(msg, lang, player->GetGUID());
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
diff --git a/src/server/game/Server/Protocol/Handlers/GuildHandler.cpp b/src/server/game/Server/Protocol/Handlers/GuildHandler.cpp
index 9fae9ab..1c19b82 100755
--- a/src/server/game/Server/Protocol/Handlers/GuildHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GuildHandler.cpp
@@ -356,8 +356,22 @@ void WorldSession::HandleGuildBankerActivate(WorldPacket & recv_data)
 
     if (GetPlayer()->GetGameObjectIfCanInteractWith(GoGuid, GAMEOBJECT_TYPE_GUILD_BANK))
     {
-        if (Guild* pGuild = _GetPlayerGuild(this))
-            pGuild->SendBankTabsInfo(this);
+		if (Guild* pGuild = _GetPlayerGuild(this))
+		{
+			// Playerbot - resend the permissions, since we
+			// screw with them to create the fake guild bank
+			// used for inventory management
+			pGuild->SendPermissions(this);
+			pGuild->SendBankTabsInfo(this);
+		}
+		if (Guild* pGuild = _GetPlayerGuild(this))
+		{
+			// Playerbot - resend the permissions, since we
+			// screw with them to create the fake guild bank
+			// used for inventory management
+			pGuild->SendPermissions(this);
+			pGuild->SendBankTabsInfo(this);
+		}
         else
             Guild::SendCommandResult(this, GUILD_UNK1, ERR_GUILD_PLAYER_NOT_IN_GUILD);
     }
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
index 73e4f29..5efe8e8 100755
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -49,6 +49,7 @@
 #include "InstanceScript.h"
 #include "GameObjectAI.h"
 #include "Group.h"
+#include "PlayerbotAI.h"
 
 void WorldSession::HandleRepopRequestOpcode(WorldPacket & recv_data)
 {
@@ -1234,7 +1235,10 @@ void WorldSession::HandleInspectOpcode(WorldPacket& recv_data)
     WorldPacket data(SMSG_INSPECT_TALENT, guid_size+4+talent_points);
     data.append(plr->GetPackGUID());
 
-    if (sWorld->getBoolConfig(CONFIG_TALENTS_INSPECTING) || _player->isGameMaster())
+    if (sWorld->getBoolConfig(CONFIG_TALENTS_INSPECTING) ||
+        _player->isGameMaster() ||
+        (plr->GetPlayerbotAI() && plr->GetPlayerbotAI()->canObeyCommandFrom(*_player))
+        )
     {
         plr->BuildPlayerTalentsInfoData(&data);
     }
diff --git a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
index 051cb12..cd6d716 100755
--- a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
@@ -583,6 +583,20 @@ void WorldSession::HandleQuestPushResult(WorldPacket& recvPacket)
     }
 }
 
+uint32 WorldSession::getBotDialogStatus(Player *pPlayer, Object* questgiver, uint32 defstatus)
+{
+	uint32 result = 0;
+	WorldSession *session = pPlayer->GetSession();
+	for(PlayerbotMap::const_iterator itr = session->GetPlayerbotsBegin(); itr != session->GetPlayerbotsEnd(); ++itr)
+	{
+		Player *bot = itr->second;
+		uint32 result2 = getDialogStatus(bot, questgiver, defstatus);
+		if (result2 > result)
+			result = result2;
+	}
+	return result;
+}
+
 uint32 WorldSession::getDialogStatus(Player *pPlayer, Object* questgiver, uint32 defstatus)
 {
     uint32 result = defstatus;
@@ -676,6 +690,17 @@ uint32 WorldSession::getDialogStatus(Player *pPlayer, Object* questgiver, uint32
         if (result2 > result)
             result = result2;
     }
+	if (!pPlayer->IsPlayerbot())
+	{
+		// Make bot's available quests show up, but as blue icons (repeatable)
+		uint32 result2 = getBotDialogStatus(pPlayer, questgiver, defstatus);
+		//if (result2 == DIALOG_STATUS_REWARD || result2 == DIALOG_STATUS_REWARD2)
+		//	result2 = DIALOG_STATUS_REWARD_REP;
+		//if (result2 == DIALOG_STATUS_AVAILABLE)
+		//	result2 = DIALOG_STATUS_AVAILABLE_REP;
+		if (result2 > result)
+			result = result2;
+	}
 
     return result;
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 0670e20..af4281a 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -41,6 +41,7 @@
 #include "zlib.h"
 #include "ScriptMgr.h"
 #include "Transport.h"
+#include "PlayerbotAI.h"
 
 bool MapSessionFilter::Process(WorldPacket *packet)
 {
@@ -92,7 +93,7 @@ m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld->GetAvailableDbcLocale(locale)),
 m_sessionDbLocaleIndex(locale),
-m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter)
+m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter), m_PlayerbotData(new PlayerbotData)
 {
     if (sock)
     {
@@ -106,6 +107,10 @@ m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter)
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
+    // Playerbot: log out any Playerbots
+    while (!m_PlayerbotData->Bots.empty())
+        LogoutPlayerbot(GetPlayerbotsBegin()->first, true);
+
     ///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
@@ -123,9 +128,57 @@ WorldSession::~WorldSession()
     while (_recvQueue.next(packet))
         delete packet;
 
+	// Clean up PlayerbotData
+	delete m_PlayerbotData;
+
     LoginDatabase.PExecute("UPDATE account SET online = 0 WHERE id = %u;", GetAccountId());
 }
 
+// Playerbot - return the Player object for a bot of the given GUID
+Player * WorldSession::GetPlayerbot(uint64 guid)
+{
+	PlayerbotMap::const_iterator it = m_PlayerbotData->Bots.find(guid);
+	return (it == GetPlayerbotsEnd()) ? 0 : it->second;
+}
+
+// Playerbot - return iterator to the beginning of the PlayerbotMap
+PlayerbotMap::const_iterator WorldSession::GetPlayerbotsBegin() const
+{
+	return m_PlayerbotData->Bots.begin();
+}
+
+// Playerbot - return iterator to the end of the PlayerbotMap
+PlayerbotMap::const_iterator WorldSession::GetPlayerbotsEnd() const
+{
+	return m_PlayerbotData->Bots.end();
+}
+
+// Playerbot - return the number of Playerbots logged in for this account
+uint8 WorldSession::GetPlayerbotsCount() const
+{
+	uint8 count = 0;
+	for(PlayerbotMap::const_iterator it = GetPlayerbotsBegin(); it != GetPlayerbotsEnd(); ++it)
+	{
+		if (!it->second) continue;
+		++count;
+	}
+	return count;
+}
+
+// Playerbot - log out a Playerbot
+void WorldSession::LogoutPlayerbot(uint64 guid, bool Save)
+{
+	Player *bot = GetPlayerbot(guid);
+	if (!bot) return;
+
+	bot->CombatStop();
+
+	WorldSession *botSession = bot->GetSession();
+	m_PlayerbotData->Bots.erase(guid);
+	botSession->LogoutPlayer(Save);
+	delete botSession;
+}
+
 void WorldSession::SizeError(WorldPacket const &packet, uint32 size) const
 {
     sLog->outError("Client (account %u) send packet %s (%u) with size " SIZEFMTD " but expected %u (attempt to crash server?), skipped",
@@ -141,6 +194,18 @@ char const *WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const *packet)
 {
+    // Playerbot
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI())
+    {
+        // This is a Playerbot, so send the packets to its AI instead of a client
+        GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+    }
+    else if (!m_PlayerbotData->Bots.empty())
+    {
+        // This is a real player with Playerbots, so send the packet to its bots as well
+        PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+    }
+
     if (!m_Socket)
         return;
 
@@ -243,9 +308,19 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                         else if (_player->IsInWorld())
                         {
                             sScriptMgr->OnPacketReceive(m_Socket, WorldPacket(*packet));
-                            (this->*opHandle.handler)(*packet);
-                            if (sLog->IsOutDebug() && packet->rpos() < packet->wpos())
-                                LogUnprocessedTail(packet);
+
+                            // Playerbot - process packets, and see if they need the default server processing
+                            if (!PlayerbotAI::HandlePlayerIncomingPacket(*packet, this))
+                            {
+                                (this->*opHandle.handler)(*packet);
+                                if (sLog->IsOutDebug() && packet->rpos() < packet->wpos())
+                                    LogUnprocessedTail(packet);
+
+                                // Playerbot - send the packet to the master's bots
+                                if (!m_PlayerbotData->Bots.empty())
+                                    PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
+                            }
+
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -325,6 +400,28 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         ///- If necessary, log the player out
         if (ShouldLogOut(currTime) && !m_playerLoading)
             LogoutPlayer(true);
+    // Playerbot: Process "Playerbot" packets.  These are packets added
+    // to the packet queue by a Playerbot to simulate being a real player.
+    // we need to handle those packets server side
+    for(PlayerbotMap::const_iterator itr = GetPlayerbotsBegin(); itr != GetPlayerbotsEnd(); ++itr)
+    {
+        Player *const bot = itr->second;
+        WorldSession *const botSession = bot->GetSession();
+        if (bot->IsBeingTeleportedFar())
+        {
+            botSession->HandleMoveWorldportAckOpcode();
+        }
+        else if (bot->IsInWorld())
+        {
+            WorldPacket *packet;
+            while (botSession->_recvQueue.next(packet))
+            {
+                OpcodeHandler &opHandle = opcodeTable[packet->GetOpcode()];
+                (botSession->*opHandle.handler)(*packet);
+                delete packet;
+            }
+        }
+    }
 
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
@@ -342,6 +439,10 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    // Playerbot: logout all Playerbots
+    while (!m_PlayerbotData->Bots.empty())
+        LogoutPlayerbot(GetPlayerbotsBegin()->first, Save);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -457,7 +558,9 @@ void WorldSession::LogoutPlayer(bool Save)
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
-        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+        // d) a Playerbot
+        if ((_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket) ||
+            (_player->IsPlayerbot() && _player->GetGroup()))
             _player->RemoveFromGroup();
 
         ///- Send update to group and reset stored max enchanting level
@@ -481,6 +584,7 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();
         sLog->outChar("Account: %d (IP: %s) Logout Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName() ,_player->GetGUIDLow());
         Map *_map = _player->GetMap();
+        uint32 guid = _player->GetGUIDLow();
         _map->Remove(_player, true);
         SetPlayer(NULL);                                    // deleted in Remove call
 
@@ -489,8 +593,9 @@ void WorldSession::LogoutPlayer(bool Save)
         SendPacket(&data);
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
+        ///- Playerbot: no longer true, since each Playerbot will be from the same account, now we have to go by GUID.
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'", GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog->outDebug("SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
 
@@ -979,6 +1084,20 @@ void WorldSession::ProcessQueryCallbacks()
         m_charLoginCallback.cancel();
     }
 
+	//! HandlePlayerbotLogin - do one login each update
+	for(PlayerbotLoginList::iterator itr = m_PlayerbotData->LoginCallbacks.begin(); itr != m_PlayerbotData->LoginCallbacks.end(); ++itr)
+	{
+		if (itr->ready())
+		{
+			SQLQueryHolder *param;
+			itr->get(param);
+			HandlePlayerbotLogin((LoginQueryHolder *)param);
+			itr->cancel();
+			m_PlayerbotData->LoginCallbacks.erase(itr);
+			break;
+		}
+	}
+
     //! HandleAddFriendOpcode
     if (m_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 4823d20..c306c1e 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -55,6 +55,7 @@ struct LfgProposal;
 struct LfgReward;
 struct LfgRoleCheck;
 struct LfgUpdateData;
+class PlayerbotData;
 
 enum AccountDataType
 {
@@ -175,6 +176,10 @@ public:
     virtual bool Process(WorldPacket* packet);
 };
 
+// Playerbot
+typedef UNORDERED_MAP<uint64, Player *> PlayerbotMap;
+typedef std::vector<QueryResultHolderFuture> PlayerbotLoginList;
+
 /// Player session in the World
 class WorldSession
 {
@@ -183,6 +188,22 @@ class WorldSession
         WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
         ~WorldSession();
 
+		// BEGIN Playerbot
+	public:
+		void AddPlayerbot(uint64 guid);								// Login character %guid% into the game as a Playerbot
+		void LogoutPlayerbot(uint64 guid, bool Save);				// Logout character %guid% from the game if logged in as a Playerbot
+		Player *GetPlayerbot(uint64 guid);							// Get the Player object for character %guid% if logged in as a Playerbot
+		PlayerbotMap::const_iterator GetPlayerbotsBegin() const;	// Accessor for m_Playerbots.begin()
+		PlayerbotMap::const_iterator GetPlayerbotsEnd() const;		// Accessor for m_Playerbots.end()
+		uint8 GetPlayerbotsCount() const;							// Accessor for m_Playerbots
+		PlayerbotData * GetPlayerbotData() { return m_PlayerbotData; }
+		const PlayerbotData * GetPlayerbotData() const { return m_PlayerbotData; }
+	private:
+		PlayerbotData			*m_PlayerbotData;
+		void HandlePlayerbotLogin(LoginQueryHolder *holder);		// Called once m_PlayerbotLoginCallback is "ready", to complete the Playerbot creation process
+	public:
+		// END Playerbot
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -337,6 +358,8 @@ class WorldSession
         uint32 GetLatency() const { return m_latency; }
         void SetLatency(uint32 latency) { m_latency = latency; }
         uint32 getDialogStatus(Player *pPlayer, Object* questgiver, uint32 defstatus);
+        // Playerbot
+		uint32 getBotDialogStatus(Player *pPlayer, Object* questgiver, uint32 defstatus);
 
         time_t m_timeOutTime;
         void UpdateTimeOutTime(uint32 diff)
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 87c37b0..f690ed9 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -88,6 +88,7 @@ enum WorldTimers
 enum WorldBoolConfigs
 {
     CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    CONFIG_HONOR_FROM_PLAYERBOTS,
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
diff --git a/src/server/scripts/World/npc_innkeeper.cpp b/src/server/scripts/World/npc_innkeeper.cpp
index 1bf6196..6bfe3f1 100644
--- a/src/server/scripts/World/npc_innkeeper.cpp
+++ b/src/server/scripts/World/npc_innkeeper.cpp
@@ -24,11 +24,19 @@ SDCategory: NPCs
 EndScriptData */
 
 #include "ScriptPCH.h"
+// Playerbot
+#include "Group.h"
 
 #define HALLOWEEN_EVENTID       12
 #define SPELL_TRICK_OR_TREATED  24755
 #define SPELL_TREAT             24715
 
+// Playerbot
+#define PLAYERBOT_CREATE_MENU   6001
+#define PLAYERBOT_CREATE        6002
+#define PLAYERBOT_DISMISS_MENU  6003
+#define PLAYERBOT_DISMISS       6004
+
 #define LOCALE_TRICK_OR_TREAT_0 "Trick or Treat!"
 #define LOCALE_TRICK_OR_TREAT_2 "Des bonbons ou des blagues!"
 #define LOCALE_TRICK_OR_TREAT_3 "Ses oder Saures!"
@@ -72,6 +80,18 @@ public:
                 case LOCALE_enUS: default: localizedEntry = LOCALE_INNKEEPER_0;
             }
             pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, localizedEntry, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INN);
+
+            // Playerbot
+            WorldSession *session = pPlayer->GetSession();
+            if (session->GetPlayerbotsCount() >=1)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "Dismiss your Player?", PLAYERBOT_DISMISS_MENU, 0);
+            if (session->GetPlayerbotsCount() < pPlayer->GetMaxPlayerbots())
+            {
+                std::list<std::string> names;
+                pPlayer->GetCharacterList(names);
+                if (!names.empty())
+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "Recruit a Player?", PLAYERBOT_CREATE_MENU, 0);
+            }
         }
 
         pPlayer->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
@@ -79,20 +99,36 @@ public:
         return true;
     }
 
-    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
     {
         pPlayer->PlayerTalkClass->ClearMenus();
-        if (uiAction == GOSSIP_ACTION_INFO_DEF+HALLOWEEN_EVENTID && IsEventActive(HALLOWEEN_EVENTID) && !pPlayer->HasAura(SPELL_TRICK_OR_TREATED))
-        {
-            pPlayer->CastSpell(pPlayer, SPELL_TRICK_OR_TREATED, true);
 
-            if (urand(0, 1))
-                pPlayer->CastSpell(pPlayer, SPELL_TREAT, true);
-            else
+        switch(uiSender)
+        {
+        case PLAYERBOT_CREATE_MENU:
+            SendCreatePlayerbotMenu(pPlayer, pCreature);
+            break;
+        case PLAYERBOT_CREATE:
+            SendCreatePlayerbot(pPlayer, pCreature, uiAction);
+            break;
+        case PLAYERBOT_DISMISS_MENU:
+            SendDismissPlayerbotMenu(pPlayer, pCreature);
+            break;
+        case PLAYERBOT_DISMISS:
+            SendDismissPlayerbot(pPlayer, pCreature, uiAction);
+            break;
+        default:
+            if (uiAction == GOSSIP_ACTION_INFO_DEF+HALLOWEEN_EVENTID && IsEventActive(HALLOWEEN_EVENTID) && !pPlayer->HasAura(SPELL_TRICK_OR_TREATED))
             {
-                uint32 trickspell = 0;
-                switch (urand(0, 13))
+                pPlayer->CastSpell(pPlayer, SPELL_TRICK_OR_TREATED, true);
+
+                if (urand(0, 1))
+                    pPlayer->CastSpell(pPlayer, SPELL_TREAT, true);
+                else
                 {
+                    uint32 trickspell = 0;
+                    switch (urand(0, 13))
+                    {
                     case 0: trickspell = 24753; break; // cannot cast, random 30sec
                     case 1: trickspell = 24713; break; // lepper gnome costume
                     case 2: trickspell = 24735; break; // male ghost costume
@@ -107,22 +143,120 @@ public:
                     case 11: trickspell = 24925; break; // Hallow's End Candy
                     case 12: trickspell = 24926; break; // Hallow's End Candy
                     case 13: trickspell = 24927; break; // Hallow's End Candy
+                    }
+                    pPlayer->CastSpell(pPlayer, trickspell, true);
                 }
-                pPlayer->CastSpell(pPlayer, trickspell, true);
+                pPlayer->CLOSE_GOSSIP_MENU();
+                return true;
             }
+
             pPlayer->CLOSE_GOSSIP_MENU();
-            return true;
+
+            switch (uiAction)
+            {
+            case GOSSIP_ACTION_TRADE: pPlayer->SEND_VENDORLIST(pCreature->GetGUID()); break;
+            case GOSSIP_ACTION_INN: pPlayer->SetBindPoint(pCreature->GetGUID()); break;
+            }
+            break;
         }
+        return true;
+    }
+
+    void SendCreatePlayerbotMenu(Player *pPlayer, Creature *pCreature)
+    {
+        std::list<std::string> names;
+        pPlayer->GetCharacterList(names);
+        if (names.empty())
+            return;
+
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "ADD ALL", PLAYERBOT_CREATE, GOSSIP_ACTION_INFO_DEF + 1);
+        uint8 x = 2;
+
+        std::list<std::string>::iterator itr;
+        for(itr = names.begin(); itr != names.end(); ++itr, ++x)
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, itr->c_str(), PLAYERBOT_CREATE, GOSSIP_ACTION_INFO_DEF + x);
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    }
 
+    void SendCreatePlayerbot(Player *pPlayer, Creature *pCreature, uint32 uiAction)
+    {
         pPlayer->CLOSE_GOSSIP_MENU();
 
-        switch (uiAction)
+        std::list<std::string> names;
+        pPlayer->GetCharacterList(names);
+        if (names.empty())
+            return;
+
+        uiAction -= GOSSIP_ACTION_INFO_DEF + 1;
+
+        std::list<std::string>::iterator itr;
+        for(itr = names.begin(); itr != names.end(); ++itr)
         {
-            case GOSSIP_ACTION_TRADE: pPlayer->SEND_VENDORLIST(pCreature->GetGUID()); break;
-            case GOSSIP_ACTION_INN: pPlayer->SetBindPoint(pCreature->GetGUID()); break;
+            if (uiAction == 0)  // ADD ALL
+                pPlayer->CreatePlayerbot(itr->c_str());
+            else
+            {
+                // Just adding one
+                if (uiAction == 1)
+                {
+                    pPlayer->CreatePlayerbot(itr->c_str());
+                    break;
+                }
+                --uiAction;
+            }
         }
-        return true;
     }
+
+    void SendDismissPlayerbotMenu(Player *pPlayer, Creature *pCreature)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "DISMISS ALL", PLAYERBOT_DISMISS, GOSSIP_ACTION_INFO_DEF + 1);
+        uint8 x = 2;
+        WorldSession *session = pPlayer->GetSession();
+        for(PlayerbotMap::const_iterator itr = session->GetPlayerbotsBegin(); itr != session->GetPlayerbotsEnd(); ++itr, ++x)
+        {
+            Player *bot = itr->second;
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, bot->GetName(), PLAYERBOT_DISMISS, GOSSIP_ACTION_INFO_DEF + x);
+        }
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    }
+
+    void SendDismissPlayerbotAll(Player *pPlayer, Creature *pCreature)
+    {
+        for(uint8 x = 2; x < pPlayer->GetMaxPlayerbots(); ++x)
+            SendDismissPlayerbot(pPlayer, pCreature, GOSSIP_ACTION_INFO_DEF + 2);
+    }
+
+    void SendDismissPlayerbot(Player *pPlayer, Creature *pCreature, uint32 uiAction)
+    {
+        uiAction -= GOSSIP_ACTION_INFO_DEF + 1;
+        if (uiAction == 0)
+        {
+            SendDismissPlayerbotAll(pPlayer, pCreature);
+            return;
+        }
+
+        WorldSession *session = pPlayer->GetSession();
+        for(PlayerbotMap::const_iterator itr = session->GetPlayerbotsBegin(); itr != session->GetPlayerbotsEnd(); ++itr, --uiAction)
+        {
+            if (uiAction == 1 && itr->second && itr->second->GetGroup())
+            {
+                Player *bot = itr->second;
+                Group *group = bot->GetGroup();
+
+                if (group->IsMember(bot->GetGUID()))
+                {
+                    if (group->RemoveMember(bot->GetGUID(), GROUP_REMOVEMETHOD_PLAYERBOT) < 1)
+                    {
+                        delete group;
+                    }
+                }
+                session->LogoutPlayerbot(bot->GetGUID(), true);
+                break;
+            }
+        }
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+
 };
 
 void AddSC_npc_innkeeper()
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 188d6d8..481b468 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2738,3 +2738,68 @@ LevelReq.Mail = 1
 
 #
 ###################################################################################################
+
+###################################################################################################
+# BOT CONFIGURATION
+#
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 2.0
+
+#    Bot.MaxPlayerBots
+#        Maximum number of Player Bots allowed per account
+#        Default: 9
+
+Bot.MaxPlayerBots = 9
+
+#    Bot.PlayerBotsFly
+#        If PlayerBots fly with you when you use the flight master
+#        Default: 0
+#        0 = false
+#        1 = true
+
+Bot.PlayerBotsFly = 0
+
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+
+Bot.LootMethod = 2
+
+#    Bot.SaveOrgLocation
+#        Puts playerbots back to their original location after use
+#        Default: 0
+#        0 = false - keep playerbots where they were camped out
+#        1 = true - puts playerbots back to where they were originally summoned
+
+Bot.SaveOrgLocation = 0
+
+#    Bot.VendorGUI
+#        If true, Bot's selling GUI will be incorperated into vendors' gossip
+#        menus.
+#        Default: 1
+#        0 = false
+#        1 = true
+
+Bot.VendorGUI = 1
+
+#    Bot.TrainerGUI
+#        If true, bot's training will be incorperated into the trainers' gossip
+#        menus.  (Not fully tested)
+#        Default: 0
+$        0 = false
+#        1 = true
+
+Bot.TrainerGUI = 1
+
+#
+###################################################################################################
\ No newline at end of file
