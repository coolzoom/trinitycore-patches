diff -r dc4fc5c8b306 sql/world_WinterGrasp.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/world_WinterGrasp.sql	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,154 @@
+-- Unused yet: 
+-- Wintergrasp is under attack!
+-- Wintergrasp Fortress is under attack!
+-- Winter's Edge Tower is under attack!
+-- Commander Dardosh yells: The first of the Alliance towers has fallen! Destro all three and we will hasten their retreat!
+-- Commander Dardosh yells: Lok'tar! The second tower falls! Destroy the final tower and we will hasten their retreat!
+-- Eastern Bridge is under attack!
+-- Western Bridge is under attack!
+-- Westspark Bridge is under attack!
+-- Flamewatch Tower is under attack!
+
+-- TODO: Remove french trad
+DELETE FROM trinity_string WHERE entry BETWEEN 12050 AND 12072;
+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
+(12072, 'win keep text', NULL, 'TRAD', NULL, NULL, NULL, NULL, NULL, NULL),
+(12071, 'The western tower', NULL, 'La tour ouest', NULL, NULL, NULL, NULL, NULL, NULL),
+(12070, 'The eastern tower', NULL, 'La tour est', NULL, NULL, NULL, NULL, NULL, NULL),
+(12069, 'The southern tower', NULL, 'La tour sud', NULL, NULL, NULL, NULL, NULL, NULL),
+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, '%s a d?fendu la forteresse du Joug-d''hiver!', NULL, NULL, NULL, NULL, NULL, NULL),
+(12067, 'The battle for Wintergrasp begin!', NULL, 'Que la bataille pour le Joug-d''hiver commence!', NULL, NULL, NULL, NULL, NULL, NULL),
+(12066, '%s has been destroyed!', NULL, '%s a ?t? d?truite!', NULL, NULL, NULL, NULL, NULL, NULL),
+(12065, '%s has been damaged !', NULL, '%s a ?t? endommag?e !', NULL, NULL, NULL, NULL, NULL, NULL),
+(12064, 'The north-western keep tower', NULL, 'La tour du donjon nord-ouest', NULL, NULL, NULL, NULL, NULL, NULL),
+(12063, 'The south-western keep tower', NULL, 'La tour du donjon sud-ouest', NULL, NULL, NULL, NULL, NULL, NULL),
+(12062, 'The north-eastern keep tower', NULL, 'La tour du donjon nord-est', NULL, NULL, NULL, NULL, NULL, NULL),
+(12061, 'The south-eastern keep tower', NULL, 'La tour du donjon sud-est', NULL, NULL, NULL, NULL, NULL, NULL),
+(12060, 'You have reached Rank 2: First Lieutenant', NULL, 'Vous avez atteint le deuxi?me grade : premier lieutenant', NULL, NULL, NULL, NULL, NULL, NULL),
+(12059, 'You have reached Rank 1: Corporal', NULL, 'Vous avez atteint le premier grade : caporal', NULL, NULL, NULL, NULL, NULL, NULL),
+(12058, 'The battle for Wintergrasp is going to begin!', NULL, 'La bataille du lac Joug-d''hiver va commencer!', NULL, NULL, NULL, NULL, NULL, NULL),
+(12057, 'Alliance', NULL, 'L''alliance', NULL, NULL, NULL, NULL, NULL, NULL),
+(12056, 'Horde', NULL, 'la Horde', NULL, NULL, NULL, NULL, NULL, NULL),
+(12055, 'The Sunken Ring siege workshop', NULL, 'L''atelier de si?ge de l''Ar?ne Engloutie', NULL, NULL, NULL, NULL, NULL, NULL),
+(12054, 'Westspark siege workshop', NULL, 'L''atelier de si?ge de l''Ouestincelle', NULL, NULL, NULL, NULL, NULL, NULL),
+(12053, 'Eastspark siege workshop', NULL, 'L''atelier de si?ge de l''Estincelle', NULL, NULL, NULL, NULL, NULL, NULL),
+(12052, 'The Broken Temple siege workshop', NULL, 'L''atelier de si?ge du Temple Bris?', NULL, NULL, NULL, NULL, NULL, NULL),
+(12051, '%s is under attack by %s', NULL, '%s est attaqu? par %s', NULL, NULL, NULL, NULL, NULL, NULL),
+(12050, '%s has been captured by %s ', NULL, '%s a ?t? pris par %s', NULL, NULL, NULL, NULL, NULL, NULL);
+
+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, 'Montrez-moi o? est le cimeti?re de la forteresse..', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, 'Montrez-moi o? est le cimeti?re de l''ar?ne engloutie..', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, 'Montrez-moi o? est le cimeti?re du temple Bris?.', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, 'Montrez-moi o? est le cimeti?re d''Ouestincelle.', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, 'Montrez-moi o? est le cimeti?re d''Estincelle.', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, 'Ramenez-moi au camp d''arriv?e de la Horde.', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, 'Ramenez-moi au camp d''arriv?e de l''Alliance.', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, 'Se mettre dans la file pour le Joug-d''hiver', NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, '');
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_wg_dalaran_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611);
+
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger` = 54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES (54640, 54643, 0, 'WG teleporter');
+
+DELETE FROM `gameobject` where `id` in (194162,192951,192273,192274,192277,192280,192283,192289,192290,192338,192339,192406,192407,192414,192417,192418,192429,192433,192434,192435,192458,192459,192460,192461,192819,190475,190487,194959,194962,192829,190219,190220,191795,191796,191799,191800,191801,191802,191803,191804,191806,191807,191808,191809,190369,190370,190371,190372,190374,190376,190221,190373,190377,190378,191797,191798,191805,190356,190357,190358,190375,191810,	192488,192501,192374,192416,192375,192336,192255,192269,192254,192349,192366,192367,192364,192370,192369,192368,192362,192363,192379,192378,192355,192354,192358,192359,192284,192285,192371,192372,192373,192360,192361,192356,192352,192353,192357,192350,192351,190763,192501,192488,192269,192278) AND `map`=571;
+DELETE FROM `creature` where `id` in (30739,30740,31102,31841,31151,31153,32296,31051,31106,31108,31109,31053,30489,39172,31107,32294,31101,30499,31842,31036,31091,39173,31052,30400,31054) AND `map`=571;
+UPDATE `creature_template` SET `InhabitType` = '7' WHERE `entry` = 27852;
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_wg_spiritguide' WHERE `entry` IN (31841,31842);
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+UPDATE `trinity_string` SET `content_default` = 'The Wintergrasp fortress has been captured by %s !', `content_loc2` = '%s a capturé la forteresse du Joug d''hiver !' WHERE `trinity_string`.`entry` =12072 LIMIT 1 ;
+
+UPDATE `trinity_string` SET `content_loc2` = '%s a défendu la forteresse du Joug-d''hiver !' WHERE `trinity_string`.`entry` =12068 LIMIT 1 ;
+
+DELETE FROM `spell_area` where `spell` = 58730 ;
+insert into spell_area values (58730, 4581, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4539, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4197, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4585, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4612, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4582, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4583, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4589, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4575, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4538, 0, 0, 0, 0, 0, 2, 1);
+insert into spell_area values (58730, 4577, 0, 0, 0, 0, 0, 2, 1);
+
+DELETE FROM `spell_area` where `spell` = 57940 ;
+insert INTO `spell_area` VALUES (57940, 65, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 66, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 67, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 206, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 210, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 394, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 395, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 1196, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 2817, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 3456, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 3477, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 3537, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 3711, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4100, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4196, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4228, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4264, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4265, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4272, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4273, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4395, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4415, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4416, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4493, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4494, 0, 0, 0, 0, 0, 2, 1);
+insert INTO `spell_area` VALUES (57940, 4603, 0, 0, 0, 0, 0, 2, 1);
+
+UPDATE creature_template SET faction_A = 1732,faction_H = 1735,spell1 = 51421 WHERE entry = 28366;
+
+UPDATE creature_template SET faction_A = '1732', faction_H = '1732' WHERE entry IN (30499,30740, 28319); -- aliance
+UPDATE creature_template SET faction_A = '1735', faction_H = '1735' WHERE entry IN (30400,30739, 32629);  -- horde
+
+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
+INSERT INTO `command` (name, security, help) VALUES ('bf start',3,'Syntaxe: .bf start #battleid');
+INSERT INTO `command` (name, security, help) VALUES ('bf stop',3,'Syntaxe: .bf stop #battleid');
+INSERT INTO `command` (name, security, help) VALUES ('bf enable',3,'Syntaxe: .bf enable #battleid');
+INSERT INTO `command` (name, security, help) VALUES ('bf switch',3,'Syntaxe: .bf switch #battleid');
+INSERT INTO `command` (name, security, help) VALUES ('bf timer',3,'Syntaxe: .bf timer #battleid #timer');
+
+DELETE FROM `spell_scripts` WHERE `id` = 49899;
+INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
+
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131258 AND 131322;
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131326 AND 131328;
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131350 AND 131353;
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131376 AND 131380;
+DELETE FROM `creature_addon` WHERE `guid` = 131392;
+DELETE FROM `creature_addon` WHERE `guid` = 131437;
+DELETE FROM `creature_addon` WHERE `guid` = 131458;
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131631 AND 131634;
+DELETE FROM `creature_addon` WHERE `guid` = 131706;
+DELETE FROM `creature_addon` WHERE `guid` BETWEEN 131727 AND 131731;
+
+-- Wintergrasp vehicle teleport
+UPDATE gameobject_template SET ScriptName = "go_wintergrasp_teleporter" WHERE entry = 192951;
+
+-- Quètes joug
+-- Horde
+UPDATE quest_template SET ExclusiveGroup = 13199 WHERE entry IN(13193, 13199);
+UPDATE quest_template SET ExclusiveGroup = 13192 WHERE entry IN(13192, 13202);
+UPDATE quest_template SET ExclusiveGroup = 13180 WHERE entry IN(13180, 13178);
+UPDATE quest_template SET ExclusiveGroup = 13200 WHERE entry IN(13200, 13191);
+UPDATE quest_template SET ExclusiveGroup = 13201 WHERE entry IN(13201, 13194);
+UPDATE quest_template SET ExclusiveGroup = 13185 WHERE entry IN(13185, 13223);
+-- Alliance
+UPDATE quest_template SET ExclusiveGroup = 13196 WHERE entry IN(13196, 13154);
+UPDATE quest_template SET ExclusiveGroup = 13198 WHERE entry IN(13198, 13153);
+UPDATE quest_template SET ExclusiveGroup = 13179 WHERE entry IN(13179, 13177);
+UPDATE quest_template SET ExclusiveGroup = 13186 WHERE entry IN(13186, 13222);
+UPDATE quest_template SET ExclusiveGroup = 13195 WHERE entry IN(13195, 13156);
+
+UPDATE creature_template SET ScriptName = "npc_wintergrasp_quest_giver" WHERE entry IN(31054, 31052, 31091, 31036, 31101, 31107, 31053, 31051, 31153, 31151, 31102, 31106);
+
+-- Catapult
+UPDATE creature_template SET speed_walk = 2.8, speed_run = 1.6 WHERE entry = 27881;
\ No newline at end of file
diff -r dc4fc5c8b306 src/server/game/AI/CoreAI/GameObjectAI.h
--- a/src/server/game/AI/CoreAI/GameObjectAI.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/AI/CoreAI/GameObjectAI.h	Tue Nov 30 22:02:04 2010 -0500
@@ -38,7 +38,13 @@
         virtual void InitializeAI() { Reset(); }
 
         virtual void Reset() {};
-        
+
+		// Pass parameters between AI
+		virtual void DoAction(const int32 /*param*/ = 0) {}
+		virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
+		virtual void SetGUID(const uint64 &/*guid*/, int32 /*id*/ = 0) {}
+		virtual uint64 GetGUID(int32 /*id*/ = 0) { return 0; }
+
         static int Permissible(const GameObject* go);
 
         virtual bool GossipHello(Player* /*player*/) {return false;}
diff -r dc4fc5c8b306 src/server/game/AI/CreatureAISelector.cpp
--- a/src/server/game/AI/CreatureAISelector.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/AI/CreatureAISelector.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -134,6 +134,11 @@
         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
 
         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
+		
+		//scriptname in db
+		if (!ai_factory)
+		    if (GameObjectAI* scriptedAI = sScriptMgr.GetGameObjectAI(go))
+			    return scriptedAI;
 
         //future goAI types go here
 
diff -r dc4fc5c8b306 src/server/game/Battlefield/Battlefield.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/Battlefield.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,1161 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Group.h"
+#include "WorldPacket.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+
+Battlefield::Battlefield()
+{
+    m_Timer = 0;
+	m_enable = true;
+    m_WarTime = false;
+    m_DefenderTeam = TEAM_NEUTRAL;
+
+    m_TypeId = 0; 
+    m_BattleId = 0;
+    m_ZoneId = 0;   
+    m_MapId = 0;
+    m_MaxPlayer = 0;
+	m_MinPlayer = 0;
+    m_BattleTime = 0; 
+    m_NoWarBattleTime = 0;
+    m_TimeForAcceptInvite = 20;
+    m_uiKickDontAcceptTimer = 1000;
+
+    m_uiKickAfkTimer = 1000;
+    
+    m_LastResurectTimer = 30000;
+    m_StartGroupingTimer = 0;
+    m_StartGrouping = false;
+}
+Battlefield::~Battlefield()
+{
+}
+void Battlefield::HandlePlayerEnterZone(Player* plr,uint32 /*zone*/)
+{
+    //If battle is start, 
+    //  if it not fully > invite player to join the war
+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
+    if(IsWarTime())
+    {
+        if(m_PlayersInWar[plr->GetTeamId()].size()+m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer) //Not fully
+        {
+            InvitePlayerToWar(plr);
+        }
+        else //Full
+        {
+            //TODO:Send packet for announce it to player
+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()]=time(NULL)+10;
+            InvitePlayerToQueue(plr);
+        }
+    }
+    else
+    {
+        //If time left is <15 minutes invite player to join queue
+        if(m_Timer<=m_StartGroupingTimer)
+            InvitePlayerToQueue(plr);
+    }
+
+    //Add player in list of player in zone
+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
+    OnPlayerEnterZone(plr);//for scripting
+}
+//Called when a player leave the zone
+void Battlefield::HandlePlayerLeaveZone(Player* plr,uint32 /*zone*/)
+{
+    if(IsWarTime())
+    {
+        //if player is in war list
+        if(m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID())!=m_PlayersInWar[plr->GetTeamId()].end())
+        {
+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
+            if(Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId())) // remove from raid group if player is member
+            {
+                // I think that now is not a hack
+                if (!group->RemoveMember(plr->GetGUID()))             // group was disbanded
+                {
+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
+					group->SetBattlefieldGroup(NULL);
+					sObjectMgr.RemoveGroup(group);
+                    delete group;
+                }
+            }
+            OnPlayerLeaveWar(plr);//For scripting
+        }
+    }
+
+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr->second->HandlePlayerLeave(plr);
+
+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
+    SendRemoveWorldStates(plr);
+    RemovePlayerFromResurrectQueue(plr->GetGUID());
+    OnPlayerLeaveZone(plr);//For scripting
+}
+bool Battlefield::Update(uint32 diff)
+{
+    //When global timer is end
+    if(m_Timer<=diff)
+    {
+        //Here end of battle by timer
+        if(IsWarTime())
+        {
+            EndBattle(true);
+        }
+        //Start of battle
+        else
+        {
+                StartBattle();
+        }
+    }
+    else m_Timer-=diff;
+
+    //Some times before battle start invite player to queue
+    if(!m_StartGrouping && m_Timer<=m_StartGroupingTimer)
+    {
+        m_StartGrouping = true;
+        InvitePlayerInZoneToQueue();
+        OnStartGrouping();// for scripting
+    }
+
+	bool objective_changed = false;
+    if(IsWarTime())
+    {
+        if(m_uiKickAfkTimer<=diff)
+        {
+            m_uiKickAfkTimer=1000;
+            KickAfk();
+        }
+        else m_uiKickAfkTimer-=diff;
+
+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
+        if(m_uiKickDontAcceptTimer<=diff)
+        {
+            for(int team=0;team<2;team++)
+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
+                {
+                    if((*itr).second<=time(NULL))
+                        KickPlayerFromBf((*itr).first);
+                }
+            InvitePlayerInZoneToWar();
+            for(int team=0;team<2;team++)
+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
+                {
+                    if((*itr).second<=time(NULL))
+                        KickPlayerFromBf((*itr).first);
+                }
+            m_uiKickDontAcceptTimer=1000;
+        }else m_uiKickDontAcceptTimer -=diff;
+
+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        {
+            if (itr->second->Update(diff))
+                objective_changed = true;
+        }
+    }
+   
+
+    if(m_LastResurectTimer<=diff)
+    {
+        for(int i=0;i<m_GraveYardList.size();i++)
+            if(GetGraveYardById(i))
+                m_GraveYardList[i]->Resurrect();
+        m_LastResurectTimer=RESURRECTION_INTERVAL;
+    }else m_LastResurectTimer-=diff;
+	
+	return objective_changed;
+}
+
+void Battlefield::InvitePlayerInZoneToQueue()
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+        {
+			if(Player *plr = sObjectMgr.GetPlayer((*p_itr)))
+				InvitePlayerToQueue(plr);
+        }
+}
+void Battlefield::InvitePlayerToQueue(Player* plr)
+{
+    if(m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
+        return;
+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
+    {
+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
+    }
+}
+void Battlefield::InvitePlayerInQueueToWar()
+{
+    for (uint8 team = 0; team < 2; ++team)
+	{
+        for (GuidSet::const_iterator p_itr = m_PlayersInQueue[team].begin(); p_itr != m_PlayersInQueue[team].end(); ++p_itr)
+        {
+            if(Player* plr=sObjectAccessor.FindPlayer(*p_itr))
+			{
+                if(m_PlayersInWar[plr->GetTeamId()].size()+m_InvitedPlayers[plr->GetTeamId()].size()<m_MaxPlayer)
+                    InvitePlayerToWar(plr);
+                else
+                {
+                    //Full
+                }
+            }
+        }
+        m_PlayersInQueue[team].clear();
+	}
+}
+void Battlefield::InvitePlayerInZoneToWar()
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+        {
+			if(Player *plr = sObjectMgr.GetPlayer((*p_itr)))
+			{
+				if(m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
+					continue;
+				if(m_PlayersInWar[plr->GetTeamId()].size()+m_InvitedPlayers[plr->GetTeamId()].size()<m_MaxPlayer)
+					InvitePlayerToWar(plr);
+				else
+				{
+					//full
+					m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()]=time(NULL)+10;
+				}
+			}
+        }
+}
+void Battlefield::InvitePlayerToWar(Player* plr)
+{
+	if(!plr)
+		return;
+
+    //TODO : needed ?
+    if (plr->isInFlight())
+        return;
+
+	if(plr->InArena() || plr->GetBattleground())
+	{
+		m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
+		return;
+	}
+
+    if (plr->getLevel()<m_MinLevel)
+    {
+        if(m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID())==0)
+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()]=time(NULL)+10;
+        return;
+    }
+    //Check if player is not already in war
+    if(m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
+        return;
+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()]=time(NULL)+m_TimeForAcceptInvite;
+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId,m_ZoneId,m_TimeForAcceptInvite);
+}
+void Battlefield::KickAfk()
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator p_itr = m_PlayersInWar[team].begin(); p_itr != m_PlayersInWar[team].end(); ++p_itr)
+        {
+            if(Player* plr= sObjectAccessor.FindPlayer((*p_itr)))
+            {
+                if(plr->isAFK())
+                    KickPlayerFromBf((*p_itr));
+            }
+        }
+}
+void Battlefield::KickPlayerFromBf(uint64 guid)
+{
+    if(Player* plr=sObjectAccessor.FindPlayer(guid))
+    	if(plr->GetZoneId() == GetZoneId())
+            plr->TeleportTo(KickPosition);
+}
+
+void Battlefield::StartBattle()
+{
+    if(m_WarTime)
+       return;
+	for(int team=0;team<2;team++)
+    {
+        m_PlayersInWar[team].clear();
+        m_Groups[team].clear();
+    }
+    m_Timer=m_BattleTime;
+
+    m_WarTime = true;
+
+    InvitePlayerInZoneToWar();
+    InvitePlayerInQueueToWar();
+    
+    PlaySoundToAll(BF_START);
+
+    OnBattleStart();
+}
+void Battlefield::EndBattle(bool endbytimer)
+{
+    m_WarTime=false;
+
+    m_StartGrouping=false;
+
+    if(!endbytimer)
+        SetDefenderTeam(GetAttackerTeam());
+    
+    if(GetDefenderTeam() == TEAM_ALLIANCE)
+        PlaySoundToAll(BF_ALLIANCE_WINS);                // alliance wins sound
+	else
+        PlaySoundToAll(BF_HORDE_WINS);                   // horde wins sound
+
+	
+    OnBattleEnd(endbytimer);
+    
+        //reset bf timer
+    m_Timer=m_NoWarBattleTime;
+    SendInitWorldStatesToAll();
+}
+
+void Battlefield::PlaySoundToAll(uint32 SoundID)
+{
+    WorldPacket data;
+    data.Initialize(SMSG_PLAY_SOUND, 4);
+    data << uint32(SoundID);
+
+    for(int team=0;team<2;team++)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer((*itr));
+            if (plr)
+                plr->GetSession()->SendPacket(&data);
+        }
+}
+
+bool Battlefield::HasPlayer(Player *plr) const
+{
+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
+}
+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
+{
+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId,m_ZoneId);
+}
+void Battlefield::PlayerAskToLeave(Player* plr)
+{
+    KickPlayerFromBf(plr->GetGUID());
+}
+
+void Battlefield::AskToLeaveQueue(Player *plr)
+{
+	m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
+}
+
+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
+{
+    if(!IsWarTime())
+        return;
+    if(AddOrSetPlayerToCorrectBfGroup(plr))
+    {
+        plr->GetSession()->SendBfEntered(m_BattleId);
+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
+        //Remove player AFK
+        if(plr->isAFK())
+            plr->ToggleAFK();
+        OnPlayerJoinWar(plr);//for scripting
+
+
+    }
+}
+void Battlefield::TeamCastSpell(TeamId team,int32 spellId)
+{
+    if(spellId>0)
+    {
+        for (GuidSet::const_iterator p_itr = m_PlayersInWar[team].begin(); p_itr != m_PlayersInWar[team].end(); ++p_itr)
+        {
+            if(Player* plr=sObjectMgr.GetPlayer((*p_itr)))
+                plr->CastSpell(plr, (uint32)spellId, true);
+        }
+    }
+    else
+    {
+        for (GuidSet::const_iterator p_itr = m_PlayersInWar[team].begin(); p_itr != m_PlayersInWar[team].end(); ++p_itr)
+            if(Player* plr=sObjectMgr.GetPlayer((*p_itr)))
+                plr->RemoveAuraFromStack((uint32)-spellId); 
+    }
+} 
+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+			if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				plr->GetSession()->SendPacket(&data);
+}
+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
+            if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+                plr->GetSession()->SendPacket(&data);
+}
+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+                plr->GetSession()->SendPacket(&data);
+}
+
+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+    data << (uint8)CHAT_MSG_RAID_BOSS_EMOTE;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)0;
+    data << (uint32)0; // 2.1.0
+    data << (uint32)1;
+    data << (uint8)0; 
+    data << (uint64)0;
+    data << (uint32)(strlen(msg.c_str())+1);
+    data << msg.c_str();
+    data << (uint8)0;
+
+    return data;
+}
+void Battlefield::SendWarningToAllInZone(int32 entry,...)
+{
+    const char *format = sObjectMgr.GetTrinityStringForDBCLocale(entry);
+    va_list ap;
+    char str [1024];
+    va_start(ap, entry);
+    vsnprintf(str,1024,format, ap);
+    va_end(ap);
+    std::string msg = (std::string)str;
+    WorldPacket data = BuildWarningAnnPacket(msg);
+    BroadcastPacketZone(data);
+}
+void Battlefield::SendWarningToAllInWar(int32 entry,...)
+{
+    const char *format = sObjectMgr.GetTrinityStringForDBCLocale(entry);
+    va_list ap;
+    char str [1024];
+    va_start(ap, entry);
+    vsnprintf(str,1024,format, ap);
+    va_end(ap);
+    std::string msg = (std::string)str;
+
+    WorldPacket data = BuildWarningAnnPacket(msg);
+    BroadcastPacketWar(data);
+}
+void Battlefield::SendWarningToPlayer(Player* plr,int32 entry, ...)
+{
+    const char *format = sObjectMgr.GetTrinityStringForDBCLocale(entry);
+    va_list ap;
+    char str [1024];
+    va_start(ap, entry);
+    vsnprintf(str,1024,format, ap);
+    va_end(ap);
+    std::string msg = (std::string)str;
+
+    WorldPacket data = BuildWarningAnnPacket(msg);
+
+    if(plr->GetSession())
+    	plr->GetSession()->SendPacket(&data);
+}
+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (int i = 0; i < 2; ++i)
+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+		{
+			if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				plr->SendUpdateWorldState(field, value);
+		}
+}
+void Battlefield::RegisterZone(uint32 zoneId)
+{
+    sBattlefieldMgr.AddZone(zoneId, this);
+}
+void Battlefield::HideNpc(Creature* p_Creature)
+{
+    p_Creature->CombatStop();
+	p_Creature->SetReactState(REACT_PASSIVE);
+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+    p_Creature->SetPhaseMask(2,true);
+    p_Creature->DisappearAndDie();
+    p_Creature->SetVisible(false);
+}
+void Battlefield::ShowNpc(Creature* p_Creature,bool p_Aggressive)
+{
+	p_Creature->SetPhaseMask(1,true);
+    p_Creature->SetVisible(true);
+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+	if(!p_Creature->isAlive())
+		p_Creature->Respawn(true);
+    if(p_Aggressive)
+        p_Creature->SetReactState(REACT_AGGRESSIVE);
+	else
+	{
+		p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+		p_Creature->SetReactState(REACT_PASSIVE);
+	}
+}
+//*****************************************************
+//*******************Group System**********************
+//*****************************************************
+Group* Battlefield::GetFreeBfRaid(uint32 TeamId)
+{
+    //if found free group we return it
+    for(GuidSet::const_iterator itr=m_Groups[TeamId].begin();itr!=m_Groups[TeamId].end();++itr)
+    {
+        if (Group* group = sObjectMgr.GetGroupByGUID(*itr))
+		    if (!group->IsFull())
+                return group;
+    }
+    return NULL;
+}
+
+Group* Battlefield::GetGroupPlayer(uint64 guid, uint32 TeamId)
+{
+    for(GuidSet::const_iterator itr=m_Groups[TeamId].begin();itr!=m_Groups[TeamId].end();++itr)
+    {
+        if (Group* group = sObjectMgr.GetGroupByGUID(*itr))
+		    if (group->IsMember(guid))
+			    return group;
+	}
+	return NULL;
+}
+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
+{
+    if(!plr->IsInWorld())
+        return false;
+
+    if(Group* group = plr->GetGroup()) 
+        group->RemoveMember(plr->GetGUID());
+
+    Group* group = GetFreeBfRaid(plr->GetTeamId());
+    if (!group)
+    {
+		group = new Group;
+		group->SetBattlefieldGroup(this);
+        group->Create(plr->GetGUID(), plr->GetName());
+        sObjectMgr.AddGroup(group);
+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
+    }
+    else if (group->IsMember(plr->GetGUID()))
+    {
+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
+    }
+    else
+    {
+        group->AddMember(plr->GetGUID(), plr->GetName());
+    }
+    return true;
+}
+//***************End of Group System*******************
+
+//*****************************************************
+//***************Spirit Guide System*******************
+//*****************************************************
+//--------------------
+//-Battlefield Method-
+//--------------------
+BfGraveYard* Battlefield::GetGraveYardById(uint32 id)
+{
+    if(id<m_GraveYardList.size()){
+        if(m_GraveYardList[id])
+            return m_GraveYardList[id];
+        else
+            sLog.outError("Battlefield::GetGraveYardById Id:%u not existed",id);
+    }
+    else
+        sLog.outError("Battlefield::GetGraveYardById Id:%u cant be found",id);
+
+    return NULL;
+}
+WorldSafeLocsEntry const* Battlefield::GetClosestGraveYard(Player* plr)
+{
+    BfGraveYard* closestGY= NULL;
+    float maxdist=-1;
+    for(uint8 i=0;i<m_GraveYardList.size();i++)
+    {
+      if(m_GraveYardList[i])
+        {
+	  if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId() )
+	    continue;
+	 
+          float dist = m_GraveYardList[i]->GetDistance(plr);
+          if (dist<maxdist || maxdist<0)
+            {
+                closestGY=m_GraveYardList[i];
+                maxdist=dist;
+            }
+        }
+    }
+    if(closestGY)
+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
+    return NULL;
+}
+
+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    for(int i=0;i<m_GraveYardList.size();i++)
+    {
+        if(!m_GraveYardList[i])
+            continue;
+
+        if(m_GraveYardList[i]->HasNpc(npc_guid))
+        {
+            m_GraveYardList[i]->AddPlayer(player_guid);
+            break;
+        }
+    }
+}
+
+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for(int i=0;i<m_GraveYardList.size();i++)
+    {
+        if(!m_GraveYardList[i])
+            continue;
+
+        if(m_GraveYardList[i]->HasPlayer(player_guid))
+        {
+            m_GraveYardList[i]->RemovePlayer(player_guid);
+            break;
+        }
+    }
+   
+    return;
+}
+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    sLog.outError("SendAreaSpiritHealerQueryOpcode");
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time = m_LastResurectTimer;      // resurrect every 30 seconds
+
+    data << guid << time;
+    ASSERT( pl && pl->GetSession() );
+    pl->GetSession()->SendPacket(&data);
+}
+
+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
+{
+	if (!player)
+		return false;
+	Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest);
+	if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
+		return false;
+	if (complete)
+	{
+		player->CompleteQuest(quest);
+		return true;
+	}
+	else
+	{
+		for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+		{
+			int32 creature = pQuest->ReqCreatureOrGOId[i];
+			if (uint32 spell_id = pQuest->ReqSpell[i])
+			{
+				player->CastedCreatureOrGO(creature,0,spell_id);
+				return true;
+			}
+			else if (creature > 0)
+			{
+				player->KilledMonsterCredit(creature,0);
+				return true;
+			}
+			else if (creature < 0)
+			{
+				player->CastedCreatureOrGO(creature,0,0);
+				return true;
+			}
+			return true;
+		}
+	}
+	return false;
+}
+
+//--------------------
+//-BfGraveYard Method-
+//--------------------
+BfGraveYard::BfGraveYard(Battlefield* Bf)
+{
+    m_Bf=Bf;
+    m_GraveyardId = 0;
+    m_ControlTeam = TEAM_NEUTRAL;
+    m_SpiritGuide[0] = NULL;
+    m_SpiritGuide[1] = NULL;
+    m_ResurrectQueue.clear();
+}
+
+void BfGraveYard::Init(uint32 horde_entry,uint32 alliance_entry,float x,float y, float z, float o,TeamId startcontrol,uint32 gy)
+{
+    m_ControlTeam = startcontrol;
+    if(Creature* cre = m_Bf->SpawnCreature(horde_entry,x,y,z,o,TEAM_HORDE))
+    {
+        m_SpiritGuide[TEAM_HORDE] = cre;
+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
+        if(m_ControlTeam==TEAM_ALLIANCE){
+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
+        }
+    }
+    else
+        sLog.outError("BfGraveYard::Init can't spawn horde spiritguide %u",horde_entry);
+
+    if(Creature* cre = m_Bf->SpawnCreature(alliance_entry,x,y,z,o,TEAM_ALLIANCE))
+    {
+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
+        if(m_ControlTeam==TEAM_HORDE){
+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
+        }
+    }
+    else
+        sLog.outError("BfGraveYard::Init can't spawn alliance spiritguide %u",alliance_entry);
+
+    m_GraveyardId = gy;
+}
+
+float BfGraveYard::GetDistance(Player* plr)
+{
+    const WorldSafeLocsEntry* ws=sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
+    return plr->GetDistance2d(ws->x,ws->y);
+}
+
+void BfGraveYard::AddPlayer(uint64 player_guid)
+{
+    if(!m_ResurrectQueue.count(player_guid)){
+        m_ResurrectQueue.insert(player_guid);
+        
+        Player *plr = sObjectMgr.GetPlayer(player_guid);
+        if (plr)
+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+    }
+}
+
+void BfGraveYard::RemovePlayer(uint64 player_guid)
+{
+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
+    Player *plr = sObjectMgr.GetPlayer(player_guid);
+    
+    if (plr)
+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+}
+
+void BfGraveYard::Resurrect()
+{
+    if (m_ResurrectQueue.empty())
+        return;
+
+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+    {
+        //Get player object from his guid
+        Player *plr = sObjectMgr.GetPlayer(*itr);
+        if (!plr)
+            continue;
+    
+        //Cherck player isinworld and player is on good graveyard
+        if (plr->IsInWorld())
+            if (m_SpiritGuide[m_ControlTeam])
+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
+
+        //Resurect player
+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+        plr->ResurrectPlayer(1.0f);
+        plr->CastSpell(plr, 6962, true);
+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+
+        sObjectAccessor.ConvertCorpseForPlayer(plr->GetGUID());
+    }
+    m_ResurrectQueue.clear();
+
+}
+
+//For changing graveyard control
+void BfGraveYard::ChangeControl(TeamId team)
+{
+    //Guide switching
+    if(m_SpiritGuide[1-team])
+        m_SpiritGuide[1-team]->SetVisible(false);
+    if(m_SpiritGuide[team])
+        m_SpiritGuide[team]->SetVisible(true); 
+    
+    m_ControlTeam = team;
+    //Teleport to other graveyard, player witch were on this graveyard
+    RelocateDeadPlayers();
+}
+void BfGraveYard::RelocateDeadPlayers()
+{
+    WorldSafeLocsEntry const *ClosestGrave = NULL;
+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+    {
+        Player* plr = sObjectMgr.GetPlayer(*itr);
+        if (!plr)
+            continue;
+        if (ClosestGrave)
+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+        else
+        {
+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+        }
+    }
+}
+
+//***************End Spirit Guide system***************
+
+//*****************************************************
+//**********************Misc***************************
+//*****************************************************
+//Method for spawn creature on map
+Creature* Battlefield::SpawnCreature(uint32 entry, Position pos, uint32 team)
+{
+    return SpawnCreature(entry, pos.m_positionX,pos.m_positionY,pos.m_positionZ,pos.m_orientation, team);
+}
+Creature* Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, uint32 team)
+{
+    //Get map object
+    Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(m_MapId));
+    if (!map)
+    {
+        sLog.outError("Can't create creature entry: %u map not found",entry);
+        return 0;
+    }
+
+    //Create creature
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
+    {
+        sLog.outError("Can't create creature entry: %u",entry);
+        delete pCreature;
+        return NULL;
+    }
+
+    pCreature->SetHomePosition(x, y, z, o);
+
+    CreatureInfo const *cinfo = sObjectMgr.GetCreatureTemplate(entry);
+    if (!cinfo)
+    {
+        sLog.outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
+        return NULL;
+    }
+    //force using DB speeds
+    pCreature->SetSpeed(MOVE_WALK,  cinfo->speed_walk);
+    pCreature->SetSpeed(MOVE_RUN,   cinfo->speed_run);
+
+    //Set creature in world
+    map->Add(pCreature);
+    pCreature->setActive(true);
+
+    return  pCreature;
+}
+//Method for spawning gameobject on map
+GameObject* Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
+{
+    //Get map object
+    Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(571));
+    if (!map)
+        return 0;
+
+    //Create gameobject
+    GameObject * go = new GameObject;
+    if (!go->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL,  x, y, z, o,0,0,0,0,100,GO_STATE_READY))
+    {
+        sLog.outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
+        sLog.outError("Cannot create gameobject template %u! Battleground not created!", entry);
+        delete go;
+        return NULL;
+    }
+
+    //Add in the world
+    map->Add(go);
+    go->setActive(true);
+    return go;
+}
+//*****************************************************
+//*******************CapturePoint**********************
+//*****************************************************
+
+BfCapturePoint::BfCapturePoint(Battlefield* Bf)
+: m_Bf(Bf), m_capturePoint(NULL)
+{
+  m_team = TEAM_NEUTRAL;
+  m_value = 0;
+  m_maxValue = 0;
+  m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL ;
+  m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL ;
+  m_capturePointEntry = 0;
+  m_neutralValuePct = 0 ;
+  m_maxSpeed = 0 ;
+}
+
+bool BfCapturePoint::HandlePlayerEnter(Player * plr)
+{
+    if (m_capturePoint)
+    {
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+    }
+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
+}
+
+void BfCapturePoint::HandlePlayerLeave(Player * plr)
+{
+    if (m_capturePoint)
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
+}
+
+void BfCapturePoint::SendChangePhase()
+{
+    if (!m_capturePoint)
+        return;
+
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+    // send these updates to only the ones in this objective
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+}
+
+
+
+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map*/, float x, float y, float z, float o)
+{
+    sLog.outDebug("Creating capture point %u", entry);
+
+    // check info existence
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(entry);
+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
+    {
+        sLog.outError("OutdoorPvP: GO %u is not capture point!", entry);
+        return false;
+    }
+    m_capturePoint=NULL;
+    if(m_capturePoint=m_Bf->SpawnGameObject(entry,x,y,z,o))
+    {    
+        // get the needed values from goinfo
+        m_maxValue = goinfo->capturePoint.maxTime;
+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
+        m_capturePointEntry=entry;
+        if (m_team == TEAM_ALLIANCE)
+        {
+            m_value = m_maxValue;
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
+        }
+        else 
+        {
+            m_value = -m_maxValue;
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
+        }
+        return true;
+    }
+    else
+        return false;
+}
+
+
+bool BfCapturePoint::DelCapturePoint()
+{
+    if (m_capturePoint)
+    {
+        m_capturePoint->SetRespawnTime(0);                                 // not save respawn time
+        m_capturePoint->Delete();
+        m_capturePoint=NULL;
+    }
+
+    return true;
+}
+
+
+
+
+bool BfCapturePoint::Update(uint32 diff)
+{
+    if (!m_capturePoint)
+        return false;
+
+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
+
+    for (uint8 team = 0; team < 2; ++team)
+    {
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end();++itr)
+            if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
+					HandlePlayerLeave(plr);
+    }
+
+    std::list<Player*> players;
+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
+    Trinity::PlayerListSearcher<Trinity::AnyPlayerInObjectRangeCheck> searcher(m_capturePoint, players, checker);
+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
+
+    for (std::list<Player*>::iterator itr = players.begin(); itr != players.end(); ++itr)
+    {
+        if ((*itr)->IsOutdoorPvPActive())
+        {
+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
+                HandlePlayerEnter(*itr);
+        }
+    }
+
+    // get the difference of numbers
+    float fact_diff = ((float)m_activePlayers[0].size() - (float)m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
+    if (!fact_diff)
+        return false;
+
+    uint32 Challenger = 0;
+    float maxDiff = m_maxSpeed * diff;
+
+    if (fact_diff < 0)
+    {
+        // horde is in majority, but it's already horde-controlled -> no change
+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
+            return false;
+
+        if (fact_diff < -maxDiff)
+            fact_diff = -maxDiff;
+
+        Challenger = HORDE;
+    }
+    else
+    {
+        // ally is in majority, but it's already ally-controlled -> no change
+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
+            return false;
+
+        if (fact_diff > maxDiff)
+            fact_diff = maxDiff;
+
+        Challenger = ALLIANCE;
+    }
+
+    float oldValue = m_value;
+    TeamId oldTeam = m_team;
+
+    m_OldState = m_State;
+
+    m_value += fact_diff;
+
+    if (m_value < -m_minValue) // red
+    {
+        if (m_value < -m_maxValue)
+            m_value = -m_maxValue;
+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
+        m_team = TEAM_HORDE;
+    }
+    else if (m_value > m_minValue) // blue
+    {
+        if (m_value > m_maxValue)
+            m_value = m_maxValue;
+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
+        m_team = TEAM_ALLIANCE;
+    }
+    else if (oldValue * m_value <= 0) // grey, go through mid point
+    {
+        // if challenger is ally, then n->a challenge
+        if (Challenger == ALLIANCE)
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+        // if challenger is horde, then n->h challenge
+        else if (Challenger == HORDE)
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+    else // grey, did not go through mid point
+    {
+        // old phase and current are on the same side, so one team challenges the other
+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+
+    if (m_value != oldValue)
+        SendChangePhase();
+
+    if (m_OldState != m_State)
+    {
+        //sLog.outError("%u->%u", m_OldState, m_State);
+        if (oldTeam != m_team)
+            ChangeTeam(oldTeam);
+        return true;
+    }
+
+    return false;
+}
+
+
+
+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (uint8 team = 0; team < 2; ++team)
+    {
+        // send to all players present in the area
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+			if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				plr->SendUpdateWorldState(field,value);
+        }
+    }
+}
+
+void BfCapturePoint::SendObjectiveComplete(uint32 id,uint64 guid)
+{
+    uint8 team;
+    switch(m_State)
+    {
+    case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
+        team = 0;
+        break;
+    case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
+        team = 1;
+        break;
+    default:
+        return;
+    }
+
+    // send to all players present in the area
+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+	{
+		if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+			plr->KilledMonsterCredit(id, guid);
+	}
+}
+
+bool BfCapturePoint::IsInsideObjective(Player *plr) const
+{
+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
+}
diff -r dc4fc5c8b306 src/server/game/Battlefield/Battlefield.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/Battlefield.h	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_H_
+#define BATTLEFIELD_H_
+
+#include "Utilities/Util.h"
+#include "SharedDefines.h"
+#include "ZoneScript.h"
+#include "WorldPacket.h"
+#include "GameObject.h"
+
+enum BattlefieldTypes
+{
+    BATTLEFIELD_WG, //Wintergrasp
+    BATTLEFIELD_TB, //Tol Barad (cataclysm)
+};
+enum BattlefieldBattleID
+{
+    BATTLEFIELD_BATTLEID_WG = 1,   //Wintergrasp battle 
+};
+
+enum BfObjectiveStates
+{
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
+};
+
+enum BattlefieldSounds
+{
+    BF_HORDE_WINS                = 8454,
+    BF_ALLIANCE_WINS             = 8455,
+    BF_START                  = 3439
+ };
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+
+class Battlefield;
+class BfGraveYard;
+
+typedef std::set<uint64> GuidSet;
+typedef std::vector<BfGraveYard*> GraveYardVect;
+
+typedef std::map<uint64,uint32> PlayerTimerMap;
+
+#define BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL 1000
+class BfCapturePoint
+{
+public:
+    BfCapturePoint(Battlefield * bf);
+
+    virtual void FillInitialWorldStates(WorldPacket & /*data*/) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+    // send kill notify to players in the controlling faction
+    void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    //virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+    virtual void ChangeTeam(TeamId /*oldTeam*/) {}
+    virtual void SendChangePhase();
+
+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
+
+    GameObject* GetCapturePointGo(){return m_capturePoint;}
+
+protected:
+    bool DelCapturePoint();
+
+    // active players in the area of the objective, 0 - alliance, 1 - horde
+    GuidSet m_activePlayers[2];
+    // total shift needed to capture the objective
+    float m_maxValue;
+    float m_minValue;
+    // maximum speed of capture
+    float m_maxSpeed;
+    // the status of the objective
+    float m_value;
+    TeamId m_team;
+    // objective states
+    BfObjectiveStates m_OldState;
+    BfObjectiveStates m_State;
+    // neutral value on capture bar
+    uint32 m_neutralValuePct;
+
+    // pointer to the Battlefield this objective belongs to
+    Battlefield* m_Bf;
+    uint32 m_capturePointEntry;
+    GameObject *m_capturePoint;
+};
+class BfGraveYard
+{
+public:
+    BfGraveYard(Battlefield* Bf);
+
+    // method for change who control the graveyard
+    void ChangeControl(TeamId team);
+    TeamId GetControlTeamId() {return m_ControlTeam;}
+    
+    // use for found the nearest graveyard
+    float GetDistance(Player* plr);
+
+    void Init(uint32 horde_entry,uint32 alliance_entry,float x,float y,float z,float o,TeamId startcontrol,uint32 gy);
+
+    void AddPlayer(uint64 player_guid);
+    void RemovePlayer(uint64 player_guid);
+    
+
+
+    void Resurrect();
+    void RelocateDeadPlayers();
+
+    bool HasNpc(uint64 guid) {return (m_SpiritGuide[0]->GetGUID()==guid || m_SpiritGuide[1]->GetGUID()==guid);}
+    bool HasPlayer(uint64 guid) {return m_ResurrectQueue.find(guid)!=m_ResurrectQueue.end();}
+    uint32 GetGraveYardId() {return m_GraveyardId;}
+protected:
+    
+    TeamId m_ControlTeam;
+    uint32 m_GraveyardId;
+    Creature* m_SpiritGuide[2];
+    GuidSet m_ResurrectQueue;
+    Battlefield* m_Bf;
+};
+class Battlefield : public ZoneScript
+{
+    friend class BattlefieldMgr;
+    
+public:
+    // constructor
+    Battlefield();
+    // destructor
+    ~Battlefield();
+
+    typedef std::map<uint32/*lowguid*/, BfCapturePoint*> BfCapturePointMap;
+
+    // Call this for init the Battlefield
+    virtual bool SetupBattlefield() {return true;}
+
+    // Generate packet witch contain all worldstatedata of area
+    virtual void FillInitialWorldStates(WorldPacket & /*data*/) {}
+
+    //Called when a GameObject/Creature is create OR destroy (view bool add)
+    void OnGameObjectCreate(GameObject* /*go*/, bool /*add*/){}
+    void OnCreatureCreate(Creature * /*cre*/, bool /*add*/) {}
+
+    // send world state update to all players present in zone
+    void SendUpdateWorldState(uint32 field, uint32 value);
+
+    //TODO // called by OutdoorPvPMgr, updates the objectives and if needed, sends new worldstateui information
+    virtual bool Update(uint32 diff);
+
+    void InvitePlayerInZoneToQueue();
+    void InvitePlayerInQueueToWar();
+    void InvitePlayerInZoneToWar();
+    // handle npc/player kill
+    virtual void HandleKill(Player * /*killer*/, Unit * /*killed*/){};
+    
+    uint32 GetTypeId() {return m_TypeId;}
+    uint32 GetZoneId() {return m_ZoneId;}
+
+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
+
+    // return if the war is start or not
+    bool IsWarTime() {return m_WarTime;}
+
+	void SetEnable(bool enable) {m_enable = enable;}
+	bool GetEnable() {return m_enable;}
+
+    // Kick player from the bf, teleport him to kick point
+    void KickPlayerFromBf(uint64 guid);
+    
+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+
+     //All-purpose data storage 64 bit
+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
+    virtual void SetData64(uint32 DataId, uint64 Value) {m_Data64[DataId]=Value;}
+
+    //All-purpose data storage 32 bit
+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
+    virtual void SetData(uint32 DataId, uint32 Value) {m_Data32[DataId]=Value;}
+
+    //Battlefield generic method
+    TeamId GetDefenderTeam() {return m_DefenderTeam;}
+    TeamId GetAttackerTeam() {return TeamId(1-m_DefenderTeam);}
+    void SetDefenderTeam(TeamId team) {m_DefenderTeam=team;}
+    
+    // Group methods
+    Group* GetFreeBfRaid(uint32 TeamId);
+	Group* GetGroupPlayer(uint64 guid, uint32 TeamId);
+    bool AddOrSetPlayerToCorrectBfGroup(Player *plr);
+
+    // Graveyard methods
+    //  Find in witch graveyard the player must be teleport to be resurect by spiritguide
+    WorldSafeLocsEntry const* GetClosestGraveYard(Player* plr);
+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
+    void SetGraveyardNumber(uint32 number) {m_GraveYardList.resize(number);}
+    BfGraveYard* GetGraveYardById(uint32 id);
+    // Misc methods
+    Creature* SpawnCreature(uint32 entry, float x, float y, float z, float o, uint32 team);
+    Creature* SpawnCreature(uint32 entry, Position pos, uint32 team);
+    GameObject* SpawnGameObject(uint32 entry, float x, float y, float z, float o);
+
+    //ScriptingMethod
+    virtual void OnBattleStart(){};
+    virtual void OnBattleEnd(bool /*endbytimer*/){};
+    virtual void OnStartGrouping(){};
+    virtual void OnPlayerJoinWar(Player* /*plr*/){};
+    virtual void OnPlayerLeaveWar(Player* /*plr*/){};
+    virtual void OnPlayerLeaveZone(Player* /*plr*/){};
+    virtual void OnPlayerEnterZone(Player* /*plr*/){};
+
+    WorldPacket BuildWarningAnnPacket(std::string msg);
+    void SendWarningToAllInZone(int32 entry, ...);
+    void SendWarningToAllInWar(int32 entry, ...);
+    void SendWarningToPlayer(Player* plr,int32 entry, ...);
+
+    void PlayerAcceptInviteToQueue(Player* plr);
+    void PlayerAcceptInviteToWar(Player* plr);
+    uint32 GetBattleId() {return m_BattleId;}
+    void PlayerAskToLeave(Player* plr);
+    void AskToLeaveQueue(Player *plr);
+
+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement*/, Player* /*player*/, uint8 /*incrementNumber = 1*/){};
+
+    virtual void SendInitWorldStatesToAll(){};
+
+    bool CanFlyIn(){return !m_WarTime;}
+    bool IncrementQuest(Player *player, uint32 quest, bool complete = false);
+    void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+
+	void StartBattle();
+    void EndBattle(bool endbytimer);
+
+    void HideNpc(Creature* p_Creature);
+    void ShowNpc(Creature* p_Creature,bool p_Aggressive);
+
+    GraveYardVect GetGraveYardVect() {return m_GraveYardList;}
+
+    uint32 GetTimer() {return m_Timer;}
+	void SetTimer(uint32 timer) {m_Timer = timer;}
+    
+    void PlaySoundToAll(uint32 SoundID);
+
+	void InvitePlayerToQueue(Player* plr);
+    void InvitePlayerToWar(Player* plr);
+protected:
+	
+    uint32 m_Timer;//Global timer for event
+	bool m_enable;
+    bool m_WarTime;
+    TeamId m_DefenderTeam;
+	
+    // the map of the objectives belonging to this outdoorpvp
+    BfCapturePointMap m_capturePoints;
+
+    // the set of player
+    GuidSet m_players[2];     //Player in the zone
+    GuidSet m_PlayersInQueue[2];//Player in the queue
+    GuidSet m_PlayersInWar[2];  //Player in the war
+    PlayerTimerMap m_InvitedPlayers[2];
+	PlayerTimerMap m_PlayersWillBeKick[2];
+    //Variable witch must be setup for each Bf 
+    uint32 m_TypeId;    //View enum BattlefieldTypes
+    uint32 m_BattleId;
+    uint32 m_ZoneId;    //Zone id of area 4197=WG
+    uint32 m_MapId;
+    uint32 m_MaxPlayer;
+    uint32 m_MinPlayer;
+    uint32 m_MinLevel;
+    uint32 m_BattleTime; 	//Time of battle
+    uint32 m_NoWarBattleTime;//Time between to battle
+    uint32 m_TimeForAcceptInvite;
+    uint32 m_uiKickDontAcceptTimer;
+    WorldLocation KickPosition;
+ 
+    uint32 m_uiKickAfkTimer;
+    
+    //Graveyard variable
+    GraveYardVect m_GraveYardList;
+    uint32 m_LastResurectTimer;
+	
+    uint32 m_StartGroupingTimer;
+    bool m_StartGrouping;
+	
+    GuidSet m_Groups[2];
+	
+    std::vector<uint64> m_Data64;
+    std::vector<uint32> m_Data32;
+
+    void KickAfk();
+    // use for switch off all worldstate for client
+    virtual void SendRemoveWorldStates(Player * /*plr*/) {}
+
+    // use for send a packet for all player list
+    void BroadcastPacketZone(WorldPacket & data) const;
+    void BroadcastPacketQueue(WorldPacket & data) const;
+    void BroadcastPacketWar(WorldPacket & data) const;
+
+    //CapturePoint system
+    void AddCapturePoint(BfCapturePoint* cp)
+    {
+        m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp;
+    }
+
+    BfCapturePoint * GetCapturePoint(uint32 lowguid) const
+    {
+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
+        if (itr != m_capturePoints.end())
+            return itr->second;
+        return NULL;
+    }
+
+    void RegisterZone(uint32 zoneid);
+    bool HasPlayer(Player *plr) const;
+    void TeamCastSpell(TeamId team, int32 spellId);
+
+};
+
+#endif 
+
diff -r dc4fc5c8b306 src/server/game/Battlefield/BattlefieldHandler.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "Opcodes.h"
+
+//This send to player windows for invite player to join the war
+//Param1:(BattleId) the BattleId of Bf
+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
+//Param3:(time) Time in second that the player have for accept
+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 p_time)
+{
+    //Send packet 
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
+    data << uint32(BattleId);
+    data << uint32(ZoneId);
+    data << uint32((time(NULL)+p_time));
+
+    //Sending the packet to player
+    SendPacket(&data);
+}
+//This send invitation to player to join the queue
+//Param1:(BattleId) the BattleId of Bf
+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
+
+    data << uint32(BattleId);
+    data << uint8(1); //warmup ? used ?
+
+    //Sending packet to player
+    SendPacket(&data);
+}
+//This send packet for inform player that he join queue
+//Param1:(BattleId) the BattleId of Bf
+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
+    data << uint32(BattleId);
+    data << uint32(ZoneId);
+    data << uint8(1); //Accepted
+    data << uint8(0); //Logging In
+    data << uint8(1); //Warmup
+
+    SendPacket(&data);
+}
+//This is call when player accept to join war 
+//Param1:(BattleId) the BattleId of Bf
+void WorldSession::SendBfEntered(uint32 BattleId)
+{
+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
+    data << uint32(BattleId);
+    data << uint8(1);//unk
+    data << uint8(1);//unk
+    data << uint8(_player->isAFK()?1:0);//Clear AFK
+
+    SendPacket(&data);
+}
+//Send when player is kick from Battlefield
+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
+    data << uint32(BattleId);
+    data << uint8(8);//byte Reason
+    data << uint8(2);//byte BattleStatus
+    data << uint8(0);//bool Relocated
+
+    SendPacket(&data);
+}
+
+//Send by client when he click on accept for queue
+void WorldSession::HandleBfQueueInviteResponse(WorldPacket &recv_data)
+{
+    uint32 BattleId;                                             
+    uint8 Accepted;             
+
+    recv_data >> BattleId >> Accepted;
+    sLog.outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u",BattleId,Accepted);
+    Battlefield* Bf= sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if(!Bf)
+        return;
+
+    if(Accepted)
+    {
+        Bf->PlayerAcceptInviteToQueue(_player);
+    }
+}
+//Send by client on clicking in accept or refuse of invitation windows for join game
+void WorldSession::HandleBfEntryInviteResponse(WorldPacket &recv_data)
+{
+    uint32 BattleId;
+    uint8 Accepted;
+
+    recv_data >> BattleId >> Accepted;
+    sLog.outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u",BattleId,Accepted);
+    Battlefield* Bf= sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if(!Bf)
+        return;
+
+    //If player accept invitation
+    if(Accepted)
+    {
+        Bf->PlayerAcceptInviteToWar(_player);
+    }        
+    else
+    {
+        if(_player->GetZoneId()==Bf->GetZoneId())
+            Bf->KickPlayerFromBf(_player->GetGUID());
+    }
+}
+
+void WorldSession::HandleBfExitRequest(WorldPacket &recv_data)
+{
+    uint32 BattleId;
+
+    recv_data >> BattleId;
+    sLog.outError("HandleBfExitRequest: BattleID:%u ",BattleId);
+    Battlefield* Bf= sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if(!Bf)
+        return;
+
+    Bf->AskToLeaveQueue(_player);
+}
diff -r dc4fc5c8b306 src/server/game/Battlefield/BattlefieldMgr.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "BattlefieldMgr.h"
+#include "Zones/BattlefieldWG.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+
+BattlefieldMgr::BattlefieldMgr()
+{
+    m_UpdateTimer = 0;
+    //sLog.outDebug("Instantiating BattlefieldMgr");
+}
+
+BattlefieldMgr::~BattlefieldMgr()
+{
+    //sLog.outDebug("Deleting BattlefieldMgr");
+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+        delete *itr;
+}
+
+void BattlefieldMgr::InitBattlefield()
+{
+    Battlefield* pBf = new BattlefieldWG;
+    // respawn, init variables
+    if(!pBf->SetupBattlefield())
+    {
+	    sLog.outString();
+        sLog.outString("Battlefield : Wintergrasp init failed.");
+        delete pBf;
+    }
+    else
+    {
+        m_BattlefieldSet.push_back(pBf);
+		sLog.outString();
+        sLog.outString("Battlefield : Wintergrasp successfully initiated.");
+    }
+
+    /* For Cataclysm: Tol Barad
+    pBf = new BattlefieldTB;
+    // respawn, init variables
+    if(!pBf->SetupBattlefield())
+    {
+        sLog.outDebug("Battlefield : Tol Barad init failed.");
+        delete pBf;
+    }
+    else
+    {
+        m_BattlefieldSet.push_back(pBf);
+        sLog.outDebug("Battlefield : Tol Barad successfully initiated.");
+    }*/
+}
+
+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
+{
+    m_BattlefieldMap[zoneid] = handle;
+}
+
+void BattlefieldMgr::HandlePlayerEnterZone(Player *plr, uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+        return;
+
+    if (itr->second->HasPlayer(plr))
+        return;
+    if (itr->second->GetEnable() == false)
+	    return;
+    itr->second->HandlePlayerEnterZone(plr, zoneid);
+    sLog.outDebug("Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+void BattlefieldMgr::HandlePlayerLeaveZone(Player *plr, uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+        return;
+
+    // teleport: remove once in removefromworld, once in updatezone
+    if (!itr->second->HasPlayer(plr))
+        return;
+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
+    sLog.outDebug("Player %u left outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+Battlefield * BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+	if (itr->second->GetEnable() == false)
+	    return NULL;
+    return itr->second;
+}
+Battlefield * BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
+{
+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+    {
+        if((*itr)->GetBattleId()==battleid)
+            return (*itr);
+    }
+    return NULL;
+}
+
+void BattlefieldMgr::Update(uint32 diff)
+{
+    m_UpdateTimer += diff;
+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
+    {
+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+			if((*itr)->GetEnable())
+			    (*itr)->Update(m_UpdateTimer);
+        m_UpdateTimer = 0;
+    }
+}
+
+ZoneScript * BattlefieldMgr::GetZoneScript(uint32 zoneId)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
+    if (itr != m_BattlefieldMap.end())
+        return itr->second;
+    else
+        return NULL;
+}
diff -r dc4fc5c8b306 src/server/game/Battlefield/BattlefieldMgr.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/BattlefieldMgr.h	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_MGR_H_
+#define BATTLEFIELD_MGR_H_
+
+#include "Battlefield.h"
+#include "ace/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+class ZoneScript;
+struct GossipMenuItems;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class BattlefieldMgr
+{
+public:
+    // ctor
+    BattlefieldMgr();
+    // dtor
+    ~BattlefieldMgr();
+
+    // create battlefield events
+    void InitBattlefield();
+    // called when a player enters an battlefield area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an battlefield area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // called when player resurrects
+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
+    // return assigned battlefield
+    Battlefield * GetBattlefieldToZoneId(uint32 zoneid);
+    Battlefield * GetBattlefieldByBattleId(uint32 battleid);
+
+    ZoneScript * GetZoneScript(uint32 zoneId);
+
+    void AddZone(uint32 zoneid, Battlefield * handle);
+
+    void Update(uint32 diff);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::vector<Battlefield*> BattlefieldSet;
+    typedef std::map<uint32 /* zoneid */, Battlefield*> BattlefieldMap;
+private:
+    // contains all initiated battlefield events
+    // used when initing / cleaning up
+    BattlefieldSet  m_BattlefieldSet;
+    // maps the zone ids to an battlefield event
+    // used in player event handling
+    BattlefieldMap   m_BattlefieldMap;
+    // update interval
+    uint32 m_UpdateTimer;
+};
+
+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
+
+#endif 
+
diff -r dc4fc5c8b306 src/server/game/Battlefield/Zones/BattlefieldWG.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,1087 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// TODO: Implement proper support for vehicle+player teleportation
+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
+// TODO: Add proper implement of achievement
+
+#include "BattlefieldWG.h"
+#include "SpellAuras.h"
+bool BattlefieldWG::SetupBattlefield()
+{
+    m_TypeId = BATTLEFIELD_WG;    //View enum BattlefieldTypes
+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
+    m_ZoneId = 4197; // Wintergrasp
+    m_MapId = 571; // Norfendre
+    m_MaxPlayer = sWorld.getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
+	m_enable = sWorld.getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
+    m_MinPlayer = sWorld.getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
+    m_MinLevel = sWorld.getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
+    m_BattleTime = sWorld.getIntConfig(CONFIG_WINTERGRASP_BATTLETIME)*60*1000; // Time of battle (in ms)
+    m_NoWarBattleTime = sWorld.getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME)*60*1000;//Time between to battle (in ms)
+    m_TimeForAcceptInvite = 20;//in second
+    m_StartGroupingTimer = 15*60*1000; //in ms
+    m_StartGrouping=false;
+    m_tenacityStack=0;
+    KickPosition.Relocate(5728.117f,2714.346f,697.733f,0);
+    KickPosition.m_mapId=m_MapId;
+    RegisterZone(m_ZoneId);
+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
+    m_saveTimer = 60000;
+  
+    // Init GraveYards
+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
+
+    //Load from db
+    if(( sWorld.getWorldState(3801) == 0 ) && (sWorld.getWorldState(3802) == 0) && ( sWorld.getWorldState(ClockWorldState[0]) == 0 ) )
+	{
+	    sWorld.setWorldState(3801,false);
+	    sWorld.setWorldState(3802,urand(0,1));
+	    sWorld.setWorldState(ClockWorldState[0],m_NoWarBattleTime);
+	}
+
+        m_WarTime = sWorld.getWorldState(3801);
+        m_DefenderTeam = (TeamId)sWorld.getWorldState(3802);
+	    m_Timer = sWorld.getWorldState(ClockWorldState[0]);
+	if(m_WarTime)
+	{
+	    m_WarTime = false;
+	    m_Timer = 10 * 60 * 1000;
+	}
+
+    for(uint8 i=0;i<BATTLEFIELD_WG_GY_MAX;i++)
+    {
+        BfGraveYardWG* gy = new BfGraveYardWG(this);
+        if(WGGraveYard[i].startcontrol==TEAM_NEUTRAL)
+        {
+            //In no war time Gy is control by defender
+            gy->Init(31841,31842,WGGraveYard[i].x,WGGraveYard[i].y,WGGraveYard[i].z,WGGraveYard[i].o,m_DefenderTeam,WGGraveYard[i].gyid);
+        }
+        else
+            gy->Init(31841,31842,WGGraveYard[i].x,WGGraveYard[i].y,WGGraveYard[i].z,WGGraveYard[i].o,WGGraveYard[i].startcontrol,WGGraveYard[i].gyid);
+        gy->SetTextId(WGGraveYard[i].textid);
+        m_GraveYardList[i]=gy;
+    }
+
+    //Pop des gameobject et creature du workshop
+    for(uint8 i=0;i<WG_MAX_WORKSHOP;i++)
+    {
+        BfWGWorkShopData* ws=new BfWGWorkShopData(this);//Create new object
+        //Init:setup variable
+        ws->Init(WGWorkShopDataBase[i].worldstate,WGWorkShopDataBase[i].type,WGWorkShopDataBase[i].nameid);
+        //Spawn associate npc on this point (Guard/Engineer)
+        for (int c=0;c<WGWorkShopDataBase[i].nbcreature;c++)
+		{
+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
+		}
+        //Spawn associate gameobject on this point (Horde/Alliance flags)
+        for (int g=0;g<WGWorkShopDataBase[i].nbgob;g++)
+		{
+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
+		}
+
+        //Create PvPCapturePoint
+        if( WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST )
+        {
+            ws->ChangeControl(GetAttackerTeam(),true);//Update control of this point 
+            //Create Object
+            BfCapturePointWG *workshop = new BfCapturePointWG(this,GetAttackerTeam());
+            //Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
+                WGWorkShopDataBase[i].CapturePoint.x,
+                WGWorkShopDataBase[i].CapturePoint.y,
+                WGWorkShopDataBase[i].CapturePoint.z,
+                0);
+            workshop->LinkToWorkShop(ws);//Link our point to the capture point (for faction changement)
+            AddCapturePoint(workshop);//Add this capture point to list for update this (view in Update() of OutdoorPvP)
+        }
+        else{
+            ws->ChangeControl(GetDefenderTeam(),true);//Update control of this point (Keep workshop= to deffender team)
+        }
+        WorkShopList.insert(ws);
+    }
+    //Spawning npc in keep
+    for(uint8 i=0;i<WG_MAX_KEEP_NPC;i++)
+    {
+        //Horde npc
+        if(Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
+        //Alliance npc
+        if(Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
+    }
+    //Hide keep npc
+    for(GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
+		if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			if (Creature* creature = unit->ToCreature())
+			    HideNpc(creature);
+    //Spawn out of keep npc
+    for(uint8 i=0;i<WG_OUTSIDE_ALLIANCE_NPC;i++)
+    {
+        //Horde npc
+        if(Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
+    }
+    for(uint8 i=WG_OUTSIDE_ALLIANCE_NPC;i<WG_MAX_OUTSIDE_NPC;i++)
+    {
+        //Alliance npc
+        if(Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
+    }
+    //Hide outside npc
+    for(GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
+        if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+            if (Creature* creature = unit->ToCreature())
+                HideNpc(creature);
+    for(uint8 i=0;i<WG_MAX_TURRET;i++)
+	{
+        if(Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, 0))
+        {
+            CanonList.insert(creature->GetGUID());
+			HideNpc(creature);
+        }
+	}
+    //Spawning Buiding
+    for(uint8 i=0;i<WG_MAX_OBJ;i++)
+    {
+        GameObject* go=SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
+        BfWGGameObjectBuilding* b=new BfWGGameObjectBuilding(this);
+        b->Init(go,WGGameObjectBuillding[i].type,WGGameObjectBuillding[i].WorldState,WGGameObjectBuillding[i].nameid);
+        BuildingsInZone.insert(b);
+    }
+    //Spawning portal defender
+    for(uint8 i=0;i<WG_MAX_TELEPORTER;i++)
+    {
+        GameObject* go=SpawnGameObject(WGPortalDefenderData[i].entry,WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
+        DefenderPortalList.insert(go);
+        go->SetUInt32Value(GAMEOBJECT_FACTION,WintergraspFaction[GetDefenderTeam()]);
+    }
+    for(uint8 i=0;i<WG_KEEPGAMEOBJECT_MAX;i++)
+    {
+        if(GameObject* go=SpawnGameObject(WGKeepGameObject[i].entryh,WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
+        {
+        	go->SetRespawnTime(GetDefenderTeam()?RESPAWN_ONE_DAY:RESPAWN_IMMEDIATELY);
+        	m_KeepGameObject[1].insert(go);
+        }
+        if(GameObject* go=SpawnGameObject(WGKeepGameObject[i].entrya,WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
+        {
+        	go->SetRespawnTime(GetDefenderTeam()?RESPAWN_IMMEDIATELY:RESPAWN_ONE_DAY);
+        	m_KeepGameObject[0].insert(go);
+        }
+    }
+    for(GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+     
+    for(GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+    UpdateCounterVehicle(true);
+    return true;
+}
+
+bool BattlefieldWG::Update(uint32 diff)
+{
+    bool m_return = Battlefield::Update(diff);
+    if (m_saveTimer <= diff)
+    {
+	sWorld.setWorldState(3801,m_WarTime);
+	sWorld.setWorldState(3802,m_DefenderTeam);
+	sWorld.setWorldState(ClockWorldState[0],m_Timer );
+        m_saveTimer = 60 * IN_MILLISECONDS;
+    } else m_saveTimer -= diff;
+
+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
+        if (Player* plr = sObjectMgr.GetPlayer((*itr)))
+	    {
+            if(plr->HasAura(SPELL_SPIRITUAL_IMMUNITY))
+            {
+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(plr);
+                if(graveyard)
+                {
+                    if(plr->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
+			        {
+                        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+			            m_PlayersIsSpellImu.erase(plr->GetGUID());
+			        }
+                }
+            }
+        }
+    if (m_WarTime)
+    {
+	    for (uint8 team = 0; team < 2; ++team)
+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+                if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+                {
+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
+                }
+    }
+	return m_return;
+}
+
+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
+    if(IsWarTime())
+    {
+        if(Player *plr = sObjectMgr.GetPlayer(player_guid))
+        {
+            if(!plr->HasAura(SPELL_SPIRITUAL_IMMUNITY))
+            {
+                plr->CastSpell(plr, SPELL_SPIRITUAL_IMMUNITY, true);
+                m_PlayersIsSpellImu.insert(plr->GetGUID());
+            }
+        }
+    }
+}
+
+void BattlefieldWG::OnBattleStart()
+{
+    // Pop titan relic
+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
+    if(m_relic)
+    {
+        // Update faction of relic, only attacker can click on
+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION,WintergraspFaction[GetAttackerTeam()]);
+        // Set in use (not allow to click on before last door is broken)
+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
+    }
+    else
+        sLog.outError("Impossible de pop la relique");
+
+  
+    // Update tower visibility and update faction
+    for(GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
+    {
+		if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+		{
+		    if (Creature* creature = unit->ToCreature())
+			{
+			    ShowNpc(creature, true);
+			    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
+			}
+		}
+    }
+    
+    // Rebuild all wall
+    for(GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+	{
+	    if ((*itr))
+		{
+    	    (*itr)->Rebuild();
+		    (*itr)->UpdateTurretAttack(false);
+		}
+	}
+
+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]=0;
+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]=0;
+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]=0;
+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]=0;
+
+	// Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
+    for(WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+	    if ((*itr))
+            (*itr)->UpdateGraveYardAndWorkshop();
+    }
+    
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+        {
+            //Kick player in orb room, TODO: offline player ?
+			if(Player *plr = sObjectMgr.GetPlayer((*p_itr)))
+			{
+				float x,y,z;
+				plr->GetPosition(x,y,z);
+				if(5500>x && x>5392 && y<2880  && y>2800 && z<480)
+					plr->TeleportTo(571,5349.8686f,2838.481f,409.240f,0.046328f);
+				SendInitWorldStatesTo(plr);
+			}
+        }
+    // Initialisation du compteur de véhicule
+	UpdateCounterVehicle(true);
+    //Warnin message
+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
+}
+
+void BattlefieldWG::UpdateCounterVehicle(bool init)
+{
+    if (init)
+	{
+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
+	}
+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
+
+    for(WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+        if(BfWGWorkShopData *workshop = (*itr))
+        {
+            if(workshop->m_TeamControl == TEAM_ALLIANCE)
+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
+            else if(workshop->m_TeamControl == TEAM_HORDE)
+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
+        }
+    }
+
+    UpdateVehicleCountWG();
+}
+
+void BattlefieldWG::OnBattleEnd(bool endbytimer)
+{
+    // Remove relic
+    if(m_relic)
+        m_relic->RemoveFromWorld();
+    m_relic=NULL;
+    
+    // Remove turret
+    for(GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
+	{
+		if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+		{
+		    if (Creature* creature = unit->ToCreature())
+			{
+			    if(!endbytimer)
+			        creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
+			    HideNpc(creature);
+		    }
+		}
+	}
+
+    if(!endbytimer)
+	{
+        //Change all npc in keep
+        for(GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
+		{
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    HideNpc(creature);
+        }
+        for(GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
+		{
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    ShowNpc(creature,true);
+		}
+        //Change all npc out of keep
+        for(GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+                if (Creature* creature = unit->ToCreature())
+                    HideNpc(creature);
+        }
+        for(GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+                if (Creature* creature = unit->ToCreature())
+                    ShowNpc(creature,true);
+        }
+    }
+
+    for(GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+	    if ((*itr))
+		{
+	        if (!endbytimer)
+		        (*itr)->Rebuild();
+	        (*itr)->UpdateTurretAttack(true);
+		}
+	}
+
+    // Update all graveyard, control is to defender when no wartime
+    for(uint8 i=0;i<BATTLEFIELD_WG_GY_HORDE;i++)
+    {
+        if(GetGraveYardById(i))
+        {
+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
+        }
+    }
+
+    for(GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+    for(GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+    //Update portal defender faction
+    for(GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION,WintergraspFaction[GetDefenderTeam()]);
+
+    //Saving data
+    for(GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+        (*itr)->Save();
+    for(WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+        (*itr)->Save();
+
+    uint32 WinerHonor = 0;
+    uint32 LooserHonor = 0;
+
+    if(!endbytimer)
+    {
+        WinerHonor =  3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
+        LooserHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
+    }
+    else
+    {
+        WinerHonor =  3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
+        LooserHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
+    }
+
+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
+	{
+        if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+        {
+			plr->AddAura(58045,plr);
+            if(plr->HasAura(SPELL_LIEUTENANT))
+            {
+            	 plr->RewardHonor(NULL, 1, WinerHonor);
+             	 RewardMarkOfHonor(plr, 3);
+            }
+            else if(plr->HasAura(SPELL_CORPORAL))
+            {
+                plr->RewardHonor(NULL, 1, WinerHonor);
+                RewardMarkOfHonor(plr, 2);
+            }
+			if (plr->GetTeamId() == TEAM_HORDE)
+				IncrementQuest(plr, 13183, true);
+			else
+				IncrementQuest(plr, 13181, true);
+			// Victoire à Joug-d'hiver
+			DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, plr);
+			// Ployez sous notre joug
+			if (GetTimer() <= 10000 && !endbytimer)
+			DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, plr);
+        }
+	}
+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
+	{
+        if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+        {
+            if(plr->HasAura(SPELL_LIEUTENANT))
+            {
+            	 plr->RewardHonor(NULL, 1, LooserHonor);
+             	 RewardMarkOfHonor(plr, 1);
+            }
+            else if(plr->HasAura(SPELL_CORPORAL))
+            {
+            	 plr->RewardHonor(NULL, 1, LooserHonor);
+            	 RewardMarkOfHonor(plr, 1);
+            }
+        }
+	}
+
+    for (uint8 team = 0; team < 2; ++team)
+    {
+	    for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+		{
+            if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+            {
+                plr->RemoveAura(SPELL_TOWER_CONTROL);
+                plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+				plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+				plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+		}
+		m_PlayersInWar[team].clear();
+
+        for(GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+        {
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    if (creature->IsVehicle())
+					    creature->GetVehicleKit()->Dismiss();
+        }
+        m_vehicles[team].clear();
+    }
+
+    if(!endbytimer)
+    {
+        SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WIN_KEEP,
+            sObjectMgr.GetTrinityStringForDBCLocale((GetDefenderTeam() == TEAM_ALLIANCE)
+            ? BATTLEFIELD_WG_TEXT_ALLIANCE
+            : BATTLEFIELD_WG_TEXT_HORDE));
+    }
+    else
+    {
+        SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_DEFEND_KEEP,
+            sObjectMgr.GetTrinityStringForDBCLocale((GetDefenderTeam() == TEAM_ALLIANCE)
+            ? BATTLEFIELD_WG_TEXT_ALLIANCE
+            : BATTLEFIELD_WG_TEXT_HORDE));
+    }
+}
+
+//*****************************************************
+//*******************Reward System*********************
+//*****************************************************
+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player * player, uint8 /*incrementNumber*/)
+{
+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
+    
+    switch(achievement)
+    {
+      case ACHIEVEMENTS_WIN_WG_100 :
+      {
+	//player->GetAchievementMgr().UpdateAchievementCriteria();
+      }
+      default:
+      {
+        if (player)
+           player->CompletedAchievement(AE);
+      }
+      break;
+    }
+
+}
+
+void BattlefieldWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (count == 0)
+        return;
+ 
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void BattlefieldWG::OnStartGrouping()
+{
+	//Warn
+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
+}
+
+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
+{
+    if (IsWarTime())
+	{
+        switch(creature->GetEntry())
+        {
+            case 28312:
+            case 32627:
+            case 27881:
+            case 28094:
+            {
+                uint8 team;
+                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                    team = TEAM_ALLIANCE;
+                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                    team = TEAM_HORDE;
+                else
+                    return;
+
+                if(add)
+                {
+                    if(team == TEAM_HORDE )
+                    {
+                	    if(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) < GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
+                	    {
+                            creature->AddAura(SPELL_HORDE_FLAG, creature);
+                		    m_vehicles[team].insert(creature->GetGUID());
+                		    m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
+                		    UpdateVehicleCountWG();
+                	    }
+                	    else
+                	    {
+                		    creature->setDeathState(DEAD);
+                		    creature->SetRespawnTime(RESPAWN_ONE_DAY);
+                		    return;
+                	    }
+                    }
+                    else
+                    {
+                        if(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) < GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) )
+                	    {
+                            creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
+                            m_vehicles[team].insert(creature->GetGUID());
+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
+                            UpdateVehicleCountWG();
+                	    }
+                	    else
+                	    {
+                            creature->setDeathState(DEAD);
+                            creature->SetRespawnTime(RESPAWN_ONE_DAY);
+                            return;
+                	    }
+                    }
+                }
+                else
+                {
+                    m_vehicles[team].erase(creature->GetGUID());
+                    if(team == TEAM_HORDE )
+                        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
+                    else
+                        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
+                    UpdateVehicleCountWG();
+                }
+                break;
+            }
+        }
+	}
+}
+
+
+void BattlefieldWG::HandleKill(Player *killer, Unit *victim)
+{
+    if(killer==victim)
+        return;
+
+    bool again = false;
+	if (victim->GetTypeId() == TYPEID_PLAYER)
+	{
+	    IncrementQuest(killer, WGQuete[killer->GetTeamId()][4]);
+		IncrementQuest(killer, WGQuete[killer->GetTeamId()][5]);
+		for (GuidSet::const_iterator p_itr = m_PlayersInWar[killer->GetTeamId()].begin(); p_itr != m_PlayersInWar[killer->GetTeamId()].end(); ++p_itr)
+		{
+			if(Player* plr=sObjectAccessor.FindPlayer(*p_itr))
+				if(plr->GetDistance2d(killer)<40)
+					PromotePlayer(plr);
+		}
+		return;
+	}
+	for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId() ? TEAM_ALLIANCE : TEAM_HORDE].begin(); itr != m_vehicles[killer->GetTeamId() ? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
+    {
+		if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+		{
+			if (Creature* creature = unit->ToCreature())
+		    {
+				if (victim->GetEntry() == creature->GetEntry() && !again)
+				{
+					again = true;
+					for (GuidSet::const_iterator p_itr = m_PlayersInWar[killer->GetTeamId()].begin(); p_itr != m_PlayersInWar[killer->GetTeamId()].end(); ++p_itr)					
+					{
+						if(Player* plr=sObjectAccessor.FindPlayer(*p_itr))
+							if(plr->GetDistance2d(killer)<40)
+								IncrementQuest(plr, IncrementQuest(killer, WGQuete[killer->GetTeamId()][0]));
+					}
+				}
+		    }
+	    }
+	}
+	for(GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId() ? TEAM_ALLIANCE : TEAM_HORDE].begin(); itr != KeepCreature[killer->GetTeamId() ? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
+	{
+		if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+		{
+			if (Creature* creature = unit->ToCreature())
+			{
+				if (victim->GetEntry() == creature->GetEntry() && !again)
+				{
+					again = true;
+					IncrementQuest(killer, WGQuete[killer->GetTeamId()][4]);
+					IncrementQuest(killer, WGQuete[killer->GetTeamId()][5]);
+					for (GuidSet::const_iterator p_itr = m_PlayersInWar[killer->GetTeamId()].begin(); p_itr != m_PlayersInWar[killer->GetTeamId()].end(); ++p_itr)
+					{
+						if(Player* plr=sObjectAccessor.FindPlayer(*p_itr))
+							if(plr->GetDistance2d(killer)<40)
+								PromotePlayer(plr);
+					}
+				}
+		    }
+	    }
+    }
+    //TODO:Recent PvP activity worldstate
+}
+
+//Update rank for player
+void BattlefieldWG::PromotePlayer(Player *killer)
+{
+    if (!m_WarTime)
+	    return;
+    //Updating rank of player
+    if (Aura * aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)//7 or more TODO:
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            SendWarningToPlayer(killer,BATTLEFIELD_WG_TEXT_FIRSTRANK);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (Aura * aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)//7 or more TODO:
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            SendWarningToPlayer(killer,BATTLEFIELD_WG_TEXT_SECONDRANK);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void BattlefieldWG::OnPlayerJoinWar(Player* plr)
+{
+    plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+    plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+    plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+    plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+    plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+    plr->RemoveAurasDueToSpell(58045);
+
+    plr->CastSpell(plr, SPELL_RECRUIT, true);
+    
+    if(plr->GetZoneId()!=m_ZoneId){
+        if(plr->GetTeamId()==GetDefenderTeam())
+        {
+            plr->TeleportTo(571,5345,2842,410,3.14f);
+        }
+        else
+        {
+            if(plr->GetTeamId()==TEAM_HORDE)
+                plr->TeleportTo(571,5025.857422f,3674.628906f,362.737122f,4.135169f);
+            else
+                plr->TeleportTo(571,5101.284f,2186.564f,373.549f,3.812f);
+        }   
+    }
+
+    UpdateTenacity();
+
+    if(plr->GetTeamId()==GetAttackerTeam())
+    {
+        if(3-m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]>0)
+            plr->SetAuraStack(SPELL_TOWER_CONTROL,plr,3-m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
+    }
+    else
+    {
+        if(m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]>0)
+            plr->SetAuraStack(SPELL_TOWER_CONTROL,plr,m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
+    }
+    SendInitWorldStatesTo(plr);
+}
+
+void BattlefieldWG::OnPlayerLeaveWar(Player* plr)
+{
+    //Remove all aura from WG //TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
+    if (!plr->GetSession()->PlayerLogout())
+    {
+        if (plr->GetVehicle()) //Remove vehicle of player if he go out.
+            plr->GetVehicle()->Dismiss();
+        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+        plr->RemoveAurasDueToSpell(58730);
+		plr->RemoveAurasDueToSpell(58045);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+    }
+}
+
+void BattlefieldWG::OnPlayerLeaveZone(Player* plr)
+{
+    plr->RemoveAurasDueToSpell(58045);
+    if (!m_WarTime)
+	{
+		plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+        plr->RemoveAurasDueToSpell(58730);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+	}}
+
+void BattlefieldWG::OnPlayerEnterZone(Player* plr)
+{
+    plr->RemoveAurasDueToSpell(58045);
+    if(!m_WarTime)
+	{
+	    plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+        plr->RemoveAurasDueToSpell(58730);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+	    if (plr->GetTeamId()==GetDefenderTeam())
+            plr->AddAura(58045,plr);
+	}
+
+    //Send worldstate to player
+    SendInitWorldStatesTo(plr);
+}
+//Method sending worldsate to player
+WorldPacket BattlefieldWG::BuildInitWorldStates()
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(BuildingsInZone.size()*8)+(WorkShopList.size()*8)));
+
+    data << uint32(m_MapId);
+    data << uint32(m_ZoneId);
+    data << uint32(0);
+    data << uint16(4+2+4+BuildingsInZone.size()+WorkShopList.size());
+
+    data << uint32(3803) << uint32(GetAttackerTeam());
+    data << uint32(3802) << uint32(GetDefenderTeam());
+    data << uint32(3801) << uint32(IsWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(IsWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << uint32(time(NULL)+(m_Timer / 1000));
+
+    data << uint32(3490) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
+    data << uint32(3491) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
+    data << uint32(3680) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
+    data << uint32(3681) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
+
+    for(GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+        data << (*itr)->m_WorldState << (*itr)->m_State;
+    }
+    for(WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+        data << (*itr)->m_WorldState << (*itr)->m_State;
+    }
+    return data;
+}
+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
+{
+   WorldPacket data= BuildInitWorldStates();
+   player->GetSession()->SendPacket(&data);
+}
+void BattlefieldWG::SendInitWorldStatesToAll()
+{
+	WorldPacket data= BuildInitWorldStates();
+	for(uint8 team=0;team<2;team++)
+		for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+			if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				plr->GetSession()->SendPacket(&data);
+}
+
+void BattlefieldWG::BrokenWallOrTower(TeamId team)
+{
+	if (team == GetDefenderTeam())
+	{
+		for (GuidSet::const_iterator p_itr = m_PlayersInWar[GetAttackerTeam()].begin(); p_itr != m_PlayersInWar[GetAttackerTeam()].end(); ++p_itr)
+		{
+			if (Player* plr=sObjectMgr.GetPlayer((*p_itr)))
+			{
+				if (plr->GetTeamId() == TEAM_ALLIANCE)
+					IncrementQuest(plr, 13222);
+				else
+					IncrementQuest(plr, 13223);
+			}
+		}
+	}
+}
+
+void BattlefieldWG::AddBrokenTower(TeamId team)
+{
+    //Destroy an attack tower
+    if(team==GetAttackerTeam())
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
+        //Remove buff stack
+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
+            if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+                plr->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
+        
+        //Add buff stack
+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
+            if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+	        {
+                plr->CastSpell(plr,SPELL_TOWER_CONTROL,true);
+		        if (plr->GetTeamId() == TEAM_HORDE)
+		            IncrementQuest(plr, 13539, true);
+		        else
+		            IncrementQuest(plr, 13538, true);
+		        DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, plr);
+	        }
+        if(m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]==3)
+		{
+            if(int32(m_Timer-600000)<0)
+            {
+                m_Timer=0;
+            }
+            else
+            {
+                m_Timer-=600000;
+            }
+            SendInitWorldStatesToAll();
+        }
+    }
+    else
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
+    }
+}
+void BattlefieldWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{
+    if (!obj || !IsWarTime())
+        return;
+    //On click on titan relic
+    if (obj->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
+    {
+        if(m_bCanClickOnOrb)
+     		EndBattle(false);
+     	else
+     		m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
+    }
+    //if destroy or damage event, search the wall/tower and update worldstate/send warning message
+    for(GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+        if(obj->GetEntry()==(*itr)->m_Build->GetEntry())
+		{
+            if((*itr)->m_Build->GetGOInfo()->building.damagedEvent==eventId)
+                (*itr)->Damaged();
+            
+            if((*itr)->m_Build->GetGOInfo()->building.destroyedEvent==eventId)
+                (*itr)->Destroyed();
+
+            break;
+        }
+    }
+}
+void BattlefieldWG::AddDamagedTower(TeamId team)
+{
+    //Destroy an attack tower
+    if(team==GetAttackerTeam())
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
+        //Remove a stacck
+    
+    //Add a stack
+    }
+    else
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
+    }
+}
+// Update vehicle count worldstate to player
+void BattlefieldWG::UpdateVehicleCountWG()
+{
+    SendUpdateWorldState(3490,GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
+    SendUpdateWorldState(3491,GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
+    SendUpdateWorldState(3680,GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
+    SendUpdateWorldState(3681,GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
+}
+
+void BattlefieldWG::UpdateTenacity()
+{
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
+    int32 newStack = 0;
+
+    if (allianceNum && hordeNum)
+    {
+       if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == int32(m_tenacityStack))
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+			if(Player *plr = sObjectMgr.GetPlayer((*itr)))
+				if (plr->getLevel() > 76)
+					plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+
+        if (newStack < 0)
+           newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        uint32 buff_honnor = SPELL_GREATEST_HONOR;
+        buff_honnor = (newStack < 15) ? (uint32)SPELL_GREATER_HONOR : buff_honnor;
+        buff_honnor = (newStack < 10) ? (uint32)SPELL_GREAT_HONOR : buff_honnor;
+        buff_honnor = (newStack < 5) ? 0 : buff_honnor;
+
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
+
+        if(buff_honnor != 0)
+        {
+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+                if (Player* plr=sObjectMgr.GetPlayer((*itr)))
+                    plr->AddAura(buff_honnor, plr);
+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+				if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+				    if (Creature* creature = unit->ToCreature())
+					    creature->AddAura(buff_honnor, creature);
+        }
+    }
+}
+
+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam*/)
+{
+    m_WorkShop->ChangeControl(m_team,false);
+}
+
+BfCapturePointWG::BfCapturePointWG(BattlefieldWG *bf,TeamId control) : BfCapturePoint(bf)
+{
+    m_Bf=bf;
+    m_team=control;
+}
+
+
+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
+{
+    m_Bf=bf;
+}
diff -r dc4fc5c8b306 src/server/game/Battlefield/Zones/BattlefieldWG.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h	Tue Nov 30 22:02:04 2010 -0500
@@ -0,0 +1,1693 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_WG_
+#define BATTLEFIELD_WG_
+
+#include "../Battlefield.h"
+#include "Group.h"
+#include "WorldPacket.h"
+#include "World.h"
+
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+const uint32 WintergraspFaction[3] = {1732, 1735, 35};
+
+
+
+class BattlefieldWG;
+class BfCapturePointWG;
+
+struct BfWGGameObjectBuilding;
+struct BfWGWorkShopData;
+
+typedef std::set<GameObject*> GameObjectSet;
+typedef std::set<BfWGGameObjectBuilding*> GameObjectBuilding;
+typedef std::set<BfWGWorkShopData*> WorkShop;
+typedef std::set<BfCapturePointWG*> CapturePointSet;
+typedef std::set<Group*> GroupSet;
+
+enum eWGpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+    SPELL_GREAT_HONOR                            = 58555,
+    SPELL_GREATER_HONOR                          = 58556,
+    SPELL_GREATEST_HONOR                         = 58557,
+    SPELL_ALLIANCE_FLAG                          = 14268,
+    SPELL_HORDE_FLAG                             = 14267,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+    SPELL_TELEPORT_BRIDGE                        = 59096,
+    SPELL_TELEPORT_FORTRESS                      = 60035,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+	
+    // Other spells
+    SPELL_WINTERGRASP_WATER                      = 36444,
+};
+enum eWGData32
+{
+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
+    BATTLEFIELD_WG_DATA_VEHICLE_A,
+    BATTLEFIELD_WG_DATA_VEHICLE_H,
+    BATTLEFIELD_WG_DATA_MAX,
+};
+
+enum WB_ACHIEVEMENTS
+{
+	ACHIEVEMENTS_WIN_WG               = 1717,
+	ACHIEVEMENTS_WIN_WG_100           = 1718, //todo
+	ACHIEVEMENTS_WG_GNOMESLAUGHTER	  = 1723, //todo
+	ACHIEVEMENTS_WG_TOWER_DESTROY     = 1727,
+	ACHIEVEMENTS_DESTRUCTION_DERBY_A  = 1737, //todo
+	ACHIEVEMENTS_WG_TOWER_CANNON_KILL = 1751, //todo
+	ACHIEVEMENTS_WG_MASTER_A	  = 1752, //todo
+	ACHIEVEMENTS_WIN_WG_TIMER_10      = 1755,
+	ACHIEVEMENTS_STONE_KEEPER_50	  = 2085, //todo
+	ACHIEVEMENTS_STONE_KEEPER_100	  = 2086, //todo
+	ACHIEVEMENTS_STONE_KEEPER_250	  = 2087, //todo
+	ACHIEVEMENTS_STONE_KEEPER_500	  = 2088, //todo
+	ACHIEVEMENTS_STONE_KEEPER_1000	  = 2089, //todo
+	ACHIEVEMENTS_WG_RANGER		  = 2199, //todo
+	ACHIEVEMENTS_DESTRUCTION_DERBY_H  = 2476, //todo
+	ACHIEVEMENTS_WG_MASTER_H	  = 2776, //todo
+
+};
+
+/*#########################
+*####### Graveyards ######*
+#########################*/
+
+class BfGraveYardWG: public BfGraveYard
+{
+public:
+    BfGraveYardWG(BattlefieldWG* Bf);
+    void SetTextId(uint32 textid){m_GossipTextId=textid;}
+    uint32 GetTextId(){return m_GossipTextId;}
+protected:
+    uint32 m_GossipTextId;
+};
+
+enum eWGGraveyardId
+{
+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
+    BATTLEFIELD_WG_GY_KEEP,
+    BATTLEFIELD_WG_GY_HORDE,
+    BATTLEFIELD_WG_GY_ALLIANCE,
+    BATTLEFIELD_WG_GY_MAX,
+};
+
+enum eWGGossipText
+{
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE = -1850501,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW = -1850502,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE = -1850504,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW = -1850503,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP = -1850500,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE = -1850505,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE = -1850506,
+};
+enum eWGNpc
+{
+    BATTLEFIELD_WG_NPC_GUARD_H = 30739,
+    BATTLEFIELD_WG_NPC_GUARD_A = 30740,
+};
+
+struct BfWGCoordGY
+{
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 gyid;
+    uint8 type;
+    uint32 textid;//for gossip menu
+    TeamId startcontrol;
+};
+
+const uint32 WGQuete[2][6]=
+{
+    {13186,13181,13222,13538,13177,13179},
+    {13185,13183,13223,13539,13178,13180},
+};
+
+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX]=
+{
+    {5104.750f,2300.940f,368.579f,0.733038f,1329,BATTLEFIELD_WG_GY_WORKSHOP_NE,BATTLEFIELD_WG_GOSSIPTEXT_GY_NE,TEAM_NEUTRAL},
+    {5099.120f,3466.036f,368.484f,5.317802f,1330,BATTLEFIELD_WG_GY_WORKSHOP_NW,BATTLEFIELD_WG_GOSSIPTEXT_GY_NW,TEAM_NEUTRAL},
+    {4314.648f,2408.522f,392.642f,6.268125f,1333,BATTLEFIELD_WG_GY_WORKSHOP_SE,BATTLEFIELD_WG_GOSSIPTEXT_GY_SE,TEAM_NEUTRAL},
+    {4331.716f,3235.695f,390.251f,0.008500f,1334,BATTLEFIELD_WG_GY_WORKSHOP_SW,BATTLEFIELD_WG_GOSSIPTEXT_GY_SW,TEAM_NEUTRAL},
+    {5537.986f,2897.493f,517.057f,4.819249f,1285,BATTLEFIELD_WG_GY_KEEP,BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP,TEAM_NEUTRAL},
+    {5032.454f,3711.382f,372.468f,3.971623f,1331,BATTLEFIELD_WG_GY_HORDE,BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE,TEAM_HORDE},
+    {5140.790f,2179.120f,390.950f,1.972220f,1332,BATTLEFIELD_WG_GY_ALLIANCE,BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE,TEAM_ALLIANCE},
+};
+
+/*#########################
+* BfCapturePointWG       *
+#########################*/
+
+class BfCapturePointWG: public BfCapturePoint
+{
+public:
+    BfCapturePointWG(BattlefieldWG* bf,TeamId control);
+    void LinkToWorkShop(BfWGWorkShopData* ws) {m_WorkShop=ws;}
+
+    void ChangeTeam(TeamId oldteam);
+    TeamId GetTeam() const { return m_team; }
+
+protected:
+    BfWGWorkShopData* m_WorkShop;
+};
+/*#########################
+* WinterGrasp Battlefield *
+#########################*/
+
+class BattlefieldWG: public Battlefield
+{
+public:
+    void OnBattleStart();
+    void OnBattleEnd(bool endbytimer);
+    void OnStartGrouping();
+    void OnPlayerJoinWar(Player* plr);
+    void OnPlayerLeaveWar(Player* plr);
+    void OnPlayerLeaveZone(Player* plr);
+    void OnPlayerEnterZone(Player* plr);
+    bool Update(uint32 diff);
+    void OnCreatureCreate(Creature *creature, bool add);
+    void BrokenWallOrTower(TeamId team);
+    void AddDamagedTower(TeamId team);
+    void AddBrokenTower(TeamId team);
+    void DoCompleteOrIncrementAchievement(uint32 achievement, Player* player, uint8 incrementNumber = 1);
+    void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+    bool SetupBattlefield();
+    GameObject* GetRelic() {return m_relic;}
+    void SetRelic(GameObject* relic){m_relic=relic;}
+
+    bool CanClickOnOrb() {return m_bCanClickOnOrb;}
+    void AllowToClickOnOrb(bool allow) {m_bCanClickOnOrb = allow;}
+    
+    void RewardMarkOfHonor(Player *plr, uint32 count);
+    
+    void UpdateVehicleCountWG();
+	void UpdateCounterVehicle(bool init);
+
+    WorldPacket BuildInitWorldStates();
+    void SendInitWorldStatesTo(Player* plr);
+    void SendInitWorldStatesToAll();
+    
+    void HandleKill(Player *killer, Unit *victim);
+    void PromotePlayer(Player *killer);
+
+    void UpdateTenacity();
+    void ProcessEvent(GameObject *obj, uint32 eventId);
+protected:
+    bool m_bCanClickOnOrb;
+    GameObject* m_relic;
+    GameObjectBuilding BuildingsInZone;
+    GuidSet KeepCreature[2];
+	GuidSet OutsideCreature[2];
+    WorkShop WorkShopList; 
+    GuidSet CanonList;
+    GameObjectSet DefenderPortalList;
+    GameObjectSet m_KeepGameObject[2];
+    GuidSet m_vehicles[2];
+    GuidSet m_PlayersIsSpellImu;  //Player is dead
+    uint32 m_tenacityStack;
+    uint32 m_saveTimer;
+};
+
+#define NORTHREND_WINTERGRASP 4197
+
+enum eWGGameObjectBuildingType
+{
+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
+};
+
+enum eWGGameObjectState
+{
+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
+
+
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
+};
+
+enum eWGWorkShopType
+{
+    BATTLEFIELD_WG_WORKSHOP_NE,
+    BATTLEFIELD_WG_WORKSHOP_NW,
+    BATTLEFIELD_WG_WORKSHOP_SE,
+    BATTLEFIELD_WG_WORKSHOP_SW,
+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
+};
+
+enum eWGTeamControl
+{
+    BATTLEFIELD_WG_TEAM_ALLIANCE,
+    BATTLEFIELD_WG_TEAM_HORDE,
+    BATTLEFIELD_WG_TEAM_NEUTRAL,    
+};
+enum eWGText
+{
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE = 12055,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW = 12052,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE = 12053,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW = 12054,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK = 12051,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN = 12050,
+    BATTLEFIELD_WG_TEXT_ALLIANCE = 12057,
+    BATTLEFIELD_WG_TEXT_HORDE = 12056,
+    BATTLEFIELD_WG_TEXT_WILL_START = 12058,
+    BATTLEFIELD_WG_TEXT_START = 12067,
+    BATTLEFIELD_WG_TEXT_FIRSTRANK = 12059,
+    BATTLEFIELD_WG_TEXT_SECONDRANK = 12060,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE = 12062,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW = 12064,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE = 12061,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW = 12063,
+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE = 12065,
+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY = 12066,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S = 12069,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E = 12070,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W = 12071,
+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP = 12068,
+    BATTLEFIELD_WG_TEXT_WIN_KEEP = 12072,
+};
+
+enum eWGObject
+{
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE = 190475,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW = 190487,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE = 194959,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW = 194962,
+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC = 192829,
+};
+struct BfWGObjectPosition
+{
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 entryh;
+    uint32 entrya;
+};
+
+//*********************************************************
+//************Destructible (Wall,Tower..)******************
+//*********************************************************
+
+struct BfWGBuildingSpawnData
+{
+    uint32 entry;
+    uint32 WorldState;
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 type;
+    uint32 nameid;
+};
+#define WG_MAX_OBJ 32
+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = 
+{
+    // Wall
+    // Entry WS    X        Y        Z        O         type                          NameID
+    {190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190220, 3750, 5331.26f, 3047.1f,  407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191796, 3772, 5384.45f, 2771.84f, 410.27f,  3.14159f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191802, 3751, 5280.2f,  2995.58f, 408.825f, 1.61443f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f,   BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f,   BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191806, 3769, 5279.5f,  2798.94f, 409.998f, 1.5708f,   BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191808, 3760, 5279.6f,  2683.79f, 409.849f, 1.55334f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190371, 3754, 5214.96f, 2934.09f, 409.19f,  -0.008724f,BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+
+    //Tower of keep
+    {190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f,  BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW},
+    {190373, 3713, 5163.76f, 2932.23f, 409.19f,  3.12412f,  BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW},
+    {190377, 3714, 5166.4f,  2748.37f, 409.188f, -1.5708f,  BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE},
+    {190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE},
+
+    //Wall (with passage)
+    {191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+    {191805, 3768, 5279.13f, 2840.8f,  409.783f, 1.57952f,  BATTLEFIELD_WG_OBJECTTYPE_WALL, 0},
+
+    //South tower
+    {190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f,  BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W},
+    {190357, 3705, 4398.17f, 2822.5f,  405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S},
+    {190358, 3706, 4459.1f,  1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E},
+
+    //Door of forteress
+    {190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0},
+
+    //Last door
+    {191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f,  BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0},
+};
+
+
+//*********************************************************
+//**********Keep Element(GameObject,Creature)**************
+//*********************************************************
+
+//Keep gameobject
+#define WG_KEEPGAMEOBJECT_MAX 44
+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX]={
+	{5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501}, // Flag on tower
+	{5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416}, // Flag on Wall Intersect
+	{5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416}, // Flag on Wall Intersect
+	{5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501}, // Flag on tower
+	{5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501}, // Flag on tower
+	{5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416}, // Flag on wall
+	{5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416}, // Flag on Wall Intersect
+	{5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269}, // Flag on the floor
+	{5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269}, // Flag on the floor
+	{5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416}, // Flag on wall intersect
+	{5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416}, // Flag on wall
+	{5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501}, // Flag on tower
+	{5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501}, // Flag on tower
+	{5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416}, // Flag on wall intersect
+	{5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416}, // Flag on wall intersect
+	{5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501}, // Flag on tower
+	{5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501}, // Flag on tower
+	{5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416}, // Flag on wall intersect
+	{5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416}, // Flag on wall intersect
+	{5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416}, // Flag on wall intersect
+	{5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416}, // Flag on wall intersect
+	{5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416}, // Flag on wall intersect
+	{5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416}, // Flag on wall intersect
+	{5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416}, // Flag on wall intersect
+	{5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416}, // Flag on wall intersect
+	{5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416}, // Flag on wall intersect
+	{5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416}, // Flag on wall intersect
+    {5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416}, // Flag on wall intersect
+	{5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416}, // Flag on wall intersect
+	{5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416}, // Flag on keep
+	{5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416}, // Flag on keep
+	{5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269}, // Flag on floor
+	{5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269}, // Flag on floor
+	{5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416}, // Flag on wall intersect
+	{5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416}, // Flag on wall intersect
+	{5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416}, // Flag on wall intersect
+	{5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416}, // Flag on wall intersect
+	{5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416}, // Flag on wall intersect
+	{5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416}, // Flag on wall intersect
+	{5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416}, // Flag on wall intersect
+	{5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416}, // Flag on wall intersect
+	{5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416}, // Flag on wall intersect
+	{5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416}, // Flag on wall intersect
+	{5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416} // Flag on wall intersect
+};
+
+//Keep turret
+struct BfWGTurretPos
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+#define WG_MAX_TURRET 15
+const BfWGTurretPos WGTurret[WG_MAX_TURRET]=
+{
+    {5391.19f, 3060.8f, 419.616f, 1.69557f},
+    {5266.75f, 2976.5f, 421.067f, 3.20354f},
+    {5234.86f, 2948.8f, 420.88f, 1.61311f},
+    {5323.05f, 2923.7f, 421.645f, 1.5817f},
+    {5363.82f, 2923.87f, 421.709f, 1.60527f},
+    {5264.04f, 2861.34f, 421.587f, 3.21142f},
+    {5264.68f, 2819.78f, 421.656f, 3.15645f},
+    {5322.16f, 2756.69f, 421.646f, 4.69978f},
+    {5363.78f, 2756.77f, 421.629f, 4.78226f},
+    {5236.2f, 2732.68f, 421.649f, 4.72336f},
+    {5265.02f, 2704.63f, 421.7f, 3.12507f},
+    {5350.87f, 2616.03f, 421.243f, 4.72729f},
+    {5390.95f, 2615.5f, 421.126f, 4.6409f},
+    {5148.8f, 2820.24f, 421.621f, 3.16043f},
+    {5147.98f, 2861.93f, 421.63f, 3.18792f},
+};
+
+
+//Here there is all npc keeper spawn point
+#define WG_MAX_KEEP_NPC 39
+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] =
+{
+    // X          Y            Z           O         horde                          alliance
+    // North East 
+    {5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Roaming Guard
+    {5298.430176f, 2738.760010f, 409.316010f, 3.971740f, 31102, 31052}, // Vieron Plumembrase /
+    {5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    // North
+    {5373.470215f, 2789.060059f, 409.322998f, 2.600540f, 32296, 32294}, // Garde de pierre Mukar /
+    {5296.560059f, 2789.870117f, 409.274994f, 0.733038f, 31101, 31051}, // Ma?tre vodoun Fu'jin /
+    {5372.670000f, 2786.740000f, 409.442000f, 2.809980f, 39173, 39172}, // Wintergrasp Quartermaster /
+    {5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5359.129883f, 2837.989990f, 409.364014f, 4.698930f, 31091, 31036}, // Commandant Dardosh /
+    {5366.129883f, 2833.399902f, 409.322998f, 3.141590f, 31151, 31153}, // Officier tactique Kilrath /
+    // X          Y            Z           O         horde  alliance
+    // North West
+    {5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5295.560059f, 2926.669922f, 409.274994f, 0.872665f, 31106, 31108}, // Poliorc?te Sabot-puissant /
+    {5371.399902f, 3026.510010f, 409.205994f, 3.250030f, 31053, 31054}, // Primaliste Mulfort /
+    {5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Roaming Guard
+    // South
+    {5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5234.970215f, 2883.399902f, 409.274994f, 4.293510f, 31107, 31109}, // Lieutenant Murp /
+    // X          Y            Z           O         horde  alliance
+    // Gardes des portails (autour de la forteresse)
+    {5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A}, // Standing Guard
+    {5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A} // Standing Guard
+};
+
+#define WG_MAX_OUTSIDE_NPC          14
+#define WG_OUTSIDE_ALLIANCE_NPC     7
+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
+{
+    {5032.04f,     3681.79f,     362.98f,     4.21f,     31102, 0}, // Vieron Plumembrase /
+    {5020.71f,     3626.19f,     360.15f,     4.64f,     31101, 0}, // Ma?tre vodoun Fu'jin /
+    {4994.85f,     3660.51f,     359.15f,     2.26f,     31091, 0}, // Commandant Dardosh /
+    {5015.46f,     3677.11f,     362.97f,     6.009f,    31151, 0}, // Officier tactique Kilrath /
+    {5031.12f,     3663.77f,     363.50f,     3.11f,     31106, 0}, // Poliorc?te Sabot-puissant /
+    {5042.74f,     3675.82f,     363.06f,     3.358f,    31053, 0}, // Primaliste Mulfort /
+    {5014.45f,     3640.87f,     361.39f,     3.28f,     31107, 0}, // Lieutenant Murp /
+    {5100.07f,     2168.89f,     365.779f,    1.97222f,  0, 31052}, //
+    {5081.7f,      2173.73f,     365.878f,    0.855211f, 0, 31051}, //
+    {5078.28f,     2183.7f,      365.029f,    1.46608f,  0, 31036}, //
+    {5088.49f,     2188.18f,     365.647f,    5.25344f , 0, 31153}, //
+    {5095.67f,     2193.28f,     365.924f,    4.93928f,  0, 31108}, //
+    {5088.61f,     2167.66f,     365.689f,    0.680678f, 0, 31054}, //
+    {5080.4f,      2199.0f,      359.489f,    2.96706f,  0, 31109}, //
+};
+
+struct BfWGWGTeleporterData
+{
+    uint32 entry;   //Entry of GameObject
+    float x;        //Position where must be spawn the GameObject
+    float y;        //  --
+    float z;        //  --
+    float o;        //  --
+};
+#define WG_MAX_TELEPORTER 12
+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] = 
+{
+    {190763, 5153.41f, 2901.35f, 409.191f, -0.069812f},
+    {190763, 5268.7f,  2666.42f, 409.099f, -0.715585f},
+    {190763, 5197.05f, 2944.81f, 409.191f, 2.33874f},
+    {190763, 5196.67f, 2737.34f, 409.189f, -2.93214f},
+    {190763, 5314.58f, 3055.85f, 408.862f, 0.541051f},
+    {190763, 5391.28f, 2828.09f, 418.675f, -2.16421f},
+    {190763, 5153.93f, 2781.67f, 409.246f, 1.65806f},
+    {190763, 5311.44f, 2618.93f, 409.092f, -2.37364f},
+    {190763, 5269.21f, 3013.84f, 408.828f, -1.76278f},
+    {190763, 5401.62f, 2853.66f, 418.674f, 2.635440f},
+    {192951, 5314.51f, 2703.69f, 408.55f, -0.890117f}, 		  // Teleport right vehicle
+    {192951, 5316.25f, 2977.04f, 408.539f, -0.820303f}
+};
+
+//*********************************************************
+//**********Tower Element(GameObject,Creature)*************
+//*********************************************************
+
+struct BfWGTowerData {
+	uint32 towerentry; //Gameobject id of tower // TODO: needed ? 
+	uint8 nbObject; //Number of gameobject spawned on this point
+	BfWGObjectPosition GameObject[6];//Gameobject position and entry (Horde/Alliance)
+    //Creature : Turrets and Guard, TODO: check if killed on tower destroy ? tower damage ?
+	uint8 nbCreatureBottom;//Number of Creature spawned on Bottom (4 turrets and some guard)
+    BfWGObjectPosition CreatureBottom[9]; // bottom creaturer
+    uint8 nbCreatureTop; //Number of Creature spawned on Top (4 turrets and 1 guard ? need confirm)
+    BfWGObjectPosition CreatureTop[5]; // tor creature
+};
+
+#define WG_MAX_ATTACKTOWERS 3
+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS]={
+	//Tower west
+    {
+        190356,
+        6,
+        {
+            {4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501},// Flag on tower
+            {4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501},// Flag on tower
+            {4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501},// Flag on tower
+            {4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501},// Flag on tower
+            {4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278},// Flag near workshop
+            {4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278}// Flag near bridge
+        },
+        1,
+        {
+            {4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Roaming Guard
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+            {0			, 0			 , 0 	     , 0	   , 0    , 0    },
+        },
+        0,
+        {
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+        }
+    },
+    //Tower South
+    {
+        190357,
+        5,
+        {
+			{4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501},// Flag on tower
+			{4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501},// Flag on tower
+			{4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414},// Flag near tower
+			{4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429},// Flag near tower
+			{4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278},// Flag near bridge
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+        },
+        6,
+        {
+			{4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Roaming Guard
+			{4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+        },
+        0,
+        {
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+        },
+    },
+    //Tower east
+    {
+        190358,
+        4,
+        {
+        	{4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501},// Flag on tower
+			{4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501},// Flag on tower
+			{4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501},// Flag on tower
+			{4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501},// Flag on tower
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+		},
+		5,
+		{
+			{4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},// Standing Guard
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+			{0			, 0			 , 0 	     , 0	   , 0    , 0    },
+        },
+        0,
+        {
+
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+			{0,0,0,0,0,0},
+		},
+    },
+};
+
+struct BfWGTurretData {
+	uint32 towerentry;
+	uint8 nbTurretBottom;
+	BfWGTurretPos TurretBottom[5];
+	uint8 nbTurretTop;
+	BfWGTurretPos TurretTop[5];
+};
+
+#define WG_MAX_TOWERTURRET 7
+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET]={
+	{
+		190221,
+		0,
+		{
+		    {0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+		    {5255.88f, 3047.63f, 438.499f, 3.13677f},
+            {5280.9f, 3071.32f, 438.499f, 1.62879f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	{
+		190373,
+		0,
+		{
+		    {0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+		    {5138.59f, 2935.16f, 439.845f, 3.11723f},
+			{5163.06f, 2959.52f, 439.846f, 1.47258f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	{
+		190377,
+		0,
+		{
+		    {0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+		    {5163.84f, 2723.74f, 439.844f, 1.3994f},
+			{5139.69f, 2747.4f, 439.844f, 3.17221f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	{
+		190378,
+		0,
+		{
+		    {0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+		    {5278.21f, 2607.23f, 439.755f, 4.71944f},
+			{5255.01f, 2631.98f, 439.755f, 3.15257f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	//Tower west
+	{
+		190356,
+		2,
+		{
+			{4537.380371f,3599.531738f,402.886993f,3.998462f},
+			{4581.497559f,3604.087158f,402.886963f,5.651723f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+			{4469.448242f,1966.623779f,465.647217f,1.153573f},
+			{4581.895996f,3626.438477f,426.539062f,0.117806f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	//Tower South
+	{
+		190357,
+		2,
+		{
+			{4421.640137f,2799.935791f,412.630920f,5.459298f},
+			{4420.263184f,2845.340332f,412.630951f,0.742197f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		3,
+		{
+			{4423.430664f,2822.762939f,436.283142f,6.223487f},
+			{4397.825684f,2847.629639f,436.283325f,1.579430f},
+			{4398.814941f,2797.266357f,436.283051f,4.703747f},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+	//Tower east
+	{
+		190358,
+		2,
+		{
+			{4448.138184f,1974.998779f,441.995911f,1.967238f},
+			{4448.713379f,1955.148682f,441.995178f,0.380733f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+		2,
+		{
+			{4469.448242f,1966.623779f,465.647217f,1.153573f},
+			{4481.996582f,1933.658325f,465.647186f,5.873029f},
+			{0,0,0,0},
+			{0,0,0,0},
+			{0,0,0,0},
+		},
+	},
+};
+
+//*********************************************************
+//*****************WorkShop Data & Element*****************
+//*********************************************************
+
+struct BfWGWorkShopDataBase
+{
+    uint32 entry;
+    uint32 worldstate;
+    uint32 type;
+    uint32 nameid;
+    BfWGObjectPosition CapturePoint;
+    uint8 nbcreature;
+    BfWGObjectPosition CreatureData[10];
+    uint8 nbgob;
+    BfWGObjectPosition GameObjectData[10];
+};
+
+#define WG_MAX_WORKSHOP  6
+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP]=
+{
+    {192031, 3701, BATTLEFIELD_WG_WORKSHOP_NE,BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE},
+        1,
+        //creature
+        {
+            {4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        },
+        6,
+        //gameobject
+        {
+            {4778.189f, 2438.060f, 345.644f, -2.940f, 192280,192274},
+            {5024.569f, 2532.750f, 344.023f, -1.937f, 192280,192274},
+            {4811.399f, 2441.899f, 358.207f, -2.003f, 192435,192406},
+            {4805.669f, 2407.479f, 358.191f, 1.780f, 192435,192406},
+            {5004.350f, 2486.360f, 358.449f, 2.172f, 192435,192406},
+            {4983.279f, 2503.090f, 358.177f, -0.427f, 192435,192406},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    },
+
+    {192030, 3700, BATTLEFIELD_WG_WORKSHOP_NW,BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW},
+        1,
+        //creature
+        {
+            {4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        },
+        4,
+        //gameobject
+        {
+            {5006.339f,3280.399f,371.162f, 2.225f,192280,192274},
+            {5041.609f,3294.399f,382.149f,-1.631f,192434,192406},
+            {4857.970f,3335.439f,368.881f,-2.945f,192280,192274},
+            {4855.629f,3297.620f,376.739f,-3.132f,192435,192406},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    },
+    {192033, 3703, BATTLEFIELD_WG_WORKSHOP_SE,BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
+        {4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE},
+        9,
+        //creature
+        {
+            {4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499},
+            {0,0,0,0,0,0}
+        },
+        2,
+        {
+        //gameobject
+            {4417.250f,2301.139f,377.213f, 0.026f,192435,192406},
+            {4417.939f,2324.810f,371.576f, 3.080f,192280,192274},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    },
+
+    {192032, 3702, BATTLEFIELD_WG_WORKSHOP_SW,BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
+        {4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW},
+        9,
+        //creature
+        {
+            {4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A},
+            {4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499},
+            {0,0,0,0,0,0}
+        },
+        3,
+        //gameobject
+        {
+            {4438.299f,3361.080f,371.567f,-0.017f,192435,192406},
+            {4448.169f,3235.629f,370.411f,-1.562f,192435,192406},
+            {4424.149f,3286.540f,371.545f, 3.124f,192280,192274},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    },
+
+    {192028, 3698, BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,0,
+        {0,0,0,0,0,0},
+        1,
+        //creature
+        {
+            {5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        },
+        //gameobject
+        0,
+        {
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    },
+
+    {192029, 3699, BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,0,
+        {0,0,0,0,0,0},
+        //creature
+        1,
+        {
+            {5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        },
+        //gameobject
+
+        0,
+        {
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0},
+            {0,0,0,0,0,0}
+        }
+    }
+};
+
+
+
+
+
+//*********************************
+
+
+//********************************************************************
+//*                Structs using for Building,Graveyard,Workshop         *
+//********************************************************************
+
+//Structure for different building witch can be destroy during battle
+struct BfWGGameObjectBuilding
+{
+    BfWGGameObjectBuilding(BattlefieldWG* WG)
+    {
+        m_WG = WG;
+        m_Team = 0;
+        m_Build = NULL;
+        m_Type = 0;
+        m_WorldState = 0;
+        m_State = 0;
+        m_NameId = 0;
+
+    }
+    //Team witch control this point
+    uint8 m_Team;
+
+    // WG object
+    BattlefieldWG* m_WG;
+
+    //Linked gameobject
+    GameObject* m_Build; 
+
+    //eWGGameObjectBuildingType
+    uint32 m_Type;
+
+    //WorldState
+    uint32 m_WorldState;
+
+    //eWGGameObjectState
+    uint32 m_State;
+    
+    //Name id for warning text
+    uint32 m_NameId;
+
+	//GameObject associate
+	GameObjectSet m_GameObjectList[2];
+
+	//Creature associate
+	GuidSet m_CreatureBottomList[2];
+	GuidSet m_CreatureTopList[2];
+	GuidSet m_TurretBottomList;
+	GuidSet m_TurretTopList;
+
+    void Rebuild()
+    {
+        switch(m_Type)
+        {
+        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+        case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
+        case BATTLEFIELD_WG_OBJECTTYPE_WALL:
+            m_Team=m_WG->GetDefenderTeam();//Object of Keep has defender faction
+            break;
+        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+            m_Team=m_WG->GetAttackerTeam();//Tower in south are for attacker
+            break;
+        default:
+            m_Team=TEAM_NEUTRAL;
+            break;
+        }
+
+        //Rebuild gameobject
+        m_Build->Rebuild();
+        //Updating worldstate
+        m_State=BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT-(m_Team*3);
+        m_WG->SendUpdateWorldState(m_WorldState,m_State);
+	    UpdateCreatureAndGo();
+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION,WintergraspFaction[m_Team]);
+    }
+
+    //Called when associate gameobject is damaged
+    void Damaged()
+    {
+        //Updating worldstate
+        m_State=BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE-(m_Team*3);
+        m_WG->SendUpdateWorldState(m_WorldState,m_State);
+        //Send warning message
+        if(m_NameId)
+            m_WG->SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_TOWER_DAMAGE,sObjectMgr.GetTrinityStringForDBCLocale(m_NameId));
+
+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->HideNpc(creature);
+
+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
+		    if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->HideNpc(creature);
+
+        if(m_Type==BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
+        else if (m_Type==BATTLEFIELD_WG_OBJECTTYPE_TOWER)
+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
+    }
+    
+    //Called when associate gameobject is destroy
+    void Destroyed()
+    {
+        //Updating worldstate
+        m_State=BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY-(m_Team*3);
+        m_WG->SendUpdateWorldState(m_WorldState,m_State);
+        //Warning 
+        if(m_NameId)
+            m_WG->SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_TOWER_DESTROY,sObjectMgr.GetTrinityStringForDBCLocale(m_NameId));
+        switch(m_Type)
+        {
+        //If destroy tower, inform WG script of it (using for reward calculation and event with south towers)
+        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+            m_WG->AddBrokenTower(TeamId(m_Team));
+            break;
+        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+            m_WG->AllowToClickOnOrb(true);
+            if(m_WG->GetRelic())
+                m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
+            else
+                sLog.outError("BATTLEFIELD: WG: Relic cant be clickable");
+            break;
+        }
+		m_WG->BrokenWallOrTower(TeamId(m_Team));
+    }
+
+    void Init(GameObject* go,uint32 type,uint32 worldstate,uint32 nameid)
+    {
+        //GameObject associate to object
+        m_Build = go;
+        //Type of building (WALL/TOWER/DOOR)
+        m_Type = type;
+        //WorldState for client (icon on map)
+        m_WorldState = worldstate;
+        //NameId for Warning text
+        m_NameId = nameid;
+        switch(m_Type)
+        {
+        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+        case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
+        case BATTLEFIELD_WG_OBJECTTYPE_WALL:
+            m_Team=m_WG->GetDefenderTeam();//Object of Keep has defender faction
+            break;
+        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+            m_Team=m_WG->GetAttackerTeam();//Tower in south are for attacker
+            break;
+        default: 
+            m_Team=TEAM_NEUTRAL;
+            break;
+        }
+        m_State=sWorld.getWorldState(m_WorldState);
+        switch (m_State)
+        {
+            case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
+            case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
+                if(m_Build)
+                    m_Build->Rebuild();
+                break;
+            case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
+            case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
+                if(m_Build){
+                    m_Build->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                    m_Build->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+                    m_Build->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_Build->GetGOInfo()->building.destroyedDisplayId);
+                }
+                break;
+            case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
+            case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
+                if(m_Build){
+                    m_Build->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                    m_Build->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_Build->GetGOInfo()->building.damagedDisplayId);
+                }
+                break;
+        }
+
+	    
+        int32 towerid = -1;
+	    switch(go->GetEntry())
+	    {
+		case 190221:
+			towerid=0;
+			break;
+		case 190373:
+			towerid=1;
+			break;
+		case 190377:
+			towerid=2;
+			break;
+		case 190378:
+		    towerid=3;
+			break;
+		case 190356:
+		    towerid=4;
+			break;
+		case 190357:
+		    towerid=5;
+			break;
+		case 190358:
+		    towerid=6;
+			break;
+	    }
+	    if(towerid>3)
+	    {
+            //Spawn associate gameobject
+            for(uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
+            {
+        	    BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
+        	    if(GameObject* go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
+        		    m_GameObjectList[TEAM_HORDE].insert(go);
+        	    if(GameObject* go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
+        		    m_GameObjectList[TEAM_ALLIANCE].insert(go);
+            }
+
+            //Spawn associate npc bottom
+            for(uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
+            {
+        	    BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
+        	    if(Creature* creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
+            	    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
+	            if(Creature* creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
+		            m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
+            }
+            //Spawn associate npc top
+            for(uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
+            {
+        	    BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
+        	    if(Creature* creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
+            	    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
+	            if(Creature* creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
+		            m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
+            }
+		}
+		if(towerid>=0)
+		{
+			//Spawn Turret bottom
+			for(uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
+			{
+				BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
+				if (Creature* turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, 0))
+				{
+					m_TurretBottomList.insert(turret->GetGUID());
+				    switch(go->GetEntry())
+	                {
+				        case 190221:
+						case 190373:
+						case 190377:
+						case 190378:
+						{
+					        turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+						    break;
+						}
+						case 190356:
+						case 190357:
+						case 190358:
+                        {
+					        turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                            break;
+						}
+					}
+					m_WG->HideNpc(turret);
+				}
+			}
+			//Spawn Turret top
+			for(uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
+			{
+				BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
+				if (Creature* turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, 0))
+				{
+				    m_TurretTopList.insert(turret->GetGUID());
+				    switch(go->GetEntry())
+	                {
+				        case 190221:
+						case 190373:
+						case 190377:
+						case 190378:
+						{
+					        turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+						    break;
+						}
+						case 190356:
+						case 190357:
+						case 190358:
+                        {
+					        turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                            break;
+						}
+					}
+					m_WG->HideNpc(turret);
+				}
+			}
+			UpdateCreatureAndGo();
+        }
+    }
+
+    void UpdateCreatureAndGo()
+    {
+    	for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
+          	if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->HideNpc(creature);
+        
+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->ShowNpc(creature,true);
+
+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->HideNpc(creature);
+        
+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			    if (Creature* creature = unit->ToCreature())
+				    m_WG->ShowNpc(creature,true);
+
+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
+        	(*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
+        	(*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+    }
+
+	void UpdateTurretAttack(bool disable)
+	{
+		for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
+		{
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			{
+			    if (Creature* creature = unit->ToCreature())
+				{
+				    if(disable)
+				    {
+		                if (m_Build)
+						{
+						    switch(m_Build->GetEntry())
+	                        {
+							    case 190221:
+						        case 190373:
+						        case 190377:
+						        case 190378:
+								{
+					                creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+									break;
+								}
+								case 190356:
+						        case 190357:
+						        case 190358:
+								{
+								    creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+									break;
+								}
+							}
+					        m_WG->HideNpc(creature);
+						}
+				    }
+				    else
+				    {
+					    if (m_Build)
+						{
+						    switch(m_Build->GetEntry())
+	                        {
+							    case 190221:
+						        case 190373:
+						        case 190377:
+						        case 190378:
+								{
+					                creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+									break;
+								}
+								case 190356:
+						        case 190357:
+						        case 190358:
+								{
+								    creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+									break;
+								}
+							}
+						    m_WG->ShowNpc(creature, true);
+						}
+				    }
+				}
+			}
+		}
+
+		for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
+		{
+			if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+			{
+			    if (Creature* creature = unit->ToCreature())
+				{
+				    if(disable)
+				    {
+					    if (m_Build)
+						{
+						    switch(m_Build->GetEntry())
+	                        {
+							    case 190221:
+						        case 190373:
+						        case 190377:
+						        case 190378:
+								{
+					                creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+									break;
+								}
+								case 190356:
+						        case 190357:
+						        case 190358:
+								{
+								    creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+									break;
+								}
+							}
+					        m_WG->HideNpc(creature);
+						}
+				    }
+				    else
+				    {
+					    if (m_Build)
+						{
+						    switch(m_Build->GetEntry())
+	                        {
+							    case 190221:
+						        case 190373:
+						        case 190377:
+						        case 190378:
+								{
+					                creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+									break;
+								}
+								case 190356:
+						        case 190357:
+						        case 190358:
+								{
+								    creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+									break;
+								}
+							}
+						    m_WG->ShowNpc(creature, true);
+						}
+					}
+				}
+			}
+		}
+	}
+
+    void Save()
+    {
+        sWorld.setWorldState(m_WorldState,m_State);
+    }
+};
+
+//Structure for the 6 workshop
+struct BfWGWorkShopData
+{
+    BattlefieldWG* m_WG; //Object du joug
+    GameObject* m_Build;
+    uint32 m_Type;
+    uint32 m_State;//For worldstate
+    uint32 m_WorldState;
+    uint32 m_TeamControl;//Team witch control the workshop
+    GuidSet m_CreatureOnPoint[2];//Contain all Creature associate to this point
+    GameObjectSet m_GameObjectOnPoint[2];//Contain all Gameobject associate to this point
+    uint32 m_NameId;//Id of trinity_string witch contain name of this node, using for alert message
+
+    BfWGWorkShopData(BattlefieldWG* WG)
+    {
+        m_WG = WG;
+        m_Build = NULL;
+        m_Type = 0;
+        m_State = 0;
+        m_WorldState = 0;
+        m_TeamControl = 0;
+        m_NameId = 0;
+    }
+    //Spawning associate creature and store them
+    void AddCreature(BfWGObjectPosition obj)
+    {
+        if(Creature* creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
+        	m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
+
+        if(Creature* creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
+        	m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
+
+    }
+    //Spawning Associate gameobject and store them
+    void AddGameObject(BfWGObjectPosition obj)
+    {
+        if(GameObject* gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
+        if(GameObject* gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
+    }
+    
+    //Init method, setup variable
+    void Init(uint32 worldstate, uint32 type,uint32 nameid)
+    {
+        m_WorldState = worldstate;
+        m_Type = type;
+        m_NameId = nameid;
+    }
+
+    //Called on change faction in CapturePoint class
+    void ChangeControl(uint8 team,bool init/* for first call in setup*/)
+    {
+        switch (team)
+        {
+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
+            {
+                //Send warning message to all player for inform a faction attack a workshop
+                m_WG->SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK,sObjectMgr.GetTrinityStringForDBCLocale(m_NameId),
+                    sObjectMgr.GetTrinityStringForDBCLocale(m_TeamControl?BATTLEFIELD_WG_TEXT_ALLIANCE:BATTLEFIELD_WG_TEXT_HORDE));
+                break;
+            }
+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
+            {
+                //Show Alliance creature
+                for(GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                    if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+					    if (Creature* creature = unit->ToCreature())
+						    m_WG->ShowNpc(creature,creature->GetEntry()!=30499);
+
+                //Hide Horde creature
+                for(GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
+                    if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+					    if (Creature* creature = unit->ToCreature())
+						    m_WG->HideNpc(creature);
+
+                //Show Alliance gameobject
+                for(GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                    (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+                //Hide Horde gameobject
+                for(GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
+                    (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+
+                //Updating worldstate
+                m_State=BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
+                m_WG->SendUpdateWorldState(m_WorldState,m_State);
+
+                //Warning message
+                if(!init)
+                    m_WG->SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN,sObjectMgr.GetTrinityStringForDBCLocale(m_NameId),
+                    sObjectMgr.GetTrinityStringForDBCLocale(BATTLEFIELD_WG_TEXT_ALLIANCE));
+                
+                //Found associate graveyard and update it
+                if(m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+                    if(m_WG && m_WG->GetGraveYardById(m_Type))
+                        m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
+                              
+                m_TeamControl=team;
+                break;
+            }
+            case BATTLEFIELD_WG_TEAM_HORDE:
+            {
+                //Show Horde creature
+                for(GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
+                    if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+					    if (Creature* creature = unit->ToCreature())
+						    m_WG->ShowNpc(creature,creature->GetEntry()!=30400);
+                
+                //Hide Alliance creature
+                for(GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                    if (Unit* unit = sObjectAccessor.FindUnit((*itr)))
+					    if (Creature* creature = unit->ToCreature())
+						    m_WG->HideNpc(creature);
+
+                //Hide Alliance gameobject
+                for(GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                    (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+                //Show Horde gameobject
+                for(GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
+                    (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+                //Update worlstate
+                m_State=BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
+                m_WG->SendUpdateWorldState(m_WorldState,m_State);
+                
+                //Warning message
+                if(!init)
+                    m_WG->SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN,sObjectMgr.GetTrinityStringForDBCLocale(m_NameId),
+                        sObjectMgr.GetTrinityStringForDBCLocale(BATTLEFIELD_WG_TEXT_HORDE));
+
+                //Update graveyard control
+                if(m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+                    if(m_WG && m_WG->GetGraveYardById(m_Type))
+                        m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
+
+                m_TeamControl=team;
+                break;
+            }
+        }
+		if (!init)
+		    m_WG->UpdateCounterVehicle(false);
+    }
+
+    void UpdateGraveYardAndWorkshop()
+    {
+        if(m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
+		else
+		    ChangeControl(m_WG->GetDefenderTeam(), true);
+    }
+    void Save()
+    {
+        sWorld.setWorldState(m_WorldState,m_State);
+    }
+};
+#endif
diff -r dc4fc5c8b306 src/server/game/Battlegrounds/Battleground.cpp
--- a/src/server/game/Battlegrounds/Battleground.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Battlegrounds/Battleground.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -1167,7 +1167,7 @@
         if (group->IsMember(plr_guid))
         {
             uint8 subgroup = group->GetMemberGroup(plr_guid);
-            plr->SetBattlegroundRaid(group, subgroup);
+            plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
         }
         else
         {
diff -r dc4fc5c8b306 src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/CMakeLists.txt	Tue Nov 30 22:02:04 2010 -0500
@@ -18,6 +18,7 @@
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
 file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
 file(GLOB_RECURSE sources_Combat Combat/*.cpp Combat/*.h)
@@ -67,6 +68,7 @@
   ${sources_AI}
   ${sources_AuctionHouse}
   ${sources_Battlegrounds}
+  ${sources_Battlefield}
   ${sources_Calendar}
   ${sources_Chat}
   ${sources_Combat}
@@ -134,6 +136,8 @@
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
   ${CMAKE_CURRENT_SOURCE_DIR}/Chat
   ${CMAKE_CURRENT_SOURCE_DIR}/Chat/Channels
diff -r dc4fc5c8b306 src/server/game/Chat/Chat.cpp
--- a/src/server/game/Chat/Chat.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Chat/Chat.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -351,6 +351,16 @@
         { NULL,             0,                  false, NULL,                                                "", NULL }
     };
 
+	static ChatCommand battlefieldcommandTable[] =
+	{
+		{ "start",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBattlefieldStart>,                "", NULL },
+        { "stop",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBattlefieldEnd>,                  "", NULL },
+        { "switch",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBattlefieldSwitch>,               "", NULL },
+        { "timer",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBattlefieldTimer>,                "", NULL },
+        { "enable",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBattlefieldEnable>,               "", NULL },
+		{ NULL,             0,                  false, NULL,                                                "", NULL }
+	};
+
     static ChatCommand commandTable[] =
     {
         { "character",      SEC_GAMEMASTER,     true,  NULL,                                           "", characterCommandTable},
@@ -436,7 +446,8 @@
         { "unpossess",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnPossessCommand>,           "", NULL },
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
-        { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+        { "bf",             SEC_ADMINISTRATOR,  false, NULL,                                           "", battlefieldcommandTable },
+		{ "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff -r dc4fc5c8b306 src/server/game/Chat/Chat.h
--- a/src/server/game/Chat/Chat.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Chat/Chat.h	Tue Nov 30 22:02:04 2010 -0500
@@ -306,6 +306,13 @@
         bool HandleChangeWeather(const char* args);
         bool HandleKickPlayerCommand(const char * args);
 
+		// Battlefield commands
+		bool HandleBattlefieldStart(const char* args);
+		bool HandleBattlefieldEnd(const char* args);
+		bool HandleBattlefieldSwitch(const char* args);
+		bool HandleBattlefieldTimer(const char* args);
+		bool HandleBattlefieldEnable(const char* args);
+
         // GM ticket command handlers
         bool HandleGMTicketListCommand(const char* args);
         bool HandleGMTicketListOnlineCommand(const char* args);
diff -r dc4fc5c8b306 src/server/game/Chat/Commands/Level3.cpp
--- a/src/server/game/Chat/Commands/Level3.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Chat/Commands/Level3.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -47,6 +47,7 @@
 #include "Util.h"
 #include "ItemEnchantmentMgr.h"
 #include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "InstanceSaveMgr.h"
 #include "InstanceScript.h"
 #include "CreatureEventAIMgr.h"
@@ -4685,3 +4686,114 @@
     m_session->GetPlayer()->StopCastingBindSight();
     return true;
 }
+
+bool ChatHandler::HandleBattlefieldStart(const char *args)
+{
+    uint32 battleid  = 0;
+    char* battleid_str  = strtok((char*)args, " ");
+    if (!battleid_str)
+    	return false;
+
+    battleid= atoi(battleid_str);
+
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+    if(!Bf)
+    	return false;
+
+    Bf->StartBattle();
+	if (battleid == 1)
+		SendGlobalGMSysMessage("Wintergrasp (Command start used)");
+    return true;
+
+}
+bool ChatHandler::HandleBattlefieldEnd(const char *args)
+{
+    uint32 battleid  = 0;
+    char* battleid_str  = strtok((char*)args, " ");
+    if (!battleid_str)
+    	return false;
+
+    battleid= atoi(battleid_str);
+
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+    if(!Bf)
+    	return false;
+
+    Bf->EndBattle(true);
+	if (battleid == 1)
+		SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
+    return true;
+
+}
+bool ChatHandler::HandleBattlefieldEnable(const char *args)
+{
+    uint32 battleid  = 0;
+    char* battleid_str  = strtok((char*)args, " ");
+    if (!battleid_str)
+    	return false;
+
+    battleid= atoi(battleid_str);
+
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+    if(!Bf)
+    	return false;
+    if (Bf->GetEnable())
+	{
+		Bf->SetEnable(false);
+		if (battleid == 1)
+			SendGlobalGMSysMessage("Wintergrasp is disable");
+	}
+	else
+	{
+		Bf->SetEnable(true);
+		if (battleid == 1)
+			SendGlobalGMSysMessage("Wintergrasp is enable");
+	}
+    return true;
+
+}
+bool ChatHandler::HandleBattlefieldSwitch(const char *args)
+{
+    uint32 battleid  = 0;
+    char* battleid_str  = strtok((char*)args, " ");
+    if (!battleid_str)
+    	return false;
+
+    battleid= atoi(battleid_str);
+
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+    if(!Bf)
+    	return false;
+
+    Bf->EndBattle(false);
+	if (battleid == 1)
+		SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
+    return true;
+
+}
+bool ChatHandler::HandleBattlefieldTimer(const char *args)
+{
+    uint32 battleid  = 0;
+    uint32 time  = 0;
+    char* battleid_str  = strtok((char*)args, " ");
+    if (!battleid_str)
+    	return false;
+    char* time_str  = strtok(NULL, " ");
+       if (!time_str)
+       	return false;
+    battleid= atoi(battleid_str);
+    time = atoi(time_str);
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+    if(!Bf)
+    	return false;
+    Bf->SetTimer(time*IN_MILLISECONDS);
+	Bf->SendInitWorldStatesToAll();
+	if (battleid == 1)
+		SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
+	return true;
+}
diff -r dc4fc5c8b306 src/server/game/Entities/GameObject/GameObject.cpp
--- a/src/server/game/Entities/GameObject/GameObject.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/GameObject/GameObject.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -804,6 +804,13 @@
     return gInfo->type == GAMEOBJECT_TYPE_TRANSPORT || gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT;
 }
 
+bool GameObject::IsDestructibleBuilding() const
+{
+    GameObjectInfo const * gInfo = GetGOInfo();
+    if (!gInfo) return false;
+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
+}
+
 // is Dynamic transport = non-stop Transport
 bool GameObject::IsDynTransport() const
 {
@@ -830,7 +837,7 @@
     if (WorldObject::isAlwaysVisibleFor(seer))
         return true;
 
-    if (IsTransport())
+    if (IsTransport() || IsDestructibleBuilding())
         return true;
     
     return false;
diff -r dc4fc5c8b306 src/server/game/Entities/GameObject/GameObject.h
--- a/src/server/game/Entities/GameObject/GameObject.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/GameObject/GameObject.h	Tue Nov 30 22:02:04 2010 -0500
@@ -614,6 +614,7 @@
 
         bool IsTransport() const;
         bool IsDynTransport() const;
+	bool IsDestructibleBuilding() const;
 
         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
 
diff -r dc4fc5c8b306 src/server/game/Entities/Object/Object.cpp
--- a/src/server/game/Entities/Object/Object.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Object/Object.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -41,7 +41,7 @@
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "SpellAuraEffects.h"
-
+#include "BattlefieldMgr.h"
 #include "TemporarySummon.h"
 #include "Totem.h"
 #include "OutdoorPvPMgr.h"
@@ -458,7 +458,7 @@
     if (flags & UPDATEFLAG_VEHICLE)                          // unused for now
     {
         *data << uint32(((Unit*)this)->GetVehicleKit()->GetVehicleInfo()->m_ID);  // vehicle id
-        *data << float(0);                                  // facing adjustment
+        *data << float(((Creature*)this)->GetOrientation());                      // facing adjustment
     }
 
     // 0x200
@@ -2135,7 +2135,12 @@
         if (map->IsDungeon())
             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
         else if (!map->IsBattlegroundOrArena())
-            m_zoneScript = sOutdoorPvPMgr.GetZoneScript(GetZoneId());
+        {
+            if(Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
+                m_zoneScript = Bf;
+            else
+                m_zoneScript = sOutdoorPvPMgr.GetZoneScript(GetZoneId());
+        }
     }
 }
 
diff -r dc4fc5c8b306 src/server/game/Entities/Player/Player.cpp
--- a/src/server/game/Entities/Player/Player.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Player/Player.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -66,6 +66,7 @@
 #include "ConditionMgr.h"
 #include "DisableMgr.h"
 #include "WeatherMgr.h"
+#include "BattlefieldMgr.h"
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
@@ -2134,6 +2135,7 @@
         StopCastingBindSight();
         UnsummonPetTemporaryIfAny();
         sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+		sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
     }
 
     ///- Do not add/remove the player from the object storage
@@ -5151,8 +5153,12 @@
     if (Battleground *bg = GetBattleground())
         ClosestGrave = bg->GetClosestGraveYard(this);
     else
-        ClosestGrave = sObjectMgr.GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
-
+    {
+        if(sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
+        else
+            ClosestGrave = sObjectMgr.GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam()); 
+    }
     // stop countdown until repop
     m_deathTimer = 0;
 
@@ -7046,6 +7052,8 @@
     {
         sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
         sOutdoorPvPMgr.HandlePlayerEnterZone(this, newZone);
+		sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
     }
 
@@ -7190,7 +7198,7 @@
 
 bool Player::IsOutdoorPvPActive()
 {
-    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld.IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP()  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
 }
 
 void Player::DuelComplete(DuelCompleteType type)
@@ -22200,7 +22208,7 @@
     return ERR_PARTY_RESULT_OK;
 }
 
-void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
+void Player::SetBattlegroundOrBattlefieldRaid(Group* group, int8 subgroup)
 {
     //we must move references from m_group to m_originalGroup
     SetOriginalGroup(GetGroup(), GetSubGroup());
@@ -22210,7 +22218,7 @@
     m_group.setSubGroup((uint8)subgroup);
 }
 
-void Player::RemoveFromBattlegroundRaid()
+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
 {
     //remove existing reference
     m_group.unlink();
diff -r dc4fc5c8b306 src/server/game/Entities/Player/Player.h
--- a/src/server/game/Entities/Player/Player.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Player/Player.h	Tue Nov 30 22:02:04 2010 -0500
@@ -2323,8 +2323,8 @@
         Player* GetNextRandomRaidMember(float radius);
         PartyResult CanUninviteFromGroup() const;
         // Battleground Group System
-        void SetBattlegroundRaid(Group *group, int8 subgroup = -1);
-        void RemoveFromBattlegroundRaid();
+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
+        void RemoveFromBattlegroundOrBattlefieldRaid();
         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
diff -r dc4fc5c8b306 src/server/game/Entities/Unit/Unit.cpp
--- a/src/server/game/Entities/Unit/Unit.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Unit/Unit.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -53,7 +53,7 @@
 #include "TemporarySummon.h"
 #include "Vehicle.h"
 #include "Transport.h"
-
+#include "BattlefieldMgr.h"
 #include <math.h>
 
 float baseMoveSpeed[MAX_MOVE_TYPE] =
@@ -15216,10 +15216,12 @@
 
     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
     // handle player kill only if not suicide (spirit of redemption for example)
-    if (player && this != pVictim)
+    if (player && this != pVictim){
         if (OutdoorPvP * pvp = player->GetOutdoorPvP())
             pvp->HandleKill(player, pVictim);
-
+        if (Battlefield * Bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
+            Bf->HandleKill(player, pVictim);
+    }
     //if (pVictim->GetTypeId() == TYPEID_PLAYER)
     //    if (OutdoorPvP * pvp = pVictim->ToPlayer()->GetOutdoorPvP())
     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
diff -r dc4fc5c8b306 src/server/game/Entities/Vehicle/Vehicle.cpp
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -445,3 +445,16 @@
     me->CombatStop();
     me->AddObjectToRemoveList();
 }
+
+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
+{
+    vehiclePlayers.clear();
+	for(int8 i = 0; i < 8; i++)
+	    if (Unit* player = GetPassenger(i))
+	        vehiclePlayers.insert(player->GetGUID());
+	RemoveAllPassengers();
+	me->NearTeleportTo(x, y, z, ang);
+	for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
+	    if(Unit *plr = sObjectAccessor.FindUnit((*itr)))
+		    plr->NearTeleportTo(x, y, z, ang);
+}
diff -r dc4fc5c8b306 src/server/game/Entities/Vehicle/Vehicle.h
--- a/src/server/game/Entities/Vehicle/Vehicle.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Vehicle/Vehicle.h	Tue Nov 30 22:02:04 2010 -0500
@@ -84,6 +84,7 @@
 typedef std::vector<VehicleAccessory> VehicleAccessoryList;
 typedef std::map<uint32, VehicleAccessoryList> VehicleAccessoryMap;
 typedef std::map<uint32, VehicleScalingInfo> VehicleScalingMap;
+typedef std::set<uint64> GuidSet;
 typedef std::map<int8, VehicleSeat> SeatMap;
 
 class Vehicle
@@ -103,6 +104,7 @@
 
         bool HasEmptySeat(int8 seatId) const;
         Unit *GetPassenger(int8 seatId) const;
+		void TeleportVehicle(float x, float y, float z, float ang);
         int8 GetNextEmptySeat(int8 seatId, bool next) const;
         bool AddPassenger(Unit *passenger, int8 seatId = -1);
         void RemovePassenger(Unit *passenger);
@@ -116,6 +118,7 @@
     protected:
         Unit *me;
         VehicleEntry const *m_vehicleInfo;
+		GuidSet vehiclePlayers;
         uint32 m_usableSeatNum;
         uint32 m_bonusHP;
 
diff -r dc4fc5c8b306 src/server/game/Globals/ObjectAccessor.h
--- a/src/server/game/Globals/ObjectAccessor.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Globals/ObjectAccessor.h	Tue Nov 30 22:02:04 2010 -0500
@@ -192,6 +192,7 @@
         // ACCESS LIKE THAT IS NOT THREAD SAFE
         static Pet * FindPet(uint64);
         static Player* FindPlayer(uint64);
+		static Creature* FindCreature(uint64);
         static Unit* FindUnit(uint64);
         Player* FindPlayerByName(const char* name);
 
diff -r dc4fc5c8b306 src/server/game/Globals/ObjectMgr.cpp
--- a/src/server/game/Globals/ObjectMgr.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Globals/ObjectMgr.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -308,7 +308,6 @@
     for (GroupSet::const_iterator itr = mGroupSet.begin(); itr != mGroupSet.end(); ++itr)
         if ((*itr)->GetLowGUID() == guid)
             return *itr;
-
     return NULL;
 }
 
diff -r dc4fc5c8b306 src/server/game/Globals/ObjectMgr.h
--- a/src/server/game/Globals/ObjectMgr.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Globals/ObjectMgr.h	Tue Nov 30 22:02:04 2010 -0500
@@ -836,6 +836,11 @@
             return &mCreatureQuestRelations;
         }
 
+		QuestRelations* GetCreatureQuestInvolvedRelation()
+        {
+            return &mCreatureQuestInvolvedRelations;
+        }
+
         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
         {
             return mCreatureQuestRelations.equal_range(creature_entry);
diff -r dc4fc5c8b306 src/server/game/Groups/Group.cpp
--- a/src/server/game/Groups/Group.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Groups/Group.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -58,6 +58,7 @@
     m_leaderGuid        = 0;
     m_groupType         = GroupType(0);
     m_bgGroup           = NULL;
+	m_bfGroup           = NULL;
     m_lootMethod        = LootMethod(0);
     m_looterGuid        = 0;
     m_lootThreshold     = ITEM_QUALITY_UNCOMMON;
@@ -111,7 +112,7 @@
     m_leaderGuid = guid;
     m_leaderName = name;
 
-    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
+    m_groupType  = isBGGroup() || isBFGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
 
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
@@ -122,7 +123,7 @@
 
     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
     {
         Player *leader = sObjectMgr.GetPlayer(guid);
         if (leader)
@@ -156,7 +157,7 @@
 
 bool Group::LoadGroupFromDB(const uint32 &groupGuid, QueryResult result, bool loadMembers)
 {
-    if (isBGGroup())
+    if (isBGGroup() || isBFGroup())
         return false;
 
     Field *fields = result->Fetch();
@@ -237,7 +238,7 @@
 {
     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
     m_lootMethod = NEED_BEFORE_GREED;
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
     SendUpdate();
 }
@@ -248,7 +249,7 @@
 
     _initRaidSubGroupsCounter();
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
     SendUpdate();
 
@@ -263,7 +264,7 @@
     if (!player || player->GetGroupInvite())
         return false;
     Group* group = player->GetGroup();
-    if (group && group->isBGGroup())
+    if (group && (group->isBGGroup() || group->isBFGroup()))
         group = player->GetOriginalGroup();
     if (group)
         return false;
@@ -339,7 +340,7 @@
     Player *player = sObjectMgr.GetPlayer(guid);
     if (player)
     {
-        if (!IsLeader(player->GetGUID()) && !isBGGroup())
+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
         {
             // reset the new member's instances, unless he is currently in one of them
             // including raid/heroic instances that they are not permanently bound to!
@@ -384,8 +385,8 @@
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
         return m_memberSlots.size();
 
-    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
-    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
+    if (GetMembersCount() > (isBGGroup() || isBFGroup() ? 1u : 2u))
     {
         bool leaderChanged = _removeMember(guid);
 
@@ -462,8 +463,8 @@
 
         //we cannot call _removeMember because it would invalidate member iterator
         //if we are removing player from battleground raid
-        if (isBGGroup())
-            player->RemoveFromBattlegroundRaid();
+        if (isBGGroup() || isBFGroup())
+            player->RemoveFromBattlegroundOrBattlefieldRaid();
         else
         {
             //we can remove player who is in battleground from his original group
@@ -507,7 +508,7 @@
 
     RemoveAllInvites();
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
     {
         uint32 lowguid = GUID_LOPART(m_guid);
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
@@ -1134,7 +1135,7 @@
             Player* member = sObjectMgr.GetPlayer(citr2->guid);
 
             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
-            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
 
             data << citr2->name;
             data << uint64(citr2->guid);                    // guid
@@ -1262,8 +1263,8 @@
     if (player)
     {
         player->SetGroupInvite(NULL);
-        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-            player->SetBattlegroundRaid(this, group);
+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
+            player->SetBattlegroundOrBattlefieldRaid(this, group);
         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
             player->SetOriginalGroup(this, group);
         else //if player is not in group, then call set group
@@ -1282,7 +1283,7 @@
     }
 
     // insert into the table if we're not a battleground group
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)", GUID_LOPART(m_guid), GUID_LOPART(member.guid), member.flags, member.group, member.roles);
 
     return true;
@@ -1294,8 +1295,8 @@
     if (player)
     {
         //if we are removing player from battleground raid
-        if (isBGGroup())
-            player->RemoveFromBattlegroundRaid();
+        if (isBGGroup() || isBFGroup())
+            player->RemoveFromBattlegroundOrBattlefieldRaid();
         else
         {
             //we can remove player who is in battleground from his original group
@@ -1315,7 +1316,7 @@
         m_memberSlots.erase(slot);
     }
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
 
     if (m_leaderGuid == guid)                                // leader was removed
@@ -1336,7 +1337,7 @@
 
     sScriptMgr.OnGroupChangeLeader(this, m_leaderGuid, guid);
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
     {
         // TODO: set a time limit to have this function run rarely cause it can be slow
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
@@ -1419,7 +1420,7 @@
 
     SubGroupCounterIncrease(group);
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
 
     return true;
@@ -1433,7 +1434,7 @@
 
     ToggleGroupMemberFlag(slot, MEMBER_FLAG_ASSISTANT, apply);
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
     return true;
@@ -1448,7 +1449,7 @@
     RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);          // Remove main tank flag from current if any.
     ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINTANK, apply);   // And apply main tank flag on new main tank.
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
     return true;
@@ -1463,7 +1464,7 @@
     RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINASSIST);         // Remove main assist flag from current if any.
     ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINASSIST, apply);  // Apply main assist flag on new main assist.
 
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
     return true;
@@ -1698,7 +1699,7 @@
 void Group::SetDungeonDifficulty(Difficulty difficulty)
 {
     m_dungeonDifficulty = difficulty;
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, GUID_LOPART(m_guid));
 
     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
@@ -1715,7 +1716,7 @@
 void Group::SetRaidDifficulty(Difficulty difficulty)
 {
     m_raidDifficulty = difficulty;
-    if (!isBGGroup())
+    if (!isBGGroup() || !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, GUID_LOPART(m_guid));
 
     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
@@ -1744,7 +1745,7 @@
 
 void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
 {
-    if (isBGGroup())
+    if (isBGGroup() || isBFGroup())
         return;
 
     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
@@ -1853,7 +1854,7 @@
 
 InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
 {
-    if (!save || isBGGroup())
+    if (!save || isBGGroup() || isBFGroup())
         return NULL;
 
     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
diff -r dc4fc5c8b306 src/server/game/Groups/Group.h
--- a/src/server/game/Groups/Group.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Groups/Group.h	Tue Nov 30 22:02:04 2010 -0500
@@ -25,6 +25,7 @@
 #include "LootMgr.h"
 #include "QueryResult.h"
 #include "SharedDefines.h"
+#include "../../Battlefield/BattlefieldMgr.h"
 
 class Creature;
 class GroupReference;
@@ -220,6 +221,7 @@
         bool isLFGGroup()  const;
         bool isRaidGroup() const;
         bool isBGGroup()   const;
+		bool isBFGroup()   const;
         bool IsCreated()   const;
         const uint64& GetLeaderGUID() const;
         const uint64& GetGUID() const;
@@ -253,6 +255,7 @@
         void ConvertToRaid();
 
         void SetBattlegroundGroup(Battleground *bg);
+		void SetBattlefieldGroup(Battlefield *bf);
         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
 
         void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
@@ -347,6 +350,7 @@
         Difficulty          m_dungeonDifficulty;
         Difficulty          m_raidDifficulty;
         Battleground*       m_bgGroup;
+		Battlefield*        m_bfGroup;
         uint64              m_targetIcons[TARGETICONCOUNT];
         LootMethod          m_lootMethod;
         ItemQualities       m_lootThreshold;
diff -r dc4fc5c8b306 src/server/game/Quests/QuestDef.h
--- a/src/server/game/Quests/QuestDef.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Quests/QuestDef.h	Tue Nov 30 22:02:04 2010 -0500
@@ -249,7 +249,7 @@
         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
-        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
         bool   IsAllowedInRaid() const;
         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
 
diff -r dc4fc5c8b306 src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Scripting/ScriptLoader.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -483,6 +483,7 @@
 void AddSC_storm_peaks();
 void AddSC_zuldrak();
 void AddSC_crystalsong_forest();
+void AddSC_wintergrasp();
 
 //outland
 void AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
@@ -1168,6 +1169,7 @@
     AddSC_storm_peaks();
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
+	AddSC_wintergrasp();
 #endif
 }
 
diff -r dc4fc5c8b306 src/server/game/Scripting/ScriptMgr.cpp
--- a/src/server/game/Scripting/ScriptMgr.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Scripting/ScriptMgr.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -750,6 +750,14 @@
     return tmpscript->GetAI(creature);
 }
 
+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
+{
+    ASSERT(gameobject);
+	
+	GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
+	return tmpscript->GetAI(gameobject);
+}
+
 void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
 {
     ASSERT(creature);
diff -r dc4fc5c8b306 src/server/game/Scripting/ScriptMgr.h
--- a/src/server/game/Scripting/ScriptMgr.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Scripting/ScriptMgr.h	Tue Nov 30 22:02:04 2010 -0500
@@ -36,6 +36,7 @@
 class ChatCommand;
 class Creature;
 class CreatureAI;
+class GameObjectAI;
 class DynamicObject;
 class GameObject;
 class Guild;
@@ -465,6 +466,9 @@
 
         // Called when the gameobject is destroyed (destructible buildings only).
         virtual void OnDestroyed(Player* /*player*/, GameObject* /*go*/, uint32 /*eventId*/) { }
+		
+		// Called when a CreatureAI object is needed for the creature.
+		virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
 };
 
 class AreaTriggerScript : public ScriptObject
@@ -857,6 +861,7 @@
         bool OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt);
         uint32 GetDialogStatus(Player* player, GameObject* go);
         void OnGameObjectDestroyed(Player* player, GameObject* go, uint32 eventId);
+		GameObjectAI* GetGameObjectAI(GameObject* gameobject);
         void OnGameObjectUpdate(GameObject* go, uint32 diff);
 
     public: /* AreaTriggerScript */
diff -r dc4fc5c8b306 src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -581,48 +581,6 @@
     }
 }
 
-void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
-
-    Battleground *bg = _player->GetBattleground();
-
-    uint64 guid;
-    recv_data >> guid;
-
-    Creature *unit = GetPlayer()->GetMap()->GetCreature(guid);
-    if (!unit)
-        return;
-
-    if (!unit->isSpiritService())                            // it's not spirit service
-        return;
-
-    if (bg)
-        sBattlegroundMgr.SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
-}
-
-
-void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
-
-    Battleground *bg = _player->GetBattleground();
-
-    uint64 guid;
-    recv_data >> guid;
-
-    Creature *unit = GetPlayer()->GetMap()->GetCreature(guid);
-    if (!unit)
-        return;
-
-    if (!unit->isSpiritService())                            // it's not spirit service
-        return;
-
-    if (bg)
-        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
-}
-
-
 void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
 {
     sLog.outDebug("WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
diff -r dc4fc5c8b306 src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -35,7 +35,8 @@
 #include "zlib.h"
 #include "ObjectAccessor.h"
 #include "Object.h"
-#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "OutdoorPvP.h"
 #include "Pet.h"
 #include "SocialMgr.h"
@@ -1727,12 +1728,68 @@
     SendPacket(&data);
 }
 
+//Battlefield and Battleground
+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
+
+    Battleground *bg = _player->GetBattleground();
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Creature *unit = GetPlayer()->GetMap()->GetCreature(guid);
+    if (!unit)
+        return;
+
+    if (!unit->isSpiritService())                            // it's not spirit service
+        return;
+
+    if (bg)
+        sBattlegroundMgr.SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+
+    if(Battlefield* Bf=sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
+        Bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
+
+}
+
+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
+
+    Battleground *bg = _player->GetBattleground();
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Creature *unit = GetPlayer()->GetMap()->GetCreature(guid);
+    if (!unit)
+        return;
+
+    if (!unit->isSpiritService())                            // it's not spirit service
+        return;
+
+    if (bg)
+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+
+    if(Battlefield* Bf=sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
+        Bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+
+}
+
 void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
 {
     if (_player->isInFlight())
         return;
 
-    AreaTableEntry const *atEntry = sAreaStore.LookupEntry(_player->GetAreaId());
+    uint32 BattleZone = _player->GetZoneId();
+	Battlefield* Bf= sBattlefieldMgr.GetBattlefieldToZoneId(BattleZone);
+	if(Bf)
+	{
+        Bf->PlayerAskToLeave(_player);
+		return;
+	}
+	AreaTableEntry const *atEntry = sAreaStore.LookupEntry(_player->GetAreaId());
     if (!atEntry || !(atEntry->flags & AREA_FLAG_OUTDOOR_PVP2))
         return;
 
diff -r dc4fc5c8b306 src/server/game/Server/Protocol/Opcodes.cpp
--- a/src/server/game/Server/Protocol/Opcodes.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Server/Protocol/Opcodes.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -1273,15 +1273,15 @@
     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4DD*/ { "UMSG_UNKNOWN_1245",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, &WorldSession::HandleBfEntryInviteResponse     },
     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, &WorldSession::HandleBfQueueInviteResponse     },
     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, &WorldSession::HandleBfExitRequest             },
     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4E9*/ { "UMSG_UNKNOWN_1257",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4EA*/ { "UMSG_UNKNOWN_1258",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
diff -r dc4fc5c8b306 src/server/game/Server/WorldSession.h
--- a/src/server/game/Server/WorldSession.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Server/WorldSession.h	Tue Nov 30 22:02:04 2010 -0500
@@ -717,6 +717,16 @@
         void HandleResetInstancesOpcode(WorldPacket& recv_data);
         void HandleHearthAndResurrect(WorldPacket& recv_data);
 
+		// Battlefield
+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
+        void SendBfInvitePlayerToQueue(uint32 BattleId);
+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
+        void SendBfEntered(uint32 BattleId);
+        void SendBfLeaveMessage(uint32 BattleId);
+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
+        void HandleBfExitRequest(WorldPacket &recv_data);
+
         // Looking for Dungeon/Raid
         void HandleSetLfgCommentOpcode(WorldPacket & recv_data);
         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
diff -r dc4fc5c8b306 src/server/game/Spells/Auras/SpellAuraEffects.cpp
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -35,6 +35,7 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 #include "ScriptMgr.h"
+#include "BattlefieldMgr.h"
 
 class Aura;
 //
@@ -5839,8 +5840,12 @@
                         case 2584: // Waiting to Resurrect
                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
                             if (target->GetTypeId() == TYPEID_PLAYER)
+							{
                                 if (Battleground *bg = target->ToPlayer()->GetBattleground())
                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
+                                if(Battlefield* Bf=sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
+                                    Bf->RemovePlayerFromResurrectQueue(target->GetGUID());
+                            }
                             break;
                         case 36730:                                     // Flame Strike
                         {
@@ -5867,6 +5872,8 @@
                         case 60244:  // Blood Parrot Despawn Aura
                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
                             break;
+			
+			case 58730: // Restricted Flight Area
                         case 58600: // Restricted Flight Area
                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
                                 target->CastSpell(target, 58601, true);
diff -r dc4fc5c8b306 src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/Spell.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -51,6 +51,7 @@
 #include "ConditionMgr.h"
 #include "DisableMgr.h"
 #include "SpellScript.h"
+#include "BattlefieldMgr.h"
 
 #define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
 
@@ -5561,8 +5562,9 @@
                 // allow always ghost flight spells
                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
                 {
+				    Battlefield * BF = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
-                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (BF && BF->CanFlyIn()==false))
                             return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
                 }
                 break;
diff -r dc4fc5c8b306 src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/SpellEffects.cpp	Tue Nov 30 22:02:04 2010 -0500
@@ -6926,9 +6926,10 @@
 
     switch(m_spellInfo->Id)
     {
-        case 58730: // Restricted Flight Area
-        case 58600: // Restricted Flight Area
+        case 58730: // Restricted Flight Area  
+	case 58600: // Restricted Flight Area
             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+	    unitTarget->PlayDirectSound(9417); // Fel Reaver sound
             break;
     }
 }
diff -r dc4fc5c8b306 src/server/game/Spells/SpellMgr.cpp
--- a/src/server/game/Spells/SpellMgr.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/SpellMgr.cpp	Tue Nov 30 22:02:05 2010 -0500
@@ -25,6 +25,7 @@
 #include "Chat.h"
 #include "Spell.h"
 #include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "CreatureAI.h"
 #include "MapManager.h"
 
@@ -3096,7 +3097,18 @@
     // Extra conditions -- leaving the possibility add extra conditions...
     switch(spellId)
     {
+	    case 58730:
+        {
+		    if (!player)
+                return false;
+
+	        Battlefield * BF = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId());
+	        if (!BF || BF->CanFlyIn()==true || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)))
+                return false;
+	        break;
+        }
         case 58600: // No fly Zone - Dalaran
+        {
             if (!player)
                 return false;
 
@@ -3106,8 +3118,18 @@
             if (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY))
                 return false;
             break;
-    }
-
+	    }
+        case 57940: // Essence of Wintergrasp - Northrend
+        {
+		    if (!player)
+                return false;
+
+            Battlefield *Bf = sBattlefieldMgr.GetBattlefieldToZoneId(4197);
+            if (!Bf || player->GetTeamId() != Bf->GetDefenderTeam())
+                return false;
+            break;
+        }
+    }
     return true;
 }
 
diff -r dc4fc5c8b306 src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/World/World.cpp	Tue Nov 30 22:02:05 2010 -0500
@@ -47,6 +47,7 @@
 #include "MapManager.h"
 #include "CreatureAIRegistry.h"
 #include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "TemporarySummon.h"
 #include "WaypointMovementGenerator.h"
@@ -1181,6 +1182,14 @@
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig.GetIntDefault("MaxPingTime", 1800);
 
+	// WINTERGRASP
+	m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig.GetBoolDefault("Wintergrasp.Enable", false);
+	m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig.GetIntDefault("Wintergrasp.PlayerMax", 100);
+	m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig.GetIntDefault("Wintergrasp.PlayerMin", 0);
+	m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig.GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
+	m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig.GetIntDefault("Wintergrasp.BattleTimer", 30);
+	m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig.GetIntDefault("Wintergrasp.NoBattleTimer", 150);
+
     sScriptMgr.OnConfigLoad(reload);
 }
 
@@ -1686,6 +1695,10 @@
     ///- Initialize outdoor pvp
     sLog.outString("Starting Outdoor PvP System");
     sOutdoorPvPMgr.InitOutdoorPvP();
+	
+    ///- Initialize Battlefield
+    sLog.outString("Starting Battlefield System");
+    sBattlefieldMgr.InitBattlefield();
 
     sLog.outString("Loading Transports...");
     sMapMgr.LoadTransports();
@@ -1940,6 +1953,9 @@
 
     sOutdoorPvPMgr.Update(diff);
     RecordTimeDiff("UpdateOutdoorPvPMgr");
+	
+    sBattlefieldMgr.Update(diff);
+    RecordTimeDiff("BattlefieldMgr");
 
     ///- Delete all characters which have been deleted X days before
     if (m_timers[WUPDATE_DELETECHARS].Passed())
diff -r dc4fc5c8b306 src/server/game/World/World.h
--- a/src/server/game/World/World.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/World/World.h	Tue Nov 30 22:02:05 2010 -0500
@@ -162,6 +162,7 @@
     CONFIG_DUNGEON_FINDER_ENABLE,
     CONFIG_AUTOBROADCAST,
     CONFIG_ALLOW_TICKETS,
+	CONFIG_WINTERGRASP_ENABLE,
     BOOL_CONFIG_VALUE_COUNT
 };
 
@@ -307,6 +308,11 @@
     CONFIG_AUTOBROADCAST_INTERVAL,
     CONFIG_MAX_RESULTS_LOOKUP_COMMANDS,
     CONFIG_DB_PING_INTERVAL,
+	CONFIG_WINTERGRASP_PLR_MAX,
+	CONFIG_WINTERGRASP_PLR_MIN,
+	CONFIG_WINTERGRASP_PLR_MIN_LVL,
+	CONFIG_WINTERGRASP_BATTLETIME,
+	CONFIG_WINTERGRASP_NOBATTLETIME,
     INT_CONFIG_VALUE_COUNT
 };
 
diff -r dc4fc5c8b306 src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/CMakeLists.txt	Tue Nov 30 22:02:05 2010 -0500
@@ -85,6 +85,8 @@
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
   ${CMAKE_SOURCE_DIR}/src/server/game/Chat
   ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
diff -r dc4fc5c8b306 src/server/scripts/Northrend/CMakeLists.txt
--- a/src/server/scripts/Northrend/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/Northrend/CMakeLists.txt	Tue Nov 30 22:02:05 2010 -0500
@@ -153,6 +153,7 @@
   Northrend/IcecrownCitadel/boss_professor_putricide.cpp
   Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
   Northrend/zuldrak.cpp
+  Northrend/wintergrasp.cpp
   Northrend/icecrown.cpp
   Northrend/Gundrak/boss_slad_ran.cpp
   Northrend/Gundrak/instance_gundrak.cpp
diff -r dc4fc5c8b306 src/server/scripts/Northrend/wintergrasp.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/scripts/Northrend/wintergrasp.cpp	Tue Nov 30 22:02:05 2010 -0500
@@ -0,0 +1,397 @@
+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptPCH.h"
+#include "BattlefieldMgr.h"
+#include "BattlefieldWG.h"
+#include "Battlefield.h"
+#include "ScriptSystem.h"
+#include "WorldSession.h"
+#include "ObjectMgr.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+enum eWGqueuenpctext
+{
+    WG_NPCQUEUE_TEXT_H_NOWAR = 14775,
+    WG_NPCQUEUE_TEXT_H_QUEUE = 14790,
+    WG_NPCQUEUE_TEXT_H_WAR   = 14777,
+    WG_NPCQUEUE_TEXT_A_NOWAR = 14782,
+    WG_NPCQUEUE_TEXT_A_QUEUE = 14791,
+    WG_NPCQUEUE_TEXT_A_WAR   = 14781,
+    WG_NPCQUEUE_TEXTOPTION_JOIN = -1850507,
+};
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(1);
+
+        if (!BfWG)
+            return true;
+
+        if(BfWG->GetData(pCreature->GetEntry()==30400 ?BATTLEFIELD_WG_DATA_MAX_VEHICLE_H:BATTLEFIELD_WG_DATA_MAX_VEHICLE_A)>BfWG->GetData(pCreature->GetEntry()==30400 ?BATTLEFIELD_WG_DATA_VEHICLE_H:BATTLEFIELD_WG_DATA_VEHICLE_A))
+		{
+            if (pPlayer->HasAura(SPELL_CORPORAL))
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+            {
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+            }
+        }
+        else
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(1);
+
+        if (!BfWG)
+            return true;
+
+        if(BfWG->GetData(pCreature->GetEntry()==30400 ?BATTLEFIELD_WG_DATA_MAX_VEHICLE_H:BATTLEFIELD_WG_DATA_MAX_VEHICLE_A)>BfWG->GetData(pCreature->GetEntry()==30400 ?BATTLEFIELD_WG_DATA_VEHICLE_H:BATTLEFIELD_WG_DATA_VEHICLE_A))
+		{
+            switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+                case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+                case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+            }
+            //spell 49899 Emote : 406 from sniff
+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
+            if(Creature *creature= pCreature->FindNearestCreature(27852,30.0f,true))
+                creature->CastSpell(creature,49899,true);
+        }
+        return true;
+    }
+};
+
+class npc_wg_spiritguide : public CreatureScript
+{
+public:
+    npc_wg_spiritguide() : CreatureScript("npc_wg_spiritguide") { }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            GraveYardVect gy=BfWG->GetGraveYardVect();
+            for(uint8 i=0;i<gy.size();i++)
+            {
+                if(gy[i]->GetControlTeamId()==pPlayer->GetTeamId())
+                {
+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT,sObjectMgr.GetTrinityStringForDBCLocale(((BfGraveYardWG*)gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+i);
+                }
+            }
+        }
+
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature*/, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            GraveYardVect gy=BfWG->GetGraveYardVect();
+            for(uint8 i=0;i<gy.size();i++)
+            {
+                if(uiAction-GOSSIP_ACTION_INFO_DEF==i && gy[i]->GetControlTeamId()==pPlayer->GetTeamId())
+                {
+                    const WorldSafeLocsEntry* ws=sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
+                    pPlayer->TeleportTo(ws->map_id,ws->x,ws->y,ws->z,0);
+                }
+            }
+        }
+        return true;
+    }
+};
+
+class npc_wg_dalaran_queue : public CreatureScript
+{
+public:
+    npc_wg_dalaran_queue() : CreatureScript("npc_wg_dalaran_queue") { }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+
+            if(BfWG->IsWarTime())
+            {
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT,sObjectMgr.GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()?WG_NPCQUEUE_TEXT_H_WAR:WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
+            }
+            else
+            {
+                uint32 uiTime=BfWG->GetTimer()/1000;
+                pPlayer->SendUpdateWorldState(4354,time(NULL)+uiTime);
+                if(uiTime<15*MINUTE)
+                {
+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT,sObjectMgr.GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()?WG_NPCQUEUE_TEXT_H_QUEUE:WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
+                }
+                else
+                {
+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()?WG_NPCQUEUE_TEXT_H_NOWAR:WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
+                }
+            }
+        }
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature*/, uint32 /*uiSender*/, uint32 /*uiAction*/)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            if(BfWG->IsWarTime()){
+                BfWG->InvitePlayerToWar(pPlayer);
+            }
+            else
+            {
+                uint32 uiTime=BfWG->GetTimer()/1000;
+                if(uiTime<15*MINUTE)
+                    BfWG->InvitePlayerToQueue(pPlayer);
+            }
+        }
+        return true;
+    }
+};
+
+const uint32 Vehicules[4] = {32627, 28312, 28094, 27881};
+
+#define SPELL_VEHICLE_TELEPORT          49759
+
+class go_wintergrasp_teleporter : public GameObjectScript
+{
+public:
+    go_wintergrasp_teleporter() : GameObjectScript("go_wintergrasp_teleporter") { }
+
+    struct go_wintergrasp_teleporterAI : public GameObjectAI
+    {
+        go_wintergrasp_teleporterAI(GameObject* g) : GameObjectAI(g)
+		{
+		    uiCheckTimer = 1000;
+		}
+
+        void UpdateAI(const uint32 diff)
+        {
+		    if (uiCheckTimer <= diff)
+			{
+			    for (uint8 i = 0 ; i < 4 ; i++)
+				    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
+					    if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
+						{
+						    if (pVehicle->GetVehicle())
+							{
+							    if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
+								{
+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
+                                    uint32 plfaction = player->getFaction();
+                                    if (gofaction == plfaction)
+							        {
+						                pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
+							            if(Creature* TargetTeleport = pVehicle->FindNearestCreature(23472,100.0f,true))
+                                        {
+                                            float x,y,z,o;
+                                            TargetTeleport->GetPosition(x,y,z,o);
+                                            pVehicle->GetVehicle()->TeleportVehicle(x,y,z,o);
+                                        }
+									}
+								}
+							}
+						}
+			    uiCheckTimer = 1000;
+			}
+			else
+			    uiCheckTimer -= diff;
+        }
+		private:
+		    uint32 uiCheckTimer;
+    };
+
+    GameObjectAI *GetAI(GameObject *go) const
+    {
+        return new go_wintergrasp_teleporterAI(go);
+    }
+};
+
+class npc_wintergrasp_quest_giver : public CreatureScript
+{
+public:
+    npc_wintergrasp_quest_giver() : CreatureScript("npc_wintergrasp_quest_giver") { }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG *BfWG = (BattlefieldWG*)sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            if (pCreature->isQuestGiver())
+            {
+                Object *pObject = (Object*)pCreature;
+                QuestRelations* pObjectQR = sObjectMgr.GetCreatureQuestRelationMap();
+                QuestRelations* pObjectQIR = sObjectMgr.GetCreatureQuestInvolvedRelation();
+
+                QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+                qm.ClearMenu();
+
+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+                {
+                    uint32 quest_id = i->second;
+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+                        qm.AddMenuItem(quest_id, 4);
+                    else if (status == QUEST_STATUS_INCOMPLETE)
+                        qm.AddMenuItem(quest_id, 4);
+                }
+
+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+                {
+                    uint32 quest_id = i->second;
+                    Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
+                    if (!pQuest)
+						continue;
+
+                    switch(quest_id)
+                    {
+                        // Horde attacker
+                        case 13193:
+                        case 13202:
+                        case 13180:
+                        case 13200:
+                        case 13201:
+                        case 13223:
+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Horde defender
+                        case 13199:
+                        case 13192:
+                        case 13178:
+                        case 13191:
+                        case 13194:
+                        case 13539:
+                        case 13185:
+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Alliance attacker
+                        case 13196:
+                        case 13198:
+                        case 13179:
+                        case 13222:
+                        case 13195:
+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Alliance defender
+                        case 13154:
+                        case 13153:
+                        case 13177:
+                        case 13538:
+                        case 13186:
+                        case 13156:
+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        default:
+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                qm.AddMenuItem(quest_id, 4);
+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                qm.AddMenuItem(quest_id, 2);
+                            break;
+                    }
+                }
+            }
+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+            return true;
+        }
+        return true;
+    }
+};
+
+void AddSC_wintergrasp()
+{
+   new npc_wg_dalaran_queue();
+   new npc_wg_spiritguide();
+   new npc_demolisher_engineerer();
+   new go_wintergrasp_teleporter();
+   new npc_wintergrasp_quest_giver();
+}
diff -r dc4fc5c8b306 src/server/scripts/PrecompiledHeaders/ScriptPCH.h
--- a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h	Tue Nov 30 22:02:05 2010 -0500
@@ -18,6 +18,7 @@
 #include "InstanceScript.h"
 #include "CombatAI.h"
 #include "PassiveAI.h"
+#include "GameObjectAI.h"
 #include "Chat.h"
 #include "DBCStructure.h"
 #include "DBCStores.h"
diff -r dc4fc5c8b306 src/server/worldserver/worldserver.conf.dist
--- a/src/server/worldserver/worldserver.conf.dist	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/worldserver/worldserver.conf.dist	Tue Nov 30 22:02:05 2010 -0500
@@ -2572,6 +2572,39 @@
 
 PlayerStart.AllReputation = 0
 
+#   Wintergrasp.Enable
+#	     Enable wintergrasp
+#		 Default: 0 - off
+#		          1 - on
+#
+#	Wintergrasp.PlayerMax
+#	     Max players allowed in wintergrasp
+#		 Default: 100 (players)
+#
+#	Wintergrasp.PlayerMin
+#	     Min players allowed in wintergrasp
+#		 Default: 0 (players)
+#
+#	Wintergrasp.PlayerMinLvl
+#	     Min player level allowed in wintergrasp
+#		 Default: 77
+#
+#	Wintergrasp.BattleTimer
+#	     Wartime timer
+#		 Default: 30 (in min)
+#
+#	Wintergrasp.NoBattleTimer
+#	     Out of wartime timer
+#		 Default: 150 (in min)
+#
+
+Wintergrasp.Enable = 0
+Wintergrasp.PlayerMax = 100
+Wintergrasp.PlayerMin = 0
+Wintergrasp.PlayerMinLvl = 77
+Wintergrasp.BattleTimer = 30
+Wintergrasp.NoBattleTimer = 150
+
 #
 #    PlayerStart.AllSpells
 #        Description: If enabled, players will start with all their class spells (not talents).
