diff -r dc4fc5c8b306 dep/CMakeLists.txt
--- a/dep/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/dep/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -32,6 +32,7 @@
   add_subdirectory(zlib)
 endif()
 
+add_subdirectory(recastnavigation)
 add_subdirectory(g3dlite)
 
 if(SERVERS)
diff -r dc4fc5c8b306 dep/recastnavigation/CMakeLists.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,12 @@
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+add_subdirectory(Detour)
+add_subdirectory(Recast)
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/CMakeLists.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,28 @@
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+set(Detour_STAT_SRCS
+    DetourAlloc.cpp 
+    DetourCommon.cpp 
+    DetourNavMesh.cpp 
+    DetourNavMeshBuilder.cpp 
+    DetourNavMeshQuery.cpp 
+    DetourNode.cpp 
+)
+
+if(WIN32)
+  include_directories(
+    ${CMAKE_SOURCE_DIR}/dep/zlib
+  )
+endif()
+
+add_library(Detour STATIC ${Detour_STAT_SRCS})
+
+target_link_libraries(Detour ${ZLIB_LIBRARIES})
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourAlloc.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourAlloc.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,50 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <stdlib.h>
+#include "DetourAlloc.h"
+
+static void *dtAllocDefault(int size, dtAllocHint)
+{
+	return malloc(size);
+}
+
+static void dtFreeDefault(void *ptr)
+{
+	free(ptr);
+}
+
+static dtAllocFunc* sAllocFunc = dtAllocDefault;
+static dtFreeFunc* sFreeFunc = dtFreeDefault;
+
+void dtAllocSetCustom(dtAllocFunc *allocFunc, dtFreeFunc *freeFunc)
+{
+	sAllocFunc = allocFunc ? allocFunc : dtAllocDefault;
+	sFreeFunc = freeFunc ? freeFunc : dtFreeDefault;
+}
+
+void* dtAlloc(int size, dtAllocHint hint)
+{
+	return sAllocFunc(size, hint);
+}
+
+void dtFree(void* ptr)
+{
+	if (ptr)
+		sFreeFunc(ptr);
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourAlloc.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourAlloc.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,36 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURALLOCATOR_H
+#define DETOURALLOCATOR_H
+
+enum dtAllocHint
+{
+	DT_ALLOC_PERM,		// Memory persist after a function call.
+	DT_ALLOC_TEMP		// Memory used temporarily within a function.
+};
+
+typedef void* (dtAllocFunc)(int size, dtAllocHint hint);
+typedef void (dtFreeFunc)(void* ptr);
+
+void dtAllocSetCustom(dtAllocFunc *allocFunc, dtFreeFunc *freeFunc);
+
+void* dtAlloc(int size, dtAllocHint hint);
+void dtFree(void* ptr);
+
+#endif
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourAssert.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourAssert.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,33 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURASSERT_H
+#define DETOURASSERT_H
+
+// Note: This header file's only purpose is to include define assert.
+// Feel free to change the file and include your own implementation instead.
+
+#ifdef NDEBUG
+// From http://cnicholson.net/2009/02/stupid-c-tricks-adventures-in-assert/
+#	define dtAssert(x) do { (void)sizeof(x); } while(__LINE__==-1,false)  
+#else
+#	include <assert.h> 
+#	define dtAssert assert
+#endif
+
+#endif // DETOURASSERT_H
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourCommon.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourCommon.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,329 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <math.h>
+#include "DetourCommon.h"
+
+//////////////////////////////////////////////////////////////////////////////////////////
+
+float dtSqrt(float x)
+{
+	return sqrtf(x);
+}
+
+void dtClosestPtPointTriangle(float* closest, const float* p,
+							  const float* a, const float* b, const float* c)
+{
+	// Check if P in vertex region outside A
+	float ab[3], ac[3], ap[3];
+	dtVsub(ab, b, a);
+	dtVsub(ac, c, a);
+	dtVsub(ap, p, a);
+	float d1 = dtVdot(ab, ap);
+	float d2 = dtVdot(ac, ap);
+	if (d1 <= 0.0f && d2 <= 0.0f)
+	{
+		// barycentric coordinates (1,0,0)
+		dtVcopy(closest, a);
+		return;
+	}
+	
+	// Check if P in vertex region outside B
+	float bp[3];
+	dtVsub(bp, p, b);
+	float d3 = dtVdot(ab, bp);
+	float d4 = dtVdot(ac, bp);
+	if (d3 >= 0.0f && d4 <= d3)
+	{
+		// barycentric coordinates (0,1,0)
+		dtVcopy(closest, b);
+		return;
+	}
+	
+	// Check if P in edge region of AB, if so return projection of P onto AB
+	float vc = d1*d4 - d3*d2;
+	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
+	{
+		// barycentric coordinates (1-v,v,0)
+		float v = d1 / (d1 - d3);
+		closest[0] = a[0] + v * ab[0];
+		closest[1] = a[1] + v * ab[1];
+		closest[2] = a[2] + v * ab[2];
+		return;
+	}
+	
+	// Check if P in vertex region outside C
+	float cp[3];
+	dtVsub(cp, p, c);
+	float d5 = dtVdot(ab, cp);
+	float d6 = dtVdot(ac, cp);
+	if (d6 >= 0.0f && d5 <= d6)
+	{
+		// barycentric coordinates (0,0,1)
+		dtVcopy(closest, c);
+		return;
+	}
+	
+	// Check if P in edge region of AC, if so return projection of P onto AC
+	float vb = d5*d2 - d1*d6;
+	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
+	{
+		// barycentric coordinates (1-w,0,w)
+		float w = d2 / (d2 - d6);
+		closest[0] = a[0] + w * ac[0];
+		closest[1] = a[1] + w * ac[1];
+		closest[2] = a[2] + w * ac[2];
+		return;
+	}
+	
+	// Check if P in edge region of BC, if so return projection of P onto BC
+	float va = d3*d6 - d5*d4;
+	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
+	{
+		// barycentric coordinates (0,1-w,w)
+		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
+		closest[0] = b[0] + w * (c[0] - b[0]);
+		closest[1] = b[1] + w * (c[1] - b[1]);
+		closest[2] = b[2] + w * (c[2] - b[2]);
+		return;
+	}
+	
+	// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
+	float denom = 1.0f / (va + vb + vc);
+	float v = vb * denom;
+	float w = vc * denom;
+	closest[0] = a[0] + ab[0] * v + ac[0] * w;
+	closest[1] = a[1] + ab[1] * v + ac[1] * w;
+	closest[2] = a[2] + ab[2] * v + ac[2] * w;
+}
+
+bool dtIntersectSegmentPoly2D(const float* p0, const float* p1,
+							  const float* verts, int nverts,
+							  float& tmin, float& tmax,
+							  int& segMin, int& segMax)
+{
+	static const float EPS = 0.00000001f;
+	
+	tmin = 0;
+	tmax = 1;
+	segMin = -1;
+	segMax = -1;
+	
+	float dir[3];
+	dtVsub(dir, p1, p0);
+	
+	for (int i = 0, j = nverts-1; i < nverts; j=i++)
+	{
+		float edge[3], diff[3];
+		dtVsub(edge, &verts[i*3], &verts[j*3]);
+		dtVsub(diff, p0, &verts[j*3]);
+		const float n = dtVperp2D(edge, diff);
+		const float d = dtVperp2D(dir, edge);
+		if (fabsf(d) < EPS)
+		{
+			// S is nearly parallel to this edge
+			if (n < 0)
+				return false;
+			else
+				continue;
+		}
+		const float t = n / d;
+		if (d < 0)
+		{
+			// segment S is entering across this edge
+			if (t > tmin)
+			{
+				tmin = t;
+				segMin = j;
+				// S enters after leaving polygon
+				if (tmin > tmax)
+					return false;
+			}
+		}
+		else
+		{
+			// segment S is leaving across this edge
+			if (t < tmax)
+			{
+				tmax = t;
+				segMax = j;
+				// S leaves before entering polygon
+				if (tmax < tmin)
+					return false;
+			}
+		}
+	}
+	
+	return true;
+}
+
+float dtDistancePtSegSqr2D(const float* pt, const float* p, const float* q, float& t)
+{
+	float pqx = q[0] - p[0];
+	float pqz = q[2] - p[2];
+	float dx = pt[0] - p[0];
+	float dz = pt[2] - p[2];
+	float d = pqx*pqx + pqz*pqz;
+	t = pqx*dx + pqz*dz;
+	if (d > 0) t /= d;
+	if (t < 0) t = 0;
+	else if (t > 1) t = 1;
+	dx = p[0] + t*pqx - pt[0];
+	dz = p[2] + t*pqz - pt[2];
+	return dx*dx + dz*dz;
+}
+
+void dtCalcPolyCenter(float* tc, const unsigned short* idx, int nidx, const float* verts)
+{
+	tc[0] = 0.0f;
+	tc[1] = 0.0f;
+	tc[2] = 0.0f;
+	for (int j = 0; j < nidx; ++j)
+	{
+		const float* v = &verts[idx[j]*3];
+		tc[0] += v[0];
+		tc[1] += v[1];
+		tc[2] += v[2];
+	}
+	const float s = 1.0f / nidx;
+	tc[0] *= s;
+	tc[1] *= s;
+	tc[2] *= s;
+}
+
+bool dtClosestHeightPointTriangle(const float* p, const float* a, const float* b, const float* c, float& h)
+{
+	float v0[3], v1[3], v2[3];
+	dtVsub(v0, c,a);
+	dtVsub(v1, b,a);
+	dtVsub(v2, p,a);
+	
+	const float dot00 = dtVdot2D(v0, v0);
+	const float dot01 = dtVdot2D(v0, v1);
+	const float dot02 = dtVdot2D(v0, v2);
+	const float dot11 = dtVdot2D(v1, v1);
+	const float dot12 = dtVdot2D(v1, v2);
+	
+	// Compute barycentric coordinates
+	const float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
+	const float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
+	const float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
+
+	// The (sloppy) epsilon is needed to allow to get height of points which
+	// are interpolated along the edges of the triangles.
+	static const float EPS = 1e-4f;
+	
+	// If point lies inside the triangle, return interpolated ycoord.
+	if (u >= -EPS && v >= -EPS && (u+v) <= 1+EPS)
+	{
+		h = a[1] + v0[1]*u + v1[1]*v;
+		return true;
+	}
+	
+	return false;
+}
+
+bool dtPointInPolygon(const float* pt, const float* verts, const int nverts)
+{
+	// TODO: Replace pnpoly with triArea2D tests?
+	int i, j;
+	bool c = false;
+	for (i = 0, j = nverts-1; i < nverts; j = i++)
+	{
+		const float* vi = &verts[i*3];
+		const float* vj = &verts[j*3];
+		if (((vi[2] > pt[2]) != (vj[2] > pt[2])) &&
+			(pt[0] < (vj[0]-vi[0]) * (pt[2]-vi[2]) / (vj[2]-vi[2]) + vi[0]) )
+			c = !c;
+	}
+	return c;
+}
+
+bool dtDistancePtPolyEdgesSqr(const float* pt, const float* verts, const int nverts,
+							  float* ed, float* et)
+{
+	// TODO: Replace pnpoly with triArea2D tests?
+	int i, j;
+	bool c = false;
+	for (i = 0, j = nverts-1; i < nverts; j = i++)
+	{
+		const float* vi = &verts[i*3];
+		const float* vj = &verts[j*3];
+		if (((vi[2] > pt[2]) != (vj[2] > pt[2])) &&
+			(pt[0] < (vj[0]-vi[0]) * (pt[2]-vi[2]) / (vj[2]-vi[2]) + vi[0]) )
+			c = !c;
+		ed[j] = dtDistancePtSegSqr2D(pt, vj, vi, et[j]);
+	}
+	return c;
+}
+
+static void projectPoly(const float* axis, const float* poly, const int npoly,
+						float& rmin, float& rmax)
+{
+	rmin = rmax = dtVdot2D(axis, &poly[0]);
+	for (int i = 1; i < npoly; ++i)
+	{
+		const float d = dtVdot2D(axis, &poly[i*3]);
+		rmin = dtMin(rmin, d);
+		rmax = dtMax(rmax, d);
+	}
+}
+
+inline bool overlapRange(const float amin, const float amax,
+						 const float bmin, const float bmax,
+						 const float eps)
+{
+	return ((amin+eps) > bmax || (amax-eps) < bmin) ? false : true;
+}
+
+bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
+						 const float* polyb, const int npolyb)
+{
+	const float eps = 1e-4f;
+	
+	for (int i = 0, j = npolya-1; i < npolya; j=i++)
+	{
+		const float* va = &polya[j*3];
+		const float* vb = &polya[i*3];
+		const float n[3] = { vb[2]-va[2], 0, -(vb[0]-va[0]) };
+		float amin,amax,bmin,bmax;
+		projectPoly(n, polya, npolya, amin,amax);
+		projectPoly(n, polyb, npolyb, bmin,bmax);
+		if (!overlapRange(amin,amax, bmin,bmax, eps))
+		{
+			// Found separating axis
+			return false;
+		}
+	}
+	for (int i = 0, j = npolyb-1; i < npolyb; j=i++)
+	{
+		const float* va = &polyb[j*3];
+		const float* vb = &polyb[i*3];
+		const float n[3] = { vb[2]-va[2], 0, -(vb[0]-va[0]) };
+		float amin,amax,bmin,bmax;
+		projectPoly(n, polya, npolya, amin,amax);
+		projectPoly(n, polyb, npolyb, bmin,bmax);
+		if (!overlapRange(amin,amax, bmin,bmax, eps))
+		{
+			// Found separating axis
+			return false;
+		}
+	}
+	return true;
+}
+
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourCommon.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourCommon.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,248 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURCOMMON_H
+#define DETOURCOMMON_H
+
+template<class T> inline void dtSwap(T& a, T& b) { T t = a; a = b; b = t; }
+template<class T> inline T dtMin(T a, T b) { return a < b ? a : b; }
+template<class T> inline T dtMax(T a, T b) { return a > b ? a : b; }
+template<class T> inline T dtAbs(T a) { return a < 0 ? -a : a; }
+template<class T> inline T dtSqr(T a) { return a*a; }
+template<class T> inline T dtClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
+
+float dtSqrt(float x);
+
+inline void dtVcross(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
+	dest[1] = v1[2]*v2[0] - v1[0]*v2[2];
+	dest[2] = v1[0]*v2[1] - v1[1]*v2[0]; 
+}
+
+inline float dtVdot(const float* v1, const float* v2)
+{
+	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
+}
+
+inline void dtVmad(float* dest, const float* v1, const float* v2, const float s)
+{
+	dest[0] = v1[0]+v2[0]*s;
+	dest[1] = v1[1]+v2[1]*s;
+	dest[2] = v1[2]+v2[2]*s;
+}
+
+inline void dtVlerp(float* dest, const float* v1, const float* v2, const float t)
+{
+	dest[0] = v1[0]+(v2[0]-v1[0])*t;
+	dest[1] = v1[1]+(v2[1]-v1[1])*t;
+	dest[2] = v1[2]+(v2[2]-v1[2])*t;
+}
+
+inline void dtVadd(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[0]+v2[0];
+	dest[1] = v1[1]+v2[1];
+	dest[2] = v1[2]+v2[2];
+}
+
+inline void dtVsub(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[0]-v2[0];
+	dest[1] = v1[1]-v2[1];
+	dest[2] = v1[2]-v2[2];
+}
+
+inline void dtVscale(float* dest, const float* v, const float t)
+{
+	dest[0] = v[0]*t;
+	dest[1] = v[1]*t;
+	dest[2] = v[2]*t;
+}
+
+inline void dtVmin(float* mn, const float* v)
+{
+	mn[0] = dtMin(mn[0], v[0]);
+	mn[1] = dtMin(mn[1], v[1]);
+	mn[2] = dtMin(mn[2], v[2]);
+}
+
+inline void dtVmax(float* mx, const float* v)
+{
+	mx[0] = dtMax(mx[0], v[0]);
+	mx[1] = dtMax(mx[1], v[1]);
+	mx[2] = dtMax(mx[2], v[2]);
+}
+
+inline void dtVset(float* dest, const float x, const float y, const float z)
+{
+	dest[0] = x; dest[1] = y; dest[2] = z;
+}
+
+inline void dtVcopy(float* dest, const float* a)
+{
+	dest[0] = a[0];
+	dest[1] = a[1];
+	dest[2] = a[2];
+}
+
+inline float dtVlen(const float* v)
+{
+	return dtSqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+}
+
+inline float dtVlenSqr(const float* v)
+{
+	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
+}
+
+inline float dtVdist(const float* v1, const float* v2)
+{
+	const float dx = v2[0] - v1[0];
+	const float dy = v2[1] - v1[1];
+	const float dz = v2[2] - v1[2];
+	return dtSqrt(dx*dx + dy*dy + dz*dz);
+}
+
+inline float dtVdistSqr(const float* v1, const float* v2)
+{
+	const float dx = v2[0] - v1[0];
+	const float dy = v2[1] - v1[1];
+	const float dz = v2[2] - v1[2];
+	return dx*dx + dy*dy + dz*dz;
+}
+
+inline float dtVdist2D(const float* v1, const float* v2)
+{
+	const float dx = v2[0] - v1[0];
+	const float dz = v2[2] - v1[2];
+	return dtSqrt(dx*dx + dz*dz);
+}
+
+inline float dtVdist2DSqr(const float* v1, const float* v2)
+{
+	const float dx = v2[0] - v1[0];
+	const float dz = v2[2] - v1[2];
+	return dx*dx + dz*dz;
+}
+
+inline void dtVnormalize(float* v)
+{
+	float d = 1.0f / dtSqrt(dtSqr(v[0]) + dtSqr(v[1]) + dtSqr(v[2]));
+	v[0] *= d;
+	v[1] *= d;
+	v[2] *= d;
+}
+
+inline bool dtVequal(const float* p0, const float* p1)
+{
+	static const float thr = dtSqr(1.0f/16384.0f);
+	const float d = dtVdistSqr(p0, p1);
+	return d < thr;
+}
+
+inline unsigned int dtNextPow2(unsigned int v)
+{
+	v--;
+	v |= v >> 1;
+	v |= v >> 2;
+	v |= v >> 4;
+	v |= v >> 8;
+	v |= v >> 16;
+	v++;
+	return v;
+}
+
+inline unsigned int dtIlog2(unsigned int v)
+{
+	unsigned int r;
+	unsigned int shift;
+	r = (v > 0xffff) << 4; v >>= r;
+	shift = (v > 0xff) << 3; v >>= shift; r |= shift;
+	shift = (v > 0xf) << 2; v >>= shift; r |= shift;
+	shift = (v > 0x3) << 1; v >>= shift; r |= shift;
+	r |= (v >> 1);
+	return r;
+}
+
+inline int dtAlign4(int x) { return (x+3) & ~3; }
+
+inline int dtOppositeTile(int side) { return (side+4) & 0x7; }
+
+inline float dtVdot2D(const float* u, const float* v)
+{
+	return u[0]*v[0] + u[2]*v[2];
+}
+
+inline float dtVperp2D(const float* u, const float* v)
+{
+	return u[2]*v[0] - u[0]*v[2];
+}
+
+inline float dtTriArea2D(const float* a, const float* b, const float* c)
+{
+	const float abx = b[0] - a[0];
+	const float abz = b[2] - a[2];
+	const float acx = c[0] - a[0];
+	const float acz = c[2] - a[2];
+	return acx*abz - abx*acz;
+}
+
+inline bool dtOverlapQuantBounds(const unsigned short amin[3], const unsigned short amax[3],
+								 const unsigned short bmin[3], const unsigned short bmax[3])
+{
+	bool overlap = true;
+	overlap = (amin[0] > bmax[0] || amax[0] < bmin[0]) ? false : overlap;
+	overlap = (amin[1] > bmax[1] || amax[1] < bmin[1]) ? false : overlap;
+	overlap = (amin[2] > bmax[2] || amax[2] < bmin[2]) ? false : overlap;
+	return overlap;
+}
+
+inline bool dtOverlapBounds(const float* amin, const float* amax,
+							const float* bmin, const float* bmax)
+{
+	bool overlap = true;
+	overlap = (amin[0] > bmax[0] || amax[0] < bmin[0]) ? false : overlap;
+	overlap = (amin[1] > bmax[1] || amax[1] < bmin[1]) ? false : overlap;
+	overlap = (amin[2] > bmax[2] || amax[2] < bmin[2]) ? false : overlap;
+	return overlap;
+}
+
+void dtClosestPtPointTriangle(float* closest, const float* p,
+							  const float* a, const float* b, const float* c);
+
+bool dtClosestHeightPointTriangle(const float* p, const float* a, const float* b, const float* c, float& h);
+
+bool dtIntersectSegmentPoly2D(const float* p0, const float* p1,
+							  const float* verts, int nverts,
+							  float& tmin, float& tmax,
+							  int& segMin, int& segMax);
+
+bool dtPointInPolygon(const float* pt, const float* verts, const int nverts);
+
+bool dtDistancePtPolyEdgesSqr(const float* pt, const float* verts, const int nverts,
+							float* ed, float* et);
+
+float dtDistancePtSegSqr2D(const float* pt, const float* p, const float* q, float& t);
+
+void dtCalcPolyCenter(float* tc, const unsigned short* idx, int nidx, const float* verts);
+
+bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
+						 const float* polyb, const int npolyb);
+
+#endif // DETOURCOMMON_H
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMesh.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMesh.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,1235 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <math.h>
+#include <float.h>
+#include <string.h>
+#include <stdio.h>
+#include "DetourNavMesh.h"
+#include "DetourNode.h"
+#include "DetourCommon.h"
+#include "DetourAlloc.h"
+#include "DetourAssert.h"
+#include <new>
+
+
+inline bool overlapSlabs(const float* amin, const float* amax,
+						 const float* bmin, const float* bmax,
+						 const float px, const float py)
+{
+	// Check for horizontal overlap.
+	// The segment is shrunken a little so that slabs which touch
+	// at end points are not connected.
+	const float minx = dtMax(amin[0]+px,bmin[0]+px);
+	const float maxx = dtMin(amax[0]-px,bmax[0]-px);
+	if (minx > maxx)
+		return false;
+	
+	// Check vertical overlap.
+	const float ad = (amax[1]-amin[1]) / (amax[0]-amin[0]);
+	const float ak = amin[1] - ad*amin[0];
+	const float bd = (bmax[1]-bmin[1]) / (bmax[0]-bmin[0]);
+	const float bk = bmin[1] - bd*bmin[0];
+	const float aminy = ad*minx + ak;
+	const float amaxy = ad*maxx + ak;
+	const float bminy = bd*minx + bk;
+	const float bmaxy = bd*maxx + bk;
+	const float dmin = bminy - aminy;
+	const float dmax = bmaxy - amaxy;
+		
+	// Crossing segments always overlap.
+	if (dmin*dmax < 0)
+		return true;
+		
+	// Check for overlap at endpoints.
+	const float thr = dtSqr(py*2);
+	if (dmin*dmin <= thr || dmax*dmax <= thr)
+		return true;
+		
+	return false;
+}
+
+static void calcSlabEndPoints(const float* va, const float* vb, float* bmin, float* bmax, const int side)
+{
+	if (side == 0 || side == 4)
+	{
+		if (va[2] < vb[2])
+		{
+			bmin[0] = va[2];
+			bmin[1] = va[1];
+			bmax[0] = vb[2];
+			bmax[1] = vb[1];
+		}
+		else
+		{
+			bmin[0] = vb[2];
+			bmin[1] = vb[1];
+			bmax[0] = va[2];
+			bmax[1] = va[1];
+		}
+	}
+	else if (side == 2 || side == 6)
+	{
+		if (va[0] < vb[0])
+		{
+			bmin[0] = va[0];
+			bmin[1] = va[1];
+			bmax[0] = vb[0];
+			bmax[1] = vb[1];
+		}
+		else
+		{
+			bmin[0] = vb[0];
+			bmin[1] = vb[1];
+			bmax[0] = va[0];
+			bmax[1] = va[1];
+		}
+	}
+}
+
+inline int computeTileHash(int x, int y, const int mask)
+{
+	const unsigned int h1 = 0x8da6b343; // Large multiplicative constants;
+	const unsigned int h2 = 0xd8163841; // here arbitrarily chosen primes
+	unsigned int n = h1 * x + h2 * y;
+	return (int)(n & mask);
+}
+
+inline unsigned int allocLink(dtMeshTile* tile)
+{
+	if (tile->linksFreeList == DT_NULL_LINK)
+		return DT_NULL_LINK;
+	unsigned int link = tile->linksFreeList;
+	tile->linksFreeList = tile->links[link].next;
+	return link;
+}
+
+inline void freeLink(dtMeshTile* tile, unsigned int link)
+{
+	tile->links[link].next = tile->linksFreeList;
+	tile->linksFreeList = link;
+}
+
+
+dtNavMesh* dtAllocNavMesh()
+{
+	void* mem = dtAlloc(sizeof(dtNavMesh), DT_ALLOC_PERM);
+	if (!mem) return 0;
+	return new(mem) dtNavMesh;
+}
+
+void dtFreeNavMesh(dtNavMesh* navmesh)
+{
+	if (!navmesh) return;
+	navmesh->~dtNavMesh();
+	dtFree(navmesh);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+dtNavMesh::dtNavMesh() :
+	m_tileWidth(0),
+	m_tileHeight(0),
+	m_maxTiles(0),
+	m_tileLutSize(0),
+	m_tileLutMask(0),
+	m_posLookup(0),
+	m_nextFree(0),
+	m_tiles(0),
+	m_saltBits(0),
+	m_tileBits(0),
+	m_polyBits(0)
+{
+	m_orig[0] = 0;
+	m_orig[1] = 0;
+	m_orig[2] = 0;
+}
+
+dtNavMesh::~dtNavMesh()
+{
+	for (int i = 0; i < m_maxTiles; ++i)
+	{
+		if (m_tiles[i].flags & DT_TILE_FREE_DATA)
+		{
+			dtFree(m_tiles[i].data);
+			m_tiles[i].data = 0;
+			m_tiles[i].dataSize = 0;
+		}
+	}
+	dtFree(m_posLookup);
+	dtFree(m_tiles);
+}
+		
+dtStatus dtNavMesh::init(const dtNavMeshParams* params)
+{
+	memcpy(&m_params, params, sizeof(dtNavMeshParams));
+	dtVcopy(m_orig, params->orig);
+	m_tileWidth = params->tileWidth;
+	m_tileHeight = params->tileHeight;
+	
+	// Init tiles
+	m_maxTiles = params->maxTiles;
+	m_tileLutSize = dtNextPow2(params->maxTiles/4);
+	if (!m_tileLutSize) m_tileLutSize = 1;
+	m_tileLutMask = m_tileLutSize-1;
+	
+	m_tiles = (dtMeshTile*)dtAlloc(sizeof(dtMeshTile)*m_maxTiles, DT_ALLOC_PERM);
+	if (!m_tiles)
+		return DT_FAILURE;
+	m_posLookup = (dtMeshTile**)dtAlloc(sizeof(dtMeshTile*)*m_tileLutSize, DT_ALLOC_PERM);
+	if (!m_posLookup)
+		return DT_FAILURE;
+	memset(m_tiles, 0, sizeof(dtMeshTile)*m_maxTiles);
+	memset(m_posLookup, 0, sizeof(dtMeshTile*)*m_tileLutSize);
+	m_nextFree = 0;
+	for (int i = m_maxTiles-1; i >= 0; --i)
+	{
+		m_tiles[i].salt = 1;
+		m_tiles[i].next = m_nextFree;
+		m_nextFree = &m_tiles[i];
+	}
+	
+	// Init ID generator values.
+    m_tileBits = STATIC_TILE_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxTiles));
+    m_polyBits = STATIC_POLY_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxPolys));
+    m_saltBits = STATIC_SALT_BITS;    //sizeof(dtPolyRef)*8 - m_tileBits - m_polyBits;
+    //if (m_saltBits < SALT_MIN_BITS)
+    //return DT_FAILURE;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMesh::init(unsigned char* data, const int dataSize, const int flags)
+{
+	// Make sure the data is in right format.
+	dtMeshHeader* header = (dtMeshHeader*)data;
+	if (header->magic != DT_NAVMESH_MAGIC)
+		return DT_FAILURE;
+	if (header->version != DT_NAVMESH_VERSION)
+		return DT_FAILURE;
+
+	dtNavMeshParams params;
+	dtVcopy(params.orig, header->bmin);
+	params.tileWidth = header->bmax[0] - header->bmin[0];
+	params.tileHeight = header->bmax[2] - header->bmin[2];
+	params.maxTiles = 1;
+	params.maxPolys = header->polyCount;
+	
+	dtStatus res = init(&params);
+	if (res != DT_SUCCESS)
+		return res;
+
+	return addTile(data, dataSize, flags, 0, 0);
+}
+
+const dtNavMeshParams* dtNavMesh::getParams() const
+{
+	return &m_params;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+int dtNavMesh::findConnectingPolys(const float* va, const float* vb,
+								   const dtMeshTile* tile, int side,
+								   dtPolyRef* con, float* conarea, int maxcon) const
+{
+	if (!tile) return 0;
+	
+	float amin[2], amax[2];
+	calcSlabEndPoints(va,vb, amin,amax, side);
+
+	// Remove links pointing to 'side' and compact the links array. 
+	float bmin[2], bmax[2];
+	unsigned short m = DT_EXT_LINK | (unsigned short)side;
+	int n = 0;
+	
+	dtPolyRef base = getPolyRefBase(tile);
+	
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		dtPoly* poly = &tile->polys[i];
+		const int nv = poly->vertCount;
+		for (int j = 0; j < nv; ++j)
+		{
+			// Skip edges which do not point to the right side.
+			if (poly->neis[j] != m) continue;
+			// Check if the segments touch.
+			const float* vc = &tile->verts[poly->verts[j]*3];
+			const float* vd = &tile->verts[poly->verts[(j+1) % nv]*3];
+			calcSlabEndPoints(vc,vd, bmin,bmax, side);
+
+			if (!overlapSlabs(amin,amax, bmin,bmax, 0.01f, tile->header->walkableClimb)) continue;
+			
+			// Add return value.
+			if (n < maxcon)
+			{
+				conarea[n*2+0] = dtMax(amin[0], bmin[0]);
+				conarea[n*2+1] = dtMin(amax[0], bmax[0]);
+				con[n] = base | (dtPolyRef)i;
+				n++;
+			}
+			break;
+		}
+	}
+	return n;
+}
+
+void dtNavMesh::unconnectExtLinks(dtMeshTile* tile, int side)
+{
+	if (!tile) return;
+
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		dtPoly* poly = &tile->polys[i];
+		unsigned int j = poly->firstLink;
+		unsigned int pj = DT_NULL_LINK;
+		while (j != DT_NULL_LINK)
+		{
+			if (tile->links[j].side == side)
+			{
+				// Revove link.
+				unsigned int nj = tile->links[j].next;
+				if (pj == DT_NULL_LINK)
+					poly->firstLink = nj;
+				else
+					tile->links[pj].next = nj;
+				freeLink(tile, j);
+				j = nj;
+			}
+			else
+			{
+				// Advance
+				pj = j;
+				j = tile->links[j].next;
+			}
+		}
+	}
+}
+
+void dtNavMesh::connectExtLinks(dtMeshTile* tile, dtMeshTile* target, int side)
+{
+	if (!tile) return;
+	
+	// Connect border links.
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		dtPoly* poly = &tile->polys[i];
+
+		// Create new links.
+		unsigned short m = DT_EXT_LINK | (unsigned short)side;
+		const int nv = poly->vertCount;
+		for (int j = 0; j < nv; ++j)
+		{
+			// Skip edges which do not point to the right side.
+			if (poly->neis[j] != m) continue;
+			
+			// Create new links
+			const float* va = &tile->verts[poly->verts[j]*3];
+			const float* vb = &tile->verts[poly->verts[(j+1) % nv]*3];
+			dtPolyRef nei[4];
+			float neia[4*2];
+			int nnei = findConnectingPolys(va,vb, target, dtOppositeTile(side), nei,neia,4);
+			for (int k = 0; k < nnei; ++k)
+			{
+				unsigned int idx = allocLink(tile);
+				if (idx != DT_NULL_LINK)
+				{
+					dtLink* link = &tile->links[idx];
+					link->ref = nei[k];
+					link->edge = (unsigned char)j;
+					link->side = (unsigned char)side;
+					
+					link->next = poly->firstLink;
+					poly->firstLink = idx;
+
+					// Compress portal limits to a byte value.
+					if (side == 0 || side == 4)
+					{
+						float tmin = (neia[k*2+0]-va[2]) / (vb[2]-va[2]);
+						float tmax = (neia[k*2+1]-va[2]) / (vb[2]-va[2]);
+						if (tmin > tmax)
+							dtSwap(tmin,tmax);
+						link->bmin = (unsigned char)(dtClamp(tmin, 0.0f, 1.0f)*255.0f);
+						link->bmax = (unsigned char)(dtClamp(tmax, 0.0f, 1.0f)*255.0f);
+					}
+					else if (side == 2 || side == 6)
+					{
+						float tmin = (neia[k*2+0]-va[0]) / (vb[0]-va[0]);
+						float tmax = (neia[k*2+1]-va[0]) / (vb[0]-va[0]);
+						if (tmin > tmax)
+							dtSwap(tmin,tmax);
+						link->bmin = (unsigned char)(dtClamp(tmin, 0.0f, 1.0f)*255.0f);
+						link->bmax = (unsigned char)(dtClamp(tmax, 0.0f, 1.0f)*255.0f);
+					}
+				}
+			}
+		}
+	}
+}
+
+void dtNavMesh::connectExtOffMeshLinks(dtMeshTile* tile, dtMeshTile* target, int side)
+{
+	if (!tile) return;
+	
+	// Connect off-mesh links.
+	// We are interested on links which land from target tile to this tile.
+	const unsigned char oppositeSide = (unsigned char)dtOppositeTile(side);
+	
+	for (int i = 0; i < target->header->offMeshConCount; ++i)
+	{
+		dtOffMeshConnection* targetCon = &target->offMeshCons[i];
+		if (targetCon->side != oppositeSide)
+			continue;
+		
+		dtPoly* targetPoly = &target->polys[targetCon->poly];
+		
+		const float ext[3] = { targetCon->rad, target->header->walkableClimb, targetCon->rad };
+		
+		// Find polygon to connect to.
+		const float* p = &targetCon->pos[3];
+		float nearestPt[3];
+		dtPolyRef ref = findNearestPolyInTile(tile, p, ext, nearestPt);
+		if (!ref) continue;
+		// findNearestPoly may return too optimistic results, further check to make sure. 
+		if (dtSqr(nearestPt[0]-p[0])+dtSqr(nearestPt[2]-p[2]) > dtSqr(targetCon->rad))
+			continue;
+		// Make sure the location is on current mesh.
+		float* v = &target->verts[targetPoly->verts[1]*3];
+		dtVcopy(v, nearestPt);
+				
+		// Link off-mesh connection to target poly.
+		unsigned int idx = allocLink(target);
+		if (idx != DT_NULL_LINK)
+		{
+			dtLink* link = &target->links[idx];
+			link->ref = ref;
+			link->edge = (unsigned char)1;
+			link->side = oppositeSide;
+			link->bmin = link->bmax = 0;
+			// Add to linked list.
+			link->next = targetPoly->firstLink;
+			targetPoly->firstLink = idx;
+		}
+		
+		// Link target poly to off-mesh connection.
+		if (targetCon->flags & DT_OFFMESH_CON_BIDIR)
+		{
+			unsigned int idx = allocLink(tile);
+			if (idx != DT_NULL_LINK)
+			{
+				const unsigned short landPolyIdx = (unsigned short)decodePolyIdPoly(ref);
+				dtPoly* landPoly = &tile->polys[landPolyIdx];
+				dtLink* link = &tile->links[idx];
+				link->ref = getPolyRefBase(target) | (dtPolyRef)(targetCon->poly);
+				link->edge = 0xff;
+				link->side = (unsigned char)side;
+				link->bmin = link->bmax = 0;
+				// Add to linked list.
+				link->next = landPoly->firstLink;
+				landPoly->firstLink = idx;
+			}
+		}
+	}
+
+}
+
+void dtNavMesh::connectIntLinks(dtMeshTile* tile)
+{
+	if (!tile) return;
+
+	dtPolyRef base = getPolyRefBase(tile);
+
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		dtPoly* poly = &tile->polys[i];
+		poly->firstLink = DT_NULL_LINK;
+
+		if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+			continue;
+			
+		// Build edge links backwards so that the links will be
+		// in the linked list from lowest index to highest.
+		for (int j = poly->vertCount-1; j >= 0; --j)
+		{
+			// Skip hard and non-internal edges.
+			if (poly->neis[j] == 0 || (poly->neis[j] & DT_EXT_LINK)) continue;
+
+			unsigned int idx = allocLink(tile);
+			if (idx != DT_NULL_LINK)
+			{
+				dtLink* link = &tile->links[idx];
+				link->ref = base | (dtPolyRef)(poly->neis[j]-1);
+				link->edge = (unsigned char)j;
+				link->side = 0xff;
+				link->bmin = link->bmax = 0;
+				// Add to linked list.
+				link->next = poly->firstLink;
+				poly->firstLink = idx;
+			}
+		}			
+	}
+}
+
+void dtNavMesh::connectIntOffMeshLinks(dtMeshTile* tile)
+{
+	if (!tile) return;
+	
+	dtPolyRef base = getPolyRefBase(tile);
+	
+	// Find Off-mesh connection end points.
+	for (int i = 0; i < tile->header->offMeshConCount; ++i)
+	{
+		dtOffMeshConnection* con = &tile->offMeshCons[i];
+		dtPoly* poly = &tile->polys[con->poly];
+	
+		const float ext[3] = { con->rad, tile->header->walkableClimb, con->rad };
+		
+		for (int j = 0; j < 2; ++j)
+		{
+			unsigned char side = j == 0 ? 0xff : con->side;
+
+			if (side == 0xff)
+			{
+				// Find polygon to connect to.
+				const float* p = &con->pos[j*3];
+				float nearestPt[3];
+				dtPolyRef ref = findNearestPolyInTile(tile, p, ext, nearestPt);
+				if (!ref) continue;
+				// findNearestPoly may return too optimistic results, further check to make sure. 
+				if (dtSqr(nearestPt[0]-p[0])+dtSqr(nearestPt[2]-p[2]) > dtSqr(con->rad))
+					continue;
+				// Make sure the location is on current mesh.
+				float* v = &tile->verts[poly->verts[j]*3];
+				dtVcopy(v, nearestPt);
+
+				// Link off-mesh connection to target poly.
+				unsigned int idx = allocLink(tile);
+				if (idx != DT_NULL_LINK)
+				{
+					dtLink* link = &tile->links[idx];
+					link->ref = ref;
+					link->edge = (unsigned char)j;
+					link->side = 0xff;
+					link->bmin = link->bmax = 0;
+					// Add to linked list.
+					link->next = poly->firstLink;
+					poly->firstLink = idx;
+				}
+
+				// Start end-point is always connect back to off-mesh connection,
+				// Destination end-point only if it is bidirectional link. 
+				if (j == 0 || (j == 1 && (con->flags & DT_OFFMESH_CON_BIDIR)))
+				{
+					// Link target poly to off-mesh connection.
+					unsigned int idx = allocLink(tile);
+					if (idx != DT_NULL_LINK)
+					{
+						const unsigned short landPolyIdx = (unsigned short)decodePolyIdPoly(ref);
+						dtPoly* landPoly = &tile->polys[landPolyIdx];
+						dtLink* link = &tile->links[idx];
+						link->ref = base | (dtPolyRef)(con->poly);
+						link->edge = 0xff;
+						link->side = 0xff;
+						link->bmin = link->bmax = 0;
+						// Add to linked list.
+						link->next = landPoly->firstLink;
+						landPoly->firstLink = idx;
+					}
+				}
+				
+			}
+		}
+	}
+}
+
+dtStatus dtNavMesh::closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+											 const float* pos, float* closest) const
+{
+	const dtPoly* poly = &tile->polys[ip];
+	
+	float closestDistSqr = FLT_MAX;
+	const dtPolyDetail* pd = &tile->detailMeshes[ip];
+	
+	for (int j = 0; j < pd->triCount; ++j)
+	{
+		const unsigned char* t = &tile->detailTris[(pd->triBase+j)*4];
+		const float* v[3];
+		for (int k = 0; k < 3; ++k)
+		{
+			if (t[k] < poly->vertCount)
+				v[k] = &tile->verts[poly->verts[t[k]]*3];
+			else
+				v[k] = &tile->detailVerts[(pd->vertBase+(t[k]-poly->vertCount))*3];
+		}
+		float pt[3];
+		dtClosestPtPointTriangle(pt, pos, v[0], v[1], v[2]);
+		float d = dtVdistSqr(pos, pt);
+		if (d < closestDistSqr)
+		{
+			dtVcopy(closest, pt);
+			closestDistSqr = d;
+		}
+	}
+	
+	return DT_SUCCESS;
+}
+
+dtPolyRef dtNavMesh::findNearestPolyInTile(const dtMeshTile* tile,
+										   const float* center, const float* extents,
+										   float* nearestPt) const
+{
+	float bmin[3], bmax[3];
+	dtVsub(bmin, center, extents);
+	dtVadd(bmax, center, extents);
+	
+	// Get nearby polygons from proximity grid.
+	dtPolyRef polys[128];
+	int polyCount = queryPolygonsInTile(tile, bmin, bmax, polys, 128);
+	
+	// Find nearest polygon amongst the nearby polygons.
+	dtPolyRef nearest = 0;
+	float nearestDistanceSqr = FLT_MAX;
+	for (int i = 0; i < polyCount; ++i)
+	{
+		dtPolyRef ref = polys[i];
+		float closestPtPoly[3];
+		if (closestPointOnPolyInTile(tile, decodePolyIdPoly(ref), center, closestPtPoly) != DT_SUCCESS)
+			continue;
+		float d = dtVdistSqr(center, closestPtPoly);
+		if (d < nearestDistanceSqr)
+		{
+			if (nearestPt)
+				dtVcopy(nearestPt, closestPtPoly);
+			nearestDistanceSqr = d;
+			nearest = ref;
+		}
+	}
+	
+	return nearest;
+}
+
+int dtNavMesh::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+								   dtPolyRef* polys, const int maxPolys) const
+{
+	if (tile->bvTree)
+	{
+		const dtBVNode* node = &tile->bvTree[0];
+		const dtBVNode* end = &tile->bvTree[tile->header->bvNodeCount];
+		const float* tbmin = tile->header->bmin;
+		const float* tbmax = tile->header->bmax;
+		const float qfac = tile->header->bvQuantFactor;
+		
+		// Calculate quantized box
+		unsigned short bmin[3], bmax[3];
+		// dtClamp query box to world box.
+		float minx = dtClamp(qmin[0], tbmin[0], tbmax[0]) - tbmin[0];
+		float miny = dtClamp(qmin[1], tbmin[1], tbmax[1]) - tbmin[1];
+		float minz = dtClamp(qmin[2], tbmin[2], tbmax[2]) - tbmin[2];
+		float maxx = dtClamp(qmax[0], tbmin[0], tbmax[0]) - tbmin[0];
+		float maxy = dtClamp(qmax[1], tbmin[1], tbmax[1]) - tbmin[1];
+		float maxz = dtClamp(qmax[2], tbmin[2], tbmax[2]) - tbmin[2];
+		// Quantize
+		bmin[0] = (unsigned short)(qfac * minx) & 0xfffe;
+		bmin[1] = (unsigned short)(qfac * miny) & 0xfffe;
+		bmin[2] = (unsigned short)(qfac * minz) & 0xfffe;
+		bmax[0] = (unsigned short)(qfac * maxx + 1) | 1;
+		bmax[1] = (unsigned short)(qfac * maxy + 1) | 1;
+		bmax[2] = (unsigned short)(qfac * maxz + 1) | 1;
+		
+		// Traverse tree
+		dtPolyRef base = getPolyRefBase(tile);
+		int n = 0;
+		while (node < end)
+		{
+			const bool overlap = dtOverlapQuantBounds(bmin, bmax, node->bmin, node->bmax);
+			const bool isLeafNode = node->i >= 0;
+			
+			if (isLeafNode && overlap)
+			{
+				if (n < maxPolys)
+					polys[n++] = base | (dtPolyRef)node->i;
+			}
+			
+			if (overlap || isLeafNode)
+				node++;
+			else
+			{
+				const int escapeIndex = -node->i;
+				node += escapeIndex;
+			}
+		}
+		
+		return n;
+	}
+	else
+	{
+		float bmin[3], bmax[3];
+		int n = 0;
+		dtPolyRef base = getPolyRefBase(tile);
+		for (int i = 0; i < tile->header->polyCount; ++i)
+		{
+			// Calc polygon bounds.
+			dtPoly* p = &tile->polys[i];
+			const float* v = &tile->verts[p->verts[0]*3];
+			dtVcopy(bmin, v);
+			dtVcopy(bmax, v);
+			for (int j = 1; j < p->vertCount; ++j)
+			{
+				v = &tile->verts[p->verts[j]*3];
+				dtVmin(bmin, v);
+				dtVmax(bmax, v);
+			}
+			if (dtOverlapBounds(qmin,qmax, bmin,bmax))
+			{
+				if (n < maxPolys)
+					polys[n++] = base | (dtPolyRef)i;
+			}
+		}
+		return n;
+	}
+}
+
+dtStatus dtNavMesh::addTile(unsigned char* data, int dataSize, int flags,
+							dtTileRef lastRef, dtTileRef* result)
+{
+	// Make sure the data is in right format.
+	dtMeshHeader* header = (dtMeshHeader*)data;
+	if (header->magic != DT_NAVMESH_MAGIC)
+		return DT_FAILURE_DATA_MAGIC;
+	if (header->version != DT_NAVMESH_VERSION)
+		return DT_FAILURE_DATA_VERSION;
+		
+	// Make sure the location is free.
+	if (getTileAt(header->x, header->y))
+		return DT_FAILURE;
+		
+	// Allocate a tile.
+	dtMeshTile* tile = 0;
+	if (!lastRef)
+	{
+		if (m_nextFree)
+		{
+			tile = m_nextFree;
+			m_nextFree = tile->next;
+			tile->next = 0;
+		}
+	}
+	else
+	{
+		// Try to relocate the tile to specific index with same salt.
+		int tileIndex = (int)decodePolyIdTile((dtPolyRef)lastRef);
+		if (tileIndex >= m_maxTiles)
+			return DT_FAILURE_OUT_OF_MEMORY;
+		// Try to find the specific tile id from the free list.
+		dtMeshTile* target = &m_tiles[tileIndex];
+		dtMeshTile* prev = 0;
+		tile = m_nextFree;
+		while (tile && tile != target)
+		{
+			prev = tile;
+			tile = tile->next;
+		}
+		// Could not find the correct location.
+		if (tile != target)
+			return DT_FAILURE_OUT_OF_MEMORY;
+		// Remove from freelist
+		if (!prev)
+			m_nextFree = tile->next;
+		else
+			prev->next = tile->next;
+
+		// Restore salt.
+		tile->salt = decodePolyIdSalt((dtPolyRef)lastRef);
+	}
+
+	// Make sure we could allocate a tile.
+	if (!tile)
+		return DT_FAILURE_OUT_OF_MEMORY;
+	
+	// Insert tile into the position lut.
+	int h = computeTileHash(header->x, header->y, m_tileLutMask);
+	tile->next = m_posLookup[h];
+	m_posLookup[h] = tile;
+	
+	// Patch header pointers.
+	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
+	const int vertsSize = dtAlign4(sizeof(float)*3*header->vertCount);
+	const int polysSize = dtAlign4(sizeof(dtPoly)*header->polyCount);
+	const int linksSize = dtAlign4(sizeof(dtLink)*(header->maxLinkCount));
+	const int detailMeshesSize = dtAlign4(sizeof(dtPolyDetail)*header->detailMeshCount);
+	const int detailVertsSize = dtAlign4(sizeof(float)*3*header->detailVertCount);
+	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*header->detailTriCount);
+	const int bvtreeSize = dtAlign4(sizeof(dtBVNode)*header->bvNodeCount);
+	const int offMeshLinksSize = dtAlign4(sizeof(dtOffMeshConnection)*header->offMeshConCount);
+	
+	unsigned char* d = data + headerSize;
+	tile->verts = (float*)d; d += vertsSize;
+	tile->polys = (dtPoly*)d; d += polysSize;
+	tile->links = (dtLink*)d; d += linksSize;
+	tile->detailMeshes = (dtPolyDetail*)d; d += detailMeshesSize;
+	tile->detailVerts = (float*)d; d += detailVertsSize;
+	tile->detailTris = (unsigned char*)d; d += detailTrisSize;
+	tile->bvTree = (dtBVNode*)d; d += bvtreeSize;
+	tile->offMeshCons = (dtOffMeshConnection*)d; d += offMeshLinksSize;
+
+	// Build links freelist
+	tile->linksFreeList = 0;
+	tile->links[header->maxLinkCount-1].next = DT_NULL_LINK;
+	for (int i = 0; i < header->maxLinkCount-1; ++i)
+		tile->links[i].next = i+1;
+
+	// Init tile.
+	tile->header = header;
+	tile->data = data;
+	tile->dataSize = dataSize;
+	tile->flags = flags;
+
+	connectIntLinks(tile);
+	connectIntOffMeshLinks(tile);
+
+	// Create connections connections.
+	for (int i = 0; i < 8; ++i)
+	{
+		dtMeshTile* nei = getNeighbourTileAt(header->x, header->y, i);
+		if (nei)
+		{
+			connectExtLinks(tile, nei, i);
+			connectExtLinks(nei, tile, dtOppositeTile(i));
+			connectExtOffMeshLinks(tile, nei, i);
+			connectExtOffMeshLinks(nei, tile, dtOppositeTile(i));
+		}
+	}
+	
+	if (result)
+		*result = getTileRef(tile);
+	
+	return DT_SUCCESS;
+}
+
+const dtMeshTile* dtNavMesh::getTileAt(int x, int y) const
+{
+	// Find tile based on hash.
+	int h = computeTileHash(x,y,m_tileLutMask);
+	dtMeshTile* tile = m_posLookup[h];
+	while (tile)
+	{
+		if (tile->header && tile->header->x == x && tile->header->y == y)
+			return tile;
+		tile = tile->next;
+	}
+	return 0;
+}
+
+dtMeshTile* dtNavMesh::getNeighbourTileAt(int x, int y, int side) const
+{
+	switch (side)
+	{
+		case 0: x++; break;
+		case 1: x++; y++; break;
+		case 2: y++; break;
+		case 3: x--; y++; break;
+		case 4: x--; break;
+		case 5: x--; y--; break;
+		case 6: y--; break;
+		case 7: x++; y--; break;
+	};
+
+	// Find tile based on hash.
+	int h = computeTileHash(x,y,m_tileLutMask);
+	dtMeshTile* tile = m_posLookup[h];
+	while (tile)
+	{
+		if (tile->header && tile->header->x == x && tile->header->y == y)
+			return tile;
+		tile = tile->next;
+	}
+	return 0;
+}
+
+dtTileRef dtNavMesh::getTileRefAt(int x, int y) const
+{
+	// Find tile based on hash.
+	int h = computeTileHash(x,y,m_tileLutMask);
+	dtMeshTile* tile = m_posLookup[h];
+	while (tile)
+	{
+		if (tile->header && tile->header->x == x && tile->header->y == y)
+			return getTileRef(tile);
+		tile = tile->next;
+	}
+	return 0;
+}
+
+const dtMeshTile* dtNavMesh::getTileByRef(dtTileRef ref) const
+{
+	if (!ref)
+		return 0;
+	unsigned int tileIndex = decodePolyIdTile((dtPolyRef)ref);
+	unsigned int tileSalt = decodePolyIdSalt((dtPolyRef)ref);
+	if ((int)tileIndex >= m_maxTiles)
+		return 0;
+	const dtMeshTile* tile = &m_tiles[tileIndex];
+	if (tile->salt != tileSalt)
+		return 0;
+	return tile;
+}
+
+int dtNavMesh::getMaxTiles() const
+{
+	return m_maxTiles;
+}
+
+dtMeshTile* dtNavMesh::getTile(int i)
+{
+	return &m_tiles[i];
+}
+
+const dtMeshTile* dtNavMesh::getTile(int i) const
+{
+	return &m_tiles[i];
+}
+
+void dtNavMesh::calcTileLoc(const float* pos, int* tx, int* ty) const
+{
+	*tx = (int)floorf((pos[0]-m_orig[0]) / m_tileWidth);
+	*ty = (int)floorf((pos[2]-m_orig[2]) / m_tileHeight);
+}
+
+dtStatus dtNavMesh::getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return DT_FAILURE;
+	*tile = &m_tiles[it];
+	*poly = &m_tiles[it].polys[ip];
+	return DT_SUCCESS;
+}
+
+void dtNavMesh::getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	*tile = &m_tiles[it];
+	*poly = &m_tiles[it].polys[ip];
+}
+
+bool dtNavMesh::isValidPolyRef(dtPolyRef ref) const
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return false;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return false;
+	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return false;
+	return true;
+}
+
+dtStatus dtNavMesh::removeTile(dtTileRef ref, unsigned char** data, int* dataSize)
+{
+	if (!ref)
+		return DT_FAILURE;
+	unsigned int tileIndex = decodePolyIdTile((dtPolyRef)ref);
+	unsigned int tileSalt = decodePolyIdSalt((dtPolyRef)ref);
+	if ((int)tileIndex >= m_maxTiles)
+		return DT_FAILURE;
+	dtMeshTile* tile = &m_tiles[tileIndex];
+	if (tile->salt != tileSalt)
+		return DT_FAILURE;
+	
+	// Remove tile from hash lookup.
+	int h = computeTileHash(tile->header->x,tile->header->y,m_tileLutMask);
+	dtMeshTile* prev = 0;
+	dtMeshTile* cur = m_posLookup[h];
+	while (cur)
+	{
+		if (cur == tile)
+		{
+			if (prev)
+				prev->next = cur->next;
+			else
+				m_posLookup[h] = cur->next;
+			break;
+		}
+		prev = cur;
+		cur = cur->next;
+	}
+	
+	// Remove connections to neighbour tiles.
+	for (int i = 0; i < 8; ++i)
+	{
+		dtMeshTile* nei = getNeighbourTileAt(tile->header->x,tile->header->y,i);
+		if (!nei) continue;
+		unconnectExtLinks(nei, dtOppositeTile(i));
+	}
+	
+	
+	// Reset tile.
+	if (tile->flags & DT_TILE_FREE_DATA)
+	{
+		// Owns data
+		dtFree(tile->data);
+		tile->data = 0;
+		tile->dataSize = 0;
+		if (data) *data = 0;
+		if (dataSize) *dataSize = 0;
+	}
+	else
+	{
+		if (data) *data = tile->data;
+		if (dataSize) *dataSize = tile->dataSize;
+	}
+
+	tile->header = 0;
+	tile->flags = 0;
+	tile->linksFreeList = 0;
+	tile->polys = 0;
+	tile->verts = 0;
+	tile->links = 0;
+	tile->detailMeshes = 0;
+	tile->detailVerts = 0;
+	tile->detailTris = 0;
+	tile->bvTree = 0;
+	tile->offMeshCons = 0;
+
+	// Update salt, salt should never be zero.
+	tile->salt = (tile->salt+1) & ((1<<m_saltBits)-1);
+	if (tile->salt == 0)
+		tile->salt++;
+
+	// Add to free list.
+	tile->next = m_nextFree;
+	m_nextFree = tile;
+
+	return DT_SUCCESS;
+}
+
+dtTileRef dtNavMesh::getTileRef(const dtMeshTile* tile) const
+{
+	if (!tile) return 0;
+	const unsigned int it = tile - m_tiles;
+	return (dtTileRef)encodePolyId(tile->salt, it, 0);
+}
+
+dtPolyRef dtNavMesh::getPolyRefBase(const dtMeshTile* tile) const
+{
+	if (!tile) return 0;
+	const unsigned int it = tile - m_tiles;
+	return encodePolyId(tile->salt, it, 0);
+}
+
+struct dtTileState
+{
+	int magic;								// Magic number, used to identify the data.
+	int version;							// Data version number.
+	dtTileRef ref;							// Tile ref at the time of storing the data.
+};
+
+struct dtPolyState
+{
+	unsigned short flags;						// Flags (see dtPolyFlags).
+	unsigned char area;							// Area ID of the polygon.
+};
+
+int dtNavMesh::getTileStateSize(const dtMeshTile* tile) const
+{
+	if (!tile) return 0;
+	const int headerSize = dtAlign4(sizeof(dtTileState));
+	const int polyStateSize = dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
+	return headerSize + polyStateSize;
+}
+
+dtStatus dtNavMesh::storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const
+{
+	// Make sure there is enough space to store the state.
+	const int sizeReq = getTileStateSize(tile);
+	if (maxDataSize < sizeReq)
+		return DT_FAILURE;
+		
+	dtTileState* tileState = (dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
+	dtPolyState* polyStates = (dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
+	
+	// Store tile state.
+	tileState->magic = DT_NAVMESH_STATE_MAGIC;
+	tileState->version = DT_NAVMESH_STATE_VERSION;
+	tileState->ref = getTileRef(tile);
+	
+	// Store per poly state.
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		const dtPoly* p = &tile->polys[i];
+		dtPolyState* s = &polyStates[i];
+		s->flags = p->flags;
+		s->area = p->getArea();
+	}
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMesh::restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize)
+{
+	// Make sure there is enough space to store the state.
+	const int sizeReq = getTileStateSize(tile);
+	if (maxDataSize < sizeReq)
+		return DT_FAILURE;
+	
+	const dtTileState* tileState = (const dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
+	const dtPolyState* polyStates = (const dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
+	
+	// Check that the restore is possible.
+	if (tileState->magic != DT_NAVMESH_STATE_MAGIC)
+		return DT_FAILURE_DATA_MAGIC;
+	if (tileState->version != DT_NAVMESH_STATE_VERSION)
+		return DT_FAILURE_DATA_VERSION;
+	if (tileState->ref != getTileRef(tile))
+		return DT_FAILURE;
+	
+	// Restore per poly state.
+	for (int i = 0; i < tile->header->polyCount; ++i)
+	{
+		dtPoly* p = &tile->polys[i];
+		const dtPolyState* s = &polyStates[i];
+		p->flags = s->flags;
+		p->setArea(s->area);
+	}
+	
+	return DT_SUCCESS;
+}
+
+// Returns start and end location of an off-mesh link polygon.
+dtStatus dtNavMesh::getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const
+{
+	unsigned int salt, it, ip;
+
+	// Get current polygon
+	decodePolyId(polyRef, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	const dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	const dtPoly* poly = &tile->polys[ip];
+
+	// Make sure that the current poly is indeed off-mesh link.
+	if (poly->getType() != DT_POLYTYPE_OFFMESH_CONNECTION)
+		return DT_FAILURE;
+
+	// Figure out which way to hand out the vertices.
+	int idx0 = 0, idx1 = 1;
+	
+	// Find link that points to first vertex.
+	for (unsigned int i = poly->firstLink; i != DT_NULL_LINK; i = tile->links[i].next)
+	{
+		if (tile->links[i].edge == 0)
+		{
+			if (tile->links[i].ref != prevRef)
+			{
+				idx0 = 1;
+				idx1 = 0;
+			}
+			break;
+		}
+	}
+	
+	dtVcopy(startPos, &tile->verts[poly->verts[idx0]*3]);
+	dtVcopy(endPos, &tile->verts[poly->verts[idx1]*3]);
+
+	return DT_SUCCESS;
+}
+
+
+const dtOffMeshConnection* dtNavMesh::getOffMeshConnectionByRef(dtPolyRef ref) const
+{
+	unsigned int salt, it, ip;
+	
+	// Get current polygon
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return 0;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return 0;
+	const dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return 0;
+	const dtPoly* poly = &tile->polys[ip];
+	
+	// Make sure that the current poly is indeed off-mesh link.
+	if (poly->getType() != DT_POLYTYPE_OFFMESH_CONNECTION)
+		return 0;
+
+	const unsigned int idx =  ip - tile->header->offMeshBase;
+	dtAssert(idx < (unsigned int)tile->header->offMeshConCount);
+	return &tile->offMeshCons[idx];
+}
+
+
+dtStatus dtNavMesh::setPolyFlags(dtPolyRef ref, unsigned short flags)
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	dtPoly* poly = &tile->polys[ip];
+	
+	// Change flags.
+	poly->flags = flags;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMesh::getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	const dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	const dtPoly* poly = &tile->polys[ip];
+
+	*resultFlags = poly->flags;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMesh::setPolyArea(dtPolyRef ref, unsigned char area)
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	dtPoly* poly = &tile->polys[ip];
+	
+	poly->setArea(area);
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMesh::getPolyArea(dtPolyRef ref, unsigned char* resultArea) const
+{
+	unsigned int salt, it, ip;
+	decodePolyId(ref, salt, it, ip);
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	const dtMeshTile* tile = &m_tiles[it];
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	const dtPoly* poly = &tile->polys[ip];
+	
+	*resultArea = poly->getArea();
+	
+	return DT_SUCCESS;
+}
+
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMesh.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMesh.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,428 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURNAVMESH_H
+#define DETOURNAVMESH_H
+
+#include "DetourAlloc.h"
+
+#ifdef WIN32
+    typedef unsigned __int64   uint64;
+#else
+#include <stdint.h>
+#ifndef uint64_t
+#ifdef __linux__
+#include <linux/types.h>
+#endif
+#endif
+    typedef uint64_t           uint64;
+#endif
+
+// Note: If you want to use 64-bit refs, change the types of both dtPolyRef & dtTileRef.
+// It is also recommended to change dtHashRef() to proper 64-bit hash too.
+
+// Reference to navigation polygon.
+typedef uint64 dtPolyRef;
+
+// Reference to navigation mesh tile.
+typedef uint64 dtTileRef;
+
+// Maximum number of vertices per navigation polygon.
+static const int DT_VERTS_PER_POLYGON = 6;
+
+static const int DT_NAVMESH_MAGIC = 'D'<<24 | 'N'<<16 | 'A'<<8 | 'V'; //'DNAV';
+static const int DT_NAVMESH_VERSION = 6;
+
+static const int DT_NAVMESH_STATE_MAGIC = 'D'<<24 | 'N'<<16 | 'M'<<8 | 'S'; //'DNMS';
+static const int DT_NAVMESH_STATE_VERSION = 1;
+
+static const unsigned short DT_EXT_LINK = 0x8000;
+static const unsigned int DT_NULL_LINK = 0xffffffff;
+static const unsigned int DT_OFFMESH_CON_BIDIR = 1;
+
+static const int DT_MAX_AREAS = 64;
+
+static const int STATIC_SALT_BITS = 12;
+static const int STATIC_TILE_BITS = 21;
+static const int STATIC_POLY_BITS = 31;
+// we cannot have over 31 bits for either tile nor poly
+// without changing polyCount to use 64bits too.
+
+// Flags for addTile
+enum dtTileFlags
+{
+	DT_TILE_FREE_DATA = 0x01,					// Navmesh owns the tile memory and should free it.
+};
+
+// Flags returned by findStraightPath().
+enum dtStraightPathFlags
+{
+	DT_STRAIGHTPATH_START = 0x01,				// The vertex is the start position.
+	DT_STRAIGHTPATH_END = 0x02,					// The vertex is the end position.
+	DT_STRAIGHTPATH_OFFMESH_CONNECTION = 0x04,	// The vertex is start of an off-mesh link.
+};
+
+// Flags describing polygon properties.
+enum dtPolyTypes
+{
+	DT_POLYTYPE_GROUND = 0,						// Regular ground polygons.
+	DT_POLYTYPE_OFFMESH_CONNECTION = 1,			// Off-mesh connections.
+};
+
+enum dtStatus
+{
+	DT_FAILURE = 0,								// Operation failed.
+	DT_FAILURE_DATA_MAGIC,
+	DT_FAILURE_DATA_VERSION,
+	DT_FAILURE_OUT_OF_MEMORY,
+	DT_SUCCESS,									// Operation succeed.
+	DT_IN_PROGRESS,								// Operation still in progress.
+};
+
+
+// Structure describing the navigation polygon data.
+struct dtPoly
+{
+	unsigned int firstLink;						// Index to first link in linked list. 
+	unsigned short verts[DT_VERTS_PER_POLYGON];	// Indices to vertices of the poly.
+	unsigned short neis[DT_VERTS_PER_POLYGON];	// Refs to neighbours of the poly.
+	unsigned short flags;						// Flags (see dtPolyFlags).
+	unsigned char vertCount;					// Number of vertices.
+	unsigned char areaAndtype;					// Bit packed: Area ID of the polygon, and Polygon type, see dtPolyTypes..
+	inline void setArea(unsigned char a) { areaAndtype = (areaAndtype & 0xc0) | (a & 0x3f); }
+	inline void setType(unsigned char t) { areaAndtype = (areaAndtype & 0x3f) | (t << 6); }
+	inline unsigned char getArea() const { return areaAndtype & 0x3f; }
+	inline unsigned char getType() const { return areaAndtype >> 6; }
+};
+
+// Stucture describing polygon detail triangles.
+struct dtPolyDetail
+{
+	unsigned int vertBase;						// Offset to detail vertex array.
+	unsigned int triBase;						// Offset to detail triangle array.
+	unsigned char vertCount;					// Number of vertices in the detail mesh.
+	unsigned char triCount;						// Number of triangles.
+};
+
+// Stucture describing a link to another polygon.
+struct dtLink
+{
+	dtPolyRef ref;							// Neighbour reference.
+	unsigned int next;						// Index to next link.
+	unsigned char edge;						// Index to polygon edge which owns this link. 
+	unsigned char side;						// If boundary link, defines on which side the link is.
+	unsigned char bmin, bmax;				// If boundary link, defines the sub edge area.
+};
+
+struct dtBVNode
+{
+	unsigned short bmin[3], bmax[3];		// BVnode bounds
+	int i;									// Index to item or if negative, escape index.
+};
+
+struct dtOffMeshConnection
+{
+	float pos[6];							// Both end point locations.
+	float rad;								// Link connection radius.
+	unsigned short poly;					// Poly Id
+	unsigned char flags;					// Link flags
+	unsigned char side;						// End point side.
+	unsigned int userId;					// User ID to identify this connection.
+};
+
+struct dtMeshHeader
+{
+	int magic;								// Magic number, used to identify the data.
+	int version;							// Data version number.
+	int x, y;								// Location of the time on the grid.
+	unsigned int userId;					// User ID of the tile.
+	int polyCount;							// Number of polygons in the tile.
+	int vertCount;							// Number of vertices in the tile.
+	int maxLinkCount;						// Number of allocated links.
+	int detailMeshCount;					// Number of detail meshes.
+	int detailVertCount;					// Number of detail vertices.
+	int detailTriCount;						// Number of detail triangles.
+	int bvNodeCount;						// Number of BVtree nodes.
+	int offMeshConCount;					// Number of Off-Mesh links.
+	int offMeshBase;						// Index to first polygon which is Off-Mesh link.
+	float walkableHeight;					// Height of the agent.
+	float walkableRadius;					// Radius of the agent
+	float walkableClimb;					// Max climb height of the agent.
+	float bmin[3], bmax[3];					// Bounding box of the tile.
+	float bvQuantFactor;					// BVtree quantization factor (world to bvnode coords)
+};
+
+struct dtMeshTile
+{
+	unsigned int salt;						// Counter describing modifications to the tile.
+
+	unsigned int linksFreeList;				// Index to next free link.
+	dtMeshHeader* header;					// Pointer to tile header.
+	dtPoly* polys;							// Pointer to the polygons (will be updated when tile is added).
+	float* verts;							// Pointer to the vertices (will be updated when tile added).
+	dtLink* links;							// Pointer to the links (will be updated when tile added).
+	dtPolyDetail* detailMeshes;				// Pointer to detail meshes (will be updated when tile added).
+	float* detailVerts;						// Pointer to detail vertices (will be updated when tile added).
+	unsigned char* detailTris;				// Pointer to detail triangles (will be updated when tile added).
+	dtBVNode* bvTree;						// Pointer to BVtree nodes (will be updated when tile added).
+	dtOffMeshConnection* offMeshCons;		// Pointer to Off-Mesh links. (will be updated when tile added).
+		
+	unsigned char* data;					// Pointer to tile data.
+	int dataSize;							// Size of the tile data.
+	int flags;								// Tile flags, see dtTileFlags.
+	dtMeshTile* next;						// Next free tile or, next tile in spatial grid.
+};
+
+struct dtNavMeshParams
+{
+	float orig[3];					// Origin of the nav mesh tile space.
+	float tileWidth, tileHeight;	// Width and height of each tile.
+	int maxTiles;					// Maximum number of tiles the navmesh can contain.
+	int maxPolys;					// Maximum number of polygons each tile can contain.
+};
+
+
+class dtNavMesh
+{
+public:
+	dtNavMesh();
+	~dtNavMesh();
+
+	// Initializes the nav mesh for tiled use.
+	// Params:
+	//  params - (in) navmesh initialization params, see dtNavMeshParams.
+	// Returns: True if succeed, else false.
+	dtStatus init(const dtNavMeshParams* params);
+
+	// Initializes the nav mesh for single tile use.
+	// Params:
+	//  data - (in) Data of the new tile mesh.
+	//  dataSize - (in) Data size of the new tile mesh.
+	//	flags - (in) Tile flags, see dtTileFlags.
+	// Returns: True if succeed, else false.
+	dtStatus init(unsigned char* data, const int dataSize, const int flags);
+	
+	// Returns pointer to navmesh initialization params.
+	const dtNavMeshParams* getParams() const;
+	
+	// Adds new tile into the navmesh.
+	// The add will fail if the data is in wrong format,
+	// there is not enough tiles left, or if there is a tile already at the location.
+	// Params:
+	//  data - (in) Data of the new tile mesh.
+	//  dataSize - (in) Data size of the new tile mesh.
+	//	flags - (in) Tile flags, see dtTileFlags.
+	//  lastRef - (in,optional) Last tile ref, the tile will be restored so that
+	//            the reference (as well as poly references) will be the same. Default: 0.
+	//  result - (out,optional) tile ref if the tile was succesfully added.
+	dtStatus addTile(unsigned char* data, int dataSize, int flags, dtTileRef lastRef, dtTileRef* result);
+	
+	// Removes specified tile.
+	// Params:
+	//  ref - (in) Reference to the tile to remove.
+	//  data - (out) Data associated with deleted tile.
+	//  dataSize - (out) Size of the data associated with deleted tile. 
+	dtStatus removeTile(dtTileRef ref, unsigned char** data, int* dataSize);
+
+	// Calculates tile location based in input world position.
+	// Params:
+	//  pos - (in) world position of the query.
+	//  tx - (out) tile x location.
+	//  ty - (out) tile y location.
+	void calcTileLoc(const float* pos, int* tx, int* ty) const;
+
+	// Returns pointer to tile at specified location.
+	// Params:
+	//  x,y - (in) Location of the tile to get.
+	// Returns: pointer to tile if tile exists or 0 tile does not exists.
+	const dtMeshTile* getTileAt(int x, int y) const;
+
+	// Returns reference to tile at specified location.
+	// Params:
+	//  x,y - (in) Location of the tile to get.
+	// Returns: reference to tile if tile exists or 0 tile does not exists.
+	dtTileRef getTileRefAt(int x, int y) const;
+	
+	// Returns tile references of a tile based on tile pointer.
+	dtTileRef getTileRef(const dtMeshTile* tile) const;
+
+	// Returns tile based on references.
+	const dtMeshTile* getTileByRef(dtTileRef ref) const;
+	
+	// Returns max number of tiles.
+	int getMaxTiles() const;
+	
+	// Returns pointer to tile in the tile array.
+	// Params:
+	//  i - (in) Index to the tile to retrieve, max index is getMaxTiles()-1.
+	// Returns: Pointer to specified tile.
+	const dtMeshTile* getTile(int i) const;
+
+	// Returns pointer to tile and polygon pointed by the polygon reference.
+	// Params:
+	//  ref - (in) reference to a polygon.
+	//  tile - (out) pointer to the tile containing the polygon.
+	//  poly - (out) pointer to the polygon.
+	dtStatus getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
+	
+	// Returns pointer to tile and polygon pointed by the polygon reference.
+	// Note: this function does not check if 'ref' s valid, and is thus faster. Use only with valid refs!
+	// Params:
+	//  ref - (in) reference to a polygon.
+	//  tile - (out) pointer to the tile containing the polygon.
+	//  poly - (out) pointer to the polygon.
+	void getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
+
+	// Returns true if polygon reference points to valid data.
+	bool isValidPolyRef(dtPolyRef ref) const;
+	
+	// Returns base poly id for specified tile, polygon refs can be deducted from this.
+	dtPolyRef getPolyRefBase(const dtMeshTile* tile) const;
+	
+	// Returns start and end location of an off-mesh link polygon.
+	// Params:
+	//	prevRef - (in) ref to the polygon before the link (used to select direction).
+	//	polyRef - (in) ref to the off-mesh link polygon.
+	//	startPos[3] - (out) start point of the link.
+	//	endPos[3] - (out) end point of the link.
+	// Returns: true if link is found.
+	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
+
+	// Returns pointer to off-mesh connection based on polyref, or null if ref not valid.
+	const dtOffMeshConnection* getOffMeshConnectionByRef(dtPolyRef ref) const;
+	
+	// Sets polygon flags.
+	dtStatus setPolyFlags(dtPolyRef ref, unsigned short flags);
+
+	// Return polygon flags.
+	dtStatus getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const;
+
+	// Set polygon type.
+	dtStatus setPolyArea(dtPolyRef ref, unsigned char area);
+
+	// Return polygon area type.
+	dtStatus getPolyArea(dtPolyRef ref, unsigned char* resultArea) const;
+
+
+	// Returns number of bytes required to store tile state.
+	int getTileStateSize(const dtMeshTile* tile) const;
+	
+	// Stores tile state to buffer.
+	dtStatus storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const;
+	
+	// Restores tile state.
+	dtStatus restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize);
+	
+
+	// Encodes a tile id.
+	inline dtPolyRef encodePolyId(unsigned int salt, unsigned int it, unsigned int ip) const
+	{
+		return ((dtPolyRef)salt << (m_polyBits+m_tileBits)) | ((dtPolyRef)it << m_polyBits) | (dtPolyRef)ip;
+	}
+	
+	// Decodes a tile id.
+	inline void decodePolyId(dtPolyRef ref, unsigned int& salt, unsigned int& it, unsigned int& ip) const
+	{
+		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
+		const dtPolyRef tileMask = ((dtPolyRef)1<<m_tileBits)-1;
+		const dtPolyRef polyMask = ((dtPolyRef)1<<m_polyBits)-1;
+		salt = (unsigned int)((ref >> (m_polyBits+m_tileBits)) & saltMask);
+		it = (unsigned int)((ref >> m_polyBits) & tileMask);
+		ip = (unsigned int)(ref & polyMask);
+	}
+
+	// Decodes a tile salt.
+	inline unsigned int decodePolyIdSalt(dtPolyRef ref) const
+	{
+		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
+		return (unsigned int)((ref >> (m_polyBits+m_tileBits)) & saltMask);
+	}
+	
+	// Decodes a tile id.
+	inline unsigned int decodePolyIdTile(dtPolyRef ref) const
+	{
+		const dtPolyRef tileMask = ((dtPolyRef)1<<m_tileBits)-1;
+		return (unsigned int)((ref >> m_polyBits) & tileMask);
+	}
+	
+	// Decodes a poly id.
+	inline unsigned int decodePolyIdPoly(dtPolyRef ref) const
+	{
+		const dtPolyRef polyMask = ((dtPolyRef)1<<m_polyBits)-1;
+		return (unsigned int)(ref & polyMask);
+	}
+	
+private:
+
+	// Returns pointer to tile in the tile array.
+	dtMeshTile* getTile(int i);
+
+	// Returns neighbour tile based on side. 
+	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
+	// Returns all polygons in neighbour tile based on portal defined by the segment.
+	int findConnectingPolys(const float* va, const float* vb,
+							const dtMeshTile* tile, int side,
+							dtPolyRef* con, float* conarea, int maxcon) const;
+	
+	// Builds internal polygons links for a tile.
+	void connectIntLinks(dtMeshTile* tile);
+	// Builds internal polygons links for a tile.
+	void connectIntOffMeshLinks(dtMeshTile* tile);
+
+	// Builds external polygon links for a tile.
+	void connectExtLinks(dtMeshTile* tile, dtMeshTile* target, int side);
+	// Builds external polygon links for a tile.
+	void connectExtOffMeshLinks(dtMeshTile* tile, dtMeshTile* target, int side);
+	
+	// Removes external links at specified side.
+	void unconnectExtLinks(dtMeshTile* tile, int side);
+	
+
+	// TODO: These methods are duplicates from dtNavMeshQuery, but are needed for off-mesh connection finding.
+	
+	// Queries polygons within a tile.
+	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+							dtPolyRef* polys, const int maxPolys) const;
+	// Find nearest polygon within a tile.
+	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center,
+									const float* extents, float* nearestPt) const;
+	// Returns closest point on polygon.
+	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+									  const float* pos, float* closest) const;
+	
+	dtNavMeshParams m_params;			// Current initialization params. TODO: do not store this info twice.
+	float m_orig[3];					// Origin of the tile (0,0)
+	float m_tileWidth, m_tileHeight;	// Dimensions of each tile.
+	int m_maxTiles;						// Max number of tiles.
+	int m_tileLutSize;					// Tile hash lookup size (must be pot).
+	int m_tileLutMask;					// Tile hash lookup mask.
+
+	dtMeshTile** m_posLookup;			// Tile hash lookup.
+	dtMeshTile* m_nextFree;				// Freelist of tiles.
+	dtMeshTile* m_tiles;				// List of tiles.
+		
+	unsigned int m_saltBits;			// Number of salt bits in the tile ID.
+	unsigned int m_tileBits;			// Number of tile bits in the tile ID.
+	unsigned int m_polyBits;			// Number of poly bits in the tile ID.
+};
+
+// Helper function to allocate navmesh class using Detour allocator.
+dtNavMesh* dtAllocNavMesh();
+void dtFreeNavMesh(dtNavMesh* navmesh);
+
+#endif // DETOURNAVMESH_H
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMeshBuilder.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMeshBuilder.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,717 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "DetourNavMesh.h"
+#include "DetourCommon.h"
+#include "DetourNavMeshBuilder.h"
+#include "DetourAlloc.h"
+#include "DetourAssert.h"
+
+static unsigned short MESH_NULL_IDX = 0xffff;
+
+
+struct BVItem
+{
+	unsigned short bmin[3];
+	unsigned short bmax[3];
+	int i;
+};
+
+static int compareItemX(const void* va, const void* vb)
+{
+	const BVItem* a = (const BVItem*)va;
+	const BVItem* b = (const BVItem*)vb;
+	if (a->bmin[0] < b->bmin[0])
+		return -1;
+	if (a->bmin[0] > b->bmin[0])
+		return 1;
+	return 0;
+}
+
+static int compareItemY(const void* va, const void* vb)
+{
+	const BVItem* a = (const BVItem*)va;
+	const BVItem* b = (const BVItem*)vb;
+	if (a->bmin[1] < b->bmin[1])
+		return -1;
+	if (a->bmin[1] > b->bmin[1])
+		return 1;
+	return 0;
+}
+
+static int compareItemZ(const void* va, const void* vb)
+{
+	const BVItem* a = (const BVItem*)va;
+	const BVItem* b = (const BVItem*)vb;
+	if (a->bmin[2] < b->bmin[2])
+		return -1;
+	if (a->bmin[2] > b->bmin[2])
+		return 1;
+	return 0;
+}
+
+static void calcExtends(BVItem* items, const int /*nitems*/, const int imin, const int imax,
+						unsigned short* bmin, unsigned short* bmax)
+{
+	bmin[0] = items[imin].bmin[0];
+	bmin[1] = items[imin].bmin[1];
+	bmin[2] = items[imin].bmin[2];
+	
+	bmax[0] = items[imin].bmax[0];
+	bmax[1] = items[imin].bmax[1];
+	bmax[2] = items[imin].bmax[2];
+	
+	for (int i = imin+1; i < imax; ++i)
+	{
+		const BVItem& it = items[i];
+		if (it.bmin[0] < bmin[0]) bmin[0] = it.bmin[0];
+		if (it.bmin[1] < bmin[1]) bmin[1] = it.bmin[1];
+		if (it.bmin[2] < bmin[2]) bmin[2] = it.bmin[2];
+		
+		if (it.bmax[0] > bmax[0]) bmax[0] = it.bmax[0];
+		if (it.bmax[1] > bmax[1]) bmax[1] = it.bmax[1];
+		if (it.bmax[2] > bmax[2]) bmax[2] = it.bmax[2];
+	}
+}
+
+inline int longestAxis(unsigned short x, unsigned short y, unsigned short z)
+{
+	int	axis = 0;
+	unsigned short maxVal = x;
+	if (y > maxVal)
+	{
+		axis = 1;
+		maxVal = y;
+	}
+	if (z > maxVal)
+	{
+		axis = 2;
+		maxVal = z;
+	}
+	return axis;
+}
+
+static void subdivide(BVItem* items, int nitems, int imin, int imax, int& curNode, dtBVNode* nodes)
+{
+	int inum = imax - imin;
+	int icur = curNode;
+	
+	dtBVNode& node = nodes[curNode++];
+	
+	if (inum == 1)
+	{
+		// Leaf
+		node.bmin[0] = items[imin].bmin[0];
+		node.bmin[1] = items[imin].bmin[1];
+		node.bmin[2] = items[imin].bmin[2];
+		
+		node.bmax[0] = items[imin].bmax[0];
+		node.bmax[1] = items[imin].bmax[1];
+		node.bmax[2] = items[imin].bmax[2];
+		
+		node.i = items[imin].i;
+	}
+	else
+	{
+		// Split
+		calcExtends(items, nitems, imin, imax, node.bmin, node.bmax);
+		
+		int	axis = longestAxis(node.bmax[0] - node.bmin[0],
+							   node.bmax[1] - node.bmin[1],
+							   node.bmax[2] - node.bmin[2]);
+		
+		if (axis == 0)
+		{
+			// Sort along x-axis
+			qsort(items+imin, inum, sizeof(BVItem), compareItemX);
+		}
+		else if (axis == 1)
+		{
+			// Sort along y-axis
+			qsort(items+imin, inum, sizeof(BVItem), compareItemY);
+		}
+		else
+		{
+			// Sort along z-axis
+			qsort(items+imin, inum, sizeof(BVItem), compareItemZ);
+		}
+		
+		int isplit = imin+inum/2;
+		
+		// Left
+		subdivide(items, nitems, imin, isplit, curNode, nodes);
+		// Right
+		subdivide(items, nitems, isplit, imax, curNode, nodes);
+		
+		int iescape = curNode - icur;
+		// Negative index means escape.
+		node.i = -iescape;
+	}
+}
+
+static int createBVTree(const unsigned short* verts, const int /*nverts*/,
+						const unsigned short* polys, const int npolys, const int nvp,
+						const float cs, const float ch,
+						const int /*nnodes*/, dtBVNode* nodes)
+{
+	// Build tree
+	BVItem* items = (BVItem*)dtAlloc(sizeof(BVItem)*npolys, DT_ALLOC_TEMP);
+	for (int i = 0; i < npolys; i++)
+	{
+		BVItem& it = items[i];
+		it.i = i;
+		// Calc polygon bounds.
+		const unsigned short* p = &polys[i*nvp*2];
+		it.bmin[0] = it.bmax[0] = verts[p[0]*3+0];
+		it.bmin[1] = it.bmax[1] = verts[p[0]*3+1];
+		it.bmin[2] = it.bmax[2] = verts[p[0]*3+2];
+		
+		for (int j = 1; j < nvp; ++j)
+		{
+			if (p[j] == MESH_NULL_IDX) break;
+			unsigned short x = verts[p[j]*3+0];
+			unsigned short y = verts[p[j]*3+1];
+			unsigned short z = verts[p[j]*3+2];
+			
+			if (x < it.bmin[0]) it.bmin[0] = x;
+			if (y < it.bmin[1]) it.bmin[1] = y;
+			if (z < it.bmin[2]) it.bmin[2] = z;
+			
+			if (x > it.bmax[0]) it.bmax[0] = x;
+			if (y > it.bmax[1]) it.bmax[1] = y;
+			if (z > it.bmax[2]) it.bmax[2] = z;
+		}
+		// Remap y
+		it.bmin[1] = (unsigned short)floorf((float)it.bmin[1]*ch/cs);
+		it.bmax[1] = (unsigned short)ceilf((float)it.bmax[1]*ch/cs);
+	}
+	
+	int curNode = 0;
+	subdivide(items, npolys, 0, npolys, curNode, nodes);
+	
+	dtFree(items);
+	
+	return curNode;
+}
+
+static unsigned char classifyOffMeshPoint(const float* pt, const float* bmin, const float* bmax)
+{
+	static const unsigned char XP = 1<<0;
+	static const unsigned char ZP = 1<<1;
+	static const unsigned char XM = 1<<2;
+	static const unsigned char ZM = 1<<3;	
+
+	unsigned char outcode = 0; 
+	outcode |= (pt[0] >= bmax[0]) ? XP : 0;
+	outcode |= (pt[2] >= bmax[2]) ? ZP : 0;
+	outcode |= (pt[0] < bmin[0])  ? XM : 0;
+	outcode |= (pt[2] < bmin[2])  ? ZM : 0;
+
+	switch (outcode)
+	{
+	case XP: return 0;
+	case XP|ZP: return 1;
+	case ZP: return 2;
+	case XM|ZP: return 3;
+	case XM: return 4;
+	case XM|ZM: return 5;
+	case ZM: return 6;
+	case XP|ZM: return 7;
+	};
+	return 0xff;	
+}
+
+// TODO: Better error handling.
+
+bool dtCreateNavMeshData(dtNavMeshCreateParams* params, unsigned char** outData, int* outDataSize)
+{
+	if (params->nvp > DT_VERTS_PER_POLYGON)
+		return false;
+	if (params->vertCount >= 0xffff)
+		return false;
+	if (!params->vertCount || !params->verts)
+		return false;
+	if (!params->polyCount || !params->polys)
+		return false;
+	if (!params->detailMeshes || !params->detailVerts || !params->detailTris)
+		return false;
+
+	const int nvp = params->nvp;
+	
+	// Classify off-mesh connection points. We store only the connections
+	// whose start point is inside the tile.
+	unsigned char* offMeshConClass = 0;
+	int storedOffMeshConCount = 0;
+	int offMeshConLinkCount = 0;
+	
+	if (params->offMeshConCount > 0)
+	{
+		offMeshConClass = (unsigned char*)dtAlloc(sizeof(unsigned char)*params->offMeshConCount*2, DT_ALLOC_TEMP);
+		if (!offMeshConClass)
+			return false;
+
+		for (int i = 0; i < params->offMeshConCount; ++i)
+		{
+			offMeshConClass[i*2+0] = classifyOffMeshPoint(&params->offMeshConVerts[(i*2+0)*3], params->bmin, params->bmax);
+			offMeshConClass[i*2+1] = classifyOffMeshPoint(&params->offMeshConVerts[(i*2+1)*3], params->bmin, params->bmax);
+
+			// Cound how many links should be allocated for off-mesh connections.
+			if (offMeshConClass[i*2+0] == 0xff)
+				offMeshConLinkCount++;
+			if (offMeshConClass[i*2+1] == 0xff)
+				offMeshConLinkCount++;
+
+			if (offMeshConClass[i*2+0] == 0xff)
+				storedOffMeshConCount++;
+		}
+	}
+	
+	// Off-mesh connectionss are stored as polygons, adjust values.
+	const int totPolyCount = params->polyCount + storedOffMeshConCount;
+	const int totVertCount = params->vertCount + storedOffMeshConCount*2;
+	
+	// Find portal edges which are at tile borders.
+	int edgeCount = 0;
+	int portalCount = 0;
+	for (int i = 0; i < params->polyCount; ++i)
+	{
+		const unsigned short* p = &params->polys[i*2*nvp];
+		for (int j = 0; j < nvp; ++j)
+		{
+			if (p[j] == MESH_NULL_IDX) break;
+			int nj = j+1;
+			if (nj >= nvp || p[nj] == MESH_NULL_IDX) nj = 0;
+			const unsigned short* va = &params->verts[p[j]*3];
+			const unsigned short* vb = &params->verts[p[nj]*3];
+			
+			edgeCount++;
+			
+			if (params->tileSize > 0)
+			{
+				if (va[0] == params->tileSize && vb[0] == params->tileSize)
+					portalCount++; // x+
+				else if (va[2] == params->tileSize && vb[2] == params->tileSize)
+					portalCount++; // z+
+				else if (va[0] == 0 && vb[0] == 0)
+					portalCount++; // x-
+				else if (va[2] == 0 && vb[2] == 0)
+					portalCount++; // z-
+			}
+		}
+	}
+
+	const int maxLinkCount = edgeCount + portalCount*2 + offMeshConLinkCount*2;
+	
+	// Find unique detail vertices.
+	int uniqueDetailVertCount = 0;
+	for (int i = 0; i < params->polyCount; ++i)
+	{
+		const unsigned short* p = &params->polys[i*nvp*2];
+		int ndv = params->detailMeshes[i*4+1];
+		int nv = 0;
+		for (int j = 0; j < nvp; ++j)
+		{
+			if (p[j] == MESH_NULL_IDX) break;
+			nv++;
+		}
+		ndv -= nv;
+		uniqueDetailVertCount += ndv;
+	}
+	
+	// Calculate data size
+	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
+	const int vertsSize = dtAlign4(sizeof(float)*3*totVertCount);
+	const int polysSize = dtAlign4(sizeof(dtPoly)*totPolyCount);
+	const int linksSize = dtAlign4(sizeof(dtLink)*maxLinkCount);
+	const int detailMeshesSize = dtAlign4(sizeof(dtPolyDetail)*params->polyCount);
+	const int detailVertsSize = dtAlign4(sizeof(float)*3*uniqueDetailVertCount);
+	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*params->detailTriCount);
+	const int bvTreeSize = dtAlign4(sizeof(dtBVNode)*params->polyCount*2);
+	const int offMeshConsSize = dtAlign4(sizeof(dtOffMeshConnection)*storedOffMeshConCount);
+	
+	const int dataSize = headerSize + vertsSize + polysSize + linksSize +
+						 detailMeshesSize + detailVertsSize + detailTrisSize +
+						 bvTreeSize + offMeshConsSize;
+						 
+	unsigned char* data = (unsigned char*)dtAlloc(sizeof(unsigned char)*dataSize, DT_ALLOC_PERM);
+	if (!data)
+	{
+		dtFree(offMeshConClass);
+		return false;
+	}
+	memset(data, 0, dataSize);
+	
+	unsigned char* d = data;
+	dtMeshHeader* header = (dtMeshHeader*)d; d += headerSize;
+	float* navVerts = (float*)d; d += vertsSize;
+	dtPoly* navPolys = (dtPoly*)d; d += polysSize;
+	d += linksSize;
+	dtPolyDetail* navDMeshes = (dtPolyDetail*)d; d += detailMeshesSize;
+	float* navDVerts = (float*)d; d += detailVertsSize;
+	unsigned char* navDTris = (unsigned char*)d; d += detailTrisSize;
+	dtBVNode* navBvtree = (dtBVNode*)d; d += bvTreeSize;
+	dtOffMeshConnection* offMeshCons = (dtOffMeshConnection*)d; d += offMeshConsSize;
+	
+	
+	// Store header
+	header->magic = DT_NAVMESH_MAGIC;
+	header->version = DT_NAVMESH_VERSION;
+	header->x = params->tileX;
+	header->y = params->tileY;
+	header->userId = params->userId;
+	header->polyCount = totPolyCount;
+	header->vertCount = totVertCount;
+	header->maxLinkCount = maxLinkCount;
+	dtVcopy(header->bmin, params->bmin);
+	dtVcopy(header->bmax, params->bmax);
+	header->detailMeshCount = params->polyCount;
+	header->detailVertCount = uniqueDetailVertCount;
+	header->detailTriCount = params->detailTriCount;
+	header->bvQuantFactor = 1.0f / params->cs;
+	header->offMeshBase = params->polyCount;
+	header->walkableHeight = params->walkableHeight;
+	header->walkableRadius = params->walkableRadius;
+	header->walkableClimb = params->walkableClimb;
+	header->offMeshConCount = storedOffMeshConCount;
+	header->bvNodeCount = params->polyCount*2;
+	
+	const int offMeshVertsBase = params->vertCount;
+	const int offMeshPolyBase = params->polyCount;
+	
+	// Store vertices
+	// Mesh vertices
+	for (int i = 0; i < params->vertCount; ++i)
+	{
+		const unsigned short* iv = &params->verts[i*3];
+		float* v = &navVerts[i*3];
+		v[0] = params->bmin[0] + iv[0] * params->cs;
+		v[1] = params->bmin[1] + iv[1] * params->ch;
+		v[2] = params->bmin[2] + iv[2] * params->cs;
+	}
+	// Off-mesh link vertices.
+	int n = 0;
+	for (int i = 0; i < params->offMeshConCount; ++i)
+	{
+		// Only store connections which start from this tile.
+		if (offMeshConClass[i*2+0] == 0xff)
+		{
+			const float* linkv = &params->offMeshConVerts[i*2*3];
+			float* v = &navVerts[(offMeshVertsBase + n*2)*3];
+			dtVcopy(&v[0], &linkv[0]);
+			dtVcopy(&v[3], &linkv[3]);
+			n++;
+		}
+	}
+	
+	// Store polygons
+	// Mesh polys
+	const unsigned short* src = params->polys;
+	for (int i = 0; i < params->polyCount; ++i)
+	{
+		dtPoly* p = &navPolys[i];
+		p->vertCount = 0;
+		p->flags = params->polyFlags[i];
+		p->setArea(params->polyAreas[i]);
+		p->setType(DT_POLYTYPE_GROUND);
+		for (int j = 0; j < nvp; ++j)
+		{
+			if (src[j] == MESH_NULL_IDX) break;
+			p->verts[j] = src[j];
+			p->neis[j] = (src[nvp+j]+1) & 0xffff;
+			p->vertCount++;
+		}
+		src += nvp*2;
+	}
+	// Off-mesh connection vertices.
+	n = 0;
+	for (int i = 0; i < params->offMeshConCount; ++i)
+	{
+		// Only store connections which start from this tile.
+		if (offMeshConClass[i*2+0] == 0xff)
+		{
+			dtPoly* p = &navPolys[offMeshPolyBase+n];
+			p->vertCount = 2;
+			p->verts[0] = (unsigned short)(offMeshVertsBase + n*2+0);
+			p->verts[1] = (unsigned short)(offMeshVertsBase + n*2+1);
+			p->flags = params->offMeshConFlags[i];
+			p->setArea(params->offMeshConAreas[i]);
+			p->setType(DT_POLYTYPE_OFFMESH_CONNECTION);
+			n++;
+		}
+	}
+	
+	// Store portal edges.
+	if (params->tileSize > 0)
+	{
+		for (int i = 0; i < params->polyCount; ++i)
+		{
+			dtPoly* poly = &navPolys[i];
+			for (int j = 0; j < poly->vertCount; ++j)
+			{
+				int nj = j+1;
+				if (nj >= poly->vertCount) nj = 0;
+
+				const unsigned short* va = &params->verts[poly->verts[j]*3];
+				const unsigned short* vb = &params->verts[poly->verts[nj]*3];
+							
+				if (va[0] == params->tileSize && vb[0] == params->tileSize) // x+
+					poly->neis[j] = DT_EXT_LINK | 0;
+				else if (va[2] == params->tileSize && vb[2]  == params->tileSize) // z+
+					poly->neis[j] = DT_EXT_LINK | 2;
+				else if (va[0] == 0 && vb[0] == 0) // x-
+					poly->neis[j] = DT_EXT_LINK | 4;
+				else if (va[2] == 0 && vb[2] == 0) // z-
+					poly->neis[j] = DT_EXT_LINK | 6;
+			}
+		}
+	}
+
+	// Store detail meshes and vertices.
+	// The nav polygon vertices are stored as the first vertices on each mesh.
+	// We compress the mesh data by skipping them and using the navmesh coordinates.
+	unsigned short vbase = 0;
+	for (int i = 0; i < params->polyCount; ++i)
+	{
+		dtPolyDetail& dtl = navDMeshes[i];
+		const int vb = (int)params->detailMeshes[i*4+0];
+		const int ndv = (int)params->detailMeshes[i*4+1];
+		const int nv = navPolys[i].vertCount;
+		dtl.vertBase = (unsigned int)vbase;
+		dtl.vertCount = (unsigned char)(ndv-nv);
+		dtl.triBase = (unsigned int)params->detailMeshes[i*4+2];
+		dtl.triCount = (unsigned char)params->detailMeshes[i*4+3];
+		// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
+		if (ndv-nv)
+		{
+			memcpy(&navDVerts[vbase*3], &params->detailVerts[(vb+nv)*3], sizeof(float)*3*(ndv-nv));
+			vbase += (unsigned short)(ndv-nv);
+		}
+	}
+	// Store triangles.
+	memcpy(navDTris, params->detailTris, sizeof(unsigned char)*4*params->detailTriCount);
+
+	// Store and create BVtree.
+	// TODO: take detail mesh into account! use byte per bbox extent?
+	createBVTree(params->verts, params->vertCount, params->polys, params->polyCount,
+				 nvp, params->cs, params->ch, params->polyCount*2, navBvtree);
+	
+	// Store Off-Mesh connections.
+	n = 0;
+	for (int i = 0; i < params->offMeshConCount; ++i)
+	{
+		// Only store connections which start from this tile.
+		if (offMeshConClass[i*2+0] == 0xff)
+		{
+			dtOffMeshConnection* con = &offMeshCons[n];
+			con->poly = (unsigned short)(offMeshPolyBase + n);
+			// Copy connection end-points.
+			const float* endPts = &params->offMeshConVerts[i*2*3];
+			dtVcopy(&con->pos[0], &endPts[0]);
+			dtVcopy(&con->pos[3], &endPts[3]);
+			con->rad = params->offMeshConRad[i];
+			con->flags = params->offMeshConDir[i] ? DT_OFFMESH_CON_BIDIR : 0;
+			con->side = offMeshConClass[i*2+1];
+			if (params->offMeshConUserID)
+				con->userId = params->offMeshConUserID[i];
+			n++;
+		}
+	}
+		
+	dtFree(offMeshConClass);
+	
+	*outData = data;
+	*outDataSize = dataSize;
+	
+	return true;
+}
+
+inline void swapByte(unsigned char* a, unsigned char* b)
+{
+	unsigned char tmp = *a;
+	*a = *b;
+	*b = tmp;
+}
+
+inline void swapEndian(unsigned short* v)
+{
+	unsigned char* x = (unsigned char*)v;
+	swapByte(x+0, x+1);
+}
+
+inline void swapEndian(short* v)
+{
+	unsigned char* x = (unsigned char*)v;
+	swapByte(x+0, x+1);
+}
+
+inline void swapEndian(unsigned int* v)
+{
+	unsigned char* x = (unsigned char*)v;
+	swapByte(x+0, x+3); swapByte(x+1, x+2);
+}
+
+inline void swapEndian(int* v)
+{
+	unsigned char* x = (unsigned char*)v;
+	swapByte(x+0, x+3); swapByte(x+1, x+2);
+}
+
+inline void swapEndian(float* v)
+{
+	unsigned char* x = (unsigned char*)v;
+	swapByte(x+0, x+3); swapByte(x+1, x+2);
+}
+
+bool dtNavMeshHeaderSwapEndian(unsigned char* data, const int /*dataSize*/)
+{
+	dtMeshHeader* header = (dtMeshHeader*)data;
+	
+	int swappedMagic = DT_NAVMESH_MAGIC;
+	int swappedVersion = DT_NAVMESH_VERSION;
+	swapEndian(&swappedMagic);
+	swapEndian(&swappedVersion);
+	
+	if ((header->magic != DT_NAVMESH_MAGIC || header->version != DT_NAVMESH_VERSION) &&
+		(header->magic != swappedMagic || header->version != swappedVersion))
+	{
+		return false;
+	}
+		
+	swapEndian(&header->magic);
+	swapEndian(&header->version);
+	swapEndian(&header->x);
+	swapEndian(&header->y);
+	swapEndian(&header->userId);
+	swapEndian(&header->polyCount);
+	swapEndian(&header->vertCount);
+	swapEndian(&header->maxLinkCount);
+	swapEndian(&header->detailMeshCount);
+	swapEndian(&header->detailVertCount);
+	swapEndian(&header->detailTriCount);
+	swapEndian(&header->bvNodeCount);
+	swapEndian(&header->offMeshConCount);
+	swapEndian(&header->offMeshBase);
+	swapEndian(&header->walkableHeight);
+	swapEndian(&header->walkableRadius);
+	swapEndian(&header->walkableClimb);
+	swapEndian(&header->bmin[0]);
+	swapEndian(&header->bmin[1]);
+	swapEndian(&header->bmin[2]);
+	swapEndian(&header->bmax[0]);
+	swapEndian(&header->bmax[1]);
+	swapEndian(&header->bmax[2]);
+	swapEndian(&header->bvQuantFactor);
+
+	// Freelist index and pointers are updated when tile is added, no need to swap.
+
+	return true;
+}
+
+bool dtNavMeshDataSwapEndian(unsigned char* data, const int /*dataSize*/)
+{
+	// Make sure the data is in right format.
+	dtMeshHeader* header = (dtMeshHeader*)data;
+	if (header->magic != DT_NAVMESH_MAGIC)
+		return false;
+	if (header->version != DT_NAVMESH_VERSION)
+		return false;
+	
+	// Patch header pointers.
+	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
+	const int vertsSize = dtAlign4(sizeof(float)*3*header->vertCount);
+	const int polysSize = dtAlign4(sizeof(dtPoly)*header->polyCount);
+	const int linksSize = dtAlign4(sizeof(dtLink)*(header->maxLinkCount));
+	const int detailMeshesSize = dtAlign4(sizeof(dtPolyDetail)*header->detailMeshCount);
+	const int detailVertsSize = dtAlign4(sizeof(float)*3*header->detailVertCount);
+	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*header->detailTriCount);
+	const int bvtreeSize = dtAlign4(sizeof(dtBVNode)*header->bvNodeCount);
+	const int offMeshLinksSize = dtAlign4(sizeof(dtOffMeshConnection)*header->offMeshConCount);
+	
+	unsigned char* d = data + headerSize;
+	float* verts = (float*)d; d += vertsSize;
+	dtPoly* polys = (dtPoly*)d; d += polysSize;
+	/*dtLink* links = (dtLink*)d;*/ d += linksSize;
+	dtPolyDetail* detailMeshes = (dtPolyDetail*)d; d += detailMeshesSize;
+	float* detailVerts = (float*)d; d += detailVertsSize;
+	/*unsigned char* detailTris = (unsigned char*)d;*/ d += detailTrisSize;
+	dtBVNode* bvTree = (dtBVNode*)d; d += bvtreeSize;
+	dtOffMeshConnection* offMeshCons = (dtOffMeshConnection*)d; d += offMeshLinksSize;
+	
+	// Vertices
+	for (int i = 0; i < header->vertCount*3; ++i)
+	{
+		swapEndian(&verts[i]);
+	}
+
+	// Polys
+	for (int i = 0; i < header->polyCount; ++i)
+	{
+		dtPoly* p = &polys[i];
+		// poly->firstLink is update when tile is added, no need to swap.
+		for (int j = 0; j < DT_VERTS_PER_POLYGON; ++j)
+		{
+			swapEndian(&p->verts[j]);
+			swapEndian(&p->neis[j]);
+		}
+		swapEndian(&p->flags);
+	}
+
+	// Links are rebuild when tile is added, no need to swap.
+
+	// Detail meshes
+	for (int i = 0; i < header->detailMeshCount; ++i)
+	{
+		dtPolyDetail* pd = &detailMeshes[i];
+		swapEndian(&pd->vertBase);
+		swapEndian(&pd->triBase);
+	}
+	
+	// Detail verts
+	for (int i = 0; i < header->detailVertCount*3; ++i)
+	{
+		swapEndian(&detailVerts[i]);
+	}
+
+	// BV-tree
+	for (int i = 0; i < header->bvNodeCount; ++i)
+	{
+		dtBVNode* node = &bvTree[i];
+		for (int j = 0; j < 3; ++j)
+		{
+			swapEndian(&node->bmin[j]);
+			swapEndian(&node->bmax[j]);
+		}
+		swapEndian(&node->i);
+	}
+
+	// Off-mesh Connections.
+	for (int i = 0; i < header->offMeshConCount; ++i)
+	{
+		dtOffMeshConnection* con = &offMeshCons[i];
+		for (int j = 0; j < 6; ++j)
+			swapEndian(&con->pos[j]);
+		swapEndian(&con->rad);
+		swapEndian(&con->poly);
+	}
+	
+	return true;
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMeshBuilder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMeshBuilder.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,77 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURNAVMESHBUILDER_H
+#define DETOURNAVMESHBUILDER_H
+
+#include "DetourAlloc.h"
+
+
+// The units of the parameters are specified in parenthesis as follows:
+// (vx) voxels, (wu) world units
+struct dtNavMeshCreateParams
+{
+	// Navmesh vertices.
+	const unsigned short* verts;			// Array of vertices, each vertex has 3 components. (vx).
+	int vertCount;							// Vertex count
+	// Navmesh polygons
+	const unsigned short* polys;			// Array of polygons, uses same format as rcPolyMesh. 
+	const unsigned short* polyFlags;		// Array of flags per polygon.
+	const unsigned char* polyAreas;			// Array of area ids per polygon.
+	int polyCount;							// Number of polygons
+	int nvp;								// Number of verts per polygon.
+	// Navmesh Detail
+	const unsigned int* detailMeshes;		// Detail meshes, uses same format as rcPolyMeshDetail.
+	const float* detailVerts;				// Detail mesh vertices, uses same format as rcPolyMeshDetail (wu).
+	int detailVertsCount;					// Total number of detail vertices
+	const unsigned char* detailTris;		// Array of detail tris per detail mesh.
+	int detailTriCount;						// Total number of detail triangles.
+	// Off-Mesh Connections.
+	const float* offMeshConVerts;			// Off-mesh connection vertices (wu).
+	const float* offMeshConRad;				// Off-mesh connection radii (wu).
+	const unsigned short* offMeshConFlags;	// Off-mesh connection flags.
+	const unsigned char* offMeshConAreas;	// Off-mesh connection area ids.
+	const unsigned char* offMeshConDir;		// Off-mesh connection direction flags (1 = bidir, 0 = oneway).
+	const unsigned int* offMeshConUserID;	// Off-mesh connection user id (optional).
+	int offMeshConCount;					// Number of off-mesh connections
+	// Tile location
+	unsigned int userId;					// User ID bound to the tile.
+	int tileX, tileY;						// Tile location (tile coords).
+	float bmin[3], bmax[3];					// Tile bounds (wu).
+	// Settings
+	float walkableHeight;					// Agent height (wu).
+	float walkableRadius;					// Agent radius (wu).
+	float walkableClimb;					// Agent max climb (wu).
+	float cs;								// Cell size (xz) (wu).
+	float ch;								// Cell height (y) (wu).
+	int tileSize;							// Tile size (width & height) (vx).
+};
+
+// Build navmesh data from given input data.
+bool dtCreateNavMeshData(dtNavMeshCreateParams* params, unsigned char** outData, int* outDataSize);
+
+// Swaps endianess of navmesh header.
+bool dtNavMeshHeaderSwapEndian(unsigned char* data, const int dataSize);
+
+// Swaps endianess of the navmesh data. This function assumes that the header is in correct
+// endianess already. Call dtNavMeshHeaderSwapEndian() first on the data if the data is
+// assumed to be in wrong endianess to start with. If converting from native endianess to foreign,
+// call dtNavMeshHeaderSwapEndian() after the data has been swapped.
+bool dtNavMeshDataSwapEndian(unsigned char* data, const int dataSize);
+
+#endif // DETOURNAVMESHBUILDER_H
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMeshQuery.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMeshQuery.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,2560 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <math.h>
+#include <float.h>
+#include <string.h>
+#include "DetourNavMeshQuery.h"
+#include "DetourNavMesh.h"
+#include "DetourNode.h"
+#include "DetourCommon.h"
+#include "DetourAlloc.h"
+#include "DetourAssert.h"
+#include <new>
+
+
+dtQueryFilter::dtQueryFilter() :
+	m_includeFlags(0xffff),
+	m_excludeFlags(0)
+{
+	for (int i = 0; i < DT_MAX_AREAS; ++i)
+		m_areaCost[i] = 1.0f;
+}
+
+#ifdef DT_VIRTUAL_QUERYFILTER
+bool dtQueryFilter::passFilter(const dtPolyRef /*ref*/,
+							   const dtMeshTile* /*tile*/,
+							   const dtPoly* poly) const
+{
+	return (poly->flags & m_includeFlags) != 0 && (poly->flags & m_excludeFlags) == 0;
+}
+
+float dtQueryFilter::getCost(const float* pa, const float* pb,
+							 const dtPolyRef /*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,
+							 const dtPolyRef /*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,
+							 const dtPolyRef /*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const
+{
+	return dtVdist(pa, pb) * m_areaCost[curPoly->area];
+}
+#else
+inline bool dtQueryFilter::passFilter(const dtPolyRef /*ref*/,
+									  const dtMeshTile* /*tile*/,
+									  const dtPoly* poly) const
+{
+	return (poly->flags & m_includeFlags) != 0 && (poly->flags & m_excludeFlags) == 0;
+}
+
+inline float dtQueryFilter::getCost(const float* pa, const float* pb,
+									const dtPolyRef /*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,
+									const dtPolyRef /*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,
+									const dtPolyRef /*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const
+{
+	return dtVdist(pa, pb) * m_areaCost[curPoly->getArea()];
+}
+#endif	
+	
+static const float H_SCALE = 0.999f; // Search heuristic scale.
+
+
+dtNavMeshQuery* dtAllocNavMeshQuery()
+{
+	void* mem = dtAlloc(sizeof(dtNavMeshQuery), DT_ALLOC_PERM);
+	if (!mem) return 0;
+	return new(mem) dtNavMeshQuery;
+}
+
+void dtFreeNavMeshQuery(dtNavMeshQuery* navmesh)
+{
+	if (!navmesh) return;
+	navmesh->~dtNavMeshQuery();
+	dtFree(navmesh);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+dtNavMeshQuery::dtNavMeshQuery() :
+	m_tinyNodePool(0),
+	m_nodePool(0),
+	m_openList(0)
+{
+	memset(&m_query, 0, sizeof(dtQueryData));
+}
+
+dtNavMeshQuery::~dtNavMeshQuery()
+{
+	if (m_tinyNodePool)
+		m_tinyNodePool->~dtNodePool();
+	if (m_nodePool)
+		m_nodePool->~dtNodePool();
+	if (m_openList)
+		m_openList->~dtNodeQueue();
+	dtFree(m_tinyNodePool);
+	dtFree(m_nodePool);
+	dtFree(m_openList);
+}
+
+dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
+{
+	m_nav = nav;
+	
+	if (!m_nodePool || m_nodePool->getMaxNodes() < maxNodes)
+	{
+		if (m_nodePool)
+		{
+			m_nodePool->~dtNodePool();
+			dtFree(m_nodePool);
+			m_nodePool = 0;
+		}
+		m_nodePool = new (dtAlloc(sizeof(dtNodePool), DT_ALLOC_PERM)) dtNodePool(maxNodes, dtNextPow2(maxNodes/4));
+		if (!m_nodePool)
+			return DT_FAILURE_OUT_OF_MEMORY;
+	}
+	else
+	{
+		m_nodePool->clear();
+	}
+	
+	if (!m_tinyNodePool)
+	{
+		m_tinyNodePool = new (dtAlloc(sizeof(dtNodePool), DT_ALLOC_PERM)) dtNodePool(64, 32);
+		if (!m_tinyNodePool)
+			return DT_FAILURE_OUT_OF_MEMORY;
+	}
+	else
+	{
+		m_tinyNodePool->clear();
+	}
+	
+	// TODO: check the open list size too.
+	if (!m_openList || m_openList->getCapacity() < maxNodes)
+	{
+		if (m_openList)
+		{
+			m_openList->~dtNodeQueue();
+			dtFree(m_openList);
+			m_openList = 0;
+		}
+		m_openList = new (dtAlloc(sizeof(dtNodeQueue), DT_ALLOC_PERM)) dtNodeQueue(maxNodes);
+		if (!m_openList)
+			return DT_FAILURE_OUT_OF_MEMORY;
+	}
+	else
+	{
+		m_openList->clear();
+	}
+	
+	return DT_SUCCESS;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const
+{
+	dtAssert(m_nav);
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
+		return DT_FAILURE;
+	if (!tile) return DT_FAILURE;
+	if (closestPointOnPolyInTile(tile, poly, pos, closest) != DT_SUCCESS)
+		return DT_FAILURE;
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly,
+												  const float* pos, float* closest) const
+{
+	const unsigned int ip = (unsigned int)(poly - tile->polys);
+	const dtPolyDetail* pd = &tile->detailMeshes[ip];
+
+	// TODO: The commented out version finds 'cylinder distance' instead of 'sphere distance' to the navmesh.
+	// Test and enable.
+/*
+	// Clamp point to be inside the polygon.
+	float verts[DT_VERTS_PER_POLYGON*3];	
+	float edged[DT_VERTS_PER_POLYGON];
+	float edget[DT_VERTS_PER_POLYGON];
+	const int nv = poly->vertCount;
+	for (int i = 0; i < nv; ++i)
+		dtVcopy(&verts[i*3], &tile->verts[poly->verts[i]*3]);
+	
+	dtVcopy(closest, pos);
+	if (!dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget))
+	{
+		// Point is outside the polygon, dtClamp to nearest edge.
+		float dmin = FLT_MAX;
+		int imin = -1;
+		for (int i = 0; i < nv; ++i)
+		{
+			if (edged[i] < dmin)
+			{
+				dmin = edged[i];
+				imin = i;
+			}
+		}
+		const float* va = &verts[imin*3];
+		const float* vb = &verts[((imin+1)%nv)*3];
+		dtVlerp(closest, va, vb, edget[imin]);
+	}
+
+	// Find height at the location.
+	for (int j = 0; j < pd->triCount; ++j)
+	{
+		const unsigned char* t = &tile->detailTris[(pd->triBase+j)*4];
+		const float* v[3];
+		for (int k = 0; k < 3; ++k)
+		{
+			if (t[k] < poly->vertCount)
+				v[k] = &tile->verts[poly->verts[t[k]]*3];
+			else
+				v[k] = &tile->detailVerts[(pd->vertBase+(t[k]-poly->vertCount))*3];
+		}
+		float h;
+		if (dtClosestHeightPointTriangle(pos, v[0], v[1], v[2], h))
+		{
+			closest[1] = h;
+			break;
+		}
+	}
+*/
+	float closestDistSqr = FLT_MAX;
+	for (int j = 0; j < pd->triCount; ++j)
+	{
+		const unsigned char* t = &tile->detailTris[(pd->triBase+j)*4];
+		const float* v[3];
+		for (int k = 0; k < 3; ++k)
+		{
+			if (t[k] < poly->vertCount)
+				v[k] = &tile->verts[poly->verts[t[k]]*3];
+			else
+				v[k] = &tile->detailVerts[(pd->vertBase+(t[k]-poly->vertCount))*3];
+		}
+
+		float pt[3];
+		dtClosestPtPointTriangle(pt, pos, v[0], v[1], v[2]);
+		float d = dtVdistSqr(pos, pt);
+		
+		if (d < closestDistSqr)
+		{
+			dtVcopy(closest, pt);
+			closestDistSqr = d;
+		}
+	}
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const
+{
+	dtAssert(m_nav);
+	
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	// Collect vertices.
+	float verts[DT_VERTS_PER_POLYGON*3];	
+	float edged[DT_VERTS_PER_POLYGON];
+	float edget[DT_VERTS_PER_POLYGON];
+	int nv = 0;
+	for (int i = 0; i < (int)poly->vertCount; ++i)
+	{
+		dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
+		nv++;
+	}		
+	
+	bool inside = dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget);
+	if (inside)
+	{
+		// Point is inside the polygon, return the point.
+		dtVcopy(closest, pos);
+	}
+	else
+	{
+		// Point is outside the polygon, dtClamp to nearest edge.
+		float dmin = FLT_MAX;
+		int imin = -1;
+		for (int i = 0; i < nv; ++i)
+		{
+			if (edged[i] < dmin)
+			{
+				dmin = edged[i];
+				imin = i;
+			}
+		}
+		const float* va = &verts[imin*3];
+		const float* vb = &verts[((imin+1)%nv)*3];
+		dtVlerp(closest, va, vb, edget[imin]);
+	}
+	
+	return DT_SUCCESS;
+}
+
+
+dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* height) const
+{
+	dtAssert(m_nav);
+
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+	{
+		const float* v0 = &tile->verts[poly->verts[0]*3];
+		const float* v1 = &tile->verts[poly->verts[1]*3];
+		const float d0 = dtVdist(pos, v0);
+		const float d1 = dtVdist(pos, v1);
+		const float u = d0 / (d0+d1);
+		if (height)
+			*height = v0[1] + (v1[1] - v0[1]) * u;
+		return DT_SUCCESS;
+	}
+	else
+	{
+		const unsigned int ip = (unsigned int)(poly - tile->polys);
+		const dtPolyDetail* pd = &tile->detailMeshes[ip];
+		for (int j = 0; j < pd->triCount; ++j)
+		{
+			const unsigned char* t = &tile->detailTris[(pd->triBase+j)*4];
+			const float* v[3];
+			for (int k = 0; k < 3; ++k)
+			{
+				if (t[k] < poly->vertCount)
+					v[k] = &tile->verts[poly->verts[t[k]]*3];
+				else
+					v[k] = &tile->detailVerts[(pd->vertBase+(t[k]-poly->vertCount))*3];
+			}
+			float h;
+			if (dtClosestHeightPointTriangle(pos, v[0], v[1], v[2], h))
+			{
+				if (height)
+					*height = h;
+				return DT_SUCCESS;
+			}
+		}
+	}
+	
+	return DT_FAILURE;
+}
+
+dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* extents,
+										 const dtQueryFilter* filter,
+										 dtPolyRef* nearestRef, float* nearestPt) const
+{
+	dtAssert(m_nav);
+
+	*nearestRef = 0;
+	
+	// Get nearby polygons from proximity grid.
+	dtPolyRef polys[128];
+	int polyCount = 0;
+	if (queryPolygons(center, extents, filter, polys, &polyCount, 128) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	// Find nearest polygon amongst the nearby polygons.
+	dtPolyRef nearest = 0;
+	float nearestDistanceSqr = FLT_MAX;
+	for (int i = 0; i < polyCount; ++i)
+	{
+		dtPolyRef ref = polys[i];
+		float closestPtPoly[3];
+		if (closestPointOnPoly(ref, center, closestPtPoly) != DT_SUCCESS)
+			continue;
+		float d = dtVdistSqr(center, closestPtPoly);
+		if (d < nearestDistanceSqr)
+		{
+			if (nearestPt)
+				dtVcopy(nearestPt, closestPtPoly);
+			nearestDistanceSqr = d;
+			nearest = ref;
+		}
+	}
+	
+	if (nearestRef)
+		*nearestRef = nearest;
+	
+	return DT_SUCCESS;
+}
+
+dtPolyRef dtNavMeshQuery::findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents,
+												const dtQueryFilter* filter, float* nearestPt) const
+{
+	dtAssert(m_nav);
+	
+	float bmin[3], bmax[3];
+	dtVsub(bmin, center, extents);
+	dtVadd(bmax, center, extents);
+	
+	// Get nearby polygons from proximity grid.
+	dtPolyRef polys[128];
+	int polyCount = queryPolygonsInTile(tile, bmin, bmax, filter, polys, 128);
+	
+	// Find nearest polygon amongst the nearby polygons.
+	dtPolyRef nearest = 0;
+	float nearestDistanceSqr = FLT_MAX;
+	for (int i = 0; i < polyCount; ++i)
+	{
+		dtPolyRef ref = polys[i];
+		const dtPoly* poly = &tile->polys[m_nav->decodePolyIdPoly(ref)];
+		float closestPtPoly[3];
+		if (closestPointOnPolyInTile(tile, poly, center, closestPtPoly) != DT_SUCCESS)
+			continue;
+			
+		float d = dtVdistSqr(center, closestPtPoly);
+		if (d < nearestDistanceSqr)
+		{
+			if (nearestPt)
+				dtVcopy(nearestPt, closestPtPoly);
+			nearestDistanceSqr = d;
+			nearest = ref;
+		}
+	}
+	
+	return nearest;
+}
+
+int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+										const dtQueryFilter* filter,
+										dtPolyRef* polys, const int maxPolys) const
+{
+	dtAssert(m_nav);
+
+	if (tile->bvTree)
+	{
+		const dtBVNode* node = &tile->bvTree[0];
+		const dtBVNode* end = &tile->bvTree[tile->header->bvNodeCount];
+		const float* tbmin = tile->header->bmin;
+		const float* tbmax = tile->header->bmax;
+		const float qfac = tile->header->bvQuantFactor;
+		
+		// Calculate quantized box
+		unsigned short bmin[3], bmax[3];
+		// dtClamp query box to world box.
+		float minx = dtClamp(qmin[0], tbmin[0], tbmax[0]) - tbmin[0];
+		float miny = dtClamp(qmin[1], tbmin[1], tbmax[1]) - tbmin[1];
+		float minz = dtClamp(qmin[2], tbmin[2], tbmax[2]) - tbmin[2];
+		float maxx = dtClamp(qmax[0], tbmin[0], tbmax[0]) - tbmin[0];
+		float maxy = dtClamp(qmax[1], tbmin[1], tbmax[1]) - tbmin[1];
+		float maxz = dtClamp(qmax[2], tbmin[2], tbmax[2]) - tbmin[2];
+		// Quantize
+		bmin[0] = (unsigned short)(qfac * minx) & 0xfffe;
+		bmin[1] = (unsigned short)(qfac * miny) & 0xfffe;
+		bmin[2] = (unsigned short)(qfac * minz) & 0xfffe;
+		bmax[0] = (unsigned short)(qfac * maxx + 1) | 1;
+		bmax[1] = (unsigned short)(qfac * maxy + 1) | 1;
+		bmax[2] = (unsigned short)(qfac * maxz + 1) | 1;
+		
+		// Traverse tree
+		const dtPolyRef base = m_nav->getPolyRefBase(tile);
+		int n = 0;
+		while (node < end)
+		{
+			const bool overlap = dtOverlapQuantBounds(bmin, bmax, node->bmin, node->bmax);
+			const bool isLeafNode = node->i >= 0;
+			
+			if (isLeafNode && overlap)
+			{
+				dtPolyRef ref = base | (dtPolyRef)node->i;
+				if (filter->passFilter(ref, tile, &tile->polys[node->i]))
+				{
+					if (n < maxPolys)
+						polys[n++] = ref;
+				}
+			}
+			
+			if (overlap || isLeafNode)
+				node++;
+			else
+			{
+				const int escapeIndex = -node->i;
+				node += escapeIndex;
+			}
+		}
+		
+		return n;
+	}
+	else
+	{
+		float bmin[3], bmax[3];
+		int n = 0;
+		const dtPolyRef base = m_nav->getPolyRefBase(tile);
+		for (int i = 0; i < tile->header->polyCount; ++i)
+		{
+			// Calc polygon bounds.
+			dtPoly* p = &tile->polys[i];
+			const float* v = &tile->verts[p->verts[0]*3];
+			dtVcopy(bmin, v);
+			dtVcopy(bmax, v);
+			for (int j = 1; j < p->vertCount; ++j)
+			{
+				v = &tile->verts[p->verts[j]*3];
+				dtVmin(bmin, v);
+				dtVmax(bmax, v);
+			}
+			if (dtOverlapBounds(qmin,qmax, bmin,bmax))
+			{
+				const dtPolyRef ref = base | (dtPolyRef)i;
+				if (filter->passFilter(ref, tile, p))
+				{
+					if (n < maxPolys)
+						polys[n++] = ref;
+				}
+			}
+		}
+		return n;
+	}
+}
+
+dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents,
+									   const dtQueryFilter* filter,
+									   dtPolyRef* polys, int* polyCount, const int maxPolys) const
+{
+	dtAssert(m_nav);
+	
+	float bmin[3], bmax[3];
+	dtVsub(bmin, center, extents);
+	dtVadd(bmax, center, extents);
+	
+	// Find tiles the query touches.
+	int minx, miny, maxx, maxy;
+	m_nav->calcTileLoc(bmin, &minx, &miny);
+	m_nav->calcTileLoc(bmax, &maxx, &maxy);
+
+	int n = 0;
+	for (int y = miny; y <= maxy; ++y)
+	{
+		for (int x = minx; x <= maxx; ++x)
+		{
+			const dtMeshTile* tile = m_nav->getTileAt(x,y);
+			if (!tile) continue;
+			n += queryPolygonsInTile(tile, bmin, bmax, filter, polys+n, maxPolys-n);
+			if (n >= maxPolys)
+			{
+				*polyCount = n;
+				return DT_SUCCESS;
+			}
+		}
+	}
+	*polyCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
+								  const float* startPos, const float* endPos,
+								  const dtQueryFilter* filter,
+								  dtPolyRef* path, int* pathCount, const int maxPath) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_nodePool);
+	dtAssert(m_openList);
+	
+	*pathCount = 0;
+	
+	if (!startRef || !endRef)
+		return DT_FAILURE;
+	
+	if (!maxPath)
+		return DT_FAILURE;
+	
+	// Validate input
+	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
+		return DT_FAILURE;
+	
+	if (startRef == endRef)
+	{
+		path[0] = startRef;
+		*pathCount = 1;
+		return DT_SUCCESS;
+	}
+	
+	m_nodePool->clear();
+	m_openList->clear();
+	
+	dtNode* startNode = m_nodePool->getNode(startRef);
+	dtVcopy(startNode->pos, startPos);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = dtVdist(startPos, endPos) * H_SCALE;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_OPEN;
+	m_openList->push(startNode);
+	
+	dtNode* lastBestNode = startNode;
+	float lastBestNodeCost = startNode->total;
+	
+	while (!m_openList->empty())
+	{
+		// Remove node from open list and put it in closed list.
+		dtNode* bestNode = m_openList->pop();
+		bestNode->flags &= ~DT_NODE_OPEN;
+		bestNode->flags |= DT_NODE_CLOSED;
+		
+		// Reached the goal, stop searching.
+		if (bestNode->id == endRef)
+		{
+			lastBestNode = bestNode;
+			break;
+		}
+		
+		// Get current poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef bestRef = bestNode->id;
+		const dtMeshTile* bestTile = 0;
+		const dtPoly* bestPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
+		
+		// Get parent poly and tile.
+		dtPolyRef parentRef = 0;
+		const dtMeshTile* parentTile = 0;
+		const dtPoly* parentPoly = 0;
+		if (bestNode->pidx)
+			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
+		if (parentRef)
+			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
+		
+		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
+		{
+			dtPolyRef neighbourRef = bestTile->links[i].ref;
+			
+			// Skip invalid ids and do not expand back to where we came from.
+			if (!neighbourRef || neighbourRef == parentRef)
+				continue;
+			
+			// Get neighbour poly and tile.
+			// The API input has been cheked already, skip checking internal data.
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
+			
+			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+
+			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+			
+			// If the node is visited the first time, calculate node position.
+			if (neighbourNode->flags == 0)
+			{
+				getEdgeMidPoint(bestRef, bestPoly, bestTile,
+								neighbourRef, neighbourPoly, neighbourTile,
+								neighbourNode->pos);
+			}
+
+			// Calculate cost and heuristic.
+			float cost = 0;
+			float heuristic = 0;
+			
+			// Special case for last node.
+			if (neighbourRef == endRef)
+			{
+				// Cost
+				const float curCost = filter->getCost(bestNode->pos, neighbourNode->pos,
+													  parentRef, parentTile, parentPoly,
+													  bestRef, bestTile, bestPoly,
+													  neighbourRef, neighbourTile, neighbourPoly);
+				const float endCost = filter->getCost(neighbourNode->pos, endPos,
+													  bestRef, bestTile, bestPoly,
+													  neighbourRef, neighbourTile, neighbourPoly,
+													  0, 0, 0);
+				
+				cost = bestNode->cost + curCost + endCost;
+				heuristic = 0;
+			}
+			else
+			{
+				// Cost
+				const float curCost = filter->getCost(bestNode->pos, neighbourNode->pos,
+													  parentRef, parentTile, parentPoly,
+													  bestRef, bestTile, bestPoly,
+													  neighbourRef, neighbourTile, neighbourPoly);
+				cost = bestNode->cost + curCost;
+				heuristic = dtVdist(neighbourNode->pos, endPos)*H_SCALE;
+			}
+
+			const float total = cost + heuristic;
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			// The node is already visited and process, and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
+				continue;
+			
+			// Add or update the node.
+			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
+			neighbourNode->id = neighbourRef;
+			neighbourNode->flags &= ~DT_NODE_CLOSED;
+			neighbourNode->cost = cost;
+			neighbourNode->total = total;
+			
+			if (neighbourNode->flags & DT_NODE_OPEN)
+			{
+				// Already in open, update node location.
+				m_openList->modify(neighbourNode);
+			}
+			else
+			{
+				// Put the node in open list.
+				neighbourNode->flags |= DT_NODE_OPEN;
+				m_openList->push(neighbourNode);
+			}
+			
+			// Update nearest node to target so far.
+			if (heuristic < lastBestNodeCost)
+			{
+				lastBestNodeCost = heuristic;
+				lastBestNode = neighbourNode;
+			}
+		}
+	}
+	
+	// Reverse the path.
+	dtNode* prev = 0;
+	dtNode* node = lastBestNode;
+	do
+	{
+		dtNode* next = m_nodePool->getNodeAtIdx(node->pidx);
+		node->pidx = m_nodePool->getNodeIdx(prev);
+		prev = node;
+		node = next;
+	}
+	while (node);
+	
+	// Store path
+	node = prev;
+	int n = 0;
+	do
+	{
+		path[n++] = node->id;
+		node = m_nodePool->getNodeAtIdx(node->pidx);
+	}
+	while (node && n < maxPath);
+	
+	*pathCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
+											const float* startPos, const float* endPos,
+											const dtQueryFilter* filter)
+{
+	dtAssert(m_nav);
+	dtAssert(m_nodePool);
+	dtAssert(m_openList);
+
+	// Init path state.
+	memset(&m_query, 0, sizeof(dtQueryData));
+	m_query.status = DT_FAILURE;
+	m_query.startRef = startRef;
+	m_query.endRef = endRef;
+	dtVcopy(m_query.startPos, startPos);
+	dtVcopy(m_query.endPos, endPos);
+	m_query.filter = filter;
+	
+	if (!startRef || !endRef)
+		return DT_FAILURE;
+	
+	// Validate input
+	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
+		return DT_FAILURE;
+
+	if (startRef == endRef)
+	{
+		m_query.status = DT_SUCCESS;
+		return DT_SUCCESS;
+	}
+	
+	m_nodePool->clear();
+	m_openList->clear();
+	
+	dtNode* startNode = m_nodePool->getNode(startRef);
+	dtVcopy(startNode->pos, startPos);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = dtVdist(startPos, endPos) * H_SCALE;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_OPEN;
+	m_openList->push(startNode);
+	
+	m_query.status = DT_IN_PROGRESS;
+	m_query.lastBestNode = startNode;
+	m_query.lastBestNodeCost = startNode->total;
+	
+	return m_query.status;
+}
+	
+dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter)
+{
+	if (m_query.status!= DT_IN_PROGRESS)
+		return m_query.status;
+
+	// Make sure the request is still valid.
+	if (!m_nav->isValidPolyRef(m_query.startRef) || !m_nav->isValidPolyRef(m_query.endRef))
+	{
+		m_query.status = DT_FAILURE;
+		return DT_FAILURE;
+	}
+		
+	int iter = 0;
+	while (iter < maxIter && !m_openList->empty())
+	{
+		iter++;
+		
+		// Remove node from open list and put it in closed list.
+		dtNode* bestNode = m_openList->pop();
+		bestNode->flags &= ~DT_NODE_OPEN;
+		bestNode->flags |= DT_NODE_CLOSED;
+		
+		// Reached the goal, stop searching.
+		if (bestNode->id == m_query.endRef)
+		{
+			m_query.lastBestNode = bestNode;
+			m_query.status = DT_SUCCESS;
+			return m_query.status;
+		}
+		
+		// Get current poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef bestRef = bestNode->id;
+		const dtMeshTile* bestTile = 0;
+		const dtPoly* bestPoly = 0;
+		if (m_nav->getTileAndPolyByRef(bestRef, &bestTile, &bestPoly) != DT_SUCCESS)
+		{
+			// The polygon has disappeared during the sliced query, fail.
+			m_query.status = DT_FAILURE;
+			return m_query.status;
+		}
+		
+		// Get parent poly and tile.
+		dtPolyRef parentRef = 0;
+		const dtMeshTile* parentTile = 0;
+		const dtPoly* parentPoly = 0;
+		if (bestNode->pidx)
+			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
+		if (parentRef)
+		{
+			if (m_nav->getTileAndPolyByRef(parentRef, &parentTile, &parentPoly) != DT_SUCCESS)
+			{
+				// The polygon has disappeared during the sliced query, fail.
+				m_query.status = DT_FAILURE;
+				return m_query.status;
+			}
+		}
+		
+		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
+		{
+			dtPolyRef neighbourRef = bestTile->links[i].ref;
+			
+			// Skip invalid ids and do not expand back to where we came from.
+			if (!neighbourRef || neighbourRef == parentRef)
+				continue;
+			
+			// Get neighbour poly and tile.
+			// The API input has been cheked already, skip checking internal data.
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
+			
+			if (!m_query.filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+			
+			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+			
+			// If the node is visited the first time, calculate node position.
+			if (neighbourNode->flags == 0)
+			{
+				getEdgeMidPoint(bestRef, bestPoly, bestTile,
+								neighbourRef, neighbourPoly, neighbourTile,
+								neighbourNode->pos);
+			}
+			
+			// Calculate cost and heuristic.
+			float cost = 0;
+			float heuristic = 0;
+			
+			// Special case for last node.
+			if (neighbourRef == m_query.endRef)
+			{
+				// Cost
+				const float curCost = m_query.filter->getCost(bestNode->pos, neighbourNode->pos,
+															  parentRef, parentTile, parentPoly,
+															  bestRef, bestTile, bestPoly,
+															  neighbourRef, neighbourTile, neighbourPoly);
+				const float endCost = m_query.filter->getCost(neighbourNode->pos, m_query.endPos,
+															  bestRef, bestTile, bestPoly,
+															  neighbourRef, neighbourTile, neighbourPoly,
+															  0, 0, 0);
+				
+				cost = bestNode->cost + curCost + endCost;
+				heuristic = 0;
+			}
+			else
+			{
+				// Cost
+				const float curCost = m_query.filter->getCost(bestNode->pos, neighbourNode->pos,
+															  parentRef, parentTile, parentPoly,
+															  bestRef, bestTile, bestPoly,
+															  neighbourRef, neighbourTile, neighbourPoly);
+				cost = bestNode->cost + curCost;
+				heuristic = dtVdist(neighbourNode->pos, m_query.endPos)*H_SCALE;
+			}
+			
+			const float total = cost + heuristic;
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			// The node is already visited and process, and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
+				continue;
+			
+			// Add or update the node.
+			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
+			neighbourNode->id = neighbourRef;
+			neighbourNode->flags &= ~DT_NODE_CLOSED;
+			neighbourNode->cost = cost;
+			neighbourNode->total = total;
+			
+			if (neighbourNode->flags & DT_NODE_OPEN)
+			{
+				// Already in open, update node location.
+				m_openList->modify(neighbourNode);
+			}
+			else
+			{
+				// Put the node in open list.
+				neighbourNode->flags |= DT_NODE_OPEN;
+				m_openList->push(neighbourNode);
+			}
+			
+			// Update nearest node to target so far.
+			if (heuristic < m_query.lastBestNodeCost)
+			{
+				m_query.lastBestNodeCost = heuristic;
+				m_query.lastBestNode = neighbourNode;
+			}
+		}
+	}
+	
+	// Exhausted all nodes, but could not find path.
+	if (m_openList->empty())
+		m_query.status = DT_SUCCESS;
+
+	return m_query.status;
+}
+
+dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath)
+{
+	*pathCount = 0;
+	
+	if (m_query.status != DT_SUCCESS)
+	{
+		// Reset query.
+		memset(&m_query, 0, sizeof(dtQueryData));
+		return DT_FAILURE;
+	}
+
+	int n = 0;
+
+	if (m_query.startRef == m_query.endRef)
+	{
+		// Special case: the search starts and ends at same poly.
+		path[n++] = m_query.startRef;
+	}
+	else
+	{
+		// Reverse the path.
+		dtAssert(m_query.lastBestNode);
+		dtNode* prev = 0;
+		dtNode* node = m_query.lastBestNode;
+		do
+		{
+			dtNode* next = m_nodePool->getNodeAtIdx(node->pidx);
+			node->pidx = m_nodePool->getNodeIdx(prev);
+			prev = node;
+			node = next;
+		}
+		while (node);
+		
+		// Store path
+		node = prev;
+		do
+		{
+			path[n++] = node->id;
+			node = m_nodePool->getNodeAtIdx(node->pidx);
+		}
+		while (node && n < maxPath);
+	}
+	
+	// Reset query.
+	memset(&m_query, 0, sizeof(dtQueryData));
+	
+	*pathCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
+													   dtPolyRef* path, int* pathCount, const int maxPath)
+{
+	*pathCount = 0;
+	
+	if (existingSize == 0)
+	{
+		return DT_FAILURE;
+	}
+	
+	if (m_query.status != DT_SUCCESS && m_query.status != DT_IN_PROGRESS)
+	{
+		// Reset query.
+		memset(&m_query, 0, sizeof(dtQueryData));
+		return DT_FAILURE;
+	}
+	
+	int n = 0;
+	
+	if (m_query.startRef == m_query.endRef)
+	{
+		// Special case: the search starts and ends at same poly.
+		path[n++] = m_query.startRef;
+	}
+	else
+	{
+		// Find furthest existing node that was visited.
+		dtNode* prev = 0;
+		dtNode* node = 0;
+		for (int i = existingSize-1; i >= 0; --i)
+		{
+			node = m_nodePool->findNode(existing[i]);
+			if (node)
+				break;
+		}
+		
+		if (!node)
+		{
+			return DT_FAILURE;
+		}
+		
+		// Reverse the path.
+		do
+		{
+			dtNode* next = m_nodePool->getNodeAtIdx(node->pidx);
+			node->pidx = m_nodePool->getNodeIdx(prev);
+			prev = node;
+			node = next;
+		}
+		while (node);
+		
+		// Store path
+		node = prev;
+		do
+		{
+			path[n++] = node->id;
+			node = m_nodePool->getNodeAtIdx(node->pidx);
+		}
+		while (node && n < maxPath);
+	}
+	
+	// Reset query.
+	memset(&m_query, 0, sizeof(dtQueryData));
+	
+	*pathCount = n;
+	
+	return DT_SUCCESS;
+}
+
+
+dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* endPos,
+										  const dtPolyRef* path, const int pathSize,
+										  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
+										  int* straightPathCount, const int maxStraightPath) const
+{
+	dtAssert(m_nav);
+	
+	*straightPathCount = 0;
+	
+	if (!maxStraightPath)
+		return DT_FAILURE;
+	
+	if (!path[0])
+		return DT_FAILURE;
+	
+	int n = 0;
+	
+	// TODO: Should this be callers responsibility?
+	float closestStartPos[3];
+	if (closestPointOnPolyBoundary(path[0], startPos, closestStartPos) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	// Add start point.
+	dtVcopy(&straightPath[n*3], closestStartPos);
+	if (straightPathFlags)
+		straightPathFlags[n] = DT_STRAIGHTPATH_START;
+	if (straightPathRefs)
+		straightPathRefs[n] = path[0];
+	n++;
+	if (n >= maxStraightPath)
+	{
+		*straightPathCount = n;
+		return DT_SUCCESS;
+	}
+	
+	float closestEndPos[3];
+	if (closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	if (pathSize > 1)
+	{
+		float portalApex[3], portalLeft[3], portalRight[3];
+		dtVcopy(portalApex, closestStartPos);
+		dtVcopy(portalLeft, portalApex);
+		dtVcopy(portalRight, portalApex);
+		int apexIndex = 0;
+		int leftIndex = 0;
+		int rightIndex = 0;
+		
+		unsigned char leftPolyType = 0;
+		unsigned char rightPolyType = 0;
+		
+		dtPolyRef leftPolyRef = path[0];
+		dtPolyRef rightPolyRef = path[0];
+		
+		for (int i = 0; i < pathSize; ++i)
+		{
+			float left[3], right[3];
+			unsigned char fromType, toType;
+			
+			if (i+1 < pathSize)
+			{
+				// Next portal.
+				if (getPortalPoints(path[i], path[i+1], left, right, fromType, toType) != DT_SUCCESS)
+				{
+					if (closestPointOnPolyBoundary(path[i], endPos, closestEndPos) != DT_SUCCESS)
+						return DT_FAILURE;
+					
+					dtVcopy(&straightPath[n*3], closestEndPos);
+					if (straightPathFlags)
+						straightPathFlags[n] = 0;
+					if (straightPathRefs)
+						straightPathRefs[n] = path[i];
+					n++;
+					
+					return DT_SUCCESS;
+				}
+				
+				// If starting really close the portal, advance.
+				if (i == 0)
+				{
+					float t;
+					if (dtDistancePtSegSqr2D(portalApex, left, right, t) < dtSqr(0.001f))
+						continue;
+				}
+			}
+			else
+			{
+				// End of the path.
+				dtVcopy(left, closestEndPos);
+				dtVcopy(right, closestEndPos);
+				
+				fromType = toType = DT_POLYTYPE_GROUND;
+			}
+			
+			// Right vertex.
+			if (dtTriArea2D(portalApex, portalRight, right) <= 0.0f)
+			{
+				if (dtVequal(portalApex, portalRight) || dtTriArea2D(portalApex, portalLeft, right) > 0.0f)
+				{
+					dtVcopy(portalRight, right);
+					rightPolyRef = (i+1 < pathSize) ? path[i+1] : 0;
+					rightPolyType = toType;
+					rightIndex = i;
+				}
+				else
+				{
+					dtVcopy(portalApex, portalLeft);
+					apexIndex = leftIndex;
+					
+					unsigned char flags = 0;
+					if (!leftPolyRef)
+						flags = DT_STRAIGHTPATH_END;
+					else if (leftPolyType == DT_POLYTYPE_OFFMESH_CONNECTION)
+						flags = DT_STRAIGHTPATH_OFFMESH_CONNECTION;
+					dtPolyRef ref = leftPolyRef;
+					
+					if (!dtVequal(&straightPath[(n-1)*3], portalApex))
+					{
+						// Append new vertex.
+						dtVcopy(&straightPath[n*3], portalApex);
+						if (straightPathFlags)
+							straightPathFlags[n] = flags;
+						if (straightPathRefs)
+							straightPathRefs[n] = ref;
+						n++;
+						// If reached end of path or there is no space to append more vertices, return.
+						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
+						{
+							*straightPathCount = n;
+							return DT_SUCCESS;
+						}
+					}
+					else
+					{
+						// The vertices are equal, update flags and poly.
+						if (straightPathFlags)
+							straightPathFlags[n-1] = flags;
+						if (straightPathRefs)
+							straightPathRefs[n-1] = ref;
+					}
+					
+					dtVcopy(portalLeft, portalApex);
+					dtVcopy(portalRight, portalApex);
+					leftIndex = apexIndex;
+					rightIndex = apexIndex;
+					
+					// Restart
+					i = apexIndex;
+					
+					continue;
+				}
+			}
+			
+			// Left vertex.
+			if (dtTriArea2D(portalApex, portalLeft, left) >= 0.0f)
+			{
+				if (dtVequal(portalApex, portalLeft) || dtTriArea2D(portalApex, portalRight, left) < 0.0f)
+				{
+					dtVcopy(portalLeft, left);
+					leftPolyRef = (i+1 < pathSize) ? path[i+1] : 0;
+					leftPolyType = toType;
+					leftIndex = i;
+				}
+				else
+				{
+					dtVcopy(portalApex, portalRight);
+					apexIndex = rightIndex;
+					
+					unsigned char flags = 0;
+					if (!rightPolyRef)
+						flags = DT_STRAIGHTPATH_END;
+					else if (rightPolyType == DT_POLYTYPE_OFFMESH_CONNECTION)
+						flags = DT_STRAIGHTPATH_OFFMESH_CONNECTION;
+					dtPolyRef ref = rightPolyRef;
+					
+					if (!dtVequal(&straightPath[(n-1)*3], portalApex))
+					{
+						// Append new vertex.
+						dtVcopy(&straightPath[n*3], portalApex);
+						if (straightPathFlags)
+							straightPathFlags[n] = flags;
+						if (straightPathRefs)
+							straightPathRefs[n] = ref;
+						n++;
+						// If reached end of path or there is no space to append more vertices, return.
+						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
+						{
+							*straightPathCount = n;
+							return DT_SUCCESS;
+						}
+					}
+					else
+					{
+						// The vertices are equal, update flags and poly.
+						if (straightPathFlags)
+							straightPathFlags[n-1] = flags;
+						if (straightPathRefs)
+							straightPathRefs[n-1] = ref;
+					}
+					
+					dtVcopy(portalLeft, portalApex);
+					dtVcopy(portalRight, portalApex);
+					leftIndex = apexIndex;
+					rightIndex = apexIndex;
+					
+					// Restart
+					i = apexIndex;
+					
+					continue;
+				}
+			}
+		}
+	}
+	
+	// If the point already exists, remove it and add reappend the actual end location.  
+	if (n > 0 && dtVequal(&straightPath[(n-1)*3], closestEndPos))
+		n--;
+	
+	// Add end point.
+	if (n < maxStraightPath)
+	{
+		dtVcopy(&straightPath[n*3], closestEndPos);
+		if (straightPathFlags)
+			straightPathFlags[n] = DT_STRAIGHTPATH_END;
+		if (straightPathRefs)
+			straightPathRefs[n] = 0;
+		n++;
+	}
+	
+	*straightPathCount = n;
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
+										  const dtQueryFilter* filter,
+										  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_tinyNodePool);
+
+	*visitedCount = 0;
+	
+	// Validate input
+	if (!startRef) return DT_FAILURE;
+	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	
+	static const int MAX_STACK = 48;
+	dtNode* stack[MAX_STACK];
+	int nstack = 0;
+	
+	m_tinyNodePool->clear();
+	
+	dtNode* startNode = m_tinyNodePool->getNode(startRef);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = 0;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_CLOSED;
+	stack[nstack++] = startNode;
+	
+	float bestPos[3];
+	float bestDist = FLT_MAX;
+	dtNode* bestNode = 0;
+	dtVcopy(bestPos, startPos);
+	
+	// Search constraints
+	float searchPos[3], searchRadSqr;
+	dtVlerp(searchPos, startPos, endPos, 0.5f);
+	searchRadSqr = dtSqr(dtVdist(startPos, endPos)/2.0f + 0.001f);
+	
+	float verts[DT_VERTS_PER_POLYGON*3];
+	
+	while (nstack)
+	{
+		// Pop front.
+		dtNode* curNode = stack[0];
+		for (int i = 0; i < nstack-1; ++i)
+			stack[i] = stack[i+1];
+		nstack--;
+		
+		// Get poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef curRef = curNode->id;
+		const dtMeshTile* curTile = 0;
+		const dtPoly* curPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);			
+		
+		// Collect vertices.
+		const int nverts = curPoly->vertCount;
+		for (int i = 0; i < nverts; ++i)
+			dtVcopy(&verts[i*3], &curTile->verts[curPoly->verts[i]*3]);
+		
+		// If target is inside the poly, stop search.
+		if (dtPointInPolygon(endPos, verts, nverts))
+		{
+			bestNode = curNode;
+			dtVcopy(bestPos, endPos);
+			break;
+		}
+		
+		// Find wall edges and find nearest point inside the walls.
+		for (int i = 0, j = (int)curPoly->vertCount-1; i < (int)curPoly->vertCount; j = i++)
+		{
+			// Find links to neighbours.
+			static const int MAX_NEIS = 8;
+			int nneis = 0;
+			dtPolyRef neis[MAX_NEIS];
+			
+			if (curPoly->neis[j] & DT_EXT_LINK)
+			{
+				// Tile border.
+				for (unsigned int k = curPoly->firstLink; k != DT_NULL_LINK; k = curTile->links[k].next)
+				{
+					const dtLink* link = &curTile->links[k];
+					if (link->edge == j)
+					{
+						if (link->ref != 0)
+						{
+							const dtMeshTile* neiTile = 0;
+							const dtPoly* neiPoly = 0;
+							m_nav->getTileAndPolyByRefUnsafe(link->ref, &neiTile, &neiPoly);
+							if (filter->passFilter(link->ref, neiTile, neiPoly))
+							{
+								if (nneis < MAX_NEIS)
+									neis[nneis++] = link->ref;
+							}
+						}
+					}
+				}
+			}
+			else if (curPoly->neis[j])
+			{
+				const unsigned int idx = (unsigned int)(curPoly->neis[j]-1);
+				const dtPolyRef ref = m_nav->getPolyRefBase(curTile) | idx;
+				if (filter->passFilter(ref, curTile, &curTile->polys[idx]))
+				{
+					// Internal edge, encode id.
+					neis[nneis++] = ref;
+				}
+			}
+			
+			if (!nneis)
+			{
+				// Wall edge, calc distance.
+				const float* vj = &verts[j*3];
+				const float* vi = &verts[i*3];
+				float tseg;
+				const float distSqr = dtDistancePtSegSqr2D(endPos, vj, vi, tseg);
+				if (distSqr < bestDist)
+				{
+                    // Update nearest distance.
+					dtVlerp(bestPos, vj,vi, tseg);
+					bestDist = distSqr;
+					bestNode = curNode;
+				}
+			}
+			else
+			{
+				for (int k = 0; k < nneis; ++k)
+				{
+					// Skip if no node can be allocated.
+					dtNode* neighbourNode = m_tinyNodePool->getNode(neis[k]);
+					if (!neighbourNode)
+						continue;
+					// Skip if already visited.
+					if (neighbourNode->flags & DT_NODE_CLOSED)
+						continue;
+					
+					// Skip the link if it is too far from search constraint.
+					// TODO: Maybe should use getPortalPoints(), but this one is way faster.
+					const float* vj = &verts[j*3];
+					const float* vi = &verts[i*3];
+					float tseg;
+					float distSqr = dtDistancePtSegSqr2D(searchPos, vj, vi, tseg);
+					if (distSqr > searchRadSqr)
+						continue;
+					
+					// Mark as the node as visited and push to queue.
+					if (nstack < MAX_STACK)
+					{
+						neighbourNode->pidx = m_tinyNodePool->getNodeIdx(curNode);
+						neighbourNode->flags |= DT_NODE_CLOSED;
+						stack[nstack++] = neighbourNode;
+					}
+				}
+			}
+		}
+	}
+	
+	int n = 0;
+	if (bestNode)
+	{
+		// Reverse the path.
+		dtNode* prev = 0;
+		dtNode* node = bestNode;
+		do
+		{
+			dtNode* next = m_tinyNodePool->getNodeAtIdx(node->pidx);
+			node->pidx = m_tinyNodePool->getNodeIdx(prev);
+			prev = node;
+			node = next;
+		}
+		while (node);
+		
+		// Store result
+		node = prev;
+		do
+		{
+			visited[n++] = node->id;
+			node = m_tinyNodePool->getNodeAtIdx(node->pidx);
+		}
+		while (node && n < maxVisitedSize);
+	}
+	
+	dtVcopy(resultPos, bestPos);
+	
+	*visitedCount = n;
+	
+	return DT_SUCCESS;
+}
+
+
+dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, dtPolyRef to, float* left, float* right,
+										 unsigned char& fromType, unsigned char& toType) const
+{
+	dtAssert(m_nav);
+	
+	const dtMeshTile* fromTile = 0;
+	const dtPoly* fromPoly = 0;
+	if (m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly) != DT_SUCCESS)
+		return DT_FAILURE;
+	fromType = fromPoly->getType();
+
+	const dtMeshTile* toTile = 0;
+	const dtPoly* toPoly = 0;
+	if (m_nav->getTileAndPolyByRef(to, &toTile, &toPoly) != DT_SUCCESS)
+		return DT_FAILURE;
+	toType = toPoly->getType();
+		
+	return getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right);
+}
+
+// Returns portal points between two polygons.
+dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
+										 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
+										 float* left, float* right) const
+{
+	// Find the link that points to the 'to' polygon.
+	const dtLink* link = 0;
+	for (unsigned int i = fromPoly->firstLink; i != DT_NULL_LINK; i = fromTile->links[i].next)
+	{
+		if (fromTile->links[i].ref == to)
+		{
+			link = &fromTile->links[i];
+			break;
+		}
+	}
+	if (!link)
+		return DT_FAILURE;
+	
+	// Handle off-mesh connections.
+	if (fromPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+	{
+		// Find link that points to first vertex.
+		for (unsigned int i = fromPoly->firstLink; i != DT_NULL_LINK; i = fromTile->links[i].next)
+		{
+			if (fromTile->links[i].ref == to)
+			{
+				const int v = fromTile->links[i].edge;
+				dtVcopy(left, &fromTile->verts[fromPoly->verts[v]*3]);
+				dtVcopy(right, &fromTile->verts[fromPoly->verts[v]*3]);
+				return DT_SUCCESS;
+			}
+		}
+		return DT_FAILURE;
+	}
+	
+	if (toPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+	{
+		for (unsigned int i = toPoly->firstLink; i != DT_NULL_LINK; i = toTile->links[i].next)
+		{
+			if (toTile->links[i].ref == from)
+			{
+				const int v = toTile->links[i].edge;
+				dtVcopy(left, &toTile->verts[toPoly->verts[v]*3]);
+				dtVcopy(right, &toTile->verts[toPoly->verts[v]*3]);
+				return DT_SUCCESS;
+			}
+		}
+		return DT_FAILURE;
+	}
+	
+	// Find portal vertices.
+	const int v0 = fromPoly->verts[link->edge];
+	const int v1 = fromPoly->verts[(link->edge+1) % (int)fromPoly->vertCount];
+	dtVcopy(left, &fromTile->verts[v0*3]);
+	dtVcopy(right, &fromTile->verts[v1*3]);
+	
+	// If the link is at tile boundary, dtClamp the vertices to
+	// the link width.
+	if (link->side != 0xff)
+	{
+		// Unpack portal limits.
+		if (link->bmin != 0 || link->bmax != 255)
+		{
+			const float s = 1.0f/255.0f;
+			const float tmin = link->bmin*s;
+			const float tmax = link->bmax*s;
+			dtVlerp(left, &fromTile->verts[v0*3], &fromTile->verts[v1*3], tmin);
+			dtVlerp(right, &fromTile->verts[v0*3], &fromTile->verts[v1*3], tmax);
+		}
+	}
+	
+	return DT_SUCCESS;
+}
+
+// Returns edge mid point between two polygons.
+dtStatus dtNavMeshQuery::getEdgeMidPoint(dtPolyRef from, dtPolyRef to, float* mid) const
+{
+	float left[3], right[3];
+	unsigned char fromType, toType;
+	if (!getPortalPoints(from, to, left,right, fromType, toType)) return DT_FAILURE;
+	mid[0] = (left[0]+right[0])*0.5f;
+	mid[1] = (left[1]+right[1])*0.5f;
+	mid[2] = (left[2]+right[2])*0.5f;
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
+										 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
+										 float* mid) const
+{
+	float left[3], right[3];
+	if (getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right) != DT_SUCCESS)
+		return DT_FAILURE;
+	mid[0] = (left[0]+right[0])*0.5f;
+	mid[1] = (left[1]+right[1])*0.5f;
+	mid[2] = (left[2]+right[2])*0.5f;
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
+								 const dtQueryFilter* filter,
+								 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const
+{
+	dtAssert(m_nav);
+	
+	*t = 0;
+	if (pathCount)
+		*pathCount = 0;
+	
+	// Validate input
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE;
+	
+	dtPolyRef curRef = startRef;
+	float verts[DT_VERTS_PER_POLYGON*3];	
+	int n = 0;
+	
+	hitNormal[0] = 0;
+	hitNormal[1] = 0;
+	hitNormal[2] = 0;
+	
+	while (curRef)
+	{
+		// Cast ray against current polygon.
+		
+		// The API input has been cheked already, skip checking internal data.
+		const dtMeshTile* tile = 0;
+		const dtPoly* poly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(curRef, &tile, &poly);
+		
+		// Collect vertices.
+		int nv = 0;
+		for (int i = 0; i < (int)poly->vertCount; ++i)
+		{
+			dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
+			nv++;
+		}		
+		
+		float tmin, tmax;
+		int segMin, segMax;
+		if (!dtIntersectSegmentPoly2D(startPos, endPos, verts, nv, tmin, tmax, segMin, segMax))
+		{
+			// Could not hit the polygon, keep the old t and report hit.
+			if (pathCount)
+				*pathCount = n;
+			return DT_SUCCESS;
+		}
+		// Keep track of furthest t so far.
+		if (tmax > *t)
+			*t = tmax;
+		
+		// Store visited polygons.
+		if (n < maxPath)
+			path[n++] = curRef;
+		
+		// Ray end is completely inside the polygon.
+		if (segMax == -1)
+		{
+			*t = FLT_MAX;
+			if (pathCount)
+				*pathCount = n;
+			return DT_SUCCESS;
+		}
+		
+		// Follow neighbours.
+		dtPolyRef nextRef = 0;
+		
+		for (unsigned int i = poly->firstLink; i != DT_NULL_LINK; i = tile->links[i].next)
+		{
+			const dtLink* link = &tile->links[i];
+			
+			// Find link which contains this edge.
+			if ((int)link->edge != segMax)
+				continue;
+			
+			// Get pointer to the next polygon.
+			const dtMeshTile* nextTile = 0;
+			const dtPoly* nextPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(link->ref, &nextTile, &nextPoly);
+			
+			// Skip off-mesh connections.
+			if (nextPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+				continue;
+			
+			// Skip links based on filter.
+			if (!filter->passFilter(link->ref, nextTile, nextPoly))
+				continue;
+			
+			// If the link is internal, just return the ref.
+			if (link->side == 0xff)
+			{
+				nextRef = link->ref;
+				break;
+			}
+			
+			// If the link is at tile boundary,
+			
+			// Check if the link spans the whole edge, and accept.
+			if (link->bmin == 0 && link->bmax == 255)
+			{
+				nextRef = link->ref;
+				break;
+			}
+			
+			// Check for partial edge links.
+			const int v0 = poly->verts[link->edge];
+			const int v1 = poly->verts[(link->edge+1) % poly->vertCount];
+			const float* left = &tile->verts[v0*3];
+			const float* right = &tile->verts[v1*3];
+			
+			// Check that the intersection lies inside the link portal.
+			if (link->side == 0 || link->side == 4)
+			{
+				// Calculate link size.
+				const float s = 1.0f/255.0f;
+				float lmin = left[2] + (right[2] - left[2])*(link->bmin*s);
+				float lmax = left[2] + (right[2] - left[2])*(link->bmax*s);
+				if (lmin > lmax) dtSwap(lmin, lmax);
+				
+				// Find Z intersection.
+				float z = startPos[2] + (endPos[2]-startPos[2])*tmax;
+				if (z >= lmin && z <= lmax)
+				{
+					nextRef = link->ref;
+					break;
+				}
+			}
+			else if (link->side == 2 || link->side == 6)
+			{
+				// Calculate link size.
+				const float s = 1.0f/255.0f;
+				float lmin = left[0] + (right[0] - left[0])*(link->bmin*s);
+				float lmax = left[0] + (right[0] - left[0])*(link->bmax*s);
+				if (lmin > lmax) dtSwap(lmin, lmax);
+				
+				// Find X intersection.
+				float x = startPos[0] + (endPos[0]-startPos[0])*tmax;
+				if (x >= lmin && x <= lmax)
+				{
+					nextRef = link->ref;
+					break;
+				}
+			}
+		}
+		
+		if (!nextRef)
+		{
+			// No neighbour, we hit a wall.
+			
+			// Calculate hit normal.
+			const int a = segMax;
+			const int b = segMax+1 < nv ? segMax+1 : 0;
+			const float* va = &verts[a*3];
+			const float* vb = &verts[b*3];
+			const float dx = vb[0] - va[0];
+			const float dz = vb[2] - va[2];
+			hitNormal[0] = dz;
+			hitNormal[1] = 0;
+			hitNormal[2] = -dx;
+			dtVnormalize(hitNormal);
+			
+			if (pathCount)
+				*pathCount = n;
+			return DT_SUCCESS;
+		}
+		
+		// No hit, advance to neighbour polygon.
+		curRef = nextRef;
+	}
+	
+	if (pathCount)
+		*pathCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
+											   const dtQueryFilter* filter,
+											   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
+											   int* resultCount, const int maxResult) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_nodePool);
+	dtAssert(m_openList);
+
+	*resultCount = 0;
+	
+	// Validate input
+	if (!startRef) return DT_FAILURE;
+	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	
+	m_nodePool->clear();
+	m_openList->clear();
+	
+	dtNode* startNode = m_nodePool->getNode(startRef);
+	dtVcopy(startNode->pos, centerPos);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = 0;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_OPEN;
+	m_openList->push(startNode);
+	
+	int n = 0;
+	if (n < maxResult)
+	{
+		if (resultRef)
+			resultRef[n] = startNode->id;
+		if (resultParent)
+			resultParent[n] = 0;
+		if (resultCost)
+			resultCost[n] = 0;
+		++n;
+	}
+	
+	const float radiusSqr = dtSqr(radius);
+	
+	while (!m_openList->empty())
+	{
+		dtNode* bestNode = m_openList->pop();
+		bestNode->flags &= ~DT_NODE_OPEN;
+		bestNode->flags |= DT_NODE_CLOSED;
+		
+		// Get poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef bestRef = bestNode->id;
+		const dtMeshTile* bestTile = 0;
+		const dtPoly* bestPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
+		
+		// Get parent poly and tile.
+		dtPolyRef parentRef = 0;
+		const dtMeshTile* parentTile = 0;
+		const dtPoly* parentPoly = 0;
+		if (bestNode->pidx)
+			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
+		if (parentRef)
+			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
+		
+		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
+		{
+			const dtLink* link = &bestTile->links[i];
+			dtPolyRef neighbourRef = link->ref;
+			// Skip invalid neighbours and do not follow back to parent.
+			if (!neighbourRef || neighbourRef == parentRef)
+				continue;
+			
+			// Expand to neighbour
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+		
+			// Do not advance if the polygon is excluded by the filter.
+			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+			
+			// Find edge and calc distance to the edge.
+			float va[3], vb[3];
+			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
+				continue;
+			
+			// If the circle is not touching the next polygon, skip it.
+			float tseg;
+			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
+			if (distSqr > radiusSqr)
+				continue;
+			
+			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+				
+			if (neighbourNode->flags & DT_NODE_CLOSED)
+				continue;
+			
+			// Cost
+			if (neighbourNode->flags == 0)
+				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
+			
+			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			
+			neighbourNode->id = neighbourRef;
+			neighbourNode->flags &= ~DT_NODE_CLOSED;
+			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
+			neighbourNode->total = total;
+			
+			if (neighbourNode->flags & DT_NODE_OPEN)
+			{
+				m_openList->modify(neighbourNode);
+			}
+			else
+			{
+				if (n < maxResult)
+				{
+					if (resultRef)
+						resultRef[n] = neighbourNode->id;
+					if (resultParent)
+						resultParent[n] = m_nodePool->getNodeAtIdx(neighbourNode->pidx)->id;
+					if (resultCost)
+						resultCost[n] = neighbourNode->total;
+					++n;
+				}
+				neighbourNode->flags = DT_NODE_OPEN;
+				m_openList->push(neighbourNode);
+			}
+		}
+	}
+	
+	*resultCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
+											  const dtQueryFilter* filter,
+											  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
+											  int* resultCount, const int maxResult) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_nodePool);
+	dtAssert(m_openList);
+	
+	*resultCount = 0;
+	
+	// Validate input
+	if (!startRef) return DT_FAILURE;
+	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	
+	m_nodePool->clear();
+	m_openList->clear();
+	
+	float centerPos[3] = {0,0,0};
+	for (int i = 0; i < nverts; ++i)
+		dtVadd(centerPos,centerPos,&verts[i*3]);
+	dtVscale(centerPos,centerPos,1.0f/nverts);
+
+	dtNode* startNode = m_nodePool->getNode(startRef);
+	dtVcopy(startNode->pos, centerPos);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = 0;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_OPEN;
+	m_openList->push(startNode);
+	
+	int n = 0;
+	if (n < maxResult)
+	{
+		if (resultRef)
+			resultRef[n] = startNode->id;
+		if (resultParent)
+			resultParent[n] = 0;
+		if (resultCost)
+			resultCost[n] = 0;
+		++n;
+	}
+	
+	while (!m_openList->empty())
+	{
+		dtNode* bestNode = m_openList->pop();
+		bestNode->flags &= ~DT_NODE_OPEN;
+		bestNode->flags |= DT_NODE_CLOSED;
+		
+		// Get poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef bestRef = bestNode->id;
+		const dtMeshTile* bestTile = 0;
+		const dtPoly* bestPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
+		
+		// Get parent poly and tile.
+		dtPolyRef parentRef = 0;
+		const dtMeshTile* parentTile = 0;
+		const dtPoly* parentPoly = 0;
+		if (bestNode->pidx)
+			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
+		if (parentRef)
+			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
+		
+		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
+		{
+			const dtLink* link = &bestTile->links[i];
+			dtPolyRef neighbourRef = link->ref;
+			// Skip invalid neighbours and do not follow back to parent.
+			if (!neighbourRef || neighbourRef == parentRef)
+				continue;
+			
+			// Expand to neighbour
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+			
+			// Do not advance if the polygon is excluded by the filter.
+			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+			
+			// Find edge and calc distance to the edge.
+			float va[3], vb[3];
+			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
+				continue;
+			
+			// If the poly is not touching the edge to the next polygon, skip the connection it.
+			float tmin, tmax;
+			int segMin, segMax;
+			if (!dtIntersectSegmentPoly2D(va, vb, verts, nverts, tmin, tmax, segMin, segMax))
+				continue;
+			if (tmin > 1.0f || tmax < 0.0f)
+				continue;
+			
+			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+			
+			if (neighbourNode->flags & DT_NODE_CLOSED)
+				continue;
+			
+			// Cost
+			if (neighbourNode->flags == 0)
+				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
+			
+			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			
+			neighbourNode->id = neighbourRef;
+			neighbourNode->flags &= ~DT_NODE_CLOSED;
+			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
+			neighbourNode->total = total;
+			
+			if (neighbourNode->flags & DT_NODE_OPEN)
+			{
+				m_openList->modify(neighbourNode);
+			}
+			else
+			{
+				if (n < maxResult)
+				{
+					if (resultRef)
+						resultRef[n] = neighbourNode->id;
+					if (resultParent)
+						resultParent[n] = m_nodePool->getNodeAtIdx(neighbourNode->pidx)->id;
+					if (resultCost)
+						resultCost[n] = neighbourNode->total;
+					++n;
+				}
+				neighbourNode->flags = DT_NODE_OPEN;
+				m_openList->push(neighbourNode);
+			}
+		}
+	}
+	
+	*resultCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
+												const dtQueryFilter* filter,
+												dtPolyRef* resultRef, dtPolyRef* resultParent,
+												int* resultCount, const int maxResult) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_tinyNodePool);
+	
+	*resultCount = 0;
+
+	// Validate input
+	if (!startRef) return DT_FAILURE;
+	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	
+	static const int MAX_STACK = 48;
+	dtNode* stack[MAX_STACK];
+	int nstack = 0;
+	
+	m_tinyNodePool->clear();
+	
+	dtNode* startNode = m_tinyNodePool->getNode(startRef);
+	startNode->pidx = 0;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_CLOSED;
+	stack[nstack++] = startNode;
+	
+	const float radiusSqr = dtSqr(radius);
+	
+	float pa[DT_VERTS_PER_POLYGON*3];
+	float pb[DT_VERTS_PER_POLYGON*3];
+	
+	int n = 0;
+	if (n < maxResult)
+	{
+		resultRef[n] = startNode->id;
+		if (resultParent)
+			resultParent[n] = 0;
+		++n;
+	}
+	
+	while (nstack)
+	{
+		// Pop front.
+		dtNode* curNode = stack[0];
+		for (int i = 0; i < nstack-1; ++i)
+			stack[i] = stack[i+1];
+		nstack--;
+		
+		// Get poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef curRef = curNode->id;
+		const dtMeshTile* curTile = 0;
+		const dtPoly* curPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);
+		
+		for (unsigned int i = curPoly->firstLink; i != DT_NULL_LINK; i = curTile->links[i].next)
+		{
+			const dtLink* link = &curTile->links[i];
+			dtPolyRef neighbourRef = link->ref;
+			// Skip invalid neighbours.
+			if (!neighbourRef)
+				continue;
+			
+			// Skip if cannot alloca more nodes.
+			dtNode* neighbourNode = m_tinyNodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+			// Skip visited.
+			if (neighbourNode->flags & DT_NODE_CLOSED)
+				continue;
+			
+			// Expand to neighbour
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+			
+			// Skip off-mesh connections.
+			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+				continue;
+			
+			// Do not advance if the polygon is excluded by the filter.
+			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+			
+			// Find edge and calc distance to the edge.
+			float va[3], vb[3];
+			if (!getPortalPoints(curRef, curPoly, curTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
+				continue;
+			
+			// If the circle is not touching the next polygon, skip it.
+			float tseg;
+			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
+			if (distSqr > radiusSqr)
+				continue;
+			
+			// Mark node visited, this is done before the overlap test so that
+			// we will not visit the poly again if the test fails.
+			neighbourNode->flags |= DT_NODE_CLOSED;
+			neighbourNode->pidx = m_tinyNodePool->getNodeIdx(curNode);
+			
+			// Check that the polygon does not collide with existing polygons.
+			
+			// Collect vertices of the neighbour poly.
+			const int npa = neighbourPoly->vertCount;
+			for (int k = 0; k < npa; ++k)
+				dtVcopy(&pa[k*3], &neighbourTile->verts[neighbourPoly->verts[k]*3]);
+			
+			bool overlap = false;
+			for (int j = 0; j < n; ++j)
+			{
+				dtPolyRef pastRef = resultRef[j];
+				
+				// Connected polys do not overlap.
+				bool connected = false;
+				for (unsigned int k = curPoly->firstLink; k != DT_NULL_LINK; k = curTile->links[k].next)
+				{
+					if (curTile->links[k].ref == pastRef)
+					{
+						connected = true;
+						break;
+					}
+				}
+				if (connected)
+					continue;
+				
+				// Potentially overlapping.
+				const dtMeshTile* pastTile = 0;
+				const dtPoly* pastPoly = 0;
+				m_nav->getTileAndPolyByRefUnsafe(pastRef, &pastTile, &pastPoly);
+				
+				// Get vertices and test overlap
+				const int npb = pastPoly->vertCount;
+				for (int k = 0; k < npb; ++k)
+					dtVcopy(&pb[k*3], &pastTile->verts[pastPoly->verts[k]*3]);
+				
+				if (dtOverlapPolyPoly2D(pa,npa, pb,npb))
+				{
+					overlap = true;
+					break;
+				}
+			}
+			if (overlap)
+				continue;
+			
+			// This poly is fine, store and advance to the poly.
+			if (n < maxResult)
+			{
+				resultRef[n] = neighbourRef;
+				if (resultParent)
+					resultParent[n] = curRef;
+				++n;
+			}
+			
+			if (nstack < MAX_STACK)
+			{
+				stack[nstack++] = neighbourNode;
+			}
+		}
+	}
+	
+	*resultCount = n;
+	
+	return DT_SUCCESS;
+}
+
+
+struct dtSegInterval
+{
+	short tmin, tmax;
+};
+
+static void insertInterval(dtSegInterval* ints, int& nints, const int maxInts,
+						   const short tmin, const short tmax)
+{
+	if (nints+1 > maxInts) return;
+	// Find insertion point.
+	int idx = 0;
+	while (idx < nints)
+	{
+		if (tmax <= ints[idx].tmin)
+			break;
+		idx++;
+	}
+	// Move current results.
+	if (nints-idx)
+		memmove(ints+idx+1, ints+idx, sizeof(dtSegInterval)*(nints-idx));
+	// Store
+	ints[idx].tmin = tmin;
+	ints[idx].tmax = tmax;
+	nints++;
+}
+
+dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
+											 float* segments, int* segmentCount, const int maxSegments) const
+{
+	dtAssert(m_nav);
+	
+	*segmentCount = 0;
+	
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
+		return DT_FAILURE;
+	
+	int n = 0;
+	static const int MAX_INTERVAL = 16;
+	dtSegInterval ints[MAX_INTERVAL];
+	int nints;
+	
+	for (int i = 0, j = (int)poly->vertCount-1; i < (int)poly->vertCount; j = i++)
+	{
+		// Skip non-solid edges.
+		nints = 0;
+		if (poly->neis[j] & DT_EXT_LINK)
+		{
+			// Tile border.
+			for (unsigned int k = poly->firstLink; k != DT_NULL_LINK; k = tile->links[k].next)
+			{
+				const dtLink* link = &tile->links[k];
+				if (link->edge == j)
+				{
+					if (link->ref != 0)
+					{
+						const dtMeshTile* neiTile = 0;
+						const dtPoly* neiPoly = 0;
+						m_nav->getTileAndPolyByRefUnsafe(link->ref, &neiTile, &neiPoly);
+						if (filter->passFilter(link->ref, neiTile, neiPoly))
+						{
+							insertInterval(ints, nints, MAX_INTERVAL, link->bmin, link->bmax);
+						}
+					}
+				}
+			}
+		}
+		else if (poly->neis[j])
+		{
+			// Internal edge
+			const unsigned int idx = (unsigned int)(poly->neis[j]-1);
+			const dtPolyRef ref = m_nav->getPolyRefBase(tile) | idx;
+			if (filter->passFilter(ref, tile, &tile->polys[idx]))
+				continue;
+		}
+		
+		// Add sentinels
+		insertInterval(ints, nints, MAX_INTERVAL, -1, 0);
+		insertInterval(ints, nints, MAX_INTERVAL, 255, 256);
+		
+		// Store segment.
+		const float* vj = &tile->verts[poly->verts[j]*3];
+		const float* vi = &tile->verts[poly->verts[i]*3];
+		for (int k = 1; k < nints; ++k)
+		{
+			// Find the space inbetween the opening areas.
+			const int imin = ints[k-1].tmax;
+			const int imax = ints[k].tmin;
+			if (imin == imax) continue;
+			if (imin == 0 && imax == 255)
+			{
+				if (n < maxSegments)
+				{
+					float* seg = &segments[n*6];
+					n++;
+					dtVcopy(seg+0, vj);
+					dtVcopy(seg+3, vi);
+				}
+			}
+			else
+			{
+				const float tmin = imin/255.0f; 
+				const float tmax = imax/255.0f; 
+				if (n < maxSegments)
+				{
+					float* seg = &segments[n*6];
+					n++;
+					dtVlerp(seg+0, vj,vi, tmin);
+					dtVlerp(seg+3, vj,vi, tmax);
+				}
+			}
+		}
+	}
+	
+	*segmentCount = n;
+	
+	return DT_SUCCESS;
+}
+
+dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
+											const dtQueryFilter* filter,
+											float* hitDist, float* hitPos, float* hitNormal) const
+{
+	dtAssert(m_nav);
+	dtAssert(m_nodePool);
+	dtAssert(m_openList);
+	
+	// Validate input
+	if (!startRef) return DT_FAILURE;
+	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	
+	m_nodePool->clear();
+	m_openList->clear();
+	
+	dtNode* startNode = m_nodePool->getNode(startRef);
+	dtVcopy(startNode->pos, centerPos);
+	startNode->pidx = 0;
+	startNode->cost = 0;
+	startNode->total = 0;
+	startNode->id = startRef;
+	startNode->flags = DT_NODE_OPEN;
+	m_openList->push(startNode);
+	
+	float radiusSqr = dtSqr(maxRadius);
+	
+	while (!m_openList->empty())
+	{
+		dtNode* bestNode = m_openList->pop();
+		bestNode->flags &= ~DT_NODE_OPEN;
+		bestNode->flags |= DT_NODE_CLOSED;
+		
+		// Get poly and tile.
+		// The API input has been cheked already, skip checking internal data.
+		const dtPolyRef bestRef = bestNode->id;
+		const dtMeshTile* bestTile = 0;
+		const dtPoly* bestPoly = 0;
+		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
+		
+		// Get parent poly and tile.
+		dtPolyRef parentRef = 0;
+		const dtMeshTile* parentTile = 0;
+		const dtPoly* parentPoly = 0;
+		if (bestNode->pidx)
+			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
+		if (parentRef)
+			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
+		
+		// Hit test walls.
+		for (int i = 0, j = (int)bestPoly->vertCount-1; i < (int)bestPoly->vertCount; j = i++)
+		{
+			// Skip non-solid edges.
+			if (bestPoly->neis[j] & DT_EXT_LINK)
+			{
+				// Tile border.
+				bool solid = true;
+				for (unsigned int k = bestPoly->firstLink; k != DT_NULL_LINK; k = bestTile->links[k].next)
+				{
+					const dtLink* link = &bestTile->links[k];
+					if (link->edge == j)
+					{
+						if (link->ref != 0)
+						{
+							const dtMeshTile* neiTile = 0;
+							const dtPoly* neiPoly = 0;
+							m_nav->getTileAndPolyByRefUnsafe(link->ref, &neiTile, &neiPoly);
+							if (filter->passFilter(link->ref, neiTile, neiPoly))
+								solid = false;
+						}
+						break;
+					}
+				}
+				if (!solid) continue;
+			}
+			else if (bestPoly->neis[j])
+			{
+				// Internal edge
+				const unsigned int idx = (unsigned int)(bestPoly->neis[j]-1);
+				const dtPolyRef ref = m_nav->getPolyRefBase(bestTile) | idx;
+				if (filter->passFilter(ref, bestTile, &bestTile->polys[idx]))
+					continue;
+			}
+			
+			// Calc distance to the edge.
+			const float* vj = &bestTile->verts[bestPoly->verts[j]*3];
+			const float* vi = &bestTile->verts[bestPoly->verts[i]*3];
+			float tseg;
+			float distSqr = dtDistancePtSegSqr2D(centerPos, vj, vi, tseg);
+			
+			// Edge is too far, skip.
+			if (distSqr > radiusSqr)
+				continue;
+			
+			// Hit wall, update radius.
+			radiusSqr = distSqr;
+			// Calculate hit pos.
+			hitPos[0] = vj[0] + (vi[0] - vj[0])*tseg;
+			hitPos[1] = vj[1] + (vi[1] - vj[1])*tseg;
+			hitPos[2] = vj[2] + (vi[2] - vj[2])*tseg;
+		}
+		
+		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
+		{
+			const dtLink* link = &bestTile->links[i];
+			dtPolyRef neighbourRef = link->ref;
+			// Skip invalid neighbours and do not follow back to parent.
+			if (!neighbourRef || neighbourRef == parentRef)
+				continue;
+			
+			// Expand to neighbour.
+			const dtMeshTile* neighbourTile = 0;
+			const dtPoly* neighbourPoly = 0;
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+			
+			// Skip off-mesh connections.
+			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
+				continue;
+			
+			// Calc distance to the edge.
+			const float* va = &bestTile->verts[bestPoly->verts[link->edge]*3];
+			const float* vb = &bestTile->verts[bestPoly->verts[(link->edge+1) % bestPoly->vertCount]*3];
+			float tseg;
+			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
+			
+			// If the circle is not touching the next polygon, skip it.
+			if (distSqr > radiusSqr)
+				continue;
+			
+			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
+				continue;
+
+			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
+			if (!neighbourNode)
+				continue;
+			
+			if (neighbourNode->flags & DT_NODE_CLOSED)
+				continue;
+			
+			// Cost
+			if (neighbourNode->flags == 0)
+			{
+				getEdgeMidPoint(bestRef, bestPoly, bestTile,
+								neighbourRef, neighbourPoly, neighbourTile, neighbourNode->pos);
+			}
+			
+			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			
+			neighbourNode->id = neighbourRef;
+			neighbourNode->flags &= ~DT_NODE_CLOSED;
+			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
+			neighbourNode->total = total;
+				
+			if (neighbourNode->flags & DT_NODE_OPEN)
+			{
+				m_openList->modify(neighbourNode);
+			}
+			else
+			{
+				neighbourNode->flags |= DT_NODE_OPEN;
+				m_openList->push(neighbourNode);
+			}
+		}
+	}
+	
+	// Calc hit normal.
+	dtVsub(hitNormal, centerPos, hitPos);
+	dtVnormalize(hitNormal);
+	
+	*hitDist = sqrtf(radiusSqr);
+	
+	return DT_SUCCESS;
+}
+
+bool dtNavMeshQuery::isInClosedList(dtPolyRef ref) const
+{
+	if (!m_nodePool) return false;
+	const dtNode* node = m_nodePool->findNode(ref);
+	return node && node->flags & DT_NODE_CLOSED;
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNavMeshQuery.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNavMeshQuery.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,407 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURNAVMESHQUERY_H
+#define DETOURNAVMESHQUERY_H
+
+#include "DetourNavMesh.h"
+
+
+// Define DT_VIRTUAL_QUERYFILTER if you wish to derive a custom filter from dtQueryFilter.
+// On certain platforms indirect or virtual function call is expensive. The default
+// setting is to use non-virtual functions, the actualy implementations of the functions
+// are declared as inline for maximum speed. 
+
+//#define DT_VIRTUAL_QUERYFILTER 1
+
+// Class for polygon filtering and cost calculation during query operations.
+// - It is possible to derive a custom query filter from dtQueryFilter by overriding
+//   the virtual functions passFilter() and getCost().
+// - Both functions should be as fast as possible. Use cached local copy of data
+//   instead of accessing your own objects where possible.
+// - You do not need to adhere to the flags and cost logic provided by the default
+//   implementation.
+// - In order for the A* to work properly, the cost should be proportional to
+//   the travel distance. Using cost modifier less than 1.0 is likely to lead
+//   to problems during pathfinding.
+class dtQueryFilter
+{
+	float m_areaCost[DT_MAX_AREAS];		// Array storing cost per area type, used by default implementation.
+	unsigned short m_includeFlags;		// Include poly flags, used by default implementation.
+	unsigned short m_excludeFlags;		// Exclude poly flags, used by default implementation.
+	
+public:
+	dtQueryFilter();
+	
+	// Returns true if the polygon is can visited.
+	// Params:
+	//  ref - (in) reference to the polygon test.
+	//  tile - (in) pointer to the tile of the polygon test.
+	//  poly - (in) pointer to the polygon test.
+#ifdef DT_VIRTUAL_QUERYFILTER
+	virtual bool passFilter(const dtPolyRef ref,
+							const dtMeshTile* tile,
+							const dtPoly* poly) const;
+#else
+	bool passFilter(const dtPolyRef ref,
+					const dtMeshTile* tile,
+					const dtPoly* poly) const;
+#endif
+
+	// Returns cost to travel from 'pa' to 'pb'.'
+	// The segment is fully contained inside 'cur'.
+	// 'pa' lies on the edge between 'prev' and 'cur', 
+	// 'pb' lies on the edge between 'cur' and 'next'.
+	// Params:
+	//  pa - (in) segment start position.
+	//  pb - (in) segment end position.
+	//  prevRef, prevTile, prevPoly - (in) data describing the previous polygon, can be null.
+	//  curRef, curTile, curPoly - (in) data describing the current polygon.
+	//  nextRef, nextTile, nextPoly - (in) data describing the next polygon, can be null.
+#ifdef DT_VIRTUAL_QUERYFILTER
+	virtual float getCost(const float* pa, const float* pb,
+						  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
+						  const dtPolyRef curRef, const dtMeshTile* curTile, const dtPoly* curPoly,
+						  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
+#else
+	float getCost(const float* pa, const float* pb,
+				  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
+				  const dtPolyRef curRef, const dtMeshTile* curTile, const dtPoly* curPoly,
+				  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
+#endif
+	
+	// Getters and setters for the default implementation data.
+	inline float getAreaCost(const int i) const { return m_areaCost[i]; }
+	inline void setAreaCost(const int i, const float cost) { m_areaCost[i] = cost; } 
+
+	inline unsigned short getIncludeFlags() const { return m_includeFlags; }
+	inline void setIncludeFlags(const unsigned short flags) { m_includeFlags = flags; }
+
+	inline unsigned short getExcludeFlags() const { return m_excludeFlags; }
+	inline void setExcludeFlags(const unsigned short flags) { m_excludeFlags = flags; }	
+};
+
+class dtNavMeshQuery
+{
+public:
+	dtNavMeshQuery();
+	~dtNavMeshQuery();
+	
+	// Initializes the nav mesh query.
+	// Params:
+	//  nav - (in) pointer to navigation mesh data.
+	//  maxNodes - (in) Maximum number of search nodes to use (max 65536).
+	// Returns: True if succeed, else false.
+	dtStatus init(const dtNavMesh* nav, const int maxNodes);
+	
+	// Finds the nearest navigation polygon around the center location.
+	// Params:
+	//	center[3] - (in) The center of the search box.
+	//	extents[3] - (in) The extents of the search box.
+	//  filter - (in) path polygon filter.
+	//  nearestRef - (out) Reference to the nearest polygon.
+	//  nearestPt[3] - (out, opt) The nearest point on found polygon, null if not needed.
+	// Returns: Reference identifier for the polygon, or 0 if no polygons found.
+	dtStatus findNearestPoly(const float* center, const float* extents,
+							 const dtQueryFilter* filter,
+							 dtPolyRef* nearestRef, float* nearestPt) const;
+	
+	// Returns polygons which overlap the query box.
+	// Params:
+	//	center[3] - (in) the center of the search box.
+	//	extents[3] - (in) the extents of the search box.
+	//  filter - (in) path polygon filter.
+	//	polys - (out) array holding the search result.
+	//  polyCount - (out) Number of polygons in search result array.
+	//	maxPolys - (in) The max number of polygons the polys array can hold.
+	dtStatus queryPolygons(const float* center, const float* extents,
+						   const dtQueryFilter* filter,
+						   dtPolyRef* polys, int* polyCount, const int maxPolys) const;
+	
+	// Finds path from start polygon to end polygon.
+	// If target polygon canno be reached through the navigation graph,
+	// the last node on the array is nearest node to the end polygon.
+	// Start end end positions are needed to calculate more accurate
+	// traversal cost at start end end polygons.
+	// Params:
+	//	startRef - (in) ref to path start polygon.
+	//	endRef - (in) ref to path end polygon.
+	//	startPos[3] - (in) Path start location.
+	//	endPos[3] - (in) Path end location.
+	//  filter - (in) path polygon filter.
+	//	path - (out) array holding the search result.
+	//  pathCount - (out) Number of polygons in search result array.
+	//	maxPath - (in) The max number of polygons the path array can hold. Must be at least 1.
+	dtStatus findPath(dtPolyRef startRef, dtPolyRef endRef,
+					  const float* startPos, const float* endPos,
+					  const dtQueryFilter* filter,
+					  dtPolyRef* path, int* pathCount, const int maxPath) const;
+	
+	// Intializes sliced path find query.
+	// Note 1: calling any other dtNavMeshQuery method before calling findPathEnd()
+	// may results in corrupted data!
+	// Note 2: The pointer to filter is store, and used in subsequent
+	// calls to updateSlicedFindPath().
+	// Params:
+	//	startRef - (in) ref to path start polygon.
+	//	endRef - (in) ref to path end polygon.
+	//	startPos[3] - (in) Path start location.
+	//	endPos[3] - (in) Path end location.
+	//  filter - (in) path polygon filter.
+	dtStatus initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
+								const float* startPos, const float* endPos,
+								const dtQueryFilter* filter);
+
+	// Updates sliced path find query.
+	// Params:
+	//  maxIter - (in) max number of iterations to update.
+	// Returns: Path query state.
+	dtStatus updateSlicedFindPath(const int maxIter);
+
+	// Finalizes sliced path find query and returns found path.
+	//	path - (out) array holding the search result.
+	//  pathCount - (out) Number of polygons in search result array.
+	//	maxPath - (in) The max number of polygons the path array can hold.
+	dtStatus finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath);
+	
+	// Finalizes partial sliced path find query and returns path to the furthest
+	// polygon on the existing path that was visited during the search.
+	//	existing - (out) Array of polygons in the existing path.
+	//  existingSize - (out) Number of polygons in existing path array.
+	//	path - (out) array holding the search result.
+	//  pathCount - (out) Number of polygons in search result array.
+	//	maxPath - (in) The max number of polygons the path array can hold.
+	dtStatus finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
+										   dtPolyRef* path, int* pathCount, const int maxPath);
+	
+	// Finds a straight path from start to end locations within the corridor
+	// described by the path polygons.
+	// Start and end locations will be clamped on the corridor.
+	// The returned polygon references are point to polygon which was entered when
+	// a path point was added. For the end point, zero will be returned. This allows
+	// to match for example off-mesh link points to their representative polygons.
+	// Params:
+	//	startPos[3] - (in) Path start location.
+	//	endPo[3] - (in) Path end location.
+	//	path - (in) Array of connected polygons describing the corridor.
+	//	pathSize - (in) Number of polygons in path array.
+	//	straightPath - (out) Points describing the straight path.
+	//  straightPathFlags - (out, opt) Flags describing each point type, see dtStraightPathFlags.
+	//  straightPathRefs - (out, opt) References to polygons at point locations.
+	//  straightPathCount - (out) Number of points in the path.
+	//	maxStraightPath - (in) The max number of points the straight path array can hold. Must be at least 1.
+	dtStatus findStraightPath(const float* startPos, const float* endPos,
+							  const dtPolyRef* path, const int pathSize,
+							  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
+							  int* straightPathCount, const int maxStraightPath) const;
+	
+	// Moves from startPos to endPos constrained to the navmesh.
+	// If the endPos is reachable, the resultPos will be endPos,
+	// or else the resultPos will be the nearest point in navmesh.
+	// Note: The resulting point is not projected to the ground, use getPolyHeight() to get height.
+	// Note: The algorithm is optimized for small delta movement and small number of polygons. 
+	// Params:
+	//  startRef - (in) ref to the polygon where startPos lies.
+	//  startPos[3] - (in) start position of the mover.
+	//  endPos[3] - (in) desired end position of the mover.
+	//  filter - (in) path polygon filter.
+	//  resultPos[3] - (out) new position of the mover.
+	//  visited - (out) array of visited polygons.
+	//  visitedCount - (out) Number of entries in the visited array.
+	//  maxVisitedSize - (in) max number of polygons in the visited array.
+	dtStatus moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
+							  const dtQueryFilter* filter,
+							  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const;
+	
+	// Casts 'walkability' ray along the navmesh surface from startPos towards the endPos.
+	// Params:
+	//	startRef - (in) ref to the polygon where the start lies.
+	//	startPos[3] - (in) start position of the query.
+	//	endPos[3] - (in) end position of the query.
+	//	t - (out) hit parameter along the segment, FLT_MAX if no hit.
+	//	hitNormal[3] - (out) normal of the nearest hit.
+	//  filter - (in) path polygon filter.
+	//  path - (out,opt) visited path polygons.
+	//  pathCount - (out,opt) Number of polygons visited.
+	//  maxPath - (in) max number of polygons in the path array.
+	dtStatus raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
+					 const dtQueryFilter* filter,
+					 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const;
+	
+	// Returns distance to nearest wall from the specified location.
+	// Params:
+	//	startRef - (in) ref to the polygon where the center lies.
+	//	centerPos[3] - (in) center if the query circle.
+	//	maxRadius - (in) max search radius.
+	//  filter - (in) path polygon filter.
+	//  hitDist - (out) distance to nearest wall from the test location.
+	//	hitPos[3] - (out) location of the nearest hit.
+	//	hitNormal[3] - (out) normal of the nearest hit.
+	dtStatus findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
+								const dtQueryFilter* filter,
+								float* hitDist, float* hitPos, float* hitNormal) const;
+	
+	// Finds polygons found along the navigation graph which touch the specified circle.
+	// Params:
+	//	startRef - (in) ref to the polygon where the search starts.
+	//	centerPos[3] - (in) center if the query circle.
+	//	radius - (in) radius of the query circle.
+	//  filter - (in) path polygon filter.
+	//	resultRef - (out, opt) refs to the polygons touched by the circle.
+	//	resultParent - (out, opt) parent of each result polygon.
+	//	resultCost - (out, opt) search cost at each result polygon.
+	//  resultCount - (out, opt) Number of results.
+	//	maxResult - (int) maximum capacity of search results.
+	dtStatus findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
+								   const dtQueryFilter* filter,
+								   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
+								   int* resultCount, const int maxResult) const;
+	
+	// Finds polygons found along the navigation graph which touch the convex polygon shape.
+	// Params:
+	//	startRef - (in) ref to the polygon where the search starts.
+	//	verts[3*n] - (in) vertices describing convex polygon shape (CCW).
+	//	nverts - (in) number of vertices in the polygon.
+	//  filter - (in) path polygon filter.
+	//	resultRef - (out, opt) refs to the polygons touched by the circle.
+	//	resultParent - (out, opt) parent of each result polygon.
+	//	resultCost - (out, opt) search cost at each result polygon.
+	//  resultCount - (out) number of results.
+	//	maxResult - (int) maximum capacity of search results.
+	dtStatus findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
+								  const dtQueryFilter* filter,
+								  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
+								  int* resultCount, const int maxResult) const;
+	
+	// Finds non-overlapping local neighbourhood around center location.
+	// Note: The algorithm is optimized for small query radius and small number of polygons. 
+	// Params:
+	//	startRef - (in) ref to the polygon where the search starts.
+	//	centerPos[3] - (in) center if the query circle.
+	//	radius - (in) radius of the query circle.
+	//  filter - (in) path polygon filter.
+	//	resultRef - (out) refs to the polygons touched by the circle.
+	//	resultParent - (out, opt) parent of each result polygon.
+	//  resultCount - (out) number of results.
+	//	maxResult - (int) maximum capacity of search results.
+	dtStatus findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
+									const dtQueryFilter* filter,
+									dtPolyRef* resultRef, dtPolyRef* resultParent,
+									int* resultCount, const int maxResult) const;
+	
+	// Returns wall segments of specified polygon.
+	// Params:
+	//  ref - (in) ref to the polygon.
+	//  filter - (in) path polygon filter.
+	//  segments[6*maxSegments] - (out) wall segments (2 endpoints per segment).
+	//  segmentCount - (out) number of wall segments.
+	//  maxSegments - (in) max number of segments that can be stored in 'segments'.
+	dtStatus getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
+								 float* segments, int* segmentCount, const int maxSegments) const;
+	
+	// Returns closest point on navigation polygon.
+	// Uses detail polygons to find the closest point to the navigation polygon surface. 
+	// Params:
+	//	ref - (in) ref to the polygon.
+	//	pos[3] - (in) the point to check.
+	//	closest[3] - (out) closest point.
+	// Returns: true if closest point found.
+	dtStatus closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const;
+	
+	// Returns closest point on navigation polygon boundary.
+	// Uses the navigation polygon boundary to snap the point to poly boundary
+	// if it is outside the polygon. Much faster than closestPointToPoly. Does not affect height.
+	// Params:
+	//	ref - (in) ref to the polygon.
+	//	pos[3] - (in) the point to check.
+	//	closest[3] - (out) closest point.
+	// Returns: true if closest point found.
+	dtStatus closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const;
+	
+	// Returns start and end location of an off-mesh link polygon.
+	// Params:
+	//	prevRef - (in) ref to the polygon before the link (used to select direction).
+	//	polyRef - (in) ref to the off-mesh link polygon.
+	//	startPos[3] - (out) start point of the link.
+	//	endPos[3] - (out) end point of the link.
+	// Returns: true if link is found.
+	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
+	
+	// Returns height of the polygon at specified location.
+	// Params:
+	//	ref - (in) ref to the polygon.
+	//	pos[3] - (in) the point where to locate the height.
+	//	height - (out) height at the location.
+	// Returns: true if over polygon.
+	dtStatus getPolyHeight(dtPolyRef ref, const float* pos, float* height) const;
+		
+	// Returns true if poly reference ins in closed list.
+	bool isInClosedList(dtPolyRef ref) const;
+	
+	class dtNodePool* getNodePool() const { return m_nodePool; }
+	
+private:
+	
+	// Returns neighbour tile based on side. 
+	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
+
+	// Queries polygons within a tile.
+	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, const dtQueryFilter* filter,
+							dtPolyRef* polys, const int maxPolys) const;
+	// Find nearest polygon within a tile.
+	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents,
+									const dtQueryFilter* filter, float* nearestPt) const;
+	// Returns closest point on polygon.
+	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly, const float* pos, float* closest) const;
+	
+	// Returns portal points between two polygons.
+	dtStatus getPortalPoints(dtPolyRef from, dtPolyRef to, float* left, float* right,
+							 unsigned char& fromType, unsigned char& toType) const;
+	dtStatus getPortalPoints(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
+							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
+							 float* left, float* right) const;
+	
+	// Returns edge mid point between two polygons.
+	dtStatus getEdgeMidPoint(dtPolyRef from, dtPolyRef to, float* mid) const;
+	dtStatus getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
+							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
+							 float* mid) const;
+	
+	const dtNavMesh* m_nav;				// Pointer to navmesh data.
+
+	struct dtQueryData
+	{
+		dtStatus status;
+		struct dtNode* lastBestNode;
+		float lastBestNodeCost;
+		dtPolyRef startRef, endRef;
+		float startPos[3], endPos[3];
+		const dtQueryFilter* filter;
+	};
+	dtQueryData m_query;				// Sliced query state.
+
+	class dtNodePool* m_tinyNodePool;	// Pointer to small node pool.
+	class dtNodePool* m_nodePool;		// Pointer to node pool.
+	class dtNodeQueue* m_openList;		// Pointer to open list queue.
+};
+
+// Helper function to allocate navmesh query class using Detour allocator.
+dtNavMeshQuery* dtAllocNavMeshQuery();
+void dtFreeNavMeshQuery(dtNavMeshQuery* query);
+
+#endif // DETOURNAVMESHQUERY_H
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNode.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNode.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,164 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include "DetourNode.h"
+#include "DetourAlloc.h"
+#include "DetourAssert.h"
+#include "DetourCommon.h"
+#include <string.h>
+
+inline unsigned int dtHashRef(dtPolyRef a)
+{
+    a = (~a) + (a << 18);
+    a = a ^ (a >> 31);
+    a = a * 21;
+    a = a ^ (a >> 11);
+    a = a + (a << 6);
+    a = a ^ (a >> 22);
+    return (unsigned int)a;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+dtNodePool::dtNodePool(int maxNodes, int hashSize) :
+	m_nodes(0),
+	m_first(0),
+	m_next(0),
+	m_maxNodes(maxNodes),
+	m_hashSize(hashSize),
+	m_nodeCount(0)
+{
+	dtAssert(dtNextPow2(m_hashSize) == (unsigned int)m_hashSize);
+	dtAssert(m_maxNodes > 0);
+
+	m_nodes = (dtNode*)dtAlloc(sizeof(dtNode)*m_maxNodes, DT_ALLOC_PERM);
+	m_next = (unsigned short*)dtAlloc(sizeof(unsigned short)*m_maxNodes, DT_ALLOC_PERM);
+	m_first = (unsigned short*)dtAlloc(sizeof(unsigned short)*hashSize, DT_ALLOC_PERM);
+
+	dtAssert(m_nodes);
+	dtAssert(m_next);
+	dtAssert(m_first);
+
+	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
+	memset(m_next, 0xff, sizeof(unsigned short)*m_maxNodes);
+}
+
+dtNodePool::~dtNodePool()
+{
+	dtFree(m_nodes);
+	dtFree(m_next);
+	dtFree(m_first);
+}
+
+void dtNodePool::clear()
+{
+	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
+	m_nodeCount = 0;
+}
+
+dtNode* dtNodePool::findNode(dtPolyRef id)
+{
+	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
+	unsigned short i = m_first[bucket];
+	while (i != DT_NULL_IDX)
+	{
+		if (m_nodes[i].id == id)
+			return &m_nodes[i];
+		i = m_next[i];
+	}
+	return 0;
+}
+
+dtNode* dtNodePool::getNode(dtPolyRef id)
+{
+	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
+	unsigned short i = m_first[bucket];
+	dtNode* node = 0;
+	while (i != DT_NULL_IDX)
+	{
+		if (m_nodes[i].id == id)
+			return &m_nodes[i];
+		i = m_next[i];
+	}
+	
+	if (m_nodeCount >= m_maxNodes)
+		return 0;
+	
+	i = (unsigned short)m_nodeCount;
+	m_nodeCount++;
+	
+	// Init node
+	node = &m_nodes[i];
+	node->pidx = 0;
+	node->cost = 0;
+	node->total = 0;
+	node->id = id;
+	node->flags = 0;
+	
+	m_next[i] = m_first[bucket];
+	m_first[bucket] = i;
+	
+	return node;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+dtNodeQueue::dtNodeQueue(int n) :
+	m_heap(0),
+	m_capacity(n),
+	m_size(0)
+{
+	dtAssert(m_capacity > 0);
+	
+	m_heap = (dtNode**)dtAlloc(sizeof(dtNode*)*(m_capacity+1), DT_ALLOC_PERM);
+	dtAssert(m_heap);
+}
+
+dtNodeQueue::~dtNodeQueue()
+{
+	dtFree(m_heap);
+}
+
+void dtNodeQueue::bubbleUp(int i, dtNode* node)
+{
+	int parent = (i-1)/2;
+	// note: (index > 0) means there is a parent
+	while ((i > 0) && (m_heap[parent]->total > node->total))
+	{
+		m_heap[i] = m_heap[parent];
+		i = parent;
+		parent = (i-1)/2;
+	}
+	m_heap[i] = node;
+}
+
+void dtNodeQueue::trickleDown(int i, dtNode* node)
+{
+	int child = (i*2)+1;
+	while (child < m_size)
+	{
+		if (((child+1) < m_size) && 
+			(m_heap[child]->total > m_heap[child+1]->total))
+		{
+			child++;
+		}
+		m_heap[i] = m_heap[child];
+		i = child;
+		child = (i*2)+1;
+	}
+	bubbleUp(i, node);
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourNode.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourNode.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,157 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOURNODE_H
+#define DETOURNODE_H
+
+#include "DetourNavMesh.h"
+
+enum dtNodeFlags
+{
+	DT_NODE_OPEN = 0x01,
+	DT_NODE_CLOSED = 0x02,
+};
+
+static const unsigned short DT_NULL_IDX = 0xffff;
+
+struct dtNode
+{
+	float pos[3];				// Position of the node.
+	float cost;					// Cost from previous node to current node.
+	float total;				// Cost up to the node.
+	unsigned int pidx : 30;		// Index to parent node.
+	unsigned int flags : 2;		// Node flags 0/open/closed.
+	dtPolyRef id;				// Polygon ref the node corresponds to.
+};
+
+class dtNodePool
+{
+public:
+	dtNodePool(int maxNodes, int hashSize);
+	~dtNodePool();
+	inline void operator=(const dtNodePool&) {}
+	void clear();
+	dtNode* getNode(dtPolyRef id);
+	dtNode* findNode(dtPolyRef id);
+
+	inline unsigned int getNodeIdx(const dtNode* node) const
+	{
+		if (!node) return 0;
+		return (unsigned int)(node - m_nodes)+1;
+	}
+
+	inline dtNode* getNodeAtIdx(unsigned int idx)
+	{
+		if (!idx) return 0;
+		return &m_nodes[idx-1];
+	}
+
+	inline const dtNode* getNodeAtIdx(unsigned int idx) const
+	{
+		if (!idx) return 0;
+		return &m_nodes[idx-1];
+	}
+	
+	inline int getMemUsed() const
+	{
+		return sizeof(*this) +
+		sizeof(dtNode)*m_maxNodes +
+		sizeof(unsigned short)*m_maxNodes +
+		sizeof(unsigned short)*m_hashSize;
+	}
+	
+	inline int getMaxNodes() const { return m_maxNodes; }
+	
+	inline int getHashSize() const { return m_hashSize; }
+	inline unsigned short getFirst(int bucket) const { return m_first[bucket]; }
+	inline unsigned short getNext(int i) const { return m_next[i]; }
+	
+private:
+	
+	dtNode* m_nodes;
+	unsigned short* m_first;
+	unsigned short* m_next;
+	const int m_maxNodes;
+	const int m_hashSize;
+	int m_nodeCount;
+};
+
+class dtNodeQueue
+{
+public:
+	dtNodeQueue(int n);
+	~dtNodeQueue();
+	inline void operator=(dtNodeQueue&) {}
+	
+	inline void clear()
+	{
+		m_size = 0;
+	}
+	
+	inline dtNode* top()
+	{
+		return m_heap[0];
+	}
+	
+	inline dtNode* pop()
+	{
+		dtNode* result = m_heap[0];
+		m_size--;
+		trickleDown(0, m_heap[m_size]);
+		return result;
+	}
+	
+	inline void push(dtNode* node)
+	{
+		m_size++;
+		bubbleUp(m_size-1, node);
+	}
+	
+	inline void modify(dtNode* node)
+	{
+		for (int i = 0; i < m_size; ++i)
+		{
+			if (m_heap[i] == node)
+			{
+				bubbleUp(i, node);
+				return;
+			}
+		}
+	}
+	
+	inline bool empty() const { return m_size == 0; }
+	
+	inline int getMemUsed() const
+	{
+		return sizeof(*this) +
+		sizeof(dtNode*)*(m_capacity+1);
+	}
+	
+	inline int getCapacity() const { return m_capacity; }
+	
+private:
+	void bubbleUp(int i, dtNode* node);
+	void trickleDown(int i, dtNode* node);
+	
+	dtNode** m_heap;
+	const int m_capacity;
+	int m_size;
+};		
+
+
+#endif // DETOURNODE_H
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourObstacleAvoidance.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourObstacleAvoidance.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,532 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include "DetourObstacleAvoidance.h"
+#include "DetourCommon.h"
+#include "DetourAlloc.h"
+#include "DetourAssert.h"
+#include <string.h>
+#include <math.h>
+#include <float.h>
+#include <new>
+
+
+static int sweepCircleCircle(const float* c0, const float r0, const float* v,
+							 const float* c1, const float r1,
+							 float& tmin, float& tmax)
+{
+	static const float EPS = 0.0001f;
+	float s[3];
+	dtVsub(s,c1,c0);
+	float r = r0+r1;
+	float c = dtVdot2D(s,s) - r*r;
+	float a = dtVdot2D(v,v);
+	if (a < EPS) return 0;	// not moving
+	
+	// Overlap, calc time to exit.
+	float b = dtVdot2D(v,s);
+	float d = b*b - a*c;
+	if (d < 0.0f) return 0; // no intersection.
+	a = 1.0f / a;
+	const float rd = dtSqrt(d);
+	tmin = (b - rd) * a;
+	tmax = (b + rd) * a;
+	return 1;
+}
+
+static int isectRaySeg(const float* ap, const float* u,
+					   const float* bp, const float* bq,
+					   float& t)
+{
+	float v[3], w[3];
+	dtVsub(v,bq,bp);
+	dtVsub(w,ap,bp);
+	float d = dtVperp2D(u,v);
+	if (fabsf(d) < 1e-6f) return 0;
+	d = 1.0f/d;
+	t = dtVperp2D(v,w) * d;
+	if (t < 0 || t > 1) return 0;
+	float s = dtVperp2D(u,w) * d;
+	if (s < 0 || s > 1) return 0;
+	return 1;
+}
+
+
+
+dtObstacleAvoidanceDebugData* dtAllocObstacleAvoidanceDebugData()
+{
+	void* mem = dtAlloc(sizeof(dtObstacleAvoidanceDebugData), DT_ALLOC_PERM);
+	if (!mem) return 0;
+	return new(mem) dtObstacleAvoidanceDebugData;
+}
+
+void dtFreeObstacleAvoidanceDebugData(dtObstacleAvoidanceDebugData* ptr)
+{
+	if (!ptr) return;
+	ptr->~dtObstacleAvoidanceDebugData();
+	dtFree(ptr);
+}
+
+
+dtObstacleAvoidanceDebugData::dtObstacleAvoidanceDebugData() :
+	m_nsamples(0),
+	m_maxSamples(0),
+	m_vel(0),
+	m_ssize(0),
+	m_pen(0),
+	m_vpen(0),
+	m_vcpen(0),
+	m_spen(0),
+	m_tpen(0)
+{
+}
+
+dtObstacleAvoidanceDebugData::~dtObstacleAvoidanceDebugData()
+{
+	dtFree(m_vel);
+	dtFree(m_ssize);
+	dtFree(m_pen);
+	dtFree(m_vpen);
+	dtFree(m_vcpen);
+	dtFree(m_spen);
+	dtFree(m_tpen);
+}
+		
+bool dtObstacleAvoidanceDebugData::init(const int maxSamples)
+{
+	dtAssert(maxSamples);
+	m_maxSamples = maxSamples;
+
+	m_vel = (float*)dtAlloc(sizeof(float)*3*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_vel)
+		return false;
+	m_pen = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_pen)
+		return false;
+	m_ssize = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_ssize)
+		return false;
+	m_vpen = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_vpen)
+		return false;
+	m_vcpen = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_vcpen)
+		return false;
+	m_spen = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_spen)
+		return false;
+	m_tpen = (float*)dtAlloc(sizeof(float)*m_maxSamples, DT_ALLOC_PERM);
+	if (!m_tpen)
+		return false;
+	
+	return true;
+}
+
+void dtObstacleAvoidanceDebugData::reset()
+{
+	m_nsamples = 0;
+}
+
+void dtObstacleAvoidanceDebugData::addSample(const float* vel, const float ssize, const float pen,
+											 const float vpen, const float vcpen, const float spen, const float tpen)
+{
+	if (m_nsamples >= m_maxSamples)
+		return;
+	dtAssert(m_vel);
+	dtAssert(m_ssize);
+	dtAssert(m_pen);
+	dtAssert(m_vpen);
+	dtAssert(m_vcpen);
+	dtAssert(m_spen);
+	dtAssert(m_tpen);
+	dtVcopy(&m_vel[m_nsamples*3], vel);
+	m_ssize[m_nsamples] = ssize;
+	m_pen[m_nsamples] = pen;
+	m_vpen[m_nsamples] = vpen;
+	m_vcpen[m_nsamples] = vcpen;
+	m_spen[m_nsamples] = spen;
+	m_tpen[m_nsamples] = tpen;
+	m_nsamples++;
+}
+
+static void normalizeArray(float* arr, const int n)
+{
+	// Normalize penaly range.
+	float minPen = FLT_MAX;
+	float maxPen = -FLT_MAX;
+	for (int i = 0; i < n; ++i)
+	{
+		minPen = dtMin(minPen, arr[i]);
+		maxPen = dtMax(maxPen, arr[i]);
+	}
+	const float penRange = maxPen-minPen;
+	const float s = penRange > 0.001f ? (1.0f / penRange) : 1;
+	for (int i = 0; i < n; ++i)
+		arr[i] = dtClamp((arr[i]-minPen)*s, 0.0f, 1.0f);
+}
+
+void dtObstacleAvoidanceDebugData::normalizeSamples()
+{
+	normalizeArray(m_pen, m_nsamples);
+	normalizeArray(m_vpen, m_nsamples);
+	normalizeArray(m_vcpen, m_nsamples);
+	normalizeArray(m_spen, m_nsamples);
+	normalizeArray(m_tpen, m_nsamples);
+}
+
+
+dtObstacleAvoidanceQuery* dtAllocObstacleAvoidanceQuery()
+{
+	void* mem = dtAlloc(sizeof(dtObstacleAvoidanceQuery), DT_ALLOC_PERM);
+	if (!mem) return 0;
+	return new(mem) dtObstacleAvoidanceQuery;
+}
+
+void dtFreeObstacleAvoidanceQuery(dtObstacleAvoidanceQuery* ptr)
+{
+	if (!ptr) return;
+	ptr->~dtObstacleAvoidanceQuery();
+	dtFree(ptr);
+}
+
+
+dtObstacleAvoidanceQuery::dtObstacleAvoidanceQuery() :
+	m_velBias(0.0f),
+	m_weightDesVel(0.0f),
+	m_weightCurVel(0.0f),
+	m_weightSide(0.0f),
+	m_weightToi(0.0f),
+	m_horizTime(0.0f),
+	m_maxCircles(0),
+	m_circles(0),
+	m_ncircles(0),
+	m_maxSegments(0),
+	m_segments(0),
+	m_nsegments(0)
+{
+}
+
+dtObstacleAvoidanceQuery::~dtObstacleAvoidanceQuery()
+{
+	dtFree(m_circles);
+	dtFree(m_segments);
+}
+
+bool dtObstacleAvoidanceQuery::init(const int maxCircles, const int maxSegments)
+{
+	m_maxCircles = maxCircles;
+	m_ncircles = 0;
+	m_circles = (dtObstacleCircle*)dtAlloc(sizeof(dtObstacleCircle)*m_maxCircles, DT_ALLOC_PERM);
+	if (!m_circles)
+		return false;
+	memset(m_circles, 0, sizeof(dtObstacleCircle)*m_maxCircles);
+
+	m_maxSegments = maxSegments;
+	m_nsegments = 0;
+	m_segments = (dtObstacleSegment*)dtAlloc(sizeof(dtObstacleSegment)*m_maxSegments, DT_ALLOC_PERM);
+	if (!m_segments)
+		return false;
+	memset(m_segments, 0, sizeof(dtObstacleSegment)*m_maxSegments);
+	
+	return true;
+}
+
+void dtObstacleAvoidanceQuery::reset()
+{
+	m_ncircles = 0;
+	m_nsegments = 0;
+}
+
+void dtObstacleAvoidanceQuery::addCircle(const float* pos, const float rad,
+										 const float* vel, const float* dvel)
+{
+	if (m_ncircles >= m_maxCircles)
+		return;
+		
+	dtObstacleCircle* cir = &m_circles[m_ncircles++];
+	dtVcopy(cir->p, pos);
+	cir->rad = rad;
+	dtVcopy(cir->vel, vel);
+	dtVcopy(cir->dvel, dvel);
+}
+
+void dtObstacleAvoidanceQuery::addSegment(const float* p, const float* q)
+{
+	if (m_nsegments > m_maxSegments)
+		return;
+	
+	dtObstacleSegment* seg = &m_segments[m_nsegments++];
+	dtVcopy(seg->p, p);
+	dtVcopy(seg->q, q);
+}
+
+void dtObstacleAvoidanceQuery::prepare(const float* pos, const float* dvel)
+{
+	// Prepare obstacles
+	for (int i = 0; i < m_ncircles; ++i)
+	{
+		dtObstacleCircle* cir = &m_circles[i];
+		
+		// Side
+		const float* pa = pos;
+		const float* pb = cir->p;
+		
+		const float orig[3] = {0,0};
+		float dv[3];
+		dtVsub(cir->dp,pb,pa);
+		dtVnormalize(cir->dp);
+		dtVsub(dv, cir->dvel, dvel);
+		
+		const float a = dtTriArea2D(orig, cir->dp,dv);
+		if (a < 0.01f)
+		{
+			cir->np[0] = -cir->dp[2];
+			cir->np[2] = cir->dp[0];
+		}
+		else
+		{
+			cir->np[0] = cir->dp[2];
+			cir->np[2] = -cir->dp[0];
+		}
+	}	
+
+	for (int i = 0; i < m_nsegments; ++i)
+	{
+		dtObstacleSegment* seg = &m_segments[i];
+		
+		// Precalc if the agent is really close to the segment.
+		const float r = 0.01f;
+		float t;
+		seg->touch = dtDistancePtSegSqr2D(pos, seg->p, seg->q, t) < dtSqr(r);
+	}	
+}
+
+float dtObstacleAvoidanceQuery::processSample(const float* vcand, const float cs,
+											  const float* pos, const float rad,
+											  const float vmax, const float* vel, const float* dvel,
+											  dtObstacleAvoidanceDebugData* debug)
+{
+	// Find min time of impact and exit amongst all obstacles.
+	float tmin = m_horizTime;
+	float side = 0;
+	int nside = 0;
+	
+	for (int i = 0; i < m_ncircles; ++i)
+	{
+		const dtObstacleCircle* cir = &m_circles[i];
+			
+		// RVO
+		float vab[3];
+		dtVscale(vab, vcand, 2);
+		dtVsub(vab, vab, vel);
+		dtVsub(vab, vab, cir->vel);
+		
+		// Side
+		side += dtClamp(dtMin(dtVdot2D(cir->dp,vab)*0.5f+0.5f, dtVdot2D(cir->np,vab)*2), 0.0f, 1.0f);
+		nside++;
+		
+		float htmin = 0, htmax = 0;
+		if (!sweepCircleCircle(pos,rad, vab, cir->p,cir->rad, htmin, htmax))
+			continue;
+		
+		// Handle overlapping obstacles.
+		if (htmin < 0.0f && htmax > 0.0f)
+		{
+			// Avoid more when overlapped.
+			htmin = -htmin * 0.5f;
+		}
+		
+		if (htmin >= 0.0f)
+		{
+			// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.
+			if (htmin < tmin)
+				tmin = htmin;
+		}
+	}
+
+	for (int i = 0; i < m_nsegments; ++i)
+	{
+		const dtObstacleSegment* seg = &m_segments[i];
+		float htmin = 0;
+		
+		if (seg->touch)
+		{
+			// Special case when the agent is very close to the segment.
+			float sdir[3], snorm[3];
+			dtVsub(sdir, seg->q, seg->p);
+			snorm[0] = -sdir[2];
+			snorm[2] = sdir[0];
+			// If the velocity is pointing towards the segment, no collision.
+			if (dtVdot2D(snorm, vcand) < 0.0f)
+				continue;
+			// Else immediate collision.
+			htmin = 0.0f;
+		}
+		else
+		{
+			if (!isectRaySeg(pos, vcand, seg->p, seg->q, htmin))
+				continue;
+		}
+		
+		// Avoid less when facing walls.
+		htmin *= 2.0f;
+		
+		// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.
+		if (htmin < tmin)
+			tmin = htmin;
+	}
+	
+	// Normalize side bias, to prevent it dominating too much.
+	if (nside)
+		side /= nside;
+	
+	const float ivmax = 1.0f / vmax;
+	const float vpen = m_weightDesVel * (dtVdist2D(vcand, dvel) * ivmax);
+	const float vcpen = m_weightCurVel * (dtVdist2D(vcand, vel) * ivmax);
+	const float spen = m_weightSide * side;
+	const float tpen = m_weightToi * (1.0f/(0.1f+tmin / m_horizTime));
+	
+	const float penalty = vpen + vcpen + spen + tpen;
+	
+	// Store different penalties for debug viewing
+	if (debug)
+		debug->addSample(vcand, cs, penalty, vpen, vcpen, spen, tpen);
+	
+	return penalty;
+}
+
+void dtObstacleAvoidanceQuery::sampleVelocityGrid(const float* pos, const float rad, const float vmax,
+												  const float* vel, const float* dvel,
+												  float* nvel, const int gsize,
+												  dtObstacleAvoidanceDebugData* debug)
+{
+	prepare(pos, dvel);
+	
+	dtVset(nvel, 0,0,0);
+	
+	if (debug)
+		debug->reset();
+
+	const float cvx = dvel[0] * m_velBias;
+	const float cvz = dvel[2] * m_velBias;
+	const float cs = vmax * 2 * (1 - m_velBias) / (float)(gsize-1);
+	const float half = (gsize-1)*cs*0.5f;
+		
+	float minPenalty = FLT_MAX;
+		
+	for (int y = 0; y < gsize; ++y)
+	{
+		for (int x = 0; x < gsize; ++x)
+		{
+			float vcand[3];
+			vcand[0] = cvx + x*cs - half;
+			vcand[1] = 0;
+			vcand[2] = cvz + y*cs - half;
+			
+			if (dtSqr(vcand[0])+dtSqr(vcand[2]) > dtSqr(vmax+cs/2)) continue;
+			
+			const float penalty = processSample(vcand, cs, pos,rad,vmax,vel,dvel, debug);
+			if (penalty < minPenalty)
+			{
+				minPenalty = penalty;
+				dtVcopy(nvel, vcand);
+			}
+		}
+	}
+}
+
+
+static const float DT_PI = 3.14159265f;
+
+void dtObstacleAvoidanceQuery::sampleVelocityAdaptive(const float* pos, const float rad, const float vmax,
+													  const float* vel, const float* dvel, float* nvel,
+													  const int ndivs, const int nrings, const int depth,
+													  dtObstacleAvoidanceDebugData* debug)
+{
+	prepare(pos, dvel);
+	
+	dtVset(nvel, 0,0,0);
+	
+	if (debug)
+		debug->reset();
+	
+	// Build sampling pattern aligned to desired velocity.
+	static const int MAX_PATTERN_DIVS = 32;
+	static const int MAX_PATTERN_RINGS = 4;
+	float pat[(MAX_PATTERN_DIVS*MAX_PATTERN_RINGS+1)*2];
+	int npat = 0;
+
+	const int nd = dtClamp(ndivs, 1, MAX_PATTERN_DIVS);
+	const int nr = dtClamp(nrings, 1, MAX_PATTERN_RINGS);
+	const float da = (1.0f/nd) * DT_PI*2;
+	const float dang = atan2f(dvel[2], dvel[0]);
+	
+	// Always add sample at zero
+	pat[npat*2+0] = 0;
+	pat[npat*2+1] = 0;
+	npat++;
+	
+	for (int j = 0; j < nr; ++j)
+	{
+		const float rad = (float)(nr-j)/(float)nr;
+		float a = dang + (j&1)*0.5f*da;
+		for (int i = 0; i < nd; ++i)
+		{
+			pat[npat*2+0] = cosf(a)*rad;
+			pat[npat*2+1] = sinf(a)*rad;
+			npat++;
+			a += da;
+		}
+	}
+
+	// Start sampling.
+	float cr = vmax * (1.0f-m_velBias);
+	float res[3];
+	dtVset(res, dvel[0] * m_velBias, 0, dvel[2] * m_velBias);
+
+	for (int k = 0; k < depth; ++k)
+	{
+		float minPenalty = FLT_MAX;
+		float bvel[3];
+		dtVset(bvel, 0,0,0);
+		
+		for (int i = 0; i < npat; ++i)
+		{
+			float vcand[3];
+			vcand[0] = res[0] + pat[i*2+0]*cr;
+			vcand[1] = 0;
+			vcand[2] = res[2] + pat[i*2+1]*cr;
+			
+			if (dtSqr(vcand[0])+dtSqr(vcand[2]) > dtSqr(vmax+0.001f)) continue;
+			
+			const float penalty = processSample(vcand,cr/10, pos,rad,vmax,vel,dvel, debug);
+			if (penalty < minPenalty)
+			{
+				minPenalty = penalty;
+				dtVcopy(bvel, vcand);
+			}
+		}
+
+		dtVcopy(res, bvel);
+
+		cr *= 0.5f;
+	}	
+	
+	dtVcopy(nvel, res);
+}
+
diff -r dc4fc5c8b306 dep/recastnavigation/Detour/DetourObstacleAvoidance.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Detour/DetourObstacleAvoidance.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,148 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef DETOUROBSTACLEAVOIDANCE_H
+#define DETOUROBSTACLEAVOIDANCE_H
+
+struct dtObstacleCircle
+{
+	float p[3];				// Position of the obstacle
+	float vel[3];			// Velocity of the obstacle
+	float dvel[3];			// Velocity of the obstacle
+	float rad;				// Radius of the obstacle
+	float dp[3], np[3];		// Use for side selection during sampling.
+};
+
+struct dtObstacleSegment
+{
+	float p[3], q[3];		// End points of the obstacle segment
+	bool touch;
+};
+
+static const int RVO_SAMPLE_RAD = 15;
+static const int MAX_RVO_SAMPLES = (RVO_SAMPLE_RAD*2+1)*(RVO_SAMPLE_RAD*2+1) + 100;
+
+class dtObstacleAvoidanceDebugData
+{
+public:
+	dtObstacleAvoidanceDebugData();
+	~dtObstacleAvoidanceDebugData();
+	
+	bool init(const int maxSamples);
+	void reset();
+	void addSample(const float* vel, const float ssize, const float pen,
+				   const float vpen, const float vcpen, const float spen, const float tpen);
+	
+	void normalizeSamples();
+	
+	inline int getSampleCount() const { return m_nsamples; }
+	inline const float* getSampleVelocity(const int i) const { return &m_vel[i*3]; }
+	inline float getSampleSize(const int i) const { return m_ssize[i]; }
+	inline float getSamplePenalty(const int i) const { return m_pen[i]; }
+	inline float getSampleDesiredVelocityPenalty(const int i) const { return m_vpen[i]; }
+	inline float getSampleCurrentVelocityPenalty(const int i) const { return m_vcpen[i]; }
+	inline float getSamplePreferredSidePenalty(const int i) const { return m_spen[i]; }
+	inline float getSampleCollisionTimePenalty(const int i) const { return m_tpen[i]; }
+
+private:
+	int m_nsamples;
+	int m_maxSamples;
+	float* m_vel;
+	float* m_ssize;
+	float* m_pen;
+	float* m_vpen;
+	float* m_vcpen;
+	float* m_spen;
+	float* m_tpen;
+};
+
+dtObstacleAvoidanceDebugData* dtAllocObstacleAvoidanceDebugData();
+void dtFreeObstacleAvoidanceDebugData(dtObstacleAvoidanceDebugData* ptr);
+
+
+class dtObstacleAvoidanceQuery
+{
+public:
+	dtObstacleAvoidanceQuery();
+	~dtObstacleAvoidanceQuery();
+	
+	bool init(const int maxCircles, const int maxSegments);
+	
+	void reset();
+
+	void addCircle(const float* pos, const float rad,
+				   const float* vel, const float* dvel);
+				   
+	void addSegment(const float* p, const float* q);
+
+	inline void setVelocitySelectionBias(float v) { m_velBias = v; }
+	inline void setDesiredVelocityWeight(float w) { m_weightDesVel = w; }
+	inline void setCurrentVelocityWeight(float w) { m_weightCurVel = w; }
+	inline void setPreferredSideWeight(float w) { m_weightSide = w; }
+	inline void setCollisionTimeWeight(float w) { m_weightToi = w; }
+	inline void setTimeHorizon(float t) { m_horizTime = t; }
+
+	void sampleVelocityGrid(const float* pos, const float rad, const float vmax,
+							const float* vel, const float* dvel, float* nvel,
+							const int gsize,
+							dtObstacleAvoidanceDebugData* debug = 0);
+
+	void sampleVelocityAdaptive(const float* pos, const float rad, const float vmax,
+								const float* vel, const float* dvel, float* nvel,
+								const int ndivs, const int nrings, const int depth, 
+								dtObstacleAvoidanceDebugData* debug = 0);
+	
+	inline int getObstacleCircleCount() const { return m_ncircles; }
+	const dtObstacleCircle* getObstacleCircle(const int i) { return &m_circles[i]; }
+
+	inline int getObstacleSegmentCount() const { return m_nsegments; }
+	const dtObstacleSegment* getObstacleSegment(const int i) { return &m_segments[i]; }
+
+private:
+
+	void prepare(const float* pos, const float* dvel);
+
+	float processSample(const float* vcand, const float cs,
+						const float* pos, const float rad,
+						const float vmax, const float* vel, const float* dvel,
+						dtObstacleAvoidanceDebugData* debug);
+
+	dtObstacleCircle* insertCircle(const float dist);
+	dtObstacleSegment* insertSegment(const float dist);
+
+	float m_velBias;
+	float m_weightDesVel;
+	float m_weightCurVel;
+	float m_weightSide;
+	float m_weightToi;
+	float m_horizTime;
+	
+	int m_maxCircles;
+	dtObstacleCircle* m_circles;
+	int m_ncircles;
+
+	int m_maxSegments;
+	dtObstacleSegment* m_segments;
+	int m_nsegments;
+};
+
+dtObstacleAvoidanceQuery* dtAllocObstacleAvoidanceQuery();
+void dtFreeObstacleAvoidanceQuery(dtObstacleAvoidanceQuery* ptr);
+
+
+#endif // DETOUROBSTACLEAVOIDANCE_H
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/CMakeLists.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,31 @@
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+set(Recast_STAT_SRCS
+    Recast.cpp 
+    RecastAlloc.cpp 
+    RecastArea.cpp 
+    RecastContour.cpp 
+    RecastFilter.cpp 
+    RecastMesh.cpp 
+    RecastMeshDetail.cpp 
+    RecastRasterization.cpp 
+    RecastRegion.cpp 
+)
+
+if(WIN32)
+  include_directories(
+    ${CMAKE_SOURCE_DIR}/dep/zlib
+  )
+endif()
+
+add_library(Recast STATIC ${Recast_STAT_SRCS})
+
+target_link_libraries(Recast ${ZLIB_LIBRARIES})
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/Recast.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/Recast.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,423 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <float.h>
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+float rcSqrt(float x)
+{
+	return sqrtf(x);
+}
+
+
+void rcContext::log(const rcLogCategory category, const char* format, ...)
+{
+	if (!m_logEnabled)
+		return;
+	static const int MSG_SIZE = 512;
+	char msg[MSG_SIZE];
+	va_list ap;
+	va_start(ap, format);
+	int len = vsnprintf(msg, MSG_SIZE, format, ap);
+	if (len >= MSG_SIZE)
+	{
+		len = MSG_SIZE-1;
+		msg[MSG_SIZE-1] = '\0';
+	}
+	va_end(ap);
+	doLog(category, msg, len);
+}
+
+rcHeightfield* rcAllocHeightfield()
+{
+	rcHeightfield* hf = (rcHeightfield*)rcAlloc(sizeof(rcHeightfield), RC_ALLOC_PERM);
+	memset(hf, 0, sizeof(rcHeightfield));
+	return hf;
+}
+
+void rcFreeHeightField(rcHeightfield* hf)
+{
+	if (!hf) return;
+	// Delete span array.
+	rcFree(hf->spans);
+	// Delete span pools.
+	while (hf->pools)
+	{
+		rcSpanPool* next = hf->pools->next;
+		rcFree(hf->pools);
+		hf->pools = next;
+	}
+	rcFree(hf);
+}
+
+rcCompactHeightfield* rcAllocCompactHeightfield()
+{
+	rcCompactHeightfield* chf = (rcCompactHeightfield*)rcAlloc(sizeof(rcCompactHeightfield), RC_ALLOC_PERM);
+	memset(chf, 0, sizeof(rcCompactHeightfield));
+	return chf;
+}
+
+void rcFreeCompactHeightfield(rcCompactHeightfield* chf)
+{
+	if (!chf) return;
+	rcFree(chf->cells);
+	rcFree(chf->spans);
+	rcFree(chf->dist);
+	rcFree(chf->areas);
+	rcFree(chf);
+}
+
+rcContourSet* rcAllocContourSet()
+{
+	rcContourSet* cset = (rcContourSet*)rcAlloc(sizeof(rcContourSet), RC_ALLOC_PERM);
+	memset(cset, 0, sizeof(rcContourSet));
+	return cset;
+}
+
+void rcFreeContourSet(rcContourSet* cset)
+{
+	if (!cset) return;
+	for (int i = 0; i < cset->nconts; ++i)
+	{
+		rcFree(cset->conts[i].verts);
+		rcFree(cset->conts[i].rverts);
+	}
+	rcFree(cset->conts);
+	rcFree(cset);
+}
+
+rcPolyMesh* rcAllocPolyMesh()
+{
+	rcPolyMesh* pmesh = (rcPolyMesh*)rcAlloc(sizeof(rcPolyMesh), RC_ALLOC_PERM);
+	memset(pmesh, 0, sizeof(rcPolyMesh));
+	return pmesh;
+}
+
+void rcFreePolyMesh(rcPolyMesh* pmesh)
+{
+	if (!pmesh) return;
+	rcFree(pmesh->verts);
+	rcFree(pmesh->polys);
+	rcFree(pmesh->regs);
+	rcFree(pmesh->flags);
+	rcFree(pmesh->areas);
+	rcFree(pmesh);
+}
+
+rcPolyMeshDetail* rcAllocPolyMeshDetail()
+{
+	rcPolyMeshDetail* dmesh = (rcPolyMeshDetail*)rcAlloc(sizeof(rcPolyMeshDetail), RC_ALLOC_PERM);
+	memset(dmesh, 0, sizeof(rcPolyMeshDetail));
+	return dmesh;
+}
+
+void rcFreePolyMeshDetail(rcPolyMeshDetail* dmesh)
+{
+	if (!dmesh) return;
+	rcFree(dmesh->meshes);
+	rcFree(dmesh->verts);
+	rcFree(dmesh->tris);
+	rcFree(dmesh);
+}
+
+
+void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax)
+{
+	// Calculate bounding box.
+	rcVcopy(bmin, verts);
+	rcVcopy(bmax, verts);
+	for (int i = 1; i < nv; ++i)
+	{
+		const float* v = &verts[i*3];
+		rcVmin(bmin, v);
+		rcVmax(bmax, v);
+	}
+}
+
+void rcCalcGridSize(const float* bmin, const float* bmax, float cs, int* w, int* h)
+{
+	*w = (int)((bmax[0] - bmin[0])/cs+0.5f);
+	*h = (int)((bmax[2] - bmin[2])/cs+0.5f);
+}
+
+bool rcCreateHeightfield(rcContext* /*ctx*/, rcHeightfield& hf, int width, int height,
+						 const float* bmin, const float* bmax,
+						 float cs, float ch)
+{
+	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
+//	rcAssert(ctx);
+	
+	hf.width = width;
+	hf.height = height;
+	rcVcopy(hf.bmin, bmin);
+	rcVcopy(hf.bmax, bmax);
+	hf.cs = cs;
+	hf.ch = ch;
+	hf.spans = (rcSpan**)rcAlloc(sizeof(rcSpan*)*hf.width*hf.height, RC_ALLOC_PERM);
+	if (!hf.spans)
+		return false;
+	memset(hf.spans, 0, sizeof(rcSpan*)*hf.width*hf.height);
+	return true;
+}
+
+static void calcTriNormal(const float* v0, const float* v1, const float* v2, float* norm)
+{
+	float e0[3], e1[3];
+	rcVsub(e0, v1, v0);
+	rcVsub(e1, v2, v0);
+	rcVcross(norm, e0, e1);
+	rcVnormalize(norm);
+}
+
+void rcMarkWalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
+							 const float* verts, int /*nv*/,
+							 const int* tris, int nt,
+							 unsigned char* areas)
+{
+	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
+//	rcAssert(ctx);
+	
+	const float walkableThr = cosf(walkableSlopeAngle/180.0f*RC_PI);
+
+	float norm[3];
+	
+	for (int i = 0; i < nt; ++i)
+	{
+		const int* tri = &tris[i*3];
+		calcTriNormal(&verts[tri[0]*3], &verts[tri[1]*3], &verts[tri[2]*3], norm);
+		// Check if the face is walkable.
+		if (norm[1] > walkableThr)
+			areas[i] = RC_WALKABLE_AREA;
+	}
+}
+
+void rcClearUnwalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
+								const float* verts, int /*nv*/,
+								const int* tris, int nt,
+								unsigned char* areas)
+{
+	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
+//	rcAssert(ctx);
+	
+	const float walkableThr = cosf(walkableSlopeAngle/180.0f*RC_PI);
+	
+	float norm[3];
+	
+	for (int i = 0; i < nt; ++i)
+	{
+		const int* tri = &tris[i*3];
+		calcTriNormal(&verts[tri[0]*3], &verts[tri[1]*3], &verts[tri[2]*3], norm);
+		// Check if the face is walkable.
+		if (norm[1] <= walkableThr)
+			areas[i] = RC_NULL_AREA;
+	}
+}
+
+int rcGetHeightFieldSpanCount(rcContext* /*ctx*/, rcHeightfield& hf)
+{
+	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
+//	rcAssert(ctx);
+	
+	const int w = hf.width;
+	const int h = hf.height;
+	int spanCount = 0;
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			for (rcSpan* s = hf.spans[x + y*w]; s; s = s->next)
+			{
+				if (s->area != RC_NULL_AREA)
+					spanCount++;
+			}
+		}
+	}
+	return spanCount;
+}
+
+bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
+							   rcHeightfield& hf, rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_COMPACTHEIGHTFIELD);
+	
+	const int w = hf.width;
+	const int h = hf.height;
+	const int spanCount = rcGetHeightFieldSpanCount(ctx, hf);
+
+	// Fill in header.
+	chf.width = w;
+	chf.height = h;
+	chf.spanCount = spanCount;
+	chf.walkableHeight = walkableHeight;
+	chf.walkableClimb = walkableClimb;
+	chf.maxRegions = 0;
+	rcVcopy(chf.bmin, hf.bmin);
+	rcVcopy(chf.bmax, hf.bmax);
+	chf.bmax[1] += walkableHeight*hf.ch;
+	chf.cs = hf.cs;
+	chf.ch = hf.ch;
+	chf.cells = (rcCompactCell*)rcAlloc(sizeof(rcCompactCell)*w*h, RC_ALLOC_PERM);
+	if (!chf.cells)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildCompactHeightfield: Out of memory 'chf.cells' (%d)", w*h);
+		return false;
+	}
+	memset(chf.cells, 0, sizeof(rcCompactCell)*w*h);
+	chf.spans = (rcCompactSpan*)rcAlloc(sizeof(rcCompactSpan)*spanCount, RC_ALLOC_PERM);
+	if (!chf.spans)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildCompactHeightfield: Out of memory 'chf.spans' (%d)", spanCount);
+		return false;
+	}
+	memset(chf.spans, 0, sizeof(rcCompactSpan)*spanCount);
+	chf.areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*spanCount, RC_ALLOC_PERM);
+	if (!chf.areas)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildCompactHeightfield: Out of memory 'chf.areas' (%d)", spanCount);
+		return false;
+	}
+	memset(chf.areas, RC_NULL_AREA, sizeof(unsigned char)*spanCount);
+	
+	const int MAX_HEIGHT = 0xffff;
+	
+	// Fill in cells and spans.
+	int idx = 0;
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcSpan* s = hf.spans[x + y*w];
+			// If there are no spans at this cell, just leave the data to index=0, count=0.
+			if (!s) continue;
+			rcCompactCell& c = chf.cells[x+y*w];
+			c.index = idx;
+			c.count = 0;
+			while (s)
+			{
+				if (s->area != RC_NULL_AREA)
+				{
+					const int bot = (int)s->smax;
+					const int top = s->next ? (int)s->next->smin : MAX_HEIGHT;
+					chf.spans[idx].y = (unsigned short)rcClamp(bot, 0, 0xffff);
+					chf.spans[idx].h = (unsigned char)rcClamp(top - bot, 0, 0xff);
+					chf.areas[idx] = s->area;
+					idx++;
+					c.count++;
+				}
+				s = s->next;
+			}
+		}
+	}
+
+	// Find neighbour connections.
+	const int MAX_LAYERS = RC_NOT_CONNECTED-1;
+	int tooHighNeighbour = 0;
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				rcCompactSpan& s = chf.spans[i];
+				
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					rcSetCon(s, dir, RC_NOT_CONNECTED);
+					const int nx = x + rcGetDirOffsetX(dir);
+					const int ny = y + rcGetDirOffsetY(dir);
+					// First check that the neighbour cell is in bounds.
+					if (nx < 0 || ny < 0 || nx >= w || ny >= h)
+						continue;
+						
+					// Iterate over all neighbour spans and check if any of the is
+					// accessible from current cell.
+					const rcCompactCell& nc = chf.cells[nx+ny*w];
+					for (int k = (int)nc.index, nk = (int)(nc.index+nc.count); k < nk; ++k)
+					{
+						const rcCompactSpan& ns = chf.spans[k];
+						const int bot = rcMax(s.y, ns.y);
+						const int top = rcMin(s.y+s.h, ns.y+ns.h);
+
+						// Check that the gap between the spans is walkable,
+						// and that the climb height between the gaps is not too high.
+						if ((top - bot) >= walkableHeight && rcAbs((int)ns.y - (int)s.y) <= walkableClimb)
+						{
+							// Mark direction as walkable.
+							const int idx = k - (int)nc.index;
+							if (idx < 0 || idx > MAX_LAYERS)
+							{
+								tooHighNeighbour = rcMax(tooHighNeighbour, idx);
+								continue;
+							}
+							rcSetCon(s, dir, idx);
+							break;
+						}
+					}
+					
+				}
+			}
+		}
+	}
+	
+	if (tooHighNeighbour > MAX_LAYERS)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildCompactHeightfield: Heightfield has too many layers %d (max: %d)",
+				 tooHighNeighbour, MAX_LAYERS);
+	}
+		
+	ctx->stopTimer(RC_TIMER_BUILD_COMPACTHEIGHTFIELD);
+	
+	return true;
+}
+
+/*
+static int getHeightfieldMemoryUsage(const rcHeightfield& hf)
+{
+	int size = 0;
+	size += sizeof(hf);
+	size += hf.width * hf.height * sizeof(rcSpan*);
+	
+	rcSpanPool* pool = hf.pools;
+	while (pool)
+	{
+		size += (sizeof(rcSpanPool) - sizeof(rcSpan)) + sizeof(rcSpan)*RC_SPANS_PER_POOL;
+		pool = pool->next;
+	}
+	return size;
+}
+
+static int getCompactHeightFieldMemoryusage(const rcCompactHeightfield& chf)
+{
+	int size = 0;
+	size += sizeof(rcCompactHeightfield);
+	size += sizeof(rcCompactSpan) * chf.spanCount;
+	size += sizeof(rcCompactCell) * chf.width * chf.height;
+	return size;
+}
+*/
\ No newline at end of file
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/Recast.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/Recast.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,688 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+ 
+#ifndef RECAST_H
+#define RECAST_H
+
+// Some math headers don't have PI defined.
+static const float RC_PI = 3.14159265f;
+
+enum rcLogCategory
+{
+	RC_LOG_PROGRESS = 1,
+	RC_LOG_WARNING,
+	RC_LOG_ERROR,
+};
+
+enum rcTimerLabel
+{
+	RC_TIMER_TOTAL,
+	RC_TIMER_TEMP,
+	RC_TIMER_RASTERIZE_TRIANGLES,
+	RC_TIMER_BUILD_COMPACTHEIGHTFIELD,
+	RC_TIMER_BUILD_CONTOURS,
+	RC_TIMER_BUILD_CONTOURS_TRACE,
+	RC_TIMER_BUILD_CONTOURS_SIMPLIFY,
+	RC_TIMER_FILTER_BORDER,
+	RC_TIMER_FILTER_WALKABLE,
+	RC_TIMER_MEDIAN_AREA,
+	RC_TIMER_FILTER_LOW_OBSTACLES,
+	RC_TIMER_BUILD_POLYMESH,
+	RC_TIMER_MERGE_POLYMESH,
+	RC_TIMER_ERODE_AREA,
+	RC_TIMER_MARK_BOX_AREA,
+	RC_TIMER_MARK_CONVEXPOLY_AREA,
+	RC_TIMER_BUILD_DISTANCEFIELD,
+	RC_TIMER_BUILD_DISTANCEFIELD_DIST,
+	RC_TIMER_BUILD_DISTANCEFIELD_BLUR,
+	RC_TIMER_BUILD_REGIONS,
+	RC_TIMER_BUILD_REGIONS_WATERSHED,
+	RC_TIMER_BUILD_REGIONS_EXPAND,
+	RC_TIMER_BUILD_REGIONS_FLOOD,
+	RC_TIMER_BUILD_REGIONS_FILTER,
+	RC_TIMER_BUILD_POLYMESHDETAIL,
+	RC_TIMER_MERGE_POLYMESHDETAIL,
+	RC_MAX_TIMERS
+};
+
+// Build context provides several optional utilities needed for the build process,
+// such as timing, logging, and build time collecting. 
+class rcContext
+{
+public:
+	inline rcContext(bool state = true) : m_logEnabled(state), m_timerEnabled(state) {}
+	virtual ~rcContext() {}
+
+	// Enables or disables logging.
+	inline void enableLog(bool state) { m_logEnabled = state; }
+	// Resets log.
+	inline void resetLog() { if (m_logEnabled) doResetLog(); }
+	// Logs a message.
+	void log(const rcLogCategory category, const char* format, ...);
+
+	// Enables or disables timer.
+	inline void enableTimer(bool state) { m_timerEnabled = state; }
+	// Resets all timers.
+	inline void resetTimers() { if (m_timerEnabled) doResetTimers(); }
+	// Starts timer, used for performance timing.
+	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }
+	// Stops timer, used for performance timing.
+	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }
+	// Returns time accumulated between timer start/stop.
+	inline int getAccumulatedTime(const rcTimerLabel label) const { return m_timerEnabled ? doGetAccumulatedTime(label) : -1; }
+
+protected:
+	// Virtual functions to override for custom implementations.
+	virtual void doResetLog() {}
+	virtual void doLog(const rcLogCategory /*category*/, const char* /*msg*/, const int /*len*/) {}
+	virtual void doResetTimers() {}
+	virtual void doStartTimer(const rcTimerLabel /*label*/) {}
+	virtual void doStopTimer(const rcTimerLabel /*label*/) {}
+	virtual int doGetAccumulatedTime(const rcTimerLabel /*label*/) const { return -1; }
+	
+	bool m_logEnabled;
+	bool m_timerEnabled;
+};
+
+
+// The units of the parameters are specified in parenthesis as follows:
+// (vx) voxels, (wu) world units
+struct rcConfig
+{
+	int width, height;				// Dimensions of the rasterized heightfield (vx)
+	int tileSize;					// Width and Height of a tile (vx)
+	int borderSize;					// Non-navigable Border around the heightfield (vx)
+	float cs, ch;					// Grid cell size and height (wu)
+	float bmin[3], bmax[3];			// Grid bounds (wu)
+	float walkableSlopeAngle;		// Maximum walkable slope angle in degrees.
+	int walkableHeight;				// Minimum height where the agent can still walk (vx)
+	int walkableClimb;				// Maximum height between grid cells the agent can climb (vx)
+	int walkableRadius;				// Radius of the agent in cells (vx)
+	int maxEdgeLen;					// Maximum contour edge length (vx)
+	float maxSimplificationError;	// Maximum distance error from contour to cells (vx)
+	int minRegionArea;				// Regions whose area is smaller than this threshold will be removed. (vx)
+	int mergeRegionArea;			// Regions whose area is smaller than this threshold will be merged (vx)
+	int maxVertsPerPoly;			// Max number of vertices per polygon
+	float detailSampleDist;			// Detail mesh sample spacing.
+	float detailSampleMaxError;		// Detail mesh simplification max sample error.
+};
+
+// Define number of bits in the above structure for smin/smax.
+// The max height is used for clamping rasterized values.
+static const int RC_SPAN_HEIGHT_BITS = 16;
+static const int RC_SPAN_MAX_HEIGHT = (1<<RC_SPAN_HEIGHT_BITS)-1;
+
+// Heightfield span.
+struct rcSpan
+{
+	unsigned int smin : 16;			// Span min height.
+	unsigned int smax : 16;			// Span max height.
+    unsigned char area;				// Span area type.
+	rcSpan* next;					// Next span in column.
+};
+
+// Number of spans allocated per pool.
+static const int RC_SPANS_PER_POOL = 2048;
+
+// Memory pool used for quick span allocation.
+struct rcSpanPool
+{
+	rcSpanPool* next;					// Pointer to next pool.
+	rcSpan items[RC_SPANS_PER_POOL];	// Array of spans.
+};
+
+// Dynamic span-heightfield.
+struct rcHeightfield
+{
+	int width, height;			// Dimension of the heightfield.
+	float bmin[3], bmax[3];		// Bounding box of the heightfield
+	float cs, ch;				// Cell size and height.
+	rcSpan** spans;				// Heightfield of spans (width*height).
+	rcSpanPool* pools;			// Linked list of span pools.
+	rcSpan* freelist;			// Pointer to next free span.
+};
+
+rcHeightfield* rcAllocHeightfield();
+void rcFreeHeightField(rcHeightfield* hf);
+
+
+struct rcCompactCell
+{
+	unsigned int index : 24;	// Index to first span in column.
+	unsigned int count : 8;		// Number of spans in this column.
+};
+
+struct rcCompactSpan
+{
+	unsigned short y;			// Bottom coordinate of the span.
+	unsigned short reg;
+	unsigned int con : 24;		// Connections to neighbour cells.
+	unsigned int h : 8;			// Height of the span.
+};
+
+// Compact static heightfield. 
+struct rcCompactHeightfield
+{
+	int width, height;					// Width and height of the heightfield.
+	int spanCount;						// Number of spans in the heightfield.
+	int walkableHeight, walkableClimb;	// Agent properties.
+	unsigned short maxDistance;			// Maximum distance value stored in heightfield.
+	unsigned short maxRegions;			// Maximum Region Id stored in heightfield.
+	float bmin[3], bmax[3];				// Bounding box of the heightfield.
+	float cs, ch;						// Cell size and height.
+	rcCompactCell* cells;				// Pointer to width*height cells.
+	rcCompactSpan* spans;				// Pointer to spans.
+	unsigned short* dist;				// Pointer to per span distance to border.
+	unsigned char* areas;				// Pointer to per span area ID.
+};
+
+rcCompactHeightfield* rcAllocCompactHeightfield();
+void rcFreeCompactHeightfield(rcCompactHeightfield* chf);
+
+
+struct rcContour
+{
+	int* verts;			// Vertex coordinates, each vertex contains 4 components.
+	int nverts;			// Number of vertices.
+	int* rverts;		// Raw vertex coordinates, each vertex contains 4 components.
+	int nrverts;		// Number of raw vertices.
+	unsigned short reg;	// Region ID of the contour.
+	unsigned char area;	// Area ID of the contour.
+};
+
+struct rcContourSet
+{
+	rcContour* conts;		// Pointer to all contours.
+	int nconts;				// Number of contours.
+	float bmin[3], bmax[3];	// Bounding box of the heightfield.
+	float cs, ch;			// Cell size and height.
+};
+
+rcContourSet* rcAllocContourSet();
+void rcFreeContourSet(rcContourSet* cset);
+
+
+// Polymesh store a connected mesh of polygons.
+// The polygons are store in an array where each polygons takes
+// 'nvp*2' elements. The first 'nvp' elements are indices to vertices
+// and the second 'nvp' elements are indices to neighbour polygons.
+// If a polygon has less than 'bvp' vertices, the remaining indices
+// are set to RC_MESH_NULL_IDX. If an polygon edge does not have a neighbour
+// the neighbour index is set to RC_MESH_NULL_IDX.
+// Vertices can be transformed into world space as follows:
+//   x = bmin[0] + verts[i*3+0]*cs;
+//   y = bmin[1] + verts[i*3+1]*ch;
+//   z = bmin[2] + verts[i*3+2]*cs;
+struct rcPolyMesh
+{	
+	unsigned short* verts;	// Vertices of the mesh, 3 elements per vertex.
+	unsigned short* polys;	// Polygons of the mesh, nvp*2 elements per polygon.
+	unsigned short* regs;	// Region ID of the polygons.
+	unsigned short* flags;	// Per polygon flags.
+	unsigned char* areas;	// Area ID of polygons.
+	int nverts;				// Number of vertices.
+	int npolys;				// Number of polygons.
+	int maxpolys;			// Number of allocated polygons.
+	int nvp;				// Max number of vertices per polygon.
+	float bmin[3], bmax[3];	// Bounding box of the mesh.
+	float cs, ch;			// Cell size and height.
+};
+
+rcPolyMesh* rcAllocPolyMesh();
+void rcFreePolyMesh(rcPolyMesh* pmesh);
+
+
+// Detail mesh generated from a rcPolyMesh.
+// Each submesh represents a polygon in the polymesh and they are stored in
+// exactly same order. Each submesh is described as 4 values:
+// base vertex, vertex count, base triangle, triangle count. That is,
+//   const unsigned char* t = &dmesh.tris[(tbase+i)*3]; and
+//   const float* v = &dmesh.verts[(vbase+t[j])*3];
+// If the input polygon has 'n' vertices, those vertices are first in the
+// submesh vertex list. This allows to compres the mesh by not storing the
+// first vertices and using the polymesh vertices instead.
+// Max number of vertices per submesh is 127 and
+// max number of triangles per submesh is 255.
+
+struct rcPolyMeshDetail
+{
+	unsigned int* meshes;	// Pointer to all mesh data.
+	float* verts;			// Pointer to all vertex data.
+	unsigned char* tris;	// Pointer to all triangle data.
+	int nmeshes;			// Number of meshes.
+	int nverts;				// Number of total vertices.
+	int ntris;				// Number of triangles.
+};
+
+rcPolyMeshDetail* rcAllocPolyMeshDetail();
+void rcFreePolyMeshDetail(rcPolyMeshDetail* dmesh);
+
+
+// If heightfield region ID has the following bit set, the region is on border area
+// and excluded from many calculations.
+static const unsigned short RC_BORDER_REG = 0x8000;
+
+// If contour region ID has the following bit set, the vertex will be later
+// removed in order to match the segments and vertices at tile boundaries.
+static const int RC_BORDER_VERTEX = 0x10000;
+
+static const int RC_AREA_BORDER = 0x20000;
+
+enum rcBuildContoursFlags
+{
+	RC_CONTOUR_TESS_WALL_EDGES = 0x01,	// Tessellate wall edges
+	RC_CONTOUR_TESS_AREA_EDGES = 0x02,	// Tessellate edges between areas.
+};
+
+// Mask used with contours to extract region id.
+static const int RC_CONTOUR_REG_MASK = 0xffff;
+
+// Null index which is used with meshes to mark unset or invalid indices.
+static const unsigned short RC_MESH_NULL_IDX = 0xffff;
+
+// Area ID that is considered empty.
+static const unsigned char RC_NULL_AREA = 0;
+
+// Area ID that is considered generally walkable.
+static const unsigned char RC_WALKABLE_AREA = 63;
+
+// Value returned by rcGetCon() if the direction is not connected.
+static const int RC_NOT_CONNECTED = 0x3f;
+
+// Compact span neighbour helpers.
+inline void rcSetCon(rcCompactSpan& s, int dir, int i)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	unsigned int con = s.con;
+	s.con = (con & ~(0x3f << shift)) | (((unsigned int)i & 0x3f) << shift);
+}
+
+inline int rcGetCon(const rcCompactSpan& s, int dir)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	return (s.con >> shift) & 0x3f;
+}
+
+inline int rcGetDirOffsetX(int dir)
+{
+	const int offset[4] = { -1, 0, 1, 0, };
+	return offset[dir&0x03];
+}
+
+inline int rcGetDirOffsetY(int dir)
+{
+	const int offset[4] = { 0, 1, 0, -1 };
+	return offset[dir&0x03];
+}
+
+// Common helper functions
+template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }
+template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }
+template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
+template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }
+template<class T> inline T rcSqr(T a) { return a*a; }
+template<class T> inline T rcClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
+float rcSqrt(float x);
+
+// Common vector helper functions.
+inline void rcVcross(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
+	dest[1] = v1[2]*v2[0] - v1[0]*v2[2];
+	dest[2] = v1[0]*v2[1] - v1[1]*v2[0];
+}
+
+inline float rcVdot(const float* v1, const float* v2)
+{
+	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
+}
+
+inline void rcVmad(float* dest, const float* v1, const float* v2, const float s)
+{
+	dest[0] = v1[0]+v2[0]*s;
+	dest[1] = v1[1]+v2[1]*s;
+	dest[2] = v1[2]+v2[2]*s;
+}
+
+inline void rcVadd(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[0]+v2[0];
+	dest[1] = v1[1]+v2[1];
+	dest[2] = v1[2]+v2[2];
+}
+
+inline void rcVsub(float* dest, const float* v1, const float* v2)
+{
+	dest[0] = v1[0]-v2[0];
+	dest[1] = v1[1]-v2[1];
+	dest[2] = v1[2]-v2[2];
+}
+
+inline void rcVmin(float* mn, const float* v)
+{
+	mn[0] = rcMin(mn[0], v[0]);
+	mn[1] = rcMin(mn[1], v[1]);
+	mn[2] = rcMin(mn[2], v[2]);
+}
+
+inline void rcVmax(float* mx, const float* v)
+{
+	mx[0] = rcMax(mx[0], v[0]);
+	mx[1] = rcMax(mx[1], v[1]);
+	mx[2] = rcMax(mx[2], v[2]);
+}
+
+inline void rcVcopy(float* dest, const float* v)
+{
+	dest[0] = v[0];
+	dest[1] = v[1];
+	dest[2] = v[2];
+}
+
+inline float rcVdist(const float* v1, const float* v2)
+{
+	float dx = v2[0] - v1[0];
+	float dy = v2[1] - v1[1];
+	float dz = v2[2] - v1[2];
+	return rcSqrt(dx*dx + dy*dy + dz*dz);
+}
+
+inline float rcVdistSqr(const float* v1, const float* v2)
+{
+	float dx = v2[0] - v1[0];
+	float dy = v2[1] - v1[1];
+	float dz = v2[2] - v1[2];
+	return dx*dx + dy*dy + dz*dz;
+}
+
+inline void rcVnormalize(float* v)
+{
+	float d = 1.0f / rcSqrt(rcSqr(v[0]) + rcSqr(v[1]) + rcSqr(v[2]));
+	v[0] *= d;
+	v[1] *= d;
+	v[2] *= d;
+}
+
+inline bool rcVequal(const float* p0, const float* p1)
+{
+	static const float thr = rcSqr(1.0f/16384.0f);
+	const float d = rcVdistSqr(p0, p1);
+	return d < thr;
+}
+
+// Calculated bounding box of array of vertices.
+// Params:
+//	verts - (in) array of vertices
+//	nv - (in) vertex count
+//	bmin, bmax - (out) bounding box
+void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax);
+
+// Calculates grid size based on bounding box and grid cell size.
+// Params:
+//	bmin, bmax - (in) bounding box
+//	cs - (in) grid cell size
+//	w - (out) grid width
+//	h - (out) grid height
+void rcCalcGridSize(const float* bmin, const float* bmax, float cs, int* w, int* h);
+
+// Creates and initializes new heightfield.
+// Params:
+//	hf - (in/out) heightfield to initialize.
+//	width - (in) width of the heightfield.
+//	height - (in) height of the heightfield.
+//	bmin, bmax - (in) bounding box of the heightfield
+//	cs - (in) grid cell size
+//	ch - (in) grid cell height
+bool rcCreateHeightfield(rcContext* ctx, rcHeightfield& hf, int width, int height,
+						 const float* bmin, const float* bmax,
+						 float cs, float ch);
+
+// Sets the RC_WALKABLE_AREA for every triangle whose slope is below
+// the maximum walkable slope angle.
+// Params:
+//	walkableSlopeAngle - (in) maximum slope angle in degrees.
+//	verts - (in) array of vertices
+//	nv - (in) vertex count
+//	tris - (in) array of triangle vertex indices
+//	nt - (in) triangle count
+//	areas - (out) array of triangle area types
+void rcMarkWalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
+							 const int* tris, int nt, unsigned char* areas); 
+
+// Sets the RC_NULL_AREA for every triangle whose slope is steeper than
+// the maximum walkable slope angle.
+// Params:
+//	walkableSlopeAngle - (in) maximum slope angle in degrees.
+//	verts - (in) array of vertices
+//	nv - (in) vertex count
+//	tris - (in) array of triangle vertex indices
+//	nt - (in) triangle count
+//	areas - (out) array of triangle are types
+void rcClearUnwalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
+								const int* tris, int nt, unsigned char* areas); 
+
+// Adds span to heightfield.
+// The span addition can set to favor flags. If the span is merged to
+// another span and the new smax is within 'flagMergeThr' units away
+// from the existing span the span flags are merged and stored.
+// Params:
+//	solid - (in) heightfield where the spans is added to
+//  x,y - (in) location on the heightfield where the span is added
+//  smin,smax - (in) spans min/max height
+//  flags - (in) span flags (zero or WALKABLE)
+//  flagMergeThr - (in) merge threshold.
+void rcAddSpan(rcContext* ctx, rcHeightfield& solid, const int x, const int y,
+			   const unsigned short smin, const unsigned short smax,
+			   const unsigned short area, const int flagMergeThr);
+
+// Rasterizes a triangle into heightfield spans.
+// Params:
+//	v0,v1,v2 - (in) the vertices of the triangle.
+//	area - (in) area type of the triangle.
+//	solid - (in) heightfield where the triangle is rasterized
+//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
+						 const unsigned char area, rcHeightfield& solid,
+						 const int flagMergeThr = 1);
+
+// Rasterizes indexed triangle mesh into heightfield spans.
+// Params:
+//	verts - (in) array of vertices
+//	nv - (in) vertex count
+//	tris - (in) array of triangle vertex indices
+//	area - (in) array of triangle area types.
+//	nt - (in) triangle count
+//	solid - (in) heightfield where the triangles are rasterized
+//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
+						  const int* tris, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr = 1);
+
+// Rasterizes indexed triangle mesh into heightfield spans.
+// Params:
+//	verts - (in) array of vertices
+//	nv - (in) vertex count
+//	tris - (in) array of triangle vertex indices
+//	area - (in) array of triangle area types.
+//	nt - (in) triangle count
+//	solid - (in) heightfield where the triangles are rasterized
+//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
+						  const unsigned short* tris, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr = 1);
+
+// Rasterizes the triangles into heightfield spans.
+// Params:
+//	verts - (in) array of vertices
+//	area - (in) array of triangle area types.
+//	nt - (in) triangle count
+//	solid - (in) heightfield where the triangles are rasterized
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr = 1);
+
+// Marks non-walkable low obstacles as walkable if they are closer than walkableClimb
+// from a walkable surface. Applying this filter allows to step over low hanging
+// low obstacles.
+// Params:
+//	walkableHeight - (in) minimum height where the agent can still walk
+//	solid - (in/out) heightfield describing the solid space
+// TODO: Missuses ledge flag, must be called before rcFilterLedgeSpans!
+void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid);
+
+// Removes WALKABLE flag from all spans that are at ledges. This filtering
+// removes possible overestimation of the conservative voxelization so that
+// the resulting mesh will not have regions hanging in air over ledges.
+// Params:
+//	walkableHeight - (in) minimum height where the agent can still walk
+//	walkableClimb - (in) maximum height between grid cells the agent can climb
+//	solid - (in/out) heightfield describing the solid space
+void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight,
+						const int walkableClimb, rcHeightfield& solid);
+
+// Removes WALKABLE flag from all spans which have smaller than
+// 'walkableHeight' clearance above them.
+// Params:
+//	walkableHeight - (in) minimum height where the agent can still walk
+//	solid - (in/out) heightfield describing the solid space
+void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid);
+
+// Returns number of spans contained in a heightfield.
+// Params:
+//	hf - (in) heightfield to be compacted
+// Returns number of spans.
+int rcGetHeightFieldSpanCount(rcContext* ctx, rcHeightfield& hf);
+
+// Builds compact representation of the heightfield.
+// Params:
+//	walkableHeight - (in) minimum height where the agent can still walk
+//	walkableClimb - (in) maximum height between grid cells the agent can climb
+//  flags - (in) require flags for a cell to be included in the compact heightfield.
+//	hf - (in) heightfield to be compacted
+//	chf - (out) compact heightfield representing the open space.
+// Returns false if operation ran out of memory.
+bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
+							   rcHeightfield& hf, rcCompactHeightfield& chf);
+
+// Erodes walkable area.
+// Params:
+//  radius - (in) radius of erosion (max 255).
+//	chf - (in/out) compact heightfield to erode.
+// Returns false if operation ran out of memory.
+bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf);
+
+// Applies median filter to walkable area types, removing noise.
+// Params:
+//	chf - (in/out) compact heightfield to erode.
+// Returns false if operation ran out of memory.
+bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf);
+
+// Marks the area of the convex polygon into the area type of the compact heightfield.
+// Params:
+//  bmin/bmax - (in) bounds of the axis aligned box.
+//  areaId - (in) area ID to mark.
+//	chf - (in/out) compact heightfield to mark.
+void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
+				   rcCompactHeightfield& chf);
+
+// Marks the area of the convex polygon into the area type of the compact heightfield.
+// Params:
+//  verts - (in) vertices of the convex polygon.
+//  nverts - (in) number of vertices in the polygon.
+//  hmin/hmax - (in) min and max height of the polygon.
+//  areaId - (in) area ID to mark.
+//	chf - (in/out) compact heightfield to mark.
+void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
+						  const float hmin, const float hmax, unsigned char areaId,
+						  rcCompactHeightfield& chf);
+
+// Builds distance field and stores it into the combat heightfield.
+// Params:
+//	chf - (in/out) compact heightfield representing the open space.
+// Returns false if operation ran out of memory.
+bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf);
+
+// Divides the walkable heighfied into simple regions using watershed partitioning.
+// Each region has only one contour and no overlaps.
+// The regions are stored in the compact heightfield 'reg' field.
+// The process sometimes creates small regions. If the area of a regions is
+// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
+// region if possible. If multiple regions form an area which is smaller than
+// 'minRegionArea' all the regions belonging to that area will be removed.
+// Here area means the count of spans in an area.
+// Params:
+//	chf - (in/out) compact heightfield representing the open space.
+//	minRegionArea - (in) the smallest allowed region area.
+//	maxMergeRegionArea - (in) the largest allowed region area which can be merged.
+// Returns false if operation ran out of memory.
+bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
+					const int borderSize, const int minRegionArea, const int mergeRegionArea);
+
+// Divides the walkable heighfied into simple regions using simple monotone partitioning.
+// Each region has only one contour and no overlaps.
+// The regions are stored in the compact heightfield 'reg' field.
+// The process sometimes creates small regions. If the area of a regions is
+// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
+// region if possible. If multiple regions form an area which is smaller than
+// 'minRegionArea' all the regions belonging to that area will be removed.
+// Here area means the count of spans in an area.
+// Params:
+//	chf - (in/out) compact heightfield representing the open space.
+//	minRegionArea - (in) the smallest allowed regions size.
+//	maxMergeRegionArea - (in) the largest allowed regions size which can be merged.
+// Returns false if operation ran out of memory.
+bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
+							const int borderSize, const int minRegionArea, const int mergeRegionArea);
+
+// Builds simplified contours from the regions outlines.
+// Params:
+//	chf - (in) compact heightfield which has regions set.
+//	maxError - (in) maximum allowed distance between simplified contour and cells.
+//	maxEdgeLen - (in) maximum allowed contour edge length in cells.
+//	cset - (out) Resulting contour set.
+//	flags - (in) build flags, see rcBuildContoursFlags.
+// Returns false if operation ran out of memory.
+bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
+					 const float maxError, const int maxEdgeLen,
+					 rcContourSet& cset, const int flags = RC_CONTOUR_TESS_WALL_EDGES);
+
+// Builds connected convex polygon mesh from contour polygons.
+// Params:
+//	cset - (in) contour set.
+//	nvp - (in) maximum number of vertices per polygon.
+//	mesh - (out) poly mesh.
+// Returns false if operation ran out of memory.
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh);
+
+bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh);
+
+// Builds detail triangle mesh for each polygon in the poly mesh.
+// Params:
+//	mesh - (in) poly mesh to detail.
+//	chf - (in) compact height field, used to query height for new vertices.
+//  sampleDist - (in) spacing between height samples used to generate more detail into mesh.
+//  sampleMaxError - (in) maximum allowed distance between simplified detail mesh and height sample.
+//	pmdtl - (out) detail mesh.
+// Returns false if operation ran out of memory.
+bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
+						   const float sampleDist, const float sampleMaxError,
+						   rcPolyMeshDetail& dmesh);
+
+bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh);
+
+
+#endif // RECAST_H
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastAlloc.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastAlloc.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,67 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <stdlib.h>
+#include <string.h>
+#include "RecastAlloc.h"
+
+static void *rcAllocDefault(int size, rcAllocHint)
+{
+	return malloc(size);
+}
+
+static void rcFreeDefault(void *ptr)
+{
+	free(ptr);
+}
+
+static rcAllocFunc* sRecastAllocFunc = rcAllocDefault;
+static rcFreeFunc* sRecastFreeFunc = rcFreeDefault;
+
+void rcAllocSetCustom(rcAllocFunc *allocFunc, rcFreeFunc *freeFunc)
+{
+	sRecastAllocFunc = allocFunc ? allocFunc : rcAllocDefault;
+	sRecastFreeFunc = freeFunc ? freeFunc : rcFreeDefault;
+}
+
+void* rcAlloc(int size, rcAllocHint hint)
+{
+	return sRecastAllocFunc(size, hint);
+}
+
+void rcFree(void* ptr)
+{
+	if (ptr)
+		sRecastFreeFunc(ptr);
+}
+
+
+void rcIntArray::resize(int n)
+{
+	if (n > m_cap)
+	{
+		if (!m_cap) m_cap = n;
+		while (m_cap < n) m_cap *= 2;
+		int* newData = (int*)rcAlloc(m_cap*sizeof(int), RC_ALLOC_TEMP);
+		if (m_size && newData) memcpy(newData, m_data, m_size*sizeof(int));
+		rcFree(m_data);
+		m_data = newData;
+	}
+	m_size = n;
+}
+
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastAlloc.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastAlloc.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,69 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef RECASTALLOC_H
+#define RECASTALLOC_H
+
+enum rcAllocHint
+{
+	RC_ALLOC_PERM,		// Memory persist after a function call.
+	RC_ALLOC_TEMP		// Memory used temporarily within a function.
+};
+
+typedef void* (rcAllocFunc)(int size, rcAllocHint hint);
+typedef void (rcFreeFunc)(void* ptr);
+
+void rcAllocSetCustom(rcAllocFunc *allocFunc, rcFreeFunc *freeFunc);
+
+void* rcAlloc(int size, rcAllocHint hint);
+void rcFree(void* ptr);
+
+
+
+// Simple dynamic array ints.
+class rcIntArray
+{
+	int* m_data;
+	int m_size, m_cap;
+	inline rcIntArray(const rcIntArray&);
+	inline rcIntArray& operator=(const rcIntArray&);
+public:
+	inline rcIntArray() : m_data(0), m_size(0), m_cap(0) {}
+	inline rcIntArray(int n) : m_data(0), m_size(0), m_cap(0) { resize(n); }
+	inline ~rcIntArray() { rcFree(m_data); }
+	void resize(int n);
+	inline void push(int item) { resize(m_size+1); m_data[m_size-1] = item; }
+	inline int pop() { if (m_size > 0) m_size--; return m_data[m_size]; }
+	inline const int& operator[](int i) const { return m_data[i]; }
+	inline int& operator[](int i) { return m_data[i]; }
+	inline int size() const { return m_size; }
+};
+
+// Simple internal helper class to delete array in scope
+template<class T> class rcScopedDelete
+{
+	T* ptr;
+	inline T* operator=(T* p);
+public:
+	inline rcScopedDelete() : ptr(0) {}
+	inline rcScopedDelete(T* p) : ptr(p) {}
+	inline ~rcScopedDelete() { rcFree(ptr); }
+	inline operator T*() { return ptr; }
+};
+
+#endif
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastArea.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastArea.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,413 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <float.h>
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+
+bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	ctx->startTimer(RC_TIMER_ERODE_AREA);
+	
+	unsigned char* dist = (unsigned char*)rcAlloc(sizeof(unsigned char)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!dist)
+	{
+		ctx->log(RC_LOG_ERROR, "erodeWalkableArea: Out of memory 'dist' (%d).", chf.spanCount);
+		return false;
+	}
+	
+	// Init distance.
+	memset(dist, 0xff, sizeof(unsigned char)*chf.spanCount);
+	
+	// Mark boundary cells.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				if (chf.areas[i] != RC_NULL_AREA)
+				{
+					const rcCompactSpan& s = chf.spans[i];
+					int nc = 0;
+					for (int dir = 0; dir < 4; ++dir)
+					{
+						if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+							nc++;
+					}
+					// At least one missing neighbour.
+					if (nc != 4)
+						dist[i] = 0;
+				}
+			}
+		}
+	}
+	
+	unsigned char nd;
+	
+	// Pass 1
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				
+				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
+				{
+					// (-1,0)
+					const int ax = x + rcGetDirOffsetX(0);
+					const int ay = y + rcGetDirOffsetY(0);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);
+					const rcCompactSpan& as = chf.spans[ai];
+					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
+					if (nd < dist[i])
+						dist[i] = nd;
+					
+					// (-1,-1)
+					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(3);
+						const int aay = ay + rcGetDirOffsetY(3);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 3);
+						nd = (unsigned char)rcMin((int)dist[aai]+3, 255);
+						if (nd < dist[i])
+							dist[i] = nd;
+					}
+				}
+				if (rcGetCon(s, 3) != RC_NOT_CONNECTED)
+				{
+					// (0,-1)
+					const int ax = x + rcGetDirOffsetX(3);
+					const int ay = y + rcGetDirOffsetY(3);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);
+					const rcCompactSpan& as = chf.spans[ai];
+					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
+					if (nd < dist[i])
+						dist[i] = nd;
+					
+					// (1,-1)
+					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(2);
+						const int aay = ay + rcGetDirOffsetY(2);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 2);
+						nd = (unsigned char)rcMin((int)dist[aai]+3, 255);
+						if (nd < dist[i])
+							dist[i] = nd;
+					}
+				}
+			}
+		}
+	}
+	
+	// Pass 2
+	for (int y = h-1; y >= 0; --y)
+	{
+		for (int x = w-1; x >= 0; --x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				
+				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)
+				{
+					// (1,0)
+					const int ax = x + rcGetDirOffsetX(2);
+					const int ay = y + rcGetDirOffsetY(2);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 2);
+					const rcCompactSpan& as = chf.spans[ai];
+					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
+					if (nd < dist[i])
+						dist[i] = nd;
+					
+					// (1,1)
+					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(1);
+						const int aay = ay + rcGetDirOffsetY(1);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 1);
+						nd = (unsigned char)rcMin((int)dist[aai]+3, 255);
+						if (nd < dist[i])
+							dist[i] = nd;
+					}
+				}
+				if (rcGetCon(s, 1) != RC_NOT_CONNECTED)
+				{
+					// (0,1)
+					const int ax = x + rcGetDirOffsetX(1);
+					const int ay = y + rcGetDirOffsetY(1);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 1);
+					const rcCompactSpan& as = chf.spans[ai];
+					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
+					if (nd < dist[i])
+						dist[i] = nd;
+					
+					// (-1,1)
+					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(0);
+						const int aay = ay + rcGetDirOffsetY(0);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 0);
+						nd = (unsigned char)rcMin((int)dist[aai]+3, 255);
+						if (nd < dist[i])
+							dist[i] = nd;
+					}
+				}
+			}
+		}
+	}
+	
+	const unsigned char thr = (unsigned char)(radius*2);
+	for (int i = 0; i < chf.spanCount; ++i)
+		if (dist[i] < thr)
+			chf.areas[i] = RC_NULL_AREA;
+	
+	rcFree(dist);
+	
+	ctx->stopTimer(RC_TIMER_ERODE_AREA);
+	
+	return true;
+}
+
+static void insertSort(unsigned char* a, const int n)
+{
+	int i, j;
+	for (i = 1; i < n; i++)
+	{
+		const unsigned char value = a[i];
+		for (j = i - 1; j >= 0 && a[j] > value; j--)
+			a[j+1] = a[j];
+		a[j+1] = value;
+	}
+}
+
+
+bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	ctx->startTimer(RC_TIMER_MEDIAN_AREA);
+	
+	unsigned char* areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!areas)
+	{
+		ctx->log(RC_LOG_ERROR, "medianFilterWalkableArea: Out of memory 'areas' (%d).", chf.spanCount);
+		return false;
+	}
+	
+	// Init distance.
+	memset(areas, 0xff, sizeof(unsigned char)*chf.spanCount);
+	
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				if (chf.areas[i] == RC_NULL_AREA)
+				{
+					areas[i] = chf.areas[i];
+					continue;
+				}
+				
+				unsigned char nei[9];
+				for (int j = 0; j < 9; ++j)
+					nei[j] = chf.areas[i];
+				
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+					{
+						const int ax = x + rcGetDirOffsetX(dir);
+						const int ay = y + rcGetDirOffsetY(dir);
+						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
+						if (chf.areas[ai] != RC_NULL_AREA)
+							nei[dir*2+0] = chf.areas[ai];
+						
+						const rcCompactSpan& as = chf.spans[ai];
+						const int dir2 = (dir+1) & 0x3;
+						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
+						{
+							const int ax2 = ax + rcGetDirOffsetX(dir2);
+							const int ay2 = ay + rcGetDirOffsetY(dir2);
+							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);
+							if (chf.areas[ai2] != RC_NULL_AREA)
+								nei[dir*2+1] = chf.areas[ai2];
+						}
+					}
+				}
+				insertSort(nei, 9);
+				areas[i] = nei[4];
+			}
+		}
+	}
+	
+	memcpy(chf.areas, areas, sizeof(unsigned char)*chf.spanCount);
+	
+	rcFree(areas);
+
+	ctx->stopTimer(RC_TIMER_MEDIAN_AREA);
+	
+	return true;
+}
+
+void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
+				   rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_MARK_BOX_AREA);
+
+	int minx = (int)((bmin[0]-chf.bmin[0])/chf.cs);
+	int miny = (int)((bmin[1]-chf.bmin[1])/chf.ch);
+	int minz = (int)((bmin[2]-chf.bmin[2])/chf.cs);
+	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
+	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
+	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
+	
+	if (maxx < 0) return;
+	if (minx >= chf.width) return;
+	if (maxz < 0) return;
+	if (minz >= chf.height) return;
+
+	if (minx < 0) minx = 0;
+	if (maxx >= chf.width) maxx = chf.width-1;
+	if (minz < 0) minz = 0;
+	if (maxz >= chf.height) maxz = chf.height-1;	
+	
+	for (int z = minz; z <= maxz; ++z)
+	{
+		for (int x = minx; x <= maxx; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+z*chf.width];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				rcCompactSpan& s = chf.spans[i];
+				if ((int)s.y >= miny && (int)s.y <= maxy)
+				{
+					chf.areas[i] = areaId;
+				}
+			}
+		}
+	}
+
+	ctx->stopTimer(RC_TIMER_MARK_BOX_AREA);
+
+}
+
+
+static int pointInPoly(int nvert, const float* verts, const float* p)
+{
+	int i, j, c = 0;
+	for (i = 0, j = nvert-1; i < nvert; j = i++)
+	{
+		const float* vi = &verts[i*3];
+		const float* vj = &verts[j*3];
+		if (((vi[2] > p[2]) != (vj[2] > p[2])) &&
+			(p[0] < (vj[0]-vi[0]) * (p[2]-vi[2]) / (vj[2]-vi[2]) + vi[0]) )
+			c = !c;
+	}
+	return c;
+}
+
+void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
+						  const float hmin, const float hmax, unsigned char areaId,
+						  rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_MARK_CONVEXPOLY_AREA);
+
+	float bmin[3], bmax[3];
+	rcVcopy(bmin, verts);
+	rcVcopy(bmax, verts);
+	for (int i = 1; i < nverts; ++i)
+	{
+		rcVmin(bmin, &verts[i*3]);
+		rcVmax(bmax, &verts[i*3]);
+	}
+	bmin[1] = hmin;
+	bmax[1] = hmax;
+
+	int minx = (int)((bmin[0]-chf.bmin[0])/chf.cs);
+	int miny = (int)((bmin[1]-chf.bmin[1])/chf.ch);
+	int minz = (int)((bmin[2]-chf.bmin[2])/chf.cs);
+	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
+	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
+	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
+	
+	if (maxx < 0) return;
+	if (minx >= chf.width) return;
+	if (maxz < 0) return;
+	if (minz >= chf.height) return;
+	
+	if (minx < 0) minx = 0;
+	if (maxx >= chf.width) maxx = chf.width-1;
+	if (minz < 0) minz = 0;
+	if (maxz >= chf.height) maxz = chf.height-1;	
+	
+	
+	// TODO: Optimize.
+	for (int z = minz; z <= maxz; ++z)
+	{
+		for (int x = minx; x <= maxx; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+z*chf.width];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				rcCompactSpan& s = chf.spans[i];
+				if ((int)s.y >= miny && (int)s.y <= maxy)
+				{
+					float p[3];
+					p[0] = chf.bmin[0] + (x+0.5f)*chf.cs; 
+					p[1] = 0;
+					p[2] = chf.bmin[2] + (z+0.5f)*chf.cs; 
+
+					if (pointInPoly(nverts, verts, p))
+					{
+						chf.areas[i] = areaId;
+					}
+				}
+			}
+		}
+	}
+
+	ctx->stopTimer(RC_TIMER_MARK_CONVEXPOLY_AREA);
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastAssert.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastAssert.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,33 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#ifndef RECASTASSERT_H
+#define RECASTASSERT_H
+
+// Note: This header file's only purpose is to include define assert.
+// Feel free to change the file and include your own implementation instead.
+
+#ifdef NDEBUG
+// From http://cnicholson.net/2009/02/stupid-c-tricks-adventures-in-assert/
+#	define rcAssert(x) do { (void)sizeof(x); } while(__LINE__==-1,false)  
+#else
+#	include <assert.h> 
+#	define rcAssert assert
+#endif
+
+#endif // RECASTASSERT_H
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastContour.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastContour.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,804 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+
+static int getCornerHeight(int x, int y, int i, int dir,
+						   const rcCompactHeightfield& chf,
+						   bool& isBorderVertex)
+{
+	const rcCompactSpan& s = chf.spans[i];
+	int ch = (int)s.y;
+	int dirp = (dir+1) & 0x3;
+	
+	unsigned int regs[4] = {0,0,0,0};
+	
+	// Combine region and area codes in order to prevent
+	// border vertices which are in between two areas to be removed. 
+	regs[0] = chf.spans[i].reg | (chf.areas[i] << 16);
+	
+	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+	{
+		const int ax = x + rcGetDirOffsetX(dir);
+		const int ay = y + rcGetDirOffsetY(dir);
+		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
+		const rcCompactSpan& as = chf.spans[ai];
+		ch = rcMax(ch, (int)as.y);
+		regs[1] = chf.spans[ai].reg | (chf.areas[ai] << 16);
+		if (rcGetCon(as, dirp) != RC_NOT_CONNECTED)
+		{
+			const int ax2 = ax + rcGetDirOffsetX(dirp);
+			const int ay2 = ay + rcGetDirOffsetY(dirp);
+			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dirp);
+			const rcCompactSpan& as2 = chf.spans[ai2];
+			ch = rcMax(ch, (int)as2.y);
+			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);
+		}
+	}
+	if (rcGetCon(s, dirp) != RC_NOT_CONNECTED)
+	{
+		const int ax = x + rcGetDirOffsetX(dirp);
+		const int ay = y + rcGetDirOffsetY(dirp);
+		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dirp);
+		const rcCompactSpan& as = chf.spans[ai];
+		ch = rcMax(ch, (int)as.y);
+		regs[3] = chf.spans[ai].reg | (chf.areas[ai] << 16);
+		if (rcGetCon(as, dir) != RC_NOT_CONNECTED)
+		{
+			const int ax2 = ax + rcGetDirOffsetX(dir);
+			const int ay2 = ay + rcGetDirOffsetY(dir);
+			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dir);
+			const rcCompactSpan& as2 = chf.spans[ai2];
+			ch = rcMax(ch, (int)as2.y);
+			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);
+		}
+	}
+
+	// Check if the vertex is special edge vertex, these vertices will be removed later.
+	for (int j = 0; j < 4; ++j)
+	{
+		const int a = j;
+		const int b = (j+1) & 0x3;
+		const int c = (j+2) & 0x3;
+		const int d = (j+3) & 0x3;
+		
+		// The vertex is a border vertex there are two same exterior cells in a row,
+		// followed by two interior cells and none of the regions are out of bounds.
+		const bool twoSameExts = (regs[a] & regs[b] & RC_BORDER_REG) != 0 && regs[a] == regs[b];
+		const bool twoInts = ((regs[c] | regs[d]) & RC_BORDER_REG) == 0;
+		const bool intsSameArea = (regs[c]>>16) == (regs[d]>>16);
+		const bool noZeros = regs[a] != 0 && regs[b] != 0 && regs[c] != 0 && regs[d] != 0;
+		if (twoSameExts && twoInts && intsSameArea && noZeros)
+		{
+			isBorderVertex = true;
+			break;
+		}
+	}
+	
+	return ch;
+}
+
+static void walkContour(int x, int y, int i,
+						rcCompactHeightfield& chf,
+						unsigned char* flags, rcIntArray& points)
+{
+	// Choose the first non-connected edge
+	unsigned char dir = 0;
+	while ((flags[i] & (1 << dir)) == 0)
+		dir++;
+	
+	unsigned char startDir = dir;
+	int starti = i;
+	
+	const unsigned char area = chf.areas[i];
+	
+	int iter = 0;
+	while (++iter < 40000)
+	{
+		if (flags[i] & (1 << dir))
+		{
+			// Choose the edge corner
+			bool isBorderVertex = false;
+			bool isAreaBorder = false;
+			int px = x;
+			int py = getCornerHeight(x, y, i, dir, chf, isBorderVertex);
+			int pz = y;
+			switch(dir)
+			{
+				case 0: pz++; break;
+				case 1: px++; pz++; break;
+				case 2: px++; break;
+			}
+			int r = 0;
+			const rcCompactSpan& s = chf.spans[i];
+			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+			{
+				const int ax = x + rcGetDirOffsetX(dir);
+				const int ay = y + rcGetDirOffsetY(dir);
+				const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
+				r = (int)chf.spans[ai].reg;
+				if (area != chf.areas[ai])
+					isAreaBorder = true;
+			}
+			if (isBorderVertex)
+				r |= RC_BORDER_VERTEX;
+			if (isAreaBorder)
+				r |= RC_AREA_BORDER;
+			points.push(px);
+			points.push(py);
+			points.push(pz);
+			points.push(r);
+			
+			flags[i] &= ~(1 << dir); // Remove visited edges
+			dir = (dir+1) & 0x3;  // Rotate CW
+		}
+		else
+		{
+			int ni = -1;
+			const int nx = x + rcGetDirOffsetX(dir);
+			const int ny = y + rcGetDirOffsetY(dir);
+			const rcCompactSpan& s = chf.spans[i];
+			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+			{
+				const rcCompactCell& nc = chf.cells[nx+ny*chf.width];
+				ni = (int)nc.index + rcGetCon(s, dir);
+			}
+			if (ni == -1)
+			{
+				// Should not happen.
+				return;
+			}
+			x = nx;
+			y = ny;
+			i = ni;
+			dir = (dir+3) & 0x3;	// Rotate CCW
+		}
+		
+		if (starti == i && startDir == dir)
+		{
+			break;
+		}
+	}
+}
+
+static float distancePtSeg(const int x, const int z,
+						   const int px, const int pz,
+						   const int qx, const int qz)
+{
+/*	float pqx = (float)(qx - px);
+	float pqy = (float)(qy - py);
+	float pqz = (float)(qz - pz);
+	float dx = (float)(x - px);
+	float dy = (float)(y - py);
+	float dz = (float)(z - pz);
+	float d = pqx*pqx + pqy*pqy + pqz*pqz;
+	float t = pqx*dx + pqy*dy + pqz*dz;
+	if (d > 0)
+		t /= d;
+	if (t < 0)
+		t = 0;
+	else if (t > 1)
+		t = 1;
+	
+	dx = px + t*pqx - x;
+	dy = py + t*pqy - y;
+	dz = pz + t*pqz - z;
+	
+	return dx*dx + dy*dy + dz*dz;*/
+
+	float pqx = (float)(qx - px);
+	float pqz = (float)(qz - pz);
+	float dx = (float)(x - px);
+	float dz = (float)(z - pz);
+	float d = pqx*pqx + pqz*pqz;
+	float t = pqx*dx + pqz*dz;
+	if (d > 0)
+		t /= d;
+	if (t < 0)
+		t = 0;
+	else if (t > 1)
+		t = 1;
+	
+	dx = px + t*pqx - x;
+	dz = pz + t*pqz - z;
+	
+	return dx*dx + dz*dz;
+}
+
+static void simplifyContour(rcIntArray& points, rcIntArray& simplified,
+							const float maxError, const int maxEdgeLen, const int buildFlags)
+{
+	// Add initial points.
+	bool hasConnections = false;
+	for (int i = 0; i < points.size(); i += 4)
+	{
+		if ((points[i+3] & RC_CONTOUR_REG_MASK) != 0)
+		{
+			hasConnections = true;
+			break;
+		}
+	}
+	
+	if (hasConnections)
+	{
+		// The contour has some portals to other regions.
+		// Add a new point to every location where the region changes.
+		for (int i = 0, ni = points.size()/4; i < ni; ++i)
+		{
+			int ii = (i+1) % ni;
+			const bool differentRegs = (points[i*4+3] & RC_CONTOUR_REG_MASK) != (points[ii*4+3] & RC_CONTOUR_REG_MASK);
+			const bool areaBorders = (points[i*4+3] & RC_AREA_BORDER) != (points[ii*4+3] & RC_AREA_BORDER);
+			if (differentRegs || areaBorders)
+			{
+				simplified.push(points[i*4+0]);
+				simplified.push(points[i*4+1]);
+				simplified.push(points[i*4+2]);
+				simplified.push(i);
+			}
+		}       
+	}
+	
+	if (simplified.size() == 0)
+	{
+		// If there is no connections at all,
+		// create some initial points for the simplification process. 
+		// Find lower-left and upper-right vertices of the contour.
+		int llx = points[0];
+		int lly = points[1];
+		int llz = points[2];
+		int lli = 0;
+		int urx = points[0];
+		int ury = points[1];
+		int urz = points[2];
+		int uri = 0;
+		for (int i = 0; i < points.size(); i += 4)
+		{
+			int x = points[i+0];
+			int y = points[i+1];
+			int z = points[i+2];
+			if (x < llx || (x == llx && z < llz))
+			{
+				llx = x;
+				lly = y;
+				llz = z;
+				lli = i/4;
+			}
+			if (x > urx || (x == urx && z > urz))
+			{
+				urx = x;
+				ury = y;
+				urz = z;
+				uri = i/4;
+			}
+		}
+		simplified.push(llx);
+		simplified.push(lly);
+		simplified.push(llz);
+		simplified.push(lli);
+		
+		simplified.push(urx);
+		simplified.push(ury);
+		simplified.push(urz);
+		simplified.push(uri);
+	}
+	
+	// Add points until all raw points are within
+	// error tolerance to the simplified shape.
+	const int pn = points.size()/4;
+	for (int i = 0; i < simplified.size()/4; )
+	{
+		int ii = (i+1) % (simplified.size()/4);
+		
+		const int ax = simplified[i*4+0];
+		const int az = simplified[i*4+2];
+		const int ai = simplified[i*4+3];
+		
+		const int bx = simplified[ii*4+0];
+		const int bz = simplified[ii*4+2];
+		const int bi = simplified[ii*4+3];
+
+		// Find maximum deviation from the segment.
+		float maxd = 0;
+		int maxi = -1;
+		int ci, cinc, endi;
+		
+		// Traverse the segment in lexilogical order so that the
+		// max deviation is calculated similarly when traversing
+		// opposite segments.
+		if (bx > ax || (bx == ax && bz > az))
+		{
+			cinc = 1;
+			ci = (ai+cinc) % pn;
+			endi = bi;
+		}
+		else
+		{
+			cinc = pn-1;
+			ci = (bi+cinc) % pn;
+			endi = ai;
+		}
+		
+		// Tessellate only outer edges oredges between areas.
+		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||
+			(points[ci*4+3] & RC_AREA_BORDER))
+		{
+			while (ci != endi)
+			{
+				float d = distancePtSeg(points[ci*4+0], points[ci*4+2], ax, az, bx, bz);
+				if (d > maxd)
+				{
+					maxd = d;
+					maxi = ci;
+				}
+				ci = (ci+cinc) % pn;
+			}
+		}
+		
+		
+		// If the max deviation is larger than accepted error,
+		// add new point, else continue to next segment.
+		if (maxi != -1 && maxd > (maxError*maxError))
+		{
+			// Add space for the new point.
+			simplified.resize(simplified.size()+4);
+			const int n = simplified.size()/4;
+			for (int j = n-1; j > i; --j)
+			{
+				simplified[j*4+0] = simplified[(j-1)*4+0];
+				simplified[j*4+1] = simplified[(j-1)*4+1];
+				simplified[j*4+2] = simplified[(j-1)*4+2];
+				simplified[j*4+3] = simplified[(j-1)*4+3];
+			}
+			// Add the point.
+			simplified[(i+1)*4+0] = points[maxi*4+0];
+			simplified[(i+1)*4+1] = points[maxi*4+1];
+			simplified[(i+1)*4+2] = points[maxi*4+2];
+			simplified[(i+1)*4+3] = maxi;
+		}
+		else
+		{
+			++i;
+		}
+	}
+	
+	// Split too long edges.
+	if (maxEdgeLen > 0 && (buildFlags & (RC_CONTOUR_TESS_WALL_EDGES|RC_CONTOUR_TESS_AREA_EDGES)) != 0)
+	{
+		for (int i = 0; i < simplified.size()/4; )
+		{
+			const int ii = (i+1) % (simplified.size()/4);
+			
+			const int ax = simplified[i*4+0];
+			const int az = simplified[i*4+2];
+			const int ai = simplified[i*4+3];
+			
+			const int bx = simplified[ii*4+0];
+			const int bz = simplified[ii*4+2];
+			const int bi = simplified[ii*4+3];
+
+			// Find maximum deviation from the segment.
+			int maxi = -1;
+			int ci = (ai+1) % pn;
+
+			// Tessellate only outer edges or edges between areas.
+			bool tess = false;
+			// Wall edges.
+			if ((buildFlags & RC_CONTOUR_TESS_WALL_EDGES) && (points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0)
+				tess = true;
+			// Edges between areas.
+			if ((buildFlags & RC_CONTOUR_TESS_AREA_EDGES) && (points[ci*4+3] & RC_AREA_BORDER))
+				tess = true;
+			
+			if (tess)
+			{
+				int dx = bx - ax;
+				int dz = bz - az;
+				if (dx*dx + dz*dz > maxEdgeLen*maxEdgeLen)
+				{
+					// Round based on the segments in lexilogical order so that the
+					// max tesselation is consistent regardles in which direction
+					// segments are traversed.
+					if (bx > ax || (bx == ax && bz > az))
+					{
+						const int n = bi < ai ? (bi+pn - ai) : (bi - ai);
+						maxi = (ai + n/2) % pn;
+					}
+					else
+					{
+						const int n = bi < ai ? (bi+pn - ai) : (bi - ai);
+						maxi = (ai + (n+1)/2) % pn;
+					}
+				}
+			}
+			
+			// If the max deviation is larger than accepted error,
+			// add new point, else continue to next segment.
+			if (maxi != -1)
+			{
+				// Add space for the new point.
+				simplified.resize(simplified.size()+4);
+				const int n = simplified.size()/4;
+				for (int j = n-1; j > i; --j)
+				{
+					simplified[j*4+0] = simplified[(j-1)*4+0];
+					simplified[j*4+1] = simplified[(j-1)*4+1];
+					simplified[j*4+2] = simplified[(j-1)*4+2];
+					simplified[j*4+3] = simplified[(j-1)*4+3];
+				}
+				// Add the point.
+				simplified[(i+1)*4+0] = points[maxi*4+0];
+				simplified[(i+1)*4+1] = points[maxi*4+1];
+				simplified[(i+1)*4+2] = points[maxi*4+2];
+				simplified[(i+1)*4+3] = maxi;
+			}
+			else
+			{
+				++i;
+			}
+		}
+	}
+	
+	for (int i = 0; i < simplified.size()/4; ++i)
+	{
+		// The edge vertex flag is take from the current raw point,
+		// and the neighbour region is take from the next raw point.
+		const int ai = (simplified[i*4+3]+1) % pn;
+		const int bi = simplified[i*4+3];
+		simplified[i*4+3] = (points[ai*4+3] & RC_CONTOUR_REG_MASK) | (points[bi*4+3] & RC_BORDER_VERTEX);
+	}
+	
+}
+
+static void removeDegenerateSegments(rcIntArray& simplified)
+{
+	// Remove adjacent vertices which are equal on xz-plane,
+	// or else the triangulator will get confused.
+	for (int i = 0; i < simplified.size()/4; ++i)
+	{
+		int ni = i+1;
+		if (ni >= (simplified.size()/4))
+			ni = 0;
+			
+		if (simplified[i*4+0] == simplified[ni*4+0] &&
+			simplified[i*4+2] == simplified[ni*4+2])
+		{
+			// Degenerate segment, remove.
+			for (int j = i; j < simplified.size()/4-1; ++j)
+			{
+				simplified[j*4+0] = simplified[(j+1)*4+0];
+				simplified[j*4+1] = simplified[(j+1)*4+1];
+				simplified[j*4+2] = simplified[(j+1)*4+2];
+				simplified[j*4+3] = simplified[(j+1)*4+3];
+			}
+			simplified.resize(simplified.size()-4);
+		}
+	}
+}
+
+static int calcAreaOfPolygon2D(const int* verts, const int nverts)
+{
+	int area = 0;
+	for (int i = 0, j = nverts-1; i < nverts; j=i++)
+	{
+		const int* vi = &verts[i*4];
+		const int* vj = &verts[j*4];
+		area += vi[0] * vj[2] - vj[0] * vi[2];
+	}
+	return (area+1) / 2;
+}
+
+inline bool ileft(const int* a, const int* b, const int* c)
+{
+	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]) <= 0;
+}
+
+static void getClosestIndices(const int* vertsa, const int nvertsa,
+							  const int* vertsb, const int nvertsb,
+							  int& ia, int& ib)
+{
+	int closestDist = 0xfffffff;
+	ia = -1, ib = -1;
+	for (int i = 0; i < nvertsa; ++i)
+	{
+		const int in = (i+1) % nvertsa;
+		const int ip = (i+nvertsa-1) % nvertsa;
+		const int* va = &vertsa[i*4];
+		const int* van = &vertsa[in*4];
+		const int* vap = &vertsa[ip*4];
+		
+		for (int j = 0; j < nvertsb; ++j)
+		{
+			const int* vb = &vertsb[j*4];
+			// vb must be "infront" of va.
+			if (ileft(vap,va,vb) && ileft(va,van,vb))
+			{
+				const int dx = vb[0] - va[0];
+				const int dz = vb[2] - va[2];
+				const int d = dx*dx + dz*dz;
+				if (d < closestDist)
+				{
+					ia = i;
+					ib = j;
+					closestDist = d;
+				}
+			}
+		}
+	}
+}
+
+static bool mergeContours(rcContour& ca, rcContour& cb, int ia, int ib)
+{
+	const int maxVerts = ca.nverts + cb.nverts + 2;
+	int* verts = (int*)rcAlloc(sizeof(int)*maxVerts*4, RC_ALLOC_PERM);
+	if (!verts)
+		return false;
+
+	int nv = 0;
+
+	// Copy contour A.
+	for (int i = 0; i <= ca.nverts; ++i)
+	{
+		int* dst = &verts[nv*4];
+		const int* src = &ca.verts[((ia+i)%ca.nverts)*4];
+		dst[0] = src[0];
+		dst[1] = src[1];
+		dst[2] = src[2];
+		dst[3] = src[3];
+		nv++;
+	}
+
+	// Copy contour B
+	for (int i = 0; i <= cb.nverts; ++i)
+	{
+		int* dst = &verts[nv*4];
+		const int* src = &cb.verts[((ib+i)%cb.nverts)*4];
+		dst[0] = src[0];
+		dst[1] = src[1];
+		dst[2] = src[2];
+		dst[3] = src[3];
+		nv++;
+	}
+	
+	rcFree(ca.verts);
+	ca.verts = verts;
+	ca.nverts = nv;
+
+	rcFree(cb.verts);
+	cb.verts = 0;
+	cb.nverts = 0;
+	
+	return true;
+}
+
+bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
+					 const float maxError, const int maxEdgeLen,
+					 rcContourSet& cset, const int buildFlags)
+{
+	rcAssert(ctx);
+	
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	ctx->startTimer(RC_TIMER_BUILD_CONTOURS);
+	
+	rcVcopy(cset.bmin, chf.bmin);
+	rcVcopy(cset.bmax, chf.bmax);
+	cset.cs = chf.cs;
+	cset.ch = chf.ch;
+	
+	int maxContours = rcMax((int)chf.maxRegions, 8);
+	cset.conts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);
+	if (!cset.conts)
+		return false;
+	cset.nconts = 0;
+	
+	rcScopedDelete<unsigned char> flags = (unsigned char*)rcAlloc(sizeof(unsigned char)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!flags)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'flags' (%d).", chf.spanCount);
+		return false;
+	}
+	
+	ctx->startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
+	
+	// Mark boundaries.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				unsigned char res = 0;
+				const rcCompactSpan& s = chf.spans[i];
+				if (!chf.spans[i].reg || (chf.spans[i].reg & RC_BORDER_REG))
+				{
+					flags[i] = 0;
+					continue;
+				}
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					unsigned short r = 0;
+					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+					{
+						const int ax = x + rcGetDirOffsetX(dir);
+						const int ay = y + rcGetDirOffsetY(dir);
+						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
+						r = chf.spans[ai].reg;
+					}
+					if (r == chf.spans[i].reg)
+						res |= (1 << dir);
+				}
+				flags[i] = res ^ 0xf; // Inverse, mark non connected edges.
+			}
+		}
+	}
+	
+	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
+	
+	ctx->startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
+	
+	rcIntArray verts(256);
+	rcIntArray simplified(64);
+	
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				if (flags[i] == 0 || flags[i] == 0xf)
+				{
+					flags[i] = 0;
+					continue;
+				}
+				const unsigned short reg = chf.spans[i].reg;
+				if (!reg || (reg & RC_BORDER_REG))
+					continue;
+				const unsigned char area = chf.areas[i];
+				
+				verts.resize(0);
+				simplified.resize(0);
+				walkContour(x, y, i, chf, flags, verts);
+				simplifyContour(verts, simplified, maxError, maxEdgeLen, buildFlags);
+				removeDegenerateSegments(simplified);
+				
+				// Store region->contour remap info.
+				// Create contour.
+				if (simplified.size()/4 >= 3)
+				{
+					if (cset.nconts >= maxContours)
+					{
+						// Allocate more contours.
+						// This can happen when there are tiny holes in the heightfield.
+						const int oldMax = maxContours;
+						maxContours *= 2;
+						rcContour* newConts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);
+						for (int j = 0; j < cset.nconts; ++j)
+						{
+							newConts[j] = cset.conts[j];
+							// Reset source pointers to prevent data deletion.
+							cset.conts[j].verts = 0;
+							cset.conts[j].rverts = 0;
+						}
+						rcFree(cset.conts);
+						cset.conts = newConts;
+					
+						ctx->log(RC_LOG_WARNING, "rcBuildContours: Expanding max contours from %d to %d.", oldMax, maxContours);
+					}
+						
+					rcContour* cont = &cset.conts[cset.nconts++];
+					
+					cont->nverts = simplified.size()/4;
+					cont->verts = (int*)rcAlloc(sizeof(int)*cont->nverts*4, RC_ALLOC_PERM);
+					if (!cont->verts)
+					{
+						ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'verts' (%d).", cont->nverts);
+						return false;
+					}
+					memcpy(cont->verts, &simplified[0], sizeof(int)*cont->nverts*4);
+					
+					cont->nrverts = verts.size()/4;
+					cont->rverts = (int*)rcAlloc(sizeof(int)*cont->nrverts*4, RC_ALLOC_PERM);
+					if (!cont->rverts)
+					{
+						ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'rverts' (%d).", cont->nrverts);
+						return false;
+					}
+					memcpy(cont->rverts, &verts[0], sizeof(int)*cont->nrverts*4);
+					
+/*					cont->cx = cont->cy = cont->cz = 0;
+					for (int i = 0; i < cont->nverts; ++i)
+					{
+						cont->cx += cont->verts[i*4+0];
+						cont->cy += cont->verts[i*4+1];
+						cont->cz += cont->verts[i*4+2];
+					}
+					cont->cx /= cont->nverts;
+					cont->cy /= cont->nverts;
+					cont->cz /= cont->nverts;*/
+					
+					cont->reg = reg;
+					cont->area = area;
+				}
+			}
+		}
+	}
+	
+	// Check and merge droppings.
+	// Sometimes the previous algorithms can fail and create several contours
+	// per area. This pass will try to merge the holes into the main region.
+	for (int i = 0; i < cset.nconts; ++i)
+	{
+		rcContour& cont = cset.conts[i];
+		// Check if the contour is would backwards.
+		if (calcAreaOfPolygon2D(cont.verts, cont.nverts) < 0)
+		{
+			// Find another contour which has the same region ID.
+			int mergeIdx = -1;
+			for (int j = 0; j < cset.nconts; ++j)
+			{
+				if (i == j) continue;
+				if (cset.conts[j].nverts && cset.conts[j].reg == cont.reg)
+				{
+					// Make sure the polygon is correctly oriented.
+					if (calcAreaOfPolygon2D(cset.conts[j].verts, cset.conts[j].nverts))
+					{
+						mergeIdx = j;
+						break;
+					}
+				}
+			}
+			if (mergeIdx == -1)
+			{
+				ctx->log(RC_LOG_WARNING, "rcBuildContours: Could not find merge target for bad contour %d.", i);
+			}
+			else
+			{
+				rcContour& mcont = cset.conts[mergeIdx];
+				// Merge by closest points.
+				int ia = 0, ib = 0;
+				getClosestIndices(mcont.verts, mcont.nverts, cont.verts, cont.nverts, ia, ib);
+				if (ia == -1 || ib == -1)
+				{
+					ctx->log(RC_LOG_WARNING, "rcBuildContours: Failed to find merge points for %d and %d.", i, mergeIdx);
+					continue;
+				}
+				if (!mergeContours(mcont, cont, ia, ib))
+				{
+					ctx->log(RC_LOG_WARNING, "rcBuildContours: Failed to merge contours %d and %d.", i, mergeIdx);
+					continue;
+				}
+			}
+		}
+	}
+	
+	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
+	
+	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS);
+	
+	return true;
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastFilter.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastFilter.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,179 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAssert.h"
+
+
+void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid)
+{
+	rcAssert(ctx);
+
+	ctx->startTimer(RC_TIMER_FILTER_LOW_OBSTACLES);
+	
+	const int w = solid.width;
+	const int h = solid.height;
+	
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			rcSpan* ps = 0;
+			bool previousWalkable = false;
+			
+			for (rcSpan* s = solid.spans[x + y*w]; s; ps = s, s = s->next)
+			{
+				const bool walkable = s->area != RC_NULL_AREA;
+				// If current span is not walkable, but there is walkable
+				// span just below it, mark the span above it walkable too.
+				if (!walkable && previousWalkable)
+				{
+					if (rcAbs((int)s->smax - (int)ps->smax) <= walkableClimb)
+						s->area = RC_NULL_AREA;
+				}
+				// Copy walkable flag so that it cannot propagate
+				// past multiple non-walkable objects.
+				previousWalkable = walkable;
+			}
+		}
+	}
+
+	ctx->stopTimer(RC_TIMER_FILTER_LOW_OBSTACLES);
+}
+	
+void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight, const int walkableClimb,
+						rcHeightfield& solid)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_FILTER_BORDER);
+
+	const int w = solid.width;
+	const int h = solid.height;
+	const int MAX_HEIGHT = 0xffff;
+	
+	// Mark border spans.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			for (rcSpan* s = solid.spans[x + y*w]; s; s = s->next)
+			{
+				// Skip non walkable spans.
+				if (s->area == RC_NULL_AREA)
+					continue;
+				
+				const int bot = (int)(s->smax);
+				const int top = s->next ? (int)(s->next->smin) : MAX_HEIGHT;
+				
+				// Find neighbours minimum height.
+				int minh = MAX_HEIGHT;
+
+				// Min and max height of accessible neighbours.
+				int asmin = s->smax;
+				int asmax = s->smax;
+
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					int dx = x + rcGetDirOffsetX(dir);
+					int dy = y + rcGetDirOffsetY(dir);
+					// Skip neighbours which are out of bounds.
+					if (dx < 0 || dy < 0 || dx >= w || dy >= h)
+					{
+						minh = rcMin(minh, -walkableClimb - bot);
+						continue;
+					}
+
+					// From minus infinity to the first span.
+					rcSpan* ns = solid.spans[dx + dy*w];
+					int nbot = -walkableClimb;
+					int ntop = ns ? (int)ns->smin : MAX_HEIGHT;
+					// Skip neightbour if the gap between the spans is too small.
+					if (rcMin(top,ntop) - rcMax(bot,nbot) > walkableHeight)
+						minh = rcMin(minh, nbot - bot);
+					
+					// Rest of the spans.
+					for (ns = solid.spans[dx + dy*w]; ns; ns = ns->next)
+					{
+						nbot = (int)ns->smax;
+						ntop = ns->next ? (int)ns->next->smin : MAX_HEIGHT;
+						// Skip neightbour if the gap between the spans is too small.
+						if (rcMin(top,ntop) - rcMax(bot,nbot) > walkableHeight)
+						{
+							minh = rcMin(minh, nbot - bot);
+						
+							// Find min/max accessible neighbour height. 
+							if (rcAbs(nbot - bot) <= walkableClimb)
+							{
+								if (nbot < asmin) asmin = nbot;
+								if (nbot > asmax) asmax = nbot;
+							}
+							
+						}
+					}
+				}
+				
+				// The current span is close to a ledge if the drop to any
+				// neighbour span is less than the walkableClimb.
+				if (minh < -walkableClimb)
+					s->area = RC_NULL_AREA;
+					
+				// If the difference between all neighbours is too large,
+				// we are at steep slope, mark the span as ledge.
+				if ((asmax - asmin) > walkableClimb)
+				{
+					s->area = RC_NULL_AREA;
+				}
+			}
+		}
+	}
+	
+	ctx->stopTimer(RC_TIMER_FILTER_BORDER);
+}	
+
+void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_FILTER_WALKABLE);
+	
+	const int w = solid.width;
+	const int h = solid.height;
+	const int MAX_HEIGHT = 0xffff;
+	
+	// Remove walkable flag from spans which do not have enough
+	// space above them for the agent to stand there.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			for (rcSpan* s = solid.spans[x + y*w]; s; s = s->next)
+			{
+				const int bot = (int)(s->smax);
+				const int top = s->next ? (int)(s->next->smin) : MAX_HEIGHT;
+				if ((top - bot) <= walkableHeight)
+					s->area = RC_NULL_AREA;
+			}
+		}
+	}
+	
+	ctx->stopTimer(RC_TIMER_FILTER_WALKABLE);
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastMesh.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastMesh.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,1322 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+struct rcEdge
+{
+	unsigned short vert[2];
+	unsigned short polyEdge[2];
+	unsigned short poly[2];
+};
+
+static bool buildMeshAdjacency(unsigned short* polys, const int npolys,
+							   const int nverts, const int vertsPerPoly)
+{
+	// Based on code by Eric Lengyel from:
+	// http://www.terathon.com/code/edges.php
+	
+	int maxEdgeCount = npolys*vertsPerPoly;
+	unsigned short* firstEdge = (unsigned short*)rcAlloc(sizeof(unsigned short)*(nverts + maxEdgeCount), RC_ALLOC_TEMP);
+	if (!firstEdge)
+		return false;
+	unsigned short* nextEdge = firstEdge + nverts;
+	int edgeCount = 0;
+	
+	rcEdge* edges = (rcEdge*)rcAlloc(sizeof(rcEdge)*maxEdgeCount, RC_ALLOC_TEMP);
+	if (!edges)
+	{
+		rcFree(firstEdge);
+		return false;
+	}
+	
+	for (int i = 0; i < nverts; i++)
+		firstEdge[i] = RC_MESH_NULL_IDX;
+	
+	for (int i = 0; i < npolys; ++i)
+	{
+		unsigned short* t = &polys[i*vertsPerPoly*2];
+		for (int j = 0; j < vertsPerPoly; ++j)
+		{
+			unsigned short v0 = t[j];
+			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
+			if (v0 < v1)
+			{
+				rcEdge& edge = edges[edgeCount];
+				edge.vert[0] = v0;
+				edge.vert[1] = v1;
+				edge.poly[0] = (unsigned short)i;
+				edge.polyEdge[0] = (unsigned short)j;
+				edge.poly[1] = (unsigned short)i;
+				edge.polyEdge[1] = 0;
+				// Insert edge
+				nextEdge[edgeCount] = firstEdge[v0];
+				firstEdge[v0] = (unsigned short)edgeCount;
+				edgeCount++;
+			}
+		}
+	}
+	
+	for (int i = 0; i < npolys; ++i)
+	{
+		unsigned short* t = &polys[i*vertsPerPoly*2];
+		for (int j = 0; j < vertsPerPoly; ++j)
+		{
+			unsigned short v0 = t[j];
+			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
+			if (v0 > v1)
+			{
+				for (unsigned short e = firstEdge[v1]; e != RC_MESH_NULL_IDX; e = nextEdge[e])
+				{
+					rcEdge& edge = edges[e];
+					if (edge.vert[1] == v0 && edge.poly[0] == edge.poly[1])
+					{
+						edge.poly[1] = (unsigned short)i;
+						edge.polyEdge[1] = (unsigned short)j;
+						break;
+					}
+				}
+			}
+		}
+	}
+	
+	// Store adjacency
+	for (int i = 0; i < edgeCount; ++i)
+	{
+		const rcEdge& e = edges[i];
+		if (e.poly[0] != e.poly[1])
+		{
+			unsigned short* p0 = &polys[e.poly[0]*vertsPerPoly*2];
+			unsigned short* p1 = &polys[e.poly[1]*vertsPerPoly*2];
+			p0[vertsPerPoly + e.polyEdge[0]] = e.poly[1];
+			p1[vertsPerPoly + e.polyEdge[1]] = e.poly[0];
+		}
+	}
+	
+	rcFree(firstEdge);
+	rcFree(edges);
+	
+	return true;
+}
+
+
+static const int VERTEX_BUCKET_COUNT = (1<<12);
+
+inline int computeVertexHash(int x, int y, int z)
+{
+	const unsigned int h1 = 0x8da6b343; // Large multiplicative constants;
+	const unsigned int h2 = 0xd8163841; // here arbitrarily chosen primes
+	const unsigned int h3 = 0xcb1ab31f;
+	unsigned int n = h1 * x + h2 * y + h3 * z;
+	return (int)(n & (VERTEX_BUCKET_COUNT-1));
+}
+
+static unsigned short addVertex(unsigned short x, unsigned short y, unsigned short z,
+								unsigned short* verts, int* firstVert, int* nextVert, int& nv)
+{
+	int bucket = computeVertexHash(x, 0, z);
+	int i = firstVert[bucket];
+	
+	while (i != -1)
+	{
+		const unsigned short* v = &verts[i*3];
+		if (v[0] == x && (rcAbs(v[1] - y) <= 2) && v[2] == z)
+			return (unsigned short)i;
+		i = nextVert[i]; // next
+	}
+	
+	// Could not find, create new.
+	i = nv; nv++;
+	unsigned short* v = &verts[i*3];
+	v[0] = x;
+	v[1] = y;
+	v[2] = z;
+	nextVert[i] = firstVert[bucket];
+	firstVert[bucket] = i;
+	
+	return (unsigned short)i;
+}
+
+inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }
+inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }
+
+inline int area2(const int* a, const int* b, const int* c)
+{
+	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);
+}
+
+//	Exclusive or: true iff exactly one argument is true.
+//	The arguments are negated to ensure that they are 0/1
+//	values.  Then the bitwise Xor operator may apply.
+//	(This idea is due to Michael Baldwin.)
+inline bool xorb(bool x, bool y)
+{
+	return !x ^ !y;
+}
+
+// Returns true iff c is strictly to the left of the directed
+// line through a to b.
+inline bool left(const int* a, const int* b, const int* c)
+{
+	return area2(a, b, c) < 0;
+}
+
+inline bool leftOn(const int* a, const int* b, const int* c)
+{
+	return area2(a, b, c) <= 0;
+}
+
+inline bool collinear(const int* a, const int* b, const int* c)
+{
+	return area2(a, b, c) == 0;
+}
+
+//	Returns true iff ab properly intersects cd: they share
+//	a point interior to both segments.  The properness of the
+//	intersection is ensured by using strict leftness.
+bool intersectProp(const int* a, const int* b, const int* c, const int* d)
+{
+	// Eliminate improper cases.
+	if (collinear(a,b,c) || collinear(a,b,d) ||
+		collinear(c,d,a) || collinear(c,d,b))
+		return false;
+	
+	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));
+}
+
+// Returns T iff (a,b,c) are collinear and point c lies 
+// on the closed segement ab.
+static bool between(const int* a, const int* b, const int* c)
+{
+	if (!collinear(a, b, c))
+		return false;
+	// If ab not vertical, check betweenness on x; else on y.
+	if (a[0] != b[0])
+		return	((a[0] <= c[0]) && (c[0] <= b[0])) || ((a[0] >= c[0]) && (c[0] >= b[0]));
+	else
+		return	((a[2] <= c[2]) && (c[2] <= b[2])) || ((a[2] >= c[2]) && (c[2] >= b[2]));
+}
+
+// Returns true iff segments ab and cd intersect, properly or improperly.
+static bool intersect(const int* a, const int* b, const int* c, const int* d)
+{
+	if (intersectProp(a, b, c, d))
+		return true;
+	else if (between(a, b, c) || between(a, b, d) ||
+			 between(c, d, a) || between(c, d, b))
+		return true;
+	else
+		return false;
+}
+
+static bool vequal(const int* a, const int* b)
+{
+	return a[0] == b[0] && a[2] == b[2];
+}
+
+// Returns T iff (v_i, v_j) is a proper internal *or* external
+// diagonal of P, *ignoring edges incident to v_i and v_j*.
+static bool diagonalie(int i, int j, int n, const int* verts, int* indices)
+{
+	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];
+	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];
+	
+	// For each edge (k,k+1) of P
+	for (int k = 0; k < n; k++)
+	{
+		int k1 = next(k, n);
+		// Skip edges incident to i or j
+		if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))
+		{
+			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];
+			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];
+
+			if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
+				continue;
+			
+			if (intersect(d0, d1, p0, p1))
+				return false;
+		}
+	}
+	return true;
+}
+
+// Returns true iff the diagonal (i,j) is strictly internal to the 
+// polygon P in the neighborhood of the i endpoint.
+static bool	inCone(int i, int j, int n, const int* verts, int* indices)
+{
+	const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];
+	const int* pj = &verts[(indices[j] & 0x0fffffff) * 4];
+	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];
+	const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];
+
+	// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].
+	if (leftOn(pin1, pi, pi1))
+		return left(pi, pj, pin1) && left(pj, pi, pi1);
+	// Assume (i-1,i,i+1) not collinear.
+	// else P[i] is reflex.
+	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));
+}
+
+// Returns T iff (v_i, v_j) is a proper internal
+// diagonal of P.
+static bool diagonal(int i, int j, int n, const int* verts, int* indices)
+{
+	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);
+}
+
+static int triangulate(int n, const int* verts, int* indices, int* tris)
+{
+	int ntris = 0;
+	int* dst = tris;
+	
+	// The last bit of the index is used to indicate if the vertex can be removed.
+	for (int i = 0; i < n; i++)
+	{
+		int i1 = next(i, n);
+		int i2 = next(i1, n);
+		if (diagonal(i, i2, n, verts, indices))
+			indices[i1] |= 0x80000000;
+	}
+	
+	while (n > 3)
+	{
+		int minLen = -1;
+		int mini = -1;
+		for (int i = 0; i < n; i++)
+		{
+			int i1 = next(i, n);
+			if (indices[i1] & 0x80000000)
+			{
+				const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];
+				const int* p2 = &verts[(indices[next(i1, n)] & 0x0fffffff) * 4];
+				
+				int dx = p2[0] - p0[0];
+				int dy = p2[2] - p0[2];
+				int len = dx*dx + dy*dy;
+				
+				if (minLen < 0 || len < minLen)
+				{
+					minLen = len;
+					mini = i;
+				}
+			}
+		}
+		
+		if (mini == -1)
+		{
+			// Should not happen.
+/*			printf("mini == -1 ntris=%d n=%d\n", ntris, n);
+			for (int i = 0; i < n; i++)
+			{
+				printf("%d ", indices[i] & 0x0fffffff);
+			}
+			printf("\n");*/
+			return -ntris;
+		}
+		
+		int i = mini;
+		int i1 = next(i, n);
+		int i2 = next(i1, n);
+		
+		*dst++ = indices[i] & 0x0fffffff;
+		*dst++ = indices[i1] & 0x0fffffff;
+		*dst++ = indices[i2] & 0x0fffffff;
+		ntris++;
+		
+		// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
+		n--;
+		for (int k = i1; k < n; k++)
+			indices[k] = indices[k+1];
+		
+		if (i1 >= n) i1 = 0;
+		i = prev(i1,n);
+		// Update diagonal flags.
+		if (diagonal(prev(i, n), i1, n, verts, indices))
+			indices[i] |= 0x80000000;
+		else
+			indices[i] &= 0x0fffffff;
+		
+		if (diagonal(i, next(i1, n), n, verts, indices))
+			indices[i1] |= 0x80000000;
+		else
+			indices[i1] &= 0x0fffffff;
+	}
+	
+	// Append the remaining triangle.
+	*dst++ = indices[0] & 0x0fffffff;
+	*dst++ = indices[1] & 0x0fffffff;
+	*dst++ = indices[2] & 0x0fffffff;
+	ntris++;
+	
+	return ntris;
+}
+
+static int countPolyVerts(const unsigned short* p, const int nvp)
+{
+	for (int i = 0; i < nvp; ++i)
+		if (p[i] == RC_MESH_NULL_IDX)
+			return i;
+	return nvp;
+}
+
+inline bool uleft(const unsigned short* a, const unsigned short* b, const unsigned short* c)
+{
+	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -
+		   ((int)c[0] - (int)a[0]) * ((int)b[2] - (int)a[2]) < 0;
+}
+
+static int getPolyMergeValue(unsigned short* pa, unsigned short* pb,
+							 const unsigned short* verts, int& ea, int& eb,
+							 const int nvp)
+{
+	const int na = countPolyVerts(pa, nvp);
+	const int nb = countPolyVerts(pb, nvp);
+	
+	// If the merged polygon would be too big, do not merge.
+	if (na+nb-2 > nvp)
+		return -1;
+	
+	// Check if the polygons share an edge.
+	ea = -1;
+	eb = -1;
+	
+	for (int i = 0; i < na; ++i)
+	{
+		unsigned short va0 = pa[i];
+		unsigned short va1 = pa[(i+1) % na];
+		if (va0 > va1)
+			rcSwap(va0, va1);
+		for (int j = 0; j < nb; ++j)
+		{
+			unsigned short vb0 = pb[j];
+			unsigned short vb1 = pb[(j+1) % nb];
+			if (vb0 > vb1)
+				rcSwap(vb0, vb1);
+			if (va0 == vb0 && va1 == vb1)
+			{
+				ea = i;
+				eb = j;
+				break;
+			}
+		}
+	}
+	
+	// No common edge, cannot merge.
+	if (ea == -1 || eb == -1)
+		return -1;
+	
+	// Check to see if the merged polygon would be convex.
+	unsigned short va, vb, vc;
+	
+	va = pa[(ea+na-1) % na];
+	vb = pa[ea];
+	vc = pb[(eb+2) % nb];
+	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))
+		return -1;
+	
+	va = pb[(eb+nb-1) % nb];
+	vb = pb[eb];
+	vc = pa[(ea+2) % na];
+	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))
+		return -1;
+	
+	va = pa[ea];
+	vb = pa[(ea+1)%na];
+	
+	int dx = (int)verts[va*3+0] - (int)verts[vb*3+0];
+	int dy = (int)verts[va*3+2] - (int)verts[vb*3+2];
+	
+	return dx*dx + dy*dy;
+}
+
+static void mergePolys(unsigned short* pa, unsigned short* pb, int ea, int eb,
+					   unsigned short* tmp, const int nvp)
+{
+	const int na = countPolyVerts(pa, nvp);
+	const int nb = countPolyVerts(pb, nvp);
+	
+	// Merge polygons.
+	memset(tmp, 0xff, sizeof(unsigned short)*nvp);
+	int n = 0;
+	// Add pa
+	for (int i = 0; i < na-1; ++i)
+		tmp[n++] = pa[(ea+1+i) % na];
+	// Add pb
+	for (int i = 0; i < nb-1; ++i)
+		tmp[n++] = pb[(eb+1+i) % nb];
+	
+	memcpy(pa, tmp, sizeof(unsigned short)*nvp);
+}
+
+static void pushFront(int v, int* arr, int& an)
+{
+	an++;
+	for (int i = an-1; i > 0; --i) arr[i] = arr[i-1];
+	arr[0] = v;
+}
+
+static void pushBack(int v, int* arr, int& an)
+{
+	arr[an] = v;
+	an++;
+}
+
+static bool canRemoveVertex(rcContext* ctx, rcPolyMesh& mesh, const unsigned short rem)
+{
+	const int nvp = mesh.nvp;
+	
+	// Count number of polygons to remove.
+	int numRemovedVerts = 0;
+	int numTouchedVerts = 0;
+	int numRemainingEdges = 0;
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		unsigned short* p = &mesh.polys[i*nvp*2];
+		const int nv = countPolyVerts(p, nvp);
+		int numRemoved = 0;
+		int numVerts = 0;
+		for (int j = 0; j < nv; ++j)
+		{
+			if (p[j] == rem)
+			{
+				numTouchedVerts++;
+				numRemoved++;
+			}
+			numVerts++;
+		}
+		if (numRemoved)
+		{
+			numRemovedVerts += numRemoved;
+			numRemainingEdges += numVerts-(numRemoved+1);
+		}
+	}
+	
+	// There would be too few edges remaining to create a polygon.
+	// This can happen for example when a tip of a triangle is marked
+	// as deletion, but there are no other polys that share the vertex.
+	// In this case, the vertex should not be removed.
+	if (numRemainingEdges <= 2)
+		return false;
+	
+	// Find edges which share the removed vertex.
+	const int maxEdges = numTouchedVerts*2;
+	int nedges = 0;
+	rcScopedDelete<int> edges = (int*)rcAlloc(sizeof(int)*maxEdges*3, RC_ALLOC_TEMP);
+	if (!edges)
+	{
+		ctx->log(RC_LOG_WARNING, "canRemoveVertex: Out of memory 'edges' (%d).", maxEdges*3);
+		return false;
+	}
+		
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		unsigned short* p = &mesh.polys[i*nvp*2];
+		const int nv = countPolyVerts(p, nvp);
+
+		// Collect edges which touches the removed vertex.
+		for (int j = 0, k = nv-1; j < nv; k = j++)
+		{
+			if (p[j] == rem || p[k] == rem)
+			{
+				// Arrange edge so that a=rem.
+				int a = p[j], b = p[k];
+				if (b == rem)
+					rcSwap(a,b);
+					
+				// Check if the edge exists
+				bool exists = false;
+				for (int k = 0; k < nedges; ++k)
+				{
+					int* e = &edges[k*3];
+					if (e[1] == b)
+					{
+						// Exists, increment vertex share count.
+						e[2]++;
+						exists = true;
+					}
+				}
+				// Add new edge.
+				if (!exists)
+				{
+					int* e = &edges[nedges*3];
+					e[0] = a;
+					e[1] = b;
+					e[2] = 1;
+					nedges++;
+				}
+			}
+		}
+	}
+
+	// There should be no more than 2 open edges.
+	// This catches the case that two non-adjacent polygons
+	// share the removed vertex. In that case, do not remove the vertex.
+	int numOpenEdges = 0;
+	for (int i = 0; i < nedges; ++i)
+	{
+		if (edges[i*3+2] < 2)
+			numOpenEdges++;
+	}
+	if (numOpenEdges > 2)
+		return false;
+	
+	return true;
+}
+
+static bool removeVertex(rcContext* ctx, rcPolyMesh& mesh, const unsigned short rem, const int maxTris)
+{
+	const int nvp = mesh.nvp;
+
+	// Count number of polygons to remove.
+	int numRemovedVerts = 0;
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		unsigned short* p = &mesh.polys[i*nvp*2];
+		const int nv = countPolyVerts(p, nvp);
+		for (int j = 0; j < nv; ++j)
+		{
+			if (p[j] == rem)
+				numRemovedVerts++;
+		}
+	}
+	
+	int nedges = 0;
+	rcScopedDelete<int> edges = (int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp*4, RC_ALLOC_TEMP);
+	if (!edges)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'edges' (%d).", numRemovedVerts*nvp*4);
+		return false;
+	}
+
+	int nhole = 0;
+	rcScopedDelete<int> hole = (int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP);
+	if (!hole)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'hole' (%d).", numRemovedVerts*nvp);
+		return false;
+	}
+	
+	int nhreg = 0;
+	rcScopedDelete<int> hreg = (int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP);
+	if (!hreg)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'hreg' (%d).", numRemovedVerts*nvp);
+		return false;
+	}
+
+	int nharea = 0;
+	rcScopedDelete<int> harea = (int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP);
+	if (!harea)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'harea' (%d).", numRemovedVerts*nvp);
+		return false;
+	}
+	
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		unsigned short* p = &mesh.polys[i*nvp*2];
+		const int nv = countPolyVerts(p, nvp);
+		bool hasRem = false;
+		for (int j = 0; j < nv; ++j)
+			if (p[j] == rem) hasRem = true;
+		if (hasRem)
+		{
+			// Collect edges which does not touch the removed vertex.
+			for (int j = 0, k = nv-1; j < nv; k = j++)
+			{
+				if (p[j] != rem && p[k] != rem)
+				{
+					int* e = &edges[nedges*4];
+					e[0] = p[k];
+					e[1] = p[j];
+					e[2] = mesh.regs[i];
+					e[3] = mesh.areas[i];
+					nedges++;
+				}
+			}
+			// Remove the polygon.
+			unsigned short* p2 = &mesh.polys[(mesh.npolys-1)*nvp*2];
+			memcpy(p,p2,sizeof(unsigned short)*nvp);
+			memset(p+nvp,0xff,sizeof(unsigned short)*nvp);
+			mesh.regs[i] = mesh.regs[mesh.npolys-1];
+			mesh.areas[i] = mesh.areas[mesh.npolys-1];
+			mesh.npolys--;
+			--i;
+		}
+	}
+	
+	// Remove vertex.
+	for (int i = (int)rem; i < mesh.nverts; ++i)
+	{
+		mesh.verts[i*3+0] = mesh.verts[(i+1)*3+0];
+		mesh.verts[i*3+1] = mesh.verts[(i+1)*3+1];
+		mesh.verts[i*3+2] = mesh.verts[(i+1)*3+2];
+	}
+	mesh.nverts--;
+
+	// Adjust indices to match the removed vertex layout.
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		unsigned short* p = &mesh.polys[i*nvp*2];
+		const int nv = countPolyVerts(p, nvp);
+		for (int j = 0; j < nv; ++j)
+			if (p[j] > rem) p[j]--;
+	}
+	for (int i = 0; i < nedges; ++i)
+	{
+		if (edges[i*4+0] > rem) edges[i*4+0]--;
+		if (edges[i*4+1] > rem) edges[i*4+1]--;
+	}
+
+	if (nedges == 0)
+		return true;
+
+	// Start with one vertex, keep appending connected
+	// segments to the start and end of the hole.
+	pushBack(edges[0], hole, nhole);
+	pushBack(edges[2], hreg, nhreg);
+	pushBack(edges[3], harea, nharea);
+	
+	while (nedges)
+	{
+		bool match = false;
+		
+		for (int i = 0; i < nedges; ++i)
+		{
+			const int ea = edges[i*4+0];
+			const int eb = edges[i*4+1];
+			const int r = edges[i*4+2];
+			const int a = edges[i*4+3];
+			bool add = false;
+			if (hole[0] == eb)
+			{
+				// The segment matches the beginning of the hole boundary.
+				pushFront(ea, hole, nhole);
+				pushFront(r, hreg, nhreg);
+				pushFront(a, harea, nharea);
+				add = true;
+			}
+			else if (hole[nhole-1] == ea)
+			{
+				// The segment matches the end of the hole boundary.
+				pushBack(eb, hole, nhole);
+				pushBack(r, hreg, nhreg);
+				pushBack(a, harea, nharea);
+				add = true;
+			}
+			if (add)
+			{
+				// The edge segment was added, remove it.
+				edges[i*4+0] = edges[(nedges-1)*4+0];
+				edges[i*4+1] = edges[(nedges-1)*4+1];
+				edges[i*4+2] = edges[(nedges-1)*4+2];
+				edges[i*4+3] = edges[(nedges-1)*4+3];
+				--nedges;
+				match = true;
+				--i;
+			}
+		}
+		
+		if (!match)
+			break;
+	}
+
+	rcScopedDelete<int> tris = (int*)rcAlloc(sizeof(int)*nhole*3, RC_ALLOC_TEMP);
+	if (!tris)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'tris' (%d).", nhole*3);
+		return false;
+	}
+
+	rcScopedDelete<int> tverts = (int*)rcAlloc(sizeof(int)*nhole*4, RC_ALLOC_TEMP);
+	if (!tverts)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'tverts' (%d).", nhole*4);
+		return false;
+	}
+
+	rcScopedDelete<int> thole = (int*)rcAlloc(sizeof(int)*nhole, RC_ALLOC_TEMP);
+	if (!tverts)
+	{
+		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'thole' (%d).", nhole);
+		return false;
+	}
+
+	// Generate temp vertex array for triangulation.
+	for (int i = 0; i < nhole; ++i)
+	{
+		const int pi = hole[i];
+		tverts[i*4+0] = mesh.verts[pi*3+0];
+		tverts[i*4+1] = mesh.verts[pi*3+1];
+		tverts[i*4+2] = mesh.verts[pi*3+2];
+		tverts[i*4+3] = 0;
+		thole[i] = i;
+	}
+
+	// Triangulate the hole.
+	int ntris = triangulate(nhole, &tverts[0], &thole[0], tris);
+	if (ntris < 0)
+	{
+		ntris = -ntris;
+		ctx->log(RC_LOG_WARNING, "removeVertex: triangulate() returned bad results.");
+	}
+	
+	// Merge the hole triangles back to polygons.
+	rcScopedDelete<unsigned short> polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*(ntris+1)*nvp, RC_ALLOC_TEMP);
+	if (!polys)
+	{
+		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'polys' (%d).", (ntris+1)*nvp);
+		return false;
+	}
+	rcScopedDelete<unsigned short> pregs = (unsigned short*)rcAlloc(sizeof(unsigned short)*ntris, RC_ALLOC_TEMP);
+	if (!pregs)
+	{
+		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'pregs' (%d).", ntris);
+		return false;
+	}
+	rcScopedDelete<unsigned char> pareas = (unsigned char*)rcAlloc(sizeof(unsigned char)*ntris, RC_ALLOC_TEMP);
+	if (!pregs)
+	{
+		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'pareas' (%d).", ntris);
+		return false;
+	}
+	
+	unsigned short* tmpPoly = &polys[ntris*nvp];
+			
+	// Build initial polygons.
+	int npolys = 0;
+	memset(polys, 0xff, ntris*nvp*sizeof(unsigned short));
+	for (int j = 0; j < ntris; ++j)
+	{
+		int* t = &tris[j*3];
+		if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])
+		{
+			polys[npolys*nvp+0] = (unsigned short)hole[t[0]];
+			polys[npolys*nvp+1] = (unsigned short)hole[t[1]];
+			polys[npolys*nvp+2] = (unsigned short)hole[t[2]];
+			pregs[npolys] = (unsigned short)hreg[t[0]];
+			pareas[npolys] = (unsigned char)harea[t[0]];
+			npolys++;
+		}
+	}
+	if (!npolys)
+		return true;
+	
+	// Merge polygons.
+	if (nvp > 3)
+	{
+		for (;;)
+		{
+			// Find best polygons to merge.
+			int bestMergeVal = 0;
+			int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
+			
+			for (int j = 0; j < npolys-1; ++j)
+			{
+				unsigned short* pj = &polys[j*nvp];
+				for (int k = j+1; k < npolys; ++k)
+				{
+					unsigned short* pk = &polys[k*nvp];
+					int ea, eb;
+					int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);
+					if (v > bestMergeVal)
+					{
+						bestMergeVal = v;
+						bestPa = j;
+						bestPb = k;
+						bestEa = ea;
+						bestEb = eb;
+					}
+				}
+			}
+			
+			if (bestMergeVal > 0)
+			{
+				// Found best, merge.
+				unsigned short* pa = &polys[bestPa*nvp];
+				unsigned short* pb = &polys[bestPb*nvp];
+				mergePolys(pa, pb, bestEa, bestEb, tmpPoly, nvp);
+				memcpy(pb, &polys[(npolys-1)*nvp], sizeof(unsigned short)*nvp);
+				pregs[bestPb] = pregs[npolys-1];
+				pareas[bestPb] = pareas[npolys-1];
+				npolys--;
+			}
+			else
+			{
+				// Could not merge any polygons, stop.
+				break;
+			}
+		}
+	}
+	
+	// Store polygons.
+	for (int i = 0; i < npolys; ++i)
+	{
+		if (mesh.npolys >= maxTris) break;
+		unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];
+		memset(p,0xff,sizeof(unsigned short)*nvp*2);
+		for (int j = 0; j < nvp; ++j)
+			p[j] = polys[i*nvp+j];
+		mesh.regs[mesh.npolys] = pregs[i];
+		mesh.areas[mesh.npolys] = pareas[i];
+		mesh.npolys++;
+		if (mesh.npolys > maxTris)
+		{
+			ctx->log(RC_LOG_ERROR, "removeVertex: Too many polygons %d (max:%d).", mesh.npolys, maxTris);
+			return false;
+		}
+	}
+	
+	return true;
+}
+
+
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_POLYMESH);
+
+	rcVcopy(mesh.bmin, cset.bmin);
+	rcVcopy(mesh.bmax, cset.bmax);
+	mesh.cs = cset.cs;
+	mesh.ch = cset.ch;
+	
+	int maxVertices = 0;
+	int maxTris = 0;
+	int maxVertsPerCont = 0;
+	for (int i = 0; i < cset.nconts; ++i)
+	{
+		// Skip null contours.
+		if (cset.conts[i].nverts < 3) continue;
+		maxVertices += cset.conts[i].nverts;
+		maxTris += cset.conts[i].nverts - 2;
+		maxVertsPerCont = rcMax(maxVertsPerCont, cset.conts[i].nverts);
+	}
+	
+	if (maxVertices >= 0xfffe)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Too many vertices %d.", maxVertices);
+		return false;
+	}
+		
+	rcScopedDelete<unsigned char> vflags = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxVertices, RC_ALLOC_TEMP);
+	if (!vflags)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).", maxVertices);
+		return false;
+	}
+	memset(vflags, 0, maxVertices);
+	
+	mesh.verts = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVertices*3, RC_ALLOC_PERM);
+	if (!mesh.verts)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).", maxVertices);
+		return false;
+	}
+	mesh.polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris*nvp*2*2, RC_ALLOC_PERM);
+	if (!mesh.polys)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.polys' (%d).", maxTris*nvp*2);
+		return false;
+	}
+	mesh.regs = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris, RC_ALLOC_PERM);
+	if (!mesh.regs)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.regs' (%d).", maxTris);
+		return false;
+	}
+	mesh.areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxTris, RC_ALLOC_PERM);
+	if (!mesh.areas)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.areas' (%d).", maxTris);
+		return false;
+	}
+	
+	mesh.nverts = 0;
+	mesh.npolys = 0;
+	mesh.nvp = nvp;
+	mesh.maxpolys = maxTris;
+	
+	memset(mesh.verts, 0, sizeof(unsigned short)*maxVertices*3);
+	memset(mesh.polys, 0xff, sizeof(unsigned short)*maxTris*nvp*2);
+	memset(mesh.regs, 0, sizeof(unsigned short)*maxTris);
+	memset(mesh.areas, 0, sizeof(unsigned char)*maxTris);
+	
+	rcScopedDelete<int> nextVert = (int*)rcAlloc(sizeof(int)*maxVertices, RC_ALLOC_TEMP);
+	if (!nextVert)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'nextVert' (%d).", maxVertices);
+		return false;
+	}
+	memset(nextVert, 0, sizeof(int)*maxVertices);
+	
+	rcScopedDelete<int> firstVert = (int*)rcAlloc(sizeof(int)*VERTEX_BUCKET_COUNT, RC_ALLOC_TEMP);
+	if (!firstVert)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'firstVert' (%d).", VERTEX_BUCKET_COUNT);
+		return false;
+	}
+	for (int i = 0; i < VERTEX_BUCKET_COUNT; ++i)
+		firstVert[i] = -1;
+	
+	rcScopedDelete<int> indices = (int*)rcAlloc(sizeof(int)*maxVertsPerCont, RC_ALLOC_TEMP);
+	if (!indices)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'indices' (%d).", maxVertsPerCont);
+		return false;
+	}
+	rcScopedDelete<int> tris = (int*)rcAlloc(sizeof(int)*maxVertsPerCont*3, RC_ALLOC_TEMP);
+	if (!tris)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'tris' (%d).", maxVertsPerCont*3);
+		return false;
+	}
+	rcScopedDelete<unsigned short> polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*(maxVertsPerCont+1)*nvp, RC_ALLOC_TEMP);
+	if (!polys)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'polys' (%d).", maxVertsPerCont*nvp);
+		return false;
+	}
+	unsigned short* tmpPoly = &polys[maxVertsPerCont*nvp];
+
+	for (int i = 0; i < cset.nconts; ++i)
+	{
+		rcContour& cont = cset.conts[i];
+		
+		// Skip null contours.
+		if (cont.nverts < 3)
+			continue;
+		
+		// Triangulate contour
+		for (int j = 0; j < cont.nverts; ++j)
+			indices[j] = j;
+			
+		int ntris = triangulate(cont.nverts, cont.verts, &indices[0], &tris[0]);
+		if (ntris <= 0)
+		{
+			// Bad triangulation, should not happen.
+/*			printf("\tconst float bmin[3] = {%ff,%ff,%ff};\n", cset.bmin[0], cset.bmin[1], cset.bmin[2]);
+			printf("\tconst float cs = %ff;\n", cset.cs);
+			printf("\tconst float ch = %ff;\n", cset.ch);
+			printf("\tconst int verts[] = {\n");
+			for (int k = 0; k < cont.nverts; ++k)
+			{
+				const int* v = &cont.verts[k*4];
+				printf("\t\t%d,%d,%d,%d,\n", v[0], v[1], v[2], v[3]);
+			}
+			printf("\t};\n\tconst int nverts = sizeof(verts)/(sizeof(int)*4);\n");*/
+			ctx->log(RC_LOG_WARNING, "rcBuildPolyMesh: Bad triangulation Contour %d.", i);
+			ntris = -ntris;
+		}
+				
+		// Add and merge vertices.
+		for (int j = 0; j < cont.nverts; ++j)
+		{
+			const int* v = &cont.verts[j*4];
+			indices[j] = addVertex((unsigned short)v[0], (unsigned short)v[1], (unsigned short)v[2],
+								   mesh.verts, firstVert, nextVert, mesh.nverts);
+			if (v[3] & RC_BORDER_VERTEX)
+			{
+				// This vertex should be removed.
+				vflags[indices[j]] = 1;
+			}
+		}
+		
+		// Build initial polygons.
+		int npolys = 0;
+		memset(polys, 0xff, maxVertsPerCont*nvp*sizeof(unsigned short));
+		for (int j = 0; j < ntris; ++j)
+		{
+			int* t = &tris[j*3];
+			if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])
+			{
+				polys[npolys*nvp+0] = (unsigned short)indices[t[0]];
+				polys[npolys*nvp+1] = (unsigned short)indices[t[1]];
+				polys[npolys*nvp+2] = (unsigned short)indices[t[2]];
+				npolys++;
+			}
+		}
+		if (!npolys)
+			continue;
+		
+		// Merge polygons.
+		if (nvp > 3)
+		{
+			for(;;)
+			{
+				// Find best polygons to merge.
+				int bestMergeVal = 0;
+				int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
+				
+				for (int j = 0; j < npolys-1; ++j)
+				{
+					unsigned short* pj = &polys[j*nvp];
+					for (int k = j+1; k < npolys; ++k)
+					{
+						unsigned short* pk = &polys[k*nvp];
+						int ea, eb;
+						int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);
+						if (v > bestMergeVal)
+						{
+							bestMergeVal = v;
+							bestPa = j;
+							bestPb = k;
+							bestEa = ea;
+							bestEb = eb;
+						}
+					}
+				}
+				
+				if (bestMergeVal > 0)
+				{
+					// Found best, merge.
+					unsigned short* pa = &polys[bestPa*nvp];
+					unsigned short* pb = &polys[bestPb*nvp];
+					mergePolys(pa, pb, bestEa, bestEb, tmpPoly, nvp);
+					memcpy(pb, &polys[(npolys-1)*nvp], sizeof(unsigned short)*nvp);
+					npolys--;
+				}
+				else
+				{
+					// Could not merge any polygons, stop.
+					break;
+				}
+			}
+		}
+		
+		// Store polygons.
+		for (int j = 0; j < npolys; ++j)
+		{
+			unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];
+			unsigned short* q = &polys[j*nvp];
+			for (int k = 0; k < nvp; ++k)
+				p[k] = q[k];
+			mesh.regs[mesh.npolys] = cont.reg;
+			mesh.areas[mesh.npolys] = cont.area;
+			mesh.npolys++;
+			if (mesh.npolys > maxTris)
+			{
+				ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Too many polygons %d (max:%d).", mesh.npolys, maxTris);
+				return false;
+			}
+		}
+	}
+	
+	
+	// Remove edge vertices.
+	for (int i = 0; i < mesh.nverts; ++i)
+	{
+		if (vflags[i])
+		{
+			if (!canRemoveVertex(ctx, mesh, (unsigned short)i))
+				continue;
+			if (!removeVertex(ctx, mesh, (unsigned short)i, maxTris))
+			{
+				// Failed to remove vertex
+				ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Failed to remove edge vertex %d.", i);
+				return false;
+			}
+			// Remove vertex
+			// Note: mesh.nverts is already decremented inside removeVertex()!
+			for (int j = i; j < mesh.nverts; ++j)
+				vflags[j] = vflags[j+1];
+			--i;
+		}
+	}
+	
+	// Calculate adjacency.
+	if (!buildMeshAdjacency(mesh.polys, mesh.npolys, mesh.nverts, nvp))
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Adjacency failed.");
+		return false;
+	}
+
+	// Just allocate the mesh flags array. The user is resposible to fill it.
+	mesh.flags = (unsigned short*)rcAlloc(sizeof(unsigned short)*mesh.npolys, RC_ALLOC_PERM);
+	if (!mesh.flags)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.flags' (%d).", mesh.npolys);
+		return false;
+	}
+	memset(mesh.flags, 0, sizeof(unsigned short) * mesh.npolys);
+	
+	if (mesh.nverts > 0xffff)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
+	}
+	if (mesh.npolys > 0xffff)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
+	}
+	
+	ctx->stopTimer(RC_TIMER_BUILD_POLYMESH);
+	
+	return true;
+}
+
+bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh)
+{
+	rcAssert(ctx);
+	
+	if (!nmeshes || !meshes)
+		return true;
+
+	ctx->startTimer(RC_TIMER_MERGE_POLYMESH);
+
+	mesh.nvp = meshes[0]->nvp;
+	mesh.cs = meshes[0]->cs;
+	mesh.ch = meshes[0]->ch;
+	rcVcopy(mesh.bmin, meshes[0]->bmin);
+	rcVcopy(mesh.bmax, meshes[0]->bmax);
+
+	int maxVerts = 0;
+	int maxPolys = 0;
+	int maxVertsPerMesh = 0;
+	for (int i = 0; i < nmeshes; ++i)
+	{
+		rcVmin(mesh.bmin, meshes[i]->bmin);
+		rcVmax(mesh.bmax, meshes[i]->bmax);
+		maxVertsPerMesh = rcMax(maxVertsPerMesh, meshes[i]->nverts);
+		maxVerts += meshes[i]->nverts;
+		maxPolys += meshes[i]->npolys;
+	}
+	
+	mesh.nverts = 0;
+	mesh.verts = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVerts*3, RC_ALLOC_PERM);
+	if (!mesh.verts)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'mesh.verts' (%d).", maxVerts*3);
+		return false;
+	}
+
+	mesh.npolys = 0;
+	mesh.polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxPolys*2*mesh.nvp, RC_ALLOC_PERM);
+	if (!mesh.polys)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'mesh.polys' (%d).", maxPolys*2*mesh.nvp);
+		return false;
+	}
+	memset(mesh.polys, 0xff, sizeof(unsigned short)*maxPolys*2*mesh.nvp);
+
+	mesh.regs = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxPolys, RC_ALLOC_PERM);
+	if (!mesh.regs)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'mesh.regs' (%d).", maxPolys);
+		return false;
+	}
+	memset(mesh.regs, 0, sizeof(unsigned short)*maxPolys);
+
+	mesh.areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxPolys, RC_ALLOC_PERM);
+	if (!mesh.areas)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'mesh.areas' (%d).", maxPolys);
+		return false;
+	}
+	memset(mesh.areas, 0, sizeof(unsigned char)*maxPolys);
+
+	mesh.flags = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxPolys, RC_ALLOC_PERM);
+	if (!mesh.flags)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'mesh.flags' (%d).", maxPolys);
+		return false;
+	}
+	memset(mesh.flags, 0, sizeof(unsigned short)*maxPolys);
+	
+	rcScopedDelete<int> nextVert = (int*)rcAlloc(sizeof(int)*maxVerts, RC_ALLOC_TEMP);
+	if (!nextVert)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'nextVert' (%d).", maxVerts);
+		return false;
+	}
+	memset(nextVert, 0, sizeof(int)*maxVerts);
+	
+	rcScopedDelete<int> firstVert = (int*)rcAlloc(sizeof(int)*VERTEX_BUCKET_COUNT, RC_ALLOC_TEMP);
+	if (!firstVert)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'firstVert' (%d).", VERTEX_BUCKET_COUNT);
+		return false;
+	}
+	for (int i = 0; i < VERTEX_BUCKET_COUNT; ++i)
+		firstVert[i] = -1;
+
+	rcScopedDelete<unsigned short> vremap = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVertsPerMesh, RC_ALLOC_PERM);
+	if (!vremap)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Out of memory 'vremap' (%d).", maxVertsPerMesh);
+		return false;
+	}
+	memset(nextVert, 0, sizeof(int)*maxVerts);
+	
+	for (int i = 0; i < nmeshes; ++i)
+	{
+		const rcPolyMesh* pmesh = meshes[i];
+		
+		const unsigned short ox = (unsigned short)floorf((pmesh->bmin[0]-mesh.bmin[0])/mesh.cs+0.5f);
+		const unsigned short oz = (unsigned short)floorf((pmesh->bmin[2]-mesh.bmin[2])/mesh.cs+0.5f);
+		
+		for (int j = 0; j < pmesh->nverts; ++j)
+		{
+			unsigned short* v = &pmesh->verts[j*3];
+			vremap[j] = addVertex(v[0]+ox, v[1], v[2]+oz,
+								  mesh.verts, firstVert, nextVert, mesh.nverts);
+		}
+		
+		for (int j = 0; j < pmesh->npolys; ++j)
+		{
+			unsigned short* tgt = &mesh.polys[mesh.npolys*2*mesh.nvp];
+			unsigned short* src = &pmesh->polys[j*2*mesh.nvp];
+			mesh.regs[mesh.npolys] = pmesh->regs[j];
+			mesh.areas[mesh.npolys] = pmesh->areas[j];
+			mesh.flags[mesh.npolys] = pmesh->flags[j];
+			mesh.npolys++;
+			for (int k = 0; k < mesh.nvp; ++k)
+			{
+				if (src[k] == RC_MESH_NULL_IDX) break;
+				tgt[k] = vremap[src[k]];
+			}
+		}
+	}
+
+	// Calculate adjacency.
+	if (!buildMeshAdjacency(mesh.polys, mesh.npolys, mesh.nverts, mesh.nvp))
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: Adjacency failed.");
+		return false;
+	}
+
+	if (mesh.nverts > 0xffff)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
+	}
+	if (mesh.npolys > 0xffff)
+	{
+		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
+	}
+	
+	ctx->stopTimer(RC_TIMER_MERGE_POLYMESH);
+	
+	return true;
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastMeshDetail.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastMeshDetail.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,1237 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <float.h>
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+
+static const unsigned RC_UNSET_HEIGHT = 0xffff;
+
+struct rcHeightPatch
+{
+	inline rcHeightPatch() : data(0), xmin(0), ymin(0), width(0), height(0) {}
+	inline ~rcHeightPatch() { rcFree(data); }
+	unsigned short* data;
+	int xmin, ymin, width, height;
+};
+
+
+inline float vdot2(const float* a, const float* b)
+{
+	return a[0]*b[0] + a[2]*b[2];
+}
+
+inline float vdistSq2(const float* p, const float* q)
+{
+	const float dx = q[0] - p[0];
+	const float dy = q[2] - p[2];
+	return dx*dx + dy*dy;
+}
+
+inline float vdist2(const float* p, const float* q)
+{
+	return sqrtf(vdistSq2(p,q));
+}
+
+inline float vcross2(const float* p1, const float* p2, const float* p3)
+{ 
+	const float u1 = p2[0] - p1[0];
+	const float v1 = p2[2] - p1[2];
+	const float u2 = p3[0] - p1[0];
+	const float v2 = p3[2] - p1[2];
+	return u1 * v2 - v1 * u2;
+}
+
+static bool circumCircle(const float* p1, const float* p2, const float* p3,
+						 float* c, float& r)
+{
+	static const float EPS = 1e-6f;
+	
+	const float cp = vcross2(p1, p2, p3);
+	if (fabsf(cp) > EPS)
+	{
+		const float p1Sq = vdot2(p1,p1);
+		const float p2Sq = vdot2(p2,p2);
+		const float p3Sq = vdot2(p3,p3);
+		c[0] = (p1Sq*(p2[2]-p3[2]) + p2Sq*(p3[2]-p1[2]) + p3Sq*(p1[2]-p2[2])) / (2*cp);
+		c[2] = (p1Sq*(p3[0]-p2[0]) + p2Sq*(p1[0]-p3[0]) + p3Sq*(p2[0]-p1[0])) / (2*cp);
+		r = vdist2(c, p1);
+		return true;
+	}
+
+	c[0] = p1[0];
+	c[2] = p1[2];
+	r = 0;
+	return false;
+}
+
+static float distPtTri(const float* p, const float* a, const float* b, const float* c)
+{
+	float v0[3], v1[3], v2[3];
+	rcVsub(v0, c,a);
+	rcVsub(v1, b,a);
+	rcVsub(v2, p,a);
+
+	const float dot00 = vdot2(v0, v0);
+	const float dot01 = vdot2(v0, v1);
+	const float dot02 = vdot2(v0, v2);
+	const float dot11 = vdot2(v1, v1);
+	const float dot12 = vdot2(v1, v2);
+	
+	// Compute barycentric coordinates
+	const float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
+	const float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
+	float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
+	
+	// If point lies inside the triangle, return interpolated y-coord.
+	static const float EPS = 1e-4f;
+	if (u >= -EPS && v >= -EPS && (u+v) <= 1+EPS)
+	{
+		const float y = a[1] + v0[1]*u + v1[1]*v;
+		return fabsf(y-p[1]);
+	}
+	return FLT_MAX;
+}
+
+static float distancePtSeg(const float* pt, const float* p, const float* q)
+{
+	float pqx = q[0] - p[0];
+	float pqy = q[1] - p[1];
+	float pqz = q[2] - p[2];
+	float dx = pt[0] - p[0];
+	float dy = pt[1] - p[1];
+	float dz = pt[2] - p[2];
+	float d = pqx*pqx + pqy*pqy + pqz*pqz;
+	float t = pqx*dx + pqy*dy + pqz*dz;
+	if (d > 0)
+		t /= d;
+	if (t < 0)
+		t = 0;
+	else if (t > 1)
+		t = 1;
+	
+	dx = p[0] + t*pqx - pt[0];
+	dy = p[1] + t*pqy - pt[1];
+	dz = p[2] + t*pqz - pt[2];
+	
+	return dx*dx + dy*dy + dz*dz;
+}
+
+static float distancePtSeg2d(const float* pt, const float* p, const float* q)
+{
+	float pqx = q[0] - p[0];
+	float pqz = q[2] - p[2];
+	float dx = pt[0] - p[0];
+	float dz = pt[2] - p[2];
+	float d = pqx*pqx + pqz*pqz;
+	float t = pqx*dx + pqz*dz;
+	if (d > 0)
+		t /= d;
+	if (t < 0)
+		t = 0;
+	else if (t > 1)
+		t = 1;
+	
+	dx = p[0] + t*pqx - pt[0];
+	dz = p[2] + t*pqz - pt[2];
+	
+	return dx*dx + dz*dz;
+}
+
+static float distToTriMesh(const float* p, const float* verts, const int /*nverts*/, const int* tris, const int ntris)
+{
+	float dmin = FLT_MAX;
+	for (int i = 0; i < ntris; ++i)
+	{
+		const float* va = &verts[tris[i*4+0]*3];
+		const float* vb = &verts[tris[i*4+1]*3];
+		const float* vc = &verts[tris[i*4+2]*3];
+		float d = distPtTri(p, va,vb,vc);
+		if (d < dmin)
+			dmin = d;
+	}
+	if (dmin == FLT_MAX) return -1;
+	return dmin;
+}
+
+static float distToPoly(int nvert, const float* verts, const float* p)
+{
+
+	float dmin = FLT_MAX;
+	int i, j, c = 0;
+	for (i = 0, j = nvert-1; i < nvert; j = i++)
+	{
+		const float* vi = &verts[i*3];
+		const float* vj = &verts[j*3];
+		if (((vi[2] > p[2]) != (vj[2] > p[2])) &&
+			(p[0] < (vj[0]-vi[0]) * (p[2]-vi[2]) / (vj[2]-vi[2]) + vi[0]) )
+			c = !c;
+		dmin = rcMin(dmin, distancePtSeg2d(p, vj, vi));
+	}
+	return c ? -dmin : dmin;
+}
+
+
+static unsigned short getHeight(const float fx, const float fy, const float fz,
+								const float /*cs*/, const float ics, const float ch,
+								const rcHeightPatch& hp)
+{
+	int ix = (int)floorf(fx*ics + 0.01f);
+	int iz = (int)floorf(fz*ics + 0.01f);
+	ix = rcClamp(ix-hp.xmin, 0, hp.width);
+	iz = rcClamp(iz-hp.ymin, 0, hp.height);
+	unsigned short h = hp.data[ix+iz*hp.width];
+	if (h == RC_UNSET_HEIGHT)
+	{
+		// Special case when data might be bad.
+		// Find nearest neighbour pixel which has valid height.
+		const int off[8*2] = { -1,0, -1,-1, 0,-1, 1,-1, 1,0, 1,1, 0,1, -1,1};
+		float dmin = FLT_MAX;
+		for (int i = 0; i < 8; ++i)
+		{
+			const int nx = ix+off[i*2+0];
+			const int nz = iz+off[i*2+1];
+			if (nx < 0 || nz < 0 || nx >= hp.width || nz >= hp.height) continue;
+			const unsigned short nh = hp.data[nx+nz*hp.width];
+			if (nh == RC_UNSET_HEIGHT) continue;
+
+			const float d = fabsf(nh*ch - fy);
+			if (d < dmin)
+			{
+				h = nh;
+				dmin = d;
+			}
+			
+/*			const float dx = (nx+0.5f)*cs - fx; 
+			const float dz = (nz+0.5f)*cs - fz;
+			const float d = dx*dx+dz*dz;
+			if (d < dmin)
+			{
+				h = nh;
+				dmin = d;
+			} */
+		}
+	}
+	return h;
+}
+
+
+enum EdgeValues
+{
+	UNDEF = -1,
+	HULL = -2,
+};
+
+static int findEdge(const int* edges, int nedges, int s, int t)
+{
+	for (int i = 0; i < nedges; i++)
+	{
+		const int* e = &edges[i*4];
+		if ((e[0] == s && e[1] == t) || (e[0] == t && e[1] == s))
+			return i;
+	}
+	return UNDEF;
+}
+
+static int addEdge(rcContext* ctx, int* edges, int& nedges, const int maxEdges, int s, int t, int l, int r)
+{
+	if (nedges >= maxEdges)
+	{
+		ctx->log(RC_LOG_ERROR, "addEdge: Too many edges (%d/%d).", nedges, maxEdges);
+		return UNDEF;
+	}
+	
+	// Add edge if not already in the triangulation. 
+	int e = findEdge(edges, nedges, s, t);
+	if (e == UNDEF)
+	{
+		int* e = &edges[nedges*4];
+		e[0] = s;
+		e[1] = t;
+		e[2] = l;
+		e[3] = r;
+		return nedges++;
+	}
+	else
+	{
+		return UNDEF;
+	}
+}
+
+static void updateLeftFace(int* e, int s, int t, int f)
+{
+	if (e[0] == s && e[1] == t && e[2] == UNDEF)
+		e[2] = f;
+	else if (e[1] == s && e[0] == t && e[3] == UNDEF)
+		e[3] = f;
+}	
+
+static int overlapSegSeg2d(const float* a, const float* b, const float* c, const float* d)
+{
+	const float a1 = vcross2(a, b, d);
+	const float a2 = vcross2(a, b, c);
+	if (a1*a2 < 0.0f)
+	{
+		float a3 = vcross2(c, d, a);
+		float a4 = a3 + a2 - a1;
+		if (a3 * a4 < 0.0f)
+			return 1;
+	}	
+	return 0;
+}
+
+static bool overlapEdges(const float* pts, const int* edges, int nedges, int s1, int t1)
+{
+	for (int i = 0; i < nedges; ++i)
+	{
+		const int s0 = edges[i*4+0];
+		const int t0 = edges[i*4+1];
+		// Same or connected edges do not overlap.
+		if (s0 == s1 || s0 == t1 || t0 == s1 || t0 == t1)
+			continue;
+		if (overlapSegSeg2d(&pts[s0*3],&pts[t0*3], &pts[s1*3],&pts[t1*3]))
+			return true;
+	}
+	return false;
+}
+
+static void completeFacet(rcContext* ctx, const float* pts, int npts, int* edges, int& nedges, const int maxEdges, int& nfaces, int e)
+{
+	static const float EPS = 1e-5f;
+
+	int* edge = &edges[e*4];
+	
+	// Cache s and t.
+	int s,t;
+	if (edge[2] == UNDEF)
+	{
+		s = edge[0];
+		t = edge[1];
+	}
+	else if (edge[3] == UNDEF)
+	{
+		s = edge[1];
+		t = edge[0];
+	}
+	else
+	{
+	    // Edge already completed. 
+	    return;
+	}
+    
+	// Find best point on left of edge. 
+	int pt = npts;
+	float c[3] = {0,0,0};
+	float r = -1;
+	for (int u = 0; u < npts; ++u)
+	{
+		if (u == s || u == t) continue;
+		if (vcross2(&pts[s*3], &pts[t*3], &pts[u*3]) > EPS)
+		{
+			if (r < 0)
+			{
+				// The circle is not updated yet, do it now.
+				pt = u;
+				circumCircle(&pts[s*3], &pts[t*3], &pts[u*3], c, r);
+				continue;
+			}
+			const float d = vdist2(c, &pts[u*3]);
+			const float tol = 0.001f;
+			if (d > r*(1+tol))
+			{
+				// Outside current circumcircle, skip.
+				continue;
+			}
+			else if (d < r*(1-tol))
+			{
+				// Inside safe circumcircle, update circle.
+				pt = u;
+				circumCircle(&pts[s*3], &pts[t*3], &pts[u*3], c, r);
+			}
+			else
+			{
+				// Inside epsilon circum circle, do extra tests to make sure the edge is valid.
+				// s-u and t-u cannot overlap with s-pt nor t-pt if they exists.
+				if (overlapEdges(pts, edges, nedges, s,u))
+					continue;
+				if (overlapEdges(pts, edges, nedges, t,u))
+					continue;
+				// Edge is valid.
+				pt = u;
+				circumCircle(&pts[s*3], &pts[t*3], &pts[u*3], c, r);
+			}
+		}
+	}
+	
+	// Add new triangle or update edge info if s-t is on hull. 
+	if (pt < npts)
+	{
+		// Update face information of edge being completed. 
+		updateLeftFace(&edges[e*4], s, t, nfaces);
+		
+		// Add new edge or update face info of old edge. 
+		e = findEdge(edges, nedges, pt, s);
+		if (e == UNDEF)
+		    addEdge(ctx, edges, nedges, maxEdges, pt, s, nfaces, UNDEF);
+		else
+		    updateLeftFace(&edges[e*4], pt, s, nfaces);
+		
+		// Add new edge or update face info of old edge. 
+		e = findEdge(edges, nedges, t, pt);
+		if (e == UNDEF)
+		    addEdge(ctx, edges, nedges, maxEdges, t, pt, nfaces, UNDEF);
+		else
+		    updateLeftFace(&edges[e*4], t, pt, nfaces);
+		
+		nfaces++;
+	}
+	else
+	{
+		updateLeftFace(&edges[e*4], s, t, HULL);
+	}
+}
+
+static void delaunayHull(rcContext* ctx, const int npts, const float* pts,
+						 const int nhull, const int* hull,
+						 rcIntArray& tris, rcIntArray& edges)
+{
+	int nfaces = 0;
+	int nedges = 0;
+	const int maxEdges = npts*10;
+	edges.resize(maxEdges*4);
+	
+	for (int i = 0, j = nhull-1; i < nhull; j=i++)
+		addEdge(ctx, &edges[0], nedges, maxEdges, hull[j],hull[i], HULL, UNDEF);
+	
+	int currentEdge = 0;
+	while (currentEdge < nedges)
+	{
+		if (edges[currentEdge*4+2] == UNDEF)
+			completeFacet(ctx, pts, npts, &edges[0], nedges, maxEdges, nfaces, currentEdge);
+		if (edges[currentEdge*4+3] == UNDEF)
+			completeFacet(ctx, pts, npts, &edges[0], nedges, maxEdges, nfaces, currentEdge);
+		currentEdge++;
+	}
+
+	// Create tris
+	tris.resize(nfaces*4);
+	for (int i = 0; i < nfaces*4; ++i)
+		tris[i] = -1;
+	
+	for (int i = 0; i < nedges; ++i)
+	{
+		const int* e = &edges[i*4];
+		if (e[3] >= 0)
+		{
+			// Left face
+			int* t = &tris[e[3]*4];
+			if (t[0] == -1)
+			{
+				t[0] = e[0];
+				t[1] = e[1];
+			}
+			else if (t[0] == e[1])
+				t[2] = e[0];
+			else if (t[1] == e[0])
+				t[2] = e[1];
+		}
+		if (e[2] >= 0)
+		{
+			// Right
+			int* t = &tris[e[2]*4];
+			if (t[0] == -1)
+			{
+				t[0] = e[1];
+				t[1] = e[0];
+			}
+			else if (t[0] == e[0])
+				t[2] = e[1];
+			else if (t[1] == e[1])
+				t[2] = e[0];
+		}
+	}
+	
+	for (int i = 0; i < tris.size()/4; ++i)
+	{
+		int* t = &tris[i*4];
+		if (t[0] == -1 || t[1] == -1 || t[2] == -1)
+		{
+			ctx->log(RC_LOG_WARNING, "delaunayHull: Removing dangling face %d [%d,%d,%d].", i, t[0],t[1],t[2]);
+			t[0] = tris[tris.size()-4];
+			t[1] = tris[tris.size()-3];
+			t[2] = tris[tris.size()-2];
+			t[3] = tris[tris.size()-1];
+			tris.resize(tris.size()-4);
+			--i;
+		}
+	}
+}
+
+
+inline float getJitterX(const int i)
+{
+	return (((i * 0x8da6b343) & 0xffff) / 65535.0f * 2.0f) - 1.0f;
+}
+
+inline float getJitterY(const int i)
+{
+	return (((i * 0xd8163841) & 0xffff) / 65535.0f * 2.0f) - 1.0f;
+}
+
+static bool buildPolyDetail(rcContext* ctx, const float* in, const int nin,
+							const float sampleDist, const float sampleMaxError,
+							const rcCompactHeightfield& chf, const rcHeightPatch& hp,
+							float* verts, int& nverts, rcIntArray& tris,
+							rcIntArray& edges, rcIntArray& samples)
+{
+	static const int MAX_VERTS = 127;
+	static const int MAX_TRIS = 255;	// Max tris for delaunay is 2n-2-k (n=num verts, k=num hull verts).
+	static const int MAX_VERTS_PER_EDGE = 32;
+	float edge[(MAX_VERTS_PER_EDGE+1)*3];
+	int hull[MAX_VERTS];
+	int nhull = 0;
+
+	nverts = 0;
+
+	for (int i = 0; i < nin; ++i)
+		rcVcopy(&verts[i*3], &in[i*3]);
+	nverts = nin;
+	
+	const float cs = chf.cs;
+	const float ics = 1.0f/cs;
+	
+	// Tessellate outlines.
+	// This is done in separate pass in order to ensure
+	// seamless height values across the ply boundaries.
+	if (sampleDist > 0)
+	{
+		for (int i = 0, j = nin-1; i < nin; j=i++)
+		{
+			const float* vj = &in[j*3];
+			const float* vi = &in[i*3];
+			bool swapped = false;
+			// Make sure the segments are always handled in same order
+			// using lexological sort or else there will be seams.
+			if (fabsf(vj[0]-vi[0]) < 1e-6f)
+			{
+				if (vj[2] > vi[2])
+				{
+					rcSwap(vj,vi);
+					swapped = true;
+				}
+			}
+			else
+			{
+				if (vj[0] > vi[0])
+				{
+					rcSwap(vj,vi);
+					swapped = true;
+				}
+			}
+			// Create samples along the edge.
+			float dx = vi[0] - vj[0];
+			float dy = vi[1] - vj[1];
+			float dz = vi[2] - vj[2];
+			float d = sqrtf(dx*dx + dz*dz);
+			int nn = 1 + (int)floorf(d/sampleDist);
+			if (nn >= MAX_VERTS_PER_EDGE) nn = MAX_VERTS_PER_EDGE-1;
+			if (nverts+nn >= MAX_VERTS)
+				nn = MAX_VERTS-1-nverts;
+			
+			for (int k = 0; k <= nn; ++k)
+			{
+				float u = (float)k/(float)nn;
+				float* pos = &edge[k*3];
+				pos[0] = vj[0] + dx*u;
+				pos[1] = vj[1] + dy*u;
+				pos[2] = vj[2] + dz*u;
+				pos[1] = getHeight(pos[0],pos[1],pos[2], cs, ics, chf.ch, hp)*chf.ch;
+			}
+			// Simplify samples.
+			int idx[MAX_VERTS_PER_EDGE] = {0,nn};
+			int nidx = 2;
+			for (int k = 0; k < nidx-1; )
+			{
+				const int a = idx[k];
+				const int b = idx[k+1];
+				const float* va = &edge[a*3];
+				const float* vb = &edge[b*3];
+				// Find maximum deviation along the segment.
+				float maxd = 0;
+				int maxi = -1;
+				for (int m = a+1; m < b; ++m)
+				{
+					float d = distancePtSeg(&edge[m*3],va,vb);
+					if (d > maxd)
+					{
+						maxd = d;
+						maxi = m;
+					}
+				}
+				// If the max deviation is larger than accepted error,
+				// add new point, else continue to next segment.
+				if (maxi != -1 && maxd > rcSqr(sampleMaxError))
+				{
+					for (int m = nidx; m > k; --m)
+						idx[m] = idx[m-1];
+					idx[k+1] = maxi;
+					nidx++;
+				}
+				else
+				{
+					++k;
+				}
+			}
+			
+			hull[nhull++] = j;
+			// Add new vertices.
+			if (swapped)
+			{
+				for (int k = nidx-2; k > 0; --k)
+				{
+					rcVcopy(&verts[nverts*3], &edge[idx[k]*3]);
+					hull[nhull++] = nverts;
+					nverts++;
+				}
+			}
+			else
+			{
+				for (int k = 1; k < nidx-1; ++k)
+				{
+					rcVcopy(&verts[nverts*3], &edge[idx[k]*3]);
+					hull[nhull++] = nverts;
+					nverts++;
+				}
+			}
+		}
+	}
+	
+
+	// Tessellate the base mesh.
+	edges.resize(0);
+	tris.resize(0);
+
+	delaunayHull(ctx, nverts, verts, nhull, hull, tris, edges);
+	
+	if (tris.size() == 0)
+	{
+		// Could not triangulate the poly, make sure there is some valid data there.
+		ctx->log(RC_LOG_WARNING, "buildPolyDetail: Could not triangulate polygon, adding default data.");
+		for (int i = 2; i < nverts; ++i)
+		{
+			tris.push(0);
+			tris.push(i-1);
+			tris.push(i);
+			tris.push(0);
+		}
+		return true;
+	}
+
+	if (sampleDist > 0)
+	{
+		// Create sample locations in a grid.
+		float bmin[3], bmax[3];
+		rcVcopy(bmin, in);
+		rcVcopy(bmax, in);
+		for (int i = 1; i < nin; ++i)
+		{
+			rcVmin(bmin, &in[i*3]);
+			rcVmax(bmax, &in[i*3]);
+		}
+		int x0 = (int)floorf(bmin[0]/sampleDist);
+		int x1 = (int)ceilf(bmax[0]/sampleDist);
+		int z0 = (int)floorf(bmin[2]/sampleDist);
+		int z1 = (int)ceilf(bmax[2]/sampleDist);
+		samples.resize(0);
+		for (int z = z0; z < z1; ++z)
+		{
+			for (int x = x0; x < x1; ++x)
+			{
+				float pt[3];
+				pt[0] = x*sampleDist;
+				pt[1] = (bmax[1]+bmin[1])*0.5f;
+				pt[2] = z*sampleDist;
+				// Make sure the samples are not too close to the edges.
+				if (distToPoly(nin,in,pt) > -sampleDist/2) continue;
+				samples.push(x);
+				samples.push(getHeight(pt[0], pt[1], pt[2], cs, ics, chf.ch, hp));
+				samples.push(z);
+				samples.push(0); // Not added
+			}
+		}
+				
+		// Add the samples starting from the one that has the most
+		// error. The procedure stops when all samples are added
+		// or when the max error is within treshold.
+		const int nsamples = samples.size()/4;
+		for (int iter = 0; iter < nsamples; ++iter)
+		{
+			if (nverts >= MAX_VERTS)
+				break;
+
+			// Find sample with most error.
+			float bestpt[3] = {0,0,0};
+			float bestd = 0;
+			int besti = -1;
+			for (int i = 0; i < nsamples; ++i)
+			{
+				const int* s = &samples[i*4];
+				if (s[3]) continue; // skip added.
+				float pt[3];
+				// The sample location is jittered to get rid of some bad triangulations
+				// which are cause by symmetrical data from the grid structure.
+				pt[0] = s[0]*sampleDist + getJitterX(i)*cs*0.1f;
+				pt[1] = s[1]*chf.ch;
+				pt[2] = s[2]*sampleDist + getJitterY(i)*cs*0.1f;
+				float d = distToTriMesh(pt, verts, nverts, &tris[0], tris.size()/4);
+				if (d < 0) continue; // did not hit the mesh.
+				if (d > bestd)
+				{
+					bestd = d;
+					besti = i;
+					rcVcopy(bestpt,pt);
+				}
+			}
+			// If the max error is within accepted threshold, stop tesselating.
+			if (bestd <= sampleMaxError || besti == -1)
+				break;
+			// Mark sample as added.
+			samples[besti*4+3] = 1;
+			// Add the new sample point.
+			rcVcopy(&verts[nverts*3],bestpt);
+			nverts++;
+			
+			// Create new triangulation.
+			// TODO: Incremental add instead of full rebuild.
+			edges.resize(0);
+			tris.resize(0);
+			delaunayHull(ctx, nverts, verts, nhull, hull, tris, edges);
+		}		
+	}
+
+	const int ntris = tris.size()/4;
+	if (ntris > MAX_TRIS)
+	{
+		tris.resize(MAX_TRIS*4);
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Shrinking triangle count from %d to max %d.", ntris, MAX_TRIS);
+	}
+
+	return true;
+}
+
+static void getHeightData(const rcCompactHeightfield& chf,
+						  const unsigned short* poly, const int npoly,
+						  const unsigned short* verts,
+						  rcHeightPatch& hp, rcIntArray& stack)
+{
+	// Floodfill the heightfield to get 2D height data,
+	// starting at vertex locations as seeds.
+	
+	memset(hp.data, 0, sizeof(unsigned short)*hp.width*hp.height);
+	
+	stack.resize(0);
+	
+	static const int offset[9*2] =
+	{
+		0,0, -1,-1, 0,-1, 1,-1, 1,0, 1,1, 0,1, -1,1, -1,0,
+	};
+	
+	// Use poly vertices as seed points for the flood fill.
+	for (int j = 0; j < npoly; ++j)
+	{
+		int cx = 0, cz = 0, ci =-1;
+		int dmin = RC_UNSET_HEIGHT;
+		for (int k = 0; k < 9; ++k)
+		{
+			const int ax = (int)verts[poly[j]*3+0] + offset[k*2+0];
+			const int ay = (int)verts[poly[j]*3+1];
+			const int az = (int)verts[poly[j]*3+2] + offset[k*2+1];
+			if (ax < hp.xmin || ax >= hp.xmin+hp.width ||
+				az < hp.ymin || az >= hp.ymin+hp.height)
+				continue;
+			
+			const rcCompactCell& c = chf.cells[ax+az*chf.width];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				int d = rcAbs(ay - (int)s.y);
+				if (d < dmin)
+				{
+					cx = ax;
+					cz = az;
+					ci = i;
+					dmin = d;
+				}
+			}
+		}
+		if (ci != -1)
+		{
+			stack.push(cx);
+			stack.push(cz);
+			stack.push(ci);
+		}
+	}
+	
+	// Find center of the polygon using flood fill.
+	int pcx = 0, pcz = 0;
+	for (int j = 0; j < npoly; ++j)
+	{
+		pcx += (int)verts[poly[j]*3+0];
+		pcz += (int)verts[poly[j]*3+2];
+	}
+	pcx /= npoly;
+	pcz /= npoly;
+	
+	for (int i = 0; i < stack.size(); i += 3)
+	{
+		int cx = stack[i+0];
+		int cy = stack[i+1];
+		int idx = cx-hp.xmin+(cy-hp.ymin)*hp.width;
+		hp.data[idx] = 1;
+	}
+	
+	while (stack.size() > 0)
+	{
+		int ci = stack.pop();
+		int cy = stack.pop();
+		int cx = stack.pop();
+		
+		// Check if close to center of the polygon.
+		if (rcAbs(cx-pcx) <= 1 && rcAbs(cy-pcz) <= 1)
+		{
+			stack.resize(0);
+			stack.push(cx);
+			stack.push(cy);
+			stack.push(ci);
+			break;
+		}
+		
+		const rcCompactSpan& cs = chf.spans[ci];
+		
+		for (int dir = 0; dir < 4; ++dir)
+		{
+			if (rcGetCon(cs, dir) == RC_NOT_CONNECTED) continue;
+			
+			const int ax = cx + rcGetDirOffsetX(dir);
+			const int ay = cy + rcGetDirOffsetY(dir);
+			
+			if (ax < hp.xmin || ax >= (hp.xmin+hp.width) ||
+				ay < hp.ymin || ay >= (hp.ymin+hp.height))
+				continue;
+			
+			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != 0)
+				continue;
+			
+			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
+
+			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
+			hp.data[idx] = 1;
+			
+			stack.push(ax);
+			stack.push(ay);
+			stack.push(ai);
+		}
+	}
+
+	memset(hp.data, 0xff, sizeof(unsigned short)*hp.width*hp.height);
+
+	// Mark start locations.
+	for (int i = 0; i < stack.size(); i += 3)
+	{
+		int cx = stack[i+0];
+		int cy = stack[i+1];
+		int ci = stack[i+2];
+		int idx = cx-hp.xmin+(cy-hp.ymin)*hp.width;
+		const rcCompactSpan& cs = chf.spans[ci];
+		hp.data[idx] = cs.y;
+	}
+	
+	static const int RETRACT_SIZE = 256;
+	int head = 0;
+	
+	while (head*3 < stack.size())
+	{
+		int cx = stack[head*3+0];
+		int cy = stack[head*3+1];
+		int ci = stack[head*3+2];
+		head++;
+		if (head >= RETRACT_SIZE)
+		{
+			head = 0;
+			if (stack.size() > RETRACT_SIZE*3)
+				memmove(&stack[0], &stack[RETRACT_SIZE*3], sizeof(int)*(stack.size()-RETRACT_SIZE*3));
+			stack.resize(stack.size()-RETRACT_SIZE*3);
+		}
+
+		const rcCompactSpan& cs = chf.spans[ci];
+		for (int dir = 0; dir < 4; ++dir)
+		{
+			if (rcGetCon(cs, dir) == RC_NOT_CONNECTED) continue;
+			
+			const int ax = cx + rcGetDirOffsetX(dir);
+			const int ay = cy + rcGetDirOffsetY(dir);
+			
+			if (ax < hp.xmin || ax >= (hp.xmin+hp.width) ||
+				ay < hp.ymin || ay >= (hp.ymin+hp.height))
+				continue;
+			
+			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != RC_UNSET_HEIGHT)
+				continue;
+			
+			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
+			
+			const rcCompactSpan& as = chf.spans[ai];
+			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
+			hp.data[idx] = as.y;
+
+			stack.push(ax);
+			stack.push(ay);
+			stack.push(ai);
+		}
+	}
+	
+}
+
+static unsigned char getEdgeFlags(const float* va, const float* vb,
+								  const float* vpoly, const int npoly)
+{
+	// Return true if edge (va,vb) is part of the polygon.
+	static const float thrSqr = rcSqr(0.001f);
+	for (int i = 0, j = npoly-1; i < npoly; j=i++)
+	{
+		if (distancePtSeg2d(va, &vpoly[j*3], &vpoly[i*3]) < thrSqr && 
+			distancePtSeg2d(vb, &vpoly[j*3], &vpoly[i*3]) < thrSqr)
+			return 1;
+	}
+	return 0;
+}
+
+static unsigned char getTriFlags(const float* va, const float* vb, const float* vc,
+								 const float* vpoly, const int npoly)
+{
+	unsigned char flags = 0;
+	flags |= getEdgeFlags(va,vb,vpoly,npoly) << 0;
+	flags |= getEdgeFlags(vb,vc,vpoly,npoly) << 2;
+	flags |= getEdgeFlags(vc,va,vpoly,npoly) << 4;
+	return flags;
+}
+
+
+
+bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
+						   const float sampleDist, const float sampleMaxError,
+						   rcPolyMeshDetail& dmesh)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_POLYMESHDETAIL);
+
+	if (mesh.nverts == 0 || mesh.npolys == 0)
+		return true;
+	
+	const int nvp = mesh.nvp;
+	const float cs = mesh.cs;
+	const float ch = mesh.ch;
+	const float* orig = mesh.bmin;
+	
+	rcIntArray edges(64);
+	rcIntArray tris(512);
+	rcIntArray stack(512);
+	rcIntArray samples(512);
+	float verts[256*3];
+	rcHeightPatch hp;
+	int nPolyVerts = 0;
+	int maxhw = 0, maxhh = 0;
+	
+	rcScopedDelete<int> bounds = (int*)rcAlloc(sizeof(int)*mesh.npolys*4, RC_ALLOC_TEMP);
+	if (!bounds)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'bounds' (%d).", mesh.npolys*4);
+		return false;
+	}
+	rcScopedDelete<float> poly = (float*)rcAlloc(sizeof(float)*nvp*3, RC_ALLOC_TEMP);
+	if (!poly)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'poly' (%d).", nvp*3);
+		return false;
+	}
+	
+	// Find max size for a polygon area.
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		const unsigned short* p = &mesh.polys[i*nvp*2];
+		int& xmin = bounds[i*4+0];
+		int& xmax = bounds[i*4+1];
+		int& ymin = bounds[i*4+2];
+		int& ymax = bounds[i*4+3];
+		xmin = chf.width;
+		xmax = 0;
+		ymin = chf.height;
+		ymax = 0;
+		for (int j = 0; j < nvp; ++j)
+		{
+			if(p[j] == RC_MESH_NULL_IDX) break;
+			const unsigned short* v = &mesh.verts[p[j]*3];
+			xmin = rcMin(xmin, (int)v[0]);
+			xmax = rcMax(xmax, (int)v[0]);
+			ymin = rcMin(ymin, (int)v[2]);
+			ymax = rcMax(ymax, (int)v[2]);
+			nPolyVerts++;
+		}
+		xmin = rcMax(0,xmin-1);
+		xmax = rcMin(chf.width,xmax+1);
+		ymin = rcMax(0,ymin-1);
+		ymax = rcMin(chf.height,ymax+1);
+		if (xmin >= xmax || ymin >= ymax) continue;
+		maxhw = rcMax(maxhw, xmax-xmin);
+		maxhh = rcMax(maxhh, ymax-ymin);
+	}
+	
+	hp.data = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxhw*maxhh, RC_ALLOC_TEMP);
+	if (!hp.data)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'hp.data' (%d).", maxhw*maxhh);
+		return false;
+	}
+	
+	dmesh.nmeshes = mesh.npolys;
+	dmesh.nverts = 0;
+	dmesh.ntris = 0;
+	dmesh.meshes = (unsigned int*)rcAlloc(sizeof(unsigned int)*dmesh.nmeshes*4, RC_ALLOC_PERM);
+	if (!dmesh.meshes)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.meshes' (%d).", dmesh.nmeshes*4);
+		return false;
+	}
+
+	int vcap = nPolyVerts+nPolyVerts/2;
+	int tcap = vcap*2;
+
+	dmesh.nverts = 0;
+	dmesh.verts = (float*)rcAlloc(sizeof(float)*vcap*3, RC_ALLOC_PERM);
+	if (!dmesh.verts)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.verts' (%d).", vcap*3);
+		return false;
+	}
+	dmesh.ntris = 0;
+	dmesh.tris = (unsigned char*)rcAlloc(sizeof(unsigned char*)*tcap*4, RC_ALLOC_PERM);
+	if (!dmesh.tris)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.tris' (%d).", tcap*4);
+		return false;
+	}
+	
+	for (int i = 0; i < mesh.npolys; ++i)
+	{
+		const unsigned short* p = &mesh.polys[i*nvp*2];
+		
+		// Store polygon vertices for processing.
+		int npoly = 0;
+		for (int j = 0; j < nvp; ++j)
+		{
+			if(p[j] == RC_MESH_NULL_IDX) break;
+			const unsigned short* v = &mesh.verts[p[j]*3];
+			poly[j*3+0] = v[0]*cs;
+			poly[j*3+1] = v[1]*ch;
+			poly[j*3+2] = v[2]*cs;
+			npoly++;
+		}
+		
+		// Get the height data from the area of the polygon.
+		hp.xmin = bounds[i*4+0];
+		hp.ymin = bounds[i*4+2];
+		hp.width = bounds[i*4+1]-bounds[i*4+0];
+		hp.height = bounds[i*4+3]-bounds[i*4+2];
+		getHeightData(chf, p, npoly, mesh.verts, hp, stack);
+		
+		// Build detail mesh.
+		int nverts = 0;
+		if (!buildPolyDetail(ctx, poly, npoly,
+							 sampleDist, sampleMaxError,
+							 chf, hp, verts, nverts, tris,
+							 edges, samples))
+		{
+			return false;
+		}
+
+		// Move detail verts to world space.
+		for (int j = 0; j < nverts; ++j)
+		{
+			verts[j*3+0] += orig[0];
+			verts[j*3+1] += orig[1] + chf.ch; // Is this offset necessary?
+			verts[j*3+2] += orig[2];
+		}
+		// Offset poly too, will be used to flag checking.
+		for (int j = 0; j < npoly; ++j)
+		{
+			poly[j*3+0] += orig[0];
+			poly[j*3+1] += orig[1];
+			poly[j*3+2] += orig[2];
+		}
+	
+		// Store detail submesh.
+		const int ntris = tris.size()/4;
+
+		dmesh.meshes[i*4+0] = (unsigned int)dmesh.nverts;
+		dmesh.meshes[i*4+1] = (unsigned int)nverts;
+		dmesh.meshes[i*4+2] = (unsigned int)dmesh.ntris;
+		dmesh.meshes[i*4+3] = (unsigned int)ntris;		
+		
+		// Store vertices, allocate more memory if necessary.
+		if (dmesh.nverts+nverts > vcap)
+		{
+			while (dmesh.nverts+nverts > vcap)
+				vcap += 256;
+				
+			float* newv = (float*)rcAlloc(sizeof(float)*vcap*3, RC_ALLOC_PERM);
+			if (!newv)
+			{
+				ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'newv' (%d).", vcap*3);
+				return false;
+			}
+			if (dmesh.nverts)
+				memcpy(newv, dmesh.verts, sizeof(float)*3*dmesh.nverts);
+			rcFree(dmesh.verts);
+			dmesh.verts = newv;
+		}
+		for (int j = 0; j < nverts; ++j)
+		{
+			dmesh.verts[dmesh.nverts*3+0] = verts[j*3+0];
+			dmesh.verts[dmesh.nverts*3+1] = verts[j*3+1];
+			dmesh.verts[dmesh.nverts*3+2] = verts[j*3+2];
+			dmesh.nverts++;
+		}
+		
+		// Store triangles, allocate more memory if necessary.
+		if (dmesh.ntris+ntris > tcap)
+		{
+			while (dmesh.ntris+ntris > tcap)
+				tcap += 256;
+			unsigned char* newt = (unsigned char*)rcAlloc(sizeof(unsigned char)*tcap*4, RC_ALLOC_PERM);
+			if (!newt)
+			{
+				ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'newt' (%d).", tcap*4);
+				return false;
+			}
+			if (dmesh.ntris)
+				memcpy(newt, dmesh.tris, sizeof(unsigned char)*4*dmesh.ntris);
+			rcFree(dmesh.tris);
+			dmesh.tris = newt;
+		}
+		for (int j = 0; j < ntris; ++j)
+		{
+			const int* t = &tris[j*4];
+			dmesh.tris[dmesh.ntris*4+0] = (unsigned char)t[0];
+			dmesh.tris[dmesh.ntris*4+1] = (unsigned char)t[1];
+			dmesh.tris[dmesh.ntris*4+2] = (unsigned char)t[2];
+			dmesh.tris[dmesh.ntris*4+3] = getTriFlags(&verts[t[0]*3], &verts[t[1]*3], &verts[t[2]*3], poly, npoly);
+			dmesh.ntris++;
+		}
+	}
+		
+	ctx->stopTimer(RC_TIMER_BUILD_POLYMESHDETAIL);
+
+	return true;
+}
+
+bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_MERGE_POLYMESHDETAIL);
+
+	int maxVerts = 0;
+	int maxTris = 0;
+	int maxMeshes = 0;
+
+	for (int i = 0; i < nmeshes; ++i)
+	{
+		if (!meshes[i]) continue;
+		maxVerts += meshes[i]->nverts;
+		maxTris += meshes[i]->ntris;
+		maxMeshes += meshes[i]->nmeshes;
+	}
+
+	mesh.nmeshes = 0;
+	mesh.meshes = (unsigned int*)rcAlloc(sizeof(unsigned int)*maxMeshes*4, RC_ALLOC_PERM);
+	if (!mesh.meshes)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'pmdtl.meshes' (%d).", maxMeshes*4);
+		return false;
+	}
+
+	mesh.ntris = 0;
+	mesh.tris = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxTris*4, RC_ALLOC_PERM);
+	if (!mesh.tris)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.tris' (%d).", maxTris*4);
+		return false;
+	}
+
+	mesh.nverts = 0;
+	mesh.verts = (float*)rcAlloc(sizeof(float)*maxVerts*3, RC_ALLOC_PERM);
+	if (!mesh.verts)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.verts' (%d).", maxVerts*3);
+		return false;
+	}
+	
+	// Merge datas.
+	for (int i = 0; i < nmeshes; ++i)
+	{
+		rcPolyMeshDetail* dm = meshes[i];
+		if (!dm) continue;
+		for (int j = 0; j < dm->nmeshes; ++j)
+		{
+			unsigned int* dst = &mesh.meshes[mesh.nmeshes*4];
+			unsigned int* src = &dm->meshes[j*4];
+			dst[0] = (unsigned int)mesh.nverts+src[0];
+			dst[1] = src[1];
+			dst[2] = (unsigned int)mesh.ntris+src[2];
+			dst[3] = src[3];
+			mesh.nmeshes++;
+		}
+			
+		for (int k = 0; k < dm->nverts; ++k)
+		{
+			rcVcopy(&mesh.verts[mesh.nverts*3], &dm->verts[k*3]);
+			mesh.nverts++;
+		}
+		for (int k = 0; k < dm->ntris; ++k)
+		{
+			mesh.tris[mesh.ntris*4+0] = dm->tris[k*4+0];
+			mesh.tris[mesh.ntris*4+1] = dm->tris[k*4+1];
+			mesh.tris[mesh.ntris*4+2] = dm->tris[k*4+2];
+			mesh.tris[mesh.ntris*4+3] = dm->tris[k*4+3];
+			mesh.ntris++;
+		}
+	}
+
+	ctx->stopTimer(RC_TIMER_MERGE_POLYMESHDETAIL);
+	
+	return true;
+}
+
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastRasterization.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastRasterization.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,360 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+
+inline bool overlapBounds(const float* amin, const float* amax, const float* bmin, const float* bmax)
+{
+	bool overlap = true;
+	overlap = (amin[0] > bmax[0] || amax[0] < bmin[0]) ? false : overlap;
+	overlap = (amin[1] > bmax[1] || amax[1] < bmin[1]) ? false : overlap;
+	overlap = (amin[2] > bmax[2] || amax[2] < bmin[2]) ? false : overlap;
+	return overlap;
+}
+
+inline bool overlapInterval(unsigned short amin, unsigned short amax,
+							unsigned short bmin, unsigned short bmax)
+{
+	if (amax < bmin) return false;
+	if (amin > bmax) return false;
+	return true;
+}
+
+
+static rcSpan* allocSpan(rcHeightfield& hf)
+{
+	// If running out of memory, allocate new page and update the freelist.
+	if (!hf.freelist || !hf.freelist->next)
+	{
+		// Create new page.
+		// Allocate memory for the new pool.
+		rcSpanPool* pool = (rcSpanPool*)rcAlloc(sizeof(rcSpanPool), RC_ALLOC_PERM);
+		if (!pool) return 0;
+		pool->next = 0;
+		// Add the pool into the list of pools.
+		pool->next = hf.pools;
+		hf.pools = pool;
+		// Add new items to the free list.
+		rcSpan* freelist = hf.freelist;
+		rcSpan* head = &pool->items[0];
+		rcSpan* it = &pool->items[RC_SPANS_PER_POOL];
+		do
+		{
+			--it;
+			it->next = freelist;
+			freelist = it;
+		}
+		while (it != head);
+		hf.freelist = it;
+	}
+	
+	// Pop item from in front of the free list.
+	rcSpan* it = hf.freelist;
+	hf.freelist = hf.freelist->next;
+	return it;
+}
+
+static void freeSpan(rcHeightfield& hf, rcSpan* ptr)
+{
+	if (!ptr) return;
+	// Add the node in front of the free list.
+	ptr->next = hf.freelist;
+	hf.freelist = ptr;
+}
+
+static void addSpan(rcHeightfield& hf, const int x, const int y,
+					const unsigned short smin, const unsigned short smax,
+					const unsigned char area, const int flagMergeThr)
+{
+	
+	int idx = x + y*hf.width;
+	
+	rcSpan* s = allocSpan(hf);
+	s->smin = smin;
+	s->smax = smax;
+	s->area = area;
+	s->next = 0;
+	
+	// Empty cell, add he first span.
+	if (!hf.spans[idx])
+	{
+		hf.spans[idx] = s;
+		return;
+	}
+	rcSpan* prev = 0;
+	rcSpan* cur = hf.spans[idx];
+	
+	// Insert and merge spans.
+	while (cur)
+	{
+		if (cur->smin > s->smax)
+		{
+			// Current span is further than the new span, break.
+			break;
+		}
+		else if (cur->smax < s->smin)
+		{
+			// Current span is before the new span advance.
+			prev = cur;
+			cur = cur->next;
+		}
+		else
+		{
+			// Merge spans.
+			if (cur->smin < s->smin)
+				s->smin = cur->smin;
+			if (cur->smax > s->smax)
+				s->smax = cur->smax;
+			
+			// Merge flags.
+			if (rcAbs((int)s->smax - (int)cur->smax) <= flagMergeThr)
+				s->area = rcMax(s->area, cur->area);
+			
+			// Remove current span.
+			rcSpan* next = cur->next;
+			freeSpan(hf, cur);
+			if (prev)
+				prev->next = next;
+			else
+				hf.spans[idx] = next;
+			cur = next;
+		}
+	}
+	
+	// Insert new span.
+	if (prev)
+	{
+		s->next = prev->next;
+		prev->next = s;
+	}
+	else
+	{
+		s->next = hf.spans[idx];
+		hf.spans[idx] = s;
+	}
+}
+
+void rcAddSpan(rcContext* /*ctx*/, rcHeightfield& hf, const int x, const int y,
+			   const unsigned short smin, const unsigned short smax,
+			   const unsigned char area, const int flagMergeThr)
+{
+//	rcAssert(ctx);
+	addSpan(hf, x,y, smin, smax, area, flagMergeThr);
+}
+
+static int clipPoly(const float* in, int n, float* out, float pnx, float pnz, float pd)
+{
+	float d[12];
+	for (int i = 0; i < n; ++i)
+		d[i] = pnx*in[i*3+0] + pnz*in[i*3+2] + pd;
+	
+	int m = 0;
+	for (int i = 0, j = n-1; i < n; j=i, ++i)
+	{
+		bool ina = d[j] >= 0;
+		bool inb = d[i] >= 0;
+		if (ina != inb)
+		{
+			float s = d[j] / (d[j] - d[i]);
+			out[m*3+0] = in[j*3+0] + (in[i*3+0] - in[j*3+0])*s;
+			out[m*3+1] = in[j*3+1] + (in[i*3+1] - in[j*3+1])*s;
+			out[m*3+2] = in[j*3+2] + (in[i*3+2] - in[j*3+2])*s;
+			m++;
+		}
+		if (inb)
+		{
+			out[m*3+0] = in[i*3+0];
+			out[m*3+1] = in[i*3+1];
+			out[m*3+2] = in[i*3+2];
+			m++;
+		}
+	}
+	return m;
+}
+
+static void rasterizeTri(const float* v0, const float* v1, const float* v2,
+						 const unsigned char area, rcHeightfield& hf,
+						 const float* bmin, const float* bmax,
+						 const float cs, const float ics, const float ich,
+						 const int flagMergeThr)
+{
+	const int w = hf.width;
+	const int h = hf.height;
+	float tmin[3], tmax[3];
+	const float by = bmax[1] - bmin[1];
+	
+	// Calculate the bounding box of the triangle.
+	rcVcopy(tmin, v0);
+	rcVcopy(tmax, v0);
+	rcVmin(tmin, v1);
+	rcVmin(tmin, v2);
+	rcVmax(tmax, v1);
+	rcVmax(tmax, v2);
+	
+	// If the triangle does not touch the bbox of the heightfield, skip the triagle.
+	if (!overlapBounds(bmin, bmax, tmin, tmax))
+		return;
+	
+	// Calculate the footpring of the triangle on the grid.
+	int x0 = (int)((tmin[0] - bmin[0])*ics);
+	int y0 = (int)((tmin[2] - bmin[2])*ics);
+	int x1 = (int)((tmax[0] - bmin[0])*ics);
+	int y1 = (int)((tmax[2] - bmin[2])*ics);
+	x0 = rcClamp(x0, 0, w-1);
+	y0 = rcClamp(y0, 0, h-1);
+	x1 = rcClamp(x1, 0, w-1);
+	y1 = rcClamp(y1, 0, h-1);
+	
+	// Clip the triangle into all grid cells it touches.
+	float in[7*3], out[7*3], inrow[7*3];
+	
+	for (int y = y0; y <= y1; ++y)
+	{
+		// Clip polygon to row.
+		rcVcopy(&in[0], v0);
+		rcVcopy(&in[1*3], v1);
+		rcVcopy(&in[2*3], v2);
+		int nvrow = 3;
+		const float cz = bmin[2] + y*cs;
+		nvrow = clipPoly(in, nvrow, out, 0, 1, -cz);
+		if (nvrow < 3) continue;
+		nvrow = clipPoly(out, nvrow, inrow, 0, -1, cz+cs);
+		if (nvrow < 3) continue;
+		
+		for (int x = x0; x <= x1; ++x)
+		{
+			// Clip polygon to column.
+			int nv = nvrow;
+			const float cx = bmin[0] + x*cs;
+			nv = clipPoly(inrow, nv, out, 1, 0, -cx);
+			if (nv < 3) continue;
+			nv = clipPoly(out, nv, in, -1, 0, cx+cs);
+			if (nv < 3) continue;
+			
+			// Calculate min and max of the span.
+			float smin = in[1], smax = in[1];
+			for (int i = 1; i < nv; ++i)
+			{
+				smin = rcMin(smin, in[i*3+1]);
+				smax = rcMax(smax, in[i*3+1]);
+			}
+			smin -= bmin[1];
+			smax -= bmin[1];
+			// Skip the span if it is outside the heightfield bbox
+			if (smax < 0.0f) continue;
+			if (smin > by) continue;
+			// Clamp the span to the heightfield bbox.
+			if (smin < 0.0f) smin = 0;
+			if (smax > by) smax = by;
+			
+			// Snap the span to the heightfield height grid.
+			unsigned short ismin = (unsigned short)rcClamp((int)floorf(smin * ich), 0, RC_SPAN_MAX_HEIGHT);
+			unsigned short ismax = (unsigned short)rcClamp((int)ceilf(smax * ich), (int)ismin+1, RC_SPAN_MAX_HEIGHT);
+			
+			addSpan(hf, x, y, ismin, ismax, area, flagMergeThr);
+		}
+	}
+}
+
+void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
+						 const unsigned char area, rcHeightfield& solid,
+						 const int flagMergeThr)
+{
+	rcAssert(ctx);
+
+	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+
+	const float ics = 1.0f/solid.cs;
+	const float ich = 1.0f/solid.ch;
+	rasterizeTri(v0, v1, v2, area, solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
+
+	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+}
+
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
+						  const int* tris, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr)
+{
+	rcAssert(ctx);
+
+	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+	
+	const float ics = 1.0f/solid.cs;
+	const float ich = 1.0f/solid.ch;
+	// Rasterize triangles.
+	for (int i = 0; i < nt; ++i)
+	{
+		const float* v0 = &verts[tris[i*3+0]*3];
+		const float* v1 = &verts[tris[i*3+1]*3];
+		const float* v2 = &verts[tris[i*3+2]*3];
+		// Rasterize.
+		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
+	}
+	
+	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+}
+
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
+						  const unsigned short* tris, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr)
+{
+	rcAssert(ctx);
+
+	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+	
+	const float ics = 1.0f/solid.cs;
+	const float ich = 1.0f/solid.ch;
+	// Rasterize triangles.
+	for (int i = 0; i < nt; ++i)
+	{
+		const float* v0 = &verts[tris[i*3+0]*3];
+		const float* v1 = &verts[tris[i*3+1]*3];
+		const float* v2 = &verts[tris[i*3+2]*3];
+		// Rasterize.
+		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
+	}
+	
+	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+}
+
+void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
+						  rcHeightfield& solid, const int flagMergeThr)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+	
+	const float ics = 1.0f/solid.cs;
+	const float ich = 1.0f/solid.ch;
+	// Rasterize triangles.
+	for (int i = 0; i < nt; ++i)
+	{
+		const float* v0 = &verts[(i*3+0)*3];
+		const float* v1 = &verts[(i*3+1)*3];
+		const float* v2 = &verts[(i*3+2)*3];
+		// Rasterize.
+		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
+	}
+	
+	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
+}
diff -r dc4fc5c8b306 dep/recastnavigation/Recast/RecastRegion.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dep/recastnavigation/Recast/RecastRegion.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,1283 @@
+//
+// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
+//
+// This software is provided 'as-is', without any express or implied
+// warranty.  In no event will the authors be held liable for any damages
+// arising from the use of this software.
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would be
+//    appreciated but is not required.
+// 2. Altered source versions must be plainly marked as such, and must not be
+//    misrepresented as being the original software.
+// 3. This notice may not be removed or altered from any source distribution.
+//
+
+#include <float.h>
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "Recast.h"
+#include "RecastAlloc.h"
+#include "RecastAssert.h"
+#include <new>
+
+
+static void calculateDistanceField(rcCompactHeightfield& chf, unsigned short* src, unsigned short& maxDist)
+{
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	// Init distance and points.
+	for (int i = 0; i < chf.spanCount; ++i)
+		src[i] = 0xffff;
+	
+	// Mark boundary cells.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				const unsigned char area = chf.areas[i];
+				
+				int nc = 0;
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+					{
+						const int ax = x + rcGetDirOffsetX(dir);
+						const int ay = y + rcGetDirOffsetY(dir);
+						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
+						if (area == chf.areas[ai])
+							nc++;
+					}
+				}
+				if (nc != 4)
+					src[i] = 0;
+			}
+		}
+	}
+	
+			
+	// Pass 1
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				
+				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
+				{
+					// (-1,0)
+					const int ax = x + rcGetDirOffsetX(0);
+					const int ay = y + rcGetDirOffsetY(0);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);
+					const rcCompactSpan& as = chf.spans[ai];
+					if (src[ai]+2 < src[i])
+						src[i] = src[ai]+2;
+					
+					// (-1,-1)
+					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(3);
+						const int aay = ay + rcGetDirOffsetY(3);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 3);
+						if (src[aai]+3 < src[i])
+							src[i] = src[aai]+3;
+					}
+				}
+				if (rcGetCon(s, 3) != RC_NOT_CONNECTED)
+				{
+					// (0,-1)
+					const int ax = x + rcGetDirOffsetX(3);
+					const int ay = y + rcGetDirOffsetY(3);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);
+					const rcCompactSpan& as = chf.spans[ai];
+					if (src[ai]+2 < src[i])
+						src[i] = src[ai]+2;
+					
+					// (1,-1)
+					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(2);
+						const int aay = ay + rcGetDirOffsetY(2);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 2);
+						if (src[aai]+3 < src[i])
+							src[i] = src[aai]+3;
+					}
+				}
+			}
+		}
+	}
+	
+	// Pass 2
+	for (int y = h-1; y >= 0; --y)
+	{
+		for (int x = w-1; x >= 0; --x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				
+				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)
+				{
+					// (1,0)
+					const int ax = x + rcGetDirOffsetX(2);
+					const int ay = y + rcGetDirOffsetY(2);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 2);
+					const rcCompactSpan& as = chf.spans[ai];
+					if (src[ai]+2 < src[i])
+						src[i] = src[ai]+2;
+					
+					// (1,1)
+					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(1);
+						const int aay = ay + rcGetDirOffsetY(1);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 1);
+						if (src[aai]+3 < src[i])
+							src[i] = src[aai]+3;
+					}
+				}
+				if (rcGetCon(s, 1) != RC_NOT_CONNECTED)
+				{
+					// (0,1)
+					const int ax = x + rcGetDirOffsetX(1);
+					const int ay = y + rcGetDirOffsetY(1);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 1);
+					const rcCompactSpan& as = chf.spans[ai];
+					if (src[ai]+2 < src[i])
+						src[i] = src[ai]+2;
+					
+					// (-1,1)
+					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)
+					{
+						const int aax = ax + rcGetDirOffsetX(0);
+						const int aay = ay + rcGetDirOffsetY(0);
+						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 0);
+						if (src[aai]+3 < src[i])
+							src[i] = src[aai]+3;
+					}
+				}
+			}
+		}
+	}	
+	
+	maxDist = 0;
+	for (int i = 0; i < chf.spanCount; ++i)
+		maxDist = rcMax(src[i], maxDist);
+	
+}
+
+static unsigned short* boxBlur(rcCompactHeightfield& chf, int thr,
+							   unsigned short* src, unsigned short* dst)
+{
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	thr *= 2;
+	
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				const unsigned short cd = src[i];
+				if (cd <= thr)
+				{
+					dst[i] = cd;
+					continue;
+				}
+
+				int d = (int)cd;
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+					{
+						const int ax = x + rcGetDirOffsetX(dir);
+						const int ay = y + rcGetDirOffsetY(dir);
+						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
+						d += (int)src[ai];
+						
+						const rcCompactSpan& as = chf.spans[ai];
+						const int dir2 = (dir+1) & 0x3;
+						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
+						{
+							const int ax2 = ax + rcGetDirOffsetX(dir2);
+							const int ay2 = ay + rcGetDirOffsetY(dir2);
+							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);
+							d += (int)src[ai2];
+						}
+						else
+						{
+							d += cd;
+						}
+					}
+					else
+					{
+						d += cd*2;
+					}
+				}
+				dst[i] = (unsigned short)((d+5)/9);
+			}
+		}
+	}
+	return dst;
+}
+
+
+static bool floodRegion(int x, int y, int i,
+						unsigned short level, unsigned short r,
+						rcCompactHeightfield& chf,
+						unsigned short* srcReg, unsigned short* srcDist,
+						rcIntArray& stack)
+{
+	const int w = chf.width;
+	
+	const unsigned char area = chf.areas[i];
+	
+	// Flood fill mark region.
+	stack.resize(0);
+	stack.push((int)x);
+	stack.push((int)y);
+	stack.push((int)i);
+	srcReg[i] = r;
+	srcDist[i] = 0;
+	
+	unsigned short lev = level >= 2 ? level-2 : 0;
+	int count = 0;
+	
+	while (stack.size() > 0)
+	{
+		int ci = stack.pop();
+		int cy = stack.pop();
+		int cx = stack.pop();
+		
+		const rcCompactSpan& cs = chf.spans[ci];
+		
+		// Check if any of the neighbours already have a valid region set.
+		unsigned short ar = 0;
+		for (int dir = 0; dir < 4; ++dir)
+		{
+			// 8 connected
+			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)
+			{
+				const int ax = cx + rcGetDirOffsetX(dir);
+				const int ay = cy + rcGetDirOffsetY(dir);
+				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
+				if (chf.areas[ai] != area)
+					continue;
+				unsigned short nr = srcReg[ai];
+				if (nr != 0 && nr != r)
+					ar = nr;
+				
+				const rcCompactSpan& as = chf.spans[ai];
+				
+				const int dir2 = (dir+1) & 0x3;
+				if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
+				{
+					const int ax2 = ax + rcGetDirOffsetX(dir2);
+					const int ay2 = ay + rcGetDirOffsetY(dir2);
+					const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);
+					if (chf.areas[ai2] != area)
+						continue;
+					unsigned short nr = srcReg[ai2];
+					if (nr != 0 && nr != r)
+						ar = nr;
+				}				
+			}
+		}
+		if (ar != 0)
+		{
+			srcReg[ci] = 0;
+			continue;
+		}
+		count++;
+		
+		// Expand neighbours.
+		for (int dir = 0; dir < 4; ++dir)
+		{
+			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)
+			{
+				const int ax = cx + rcGetDirOffsetX(dir);
+				const int ay = cy + rcGetDirOffsetY(dir);
+				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
+				if (chf.areas[ai] != area)
+					continue;
+				if (chf.dist[ai] >= lev)
+				{
+					if (srcReg[ai] == 0)
+					{
+						srcReg[ai] = r;
+						srcDist[ai] = 0;
+						stack.push(ax);
+						stack.push(ay);
+						stack.push(ai);
+					}
+				}
+			}
+		}
+	}
+	
+	return count > 0;
+}
+
+static unsigned short* expandRegions(int maxIter, unsigned short level,
+									 rcCompactHeightfield& chf,
+									 unsigned short* srcReg, unsigned short* srcDist,
+									 unsigned short* dstReg, unsigned short* dstDist, 
+									 rcIntArray& stack)
+{
+	const int w = chf.width;
+	const int h = chf.height;
+
+	// Find cells revealed by the raised level.
+	stack.resize(0);
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				if (chf.dist[i] >= level && srcReg[i] == 0 && chf.areas[i] != RC_NULL_AREA)
+				{
+					stack.push(x);
+					stack.push(y);
+					stack.push(i);
+				}
+			}
+		}
+	}
+	
+	int iter = 0;
+	while (stack.size() > 0)
+	{
+		int failed = 0;
+		
+		memcpy(dstReg, srcReg, sizeof(unsigned short)*chf.spanCount);
+		memcpy(dstDist, srcDist, sizeof(unsigned short)*chf.spanCount);
+		
+		for (int j = 0; j < stack.size(); j += 3)
+		{
+			int x = stack[j+0];
+			int y = stack[j+1];
+			int i = stack[j+2];
+			if (i < 0)
+			{
+				failed++;
+				continue;
+			}
+			
+			unsigned short r = srcReg[i];
+			unsigned short d2 = 0xffff;
+			const unsigned char area = chf.areas[i];
+			const rcCompactSpan& s = chf.spans[i];
+			for (int dir = 0; dir < 4; ++dir)
+			{
+				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;
+				const int ax = x + rcGetDirOffsetX(dir);
+				const int ay = y + rcGetDirOffsetY(dir);
+				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
+				if (chf.areas[ai] != area) continue;
+				if (srcReg[ai] > 0 && (srcReg[ai] & RC_BORDER_REG) == 0)
+				{
+					if ((int)srcDist[ai]+2 < (int)d2)
+					{
+						r = srcReg[ai];
+						d2 = srcDist[ai]+2;
+					}
+				}
+			}
+			if (r)
+			{
+				stack[j+2] = -1; // mark as used
+				dstReg[i] = r;
+				dstDist[i] = d2;
+			}
+			else
+			{
+				failed++;
+			}
+		}
+		
+		// rcSwap source and dest.
+		rcSwap(srcReg, dstReg);
+		rcSwap(srcDist, dstDist);
+		
+		if (failed*3 == stack.size())
+			break;
+		
+		if (level > 0)
+		{
+			++iter;
+			if (iter >= maxIter)
+				break;
+		}
+	}
+	
+	return srcReg;
+}
+
+
+struct rcRegion
+{
+	inline rcRegion(unsigned short i) :
+		spanCount(0),
+		id(i),
+		areaType(0),
+		remap(false),
+		visited(false)
+	{}
+	
+	int spanCount;					// Number of spans belonging to this region
+	unsigned short id;				// ID of the region
+	unsigned char areaType;			// Are type.
+	bool remap;
+	bool visited;
+	rcIntArray connections;
+	rcIntArray floors;
+};
+
+static void removeAdjacentNeighbours(rcRegion& reg)
+{
+	// Remove adjacent duplicates.
+	for (int i = 0; i < reg.connections.size() && reg.connections.size() > 1; )
+	{
+		int ni = (i+1) % reg.connections.size();
+		if (reg.connections[i] == reg.connections[ni])
+		{
+			// Remove duplicate
+			for (int j = i; j < reg.connections.size()-1; ++j)
+				reg.connections[j] = reg.connections[j+1];
+			reg.connections.pop();
+		}
+		else
+			++i;
+	}
+}
+
+static void replaceNeighbour(rcRegion& reg, unsigned short oldId, unsigned short newId)
+{
+	bool neiChanged = false;
+	for (int i = 0; i < reg.connections.size(); ++i)
+	{
+		if (reg.connections[i] == oldId)
+		{
+			reg.connections[i] = newId;
+			neiChanged = true;
+		}
+	}
+	for (int i = 0; i < reg.floors.size(); ++i)
+	{
+		if (reg.floors[i] == oldId)
+			reg.floors[i] = newId;
+	}
+	if (neiChanged)
+		removeAdjacentNeighbours(reg);
+}
+
+static bool canMergeWithRegion(const rcRegion& rega, const rcRegion& regb)
+{
+	if (rega.areaType != regb.areaType)
+		return false;
+	int n = 0;
+	for (int i = 0; i < rega.connections.size(); ++i)
+	{
+		if (rega.connections[i] == regb.id)
+			n++;
+	}
+	if (n > 1)
+		return false;
+	for (int i = 0; i < rega.floors.size(); ++i)
+	{
+		if (rega.floors[i] == regb.id)
+			return false;
+	}
+	return true;
+}
+
+static void addUniqueFloorRegion(rcRegion& reg, int n)
+{
+	for (int i = 0; i < reg.floors.size(); ++i)
+		if (reg.floors[i] == n)
+			return;
+	reg.floors.push(n);
+}
+
+static bool mergeRegions(rcRegion& rega, rcRegion& regb)
+{
+	unsigned short aid = rega.id;
+	unsigned short bid = regb.id;
+	
+	// Duplicate current neighbourhood.
+	rcIntArray acon;
+	acon.resize(rega.connections.size());
+	for (int i = 0; i < rega.connections.size(); ++i)
+		acon[i] = rega.connections[i];
+	rcIntArray& bcon = regb.connections;
+	
+	// Find insertion point on A.
+	int insa = -1;
+	for (int i = 0; i < acon.size(); ++i)
+	{
+		if (acon[i] == bid)
+		{
+			insa = i;
+			break;
+		}
+	}
+	if (insa == -1)
+		return false;
+	
+	// Find insertion point on B.
+	int insb = -1;
+	for (int i = 0; i < bcon.size(); ++i)
+	{
+		if (bcon[i] == aid)
+		{
+			insb = i;
+			break;
+		}
+	}
+	if (insb == -1)
+		return false;
+	
+	// Merge neighbours.
+	rega.connections.resize(0);
+	for (int i = 0, ni = acon.size(); i < ni-1; ++i)
+		rega.connections.push(acon[(insa+1+i) % ni]);
+		
+	for (int i = 0, ni = bcon.size(); i < ni-1; ++i)
+		rega.connections.push(bcon[(insb+1+i) % ni]);
+	
+	removeAdjacentNeighbours(rega);
+	
+	for (int j = 0; j < regb.floors.size(); ++j)
+		addUniqueFloorRegion(rega, regb.floors[j]);
+	rega.spanCount += regb.spanCount;
+	regb.spanCount = 0;
+	regb.connections.resize(0);
+
+	return true;
+}
+
+static bool isRegionConnectedToBorder(const rcRegion& reg)
+{
+	// Region is connected to border if
+	// one of the neighbours is null id.
+	for (int i = 0; i < reg.connections.size(); ++i)
+	{
+		if (reg.connections[i] == 0)
+			return true;
+	}
+	return false;
+}
+
+static bool isSolidEdge(rcCompactHeightfield& chf, unsigned short* srcReg,
+						int x, int y, int i, int dir)
+{
+	const rcCompactSpan& s = chf.spans[i];
+	unsigned short r = 0;
+	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+	{
+		const int ax = x + rcGetDirOffsetX(dir);
+		const int ay = y + rcGetDirOffsetY(dir);
+		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
+		r = srcReg[ai];
+	}
+	if (r == srcReg[i])
+		return false;
+	return true;
+}
+
+static void walkContour(int x, int y, int i, int dir,
+						rcCompactHeightfield& chf,
+						unsigned short* srcReg,
+						rcIntArray& cont)
+{
+	int startDir = dir;
+	int starti = i;
+
+	const rcCompactSpan& ss = chf.spans[i];
+	unsigned short curReg = 0;
+	if (rcGetCon(ss, dir) != RC_NOT_CONNECTED)
+	{
+		const int ax = x + rcGetDirOffsetX(dir);
+		const int ay = y + rcGetDirOffsetY(dir);
+		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(ss, dir);
+		curReg = srcReg[ai];
+	}
+	cont.push(curReg);
+			
+	int iter = 0;
+	while (++iter < 40000)
+	{
+		const rcCompactSpan& s = chf.spans[i];
+		
+		if (isSolidEdge(chf, srcReg, x, y, i, dir))
+		{
+			// Choose the edge corner
+			unsigned short r = 0;
+			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+			{
+				const int ax = x + rcGetDirOffsetX(dir);
+				const int ay = y + rcGetDirOffsetY(dir);
+				const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
+				r = srcReg[ai];
+			}
+			if (r != curReg)
+			{
+				curReg = r;
+				cont.push(curReg);
+			}
+			
+			dir = (dir+1) & 0x3;  // Rotate CW
+		}
+		else
+		{
+			int ni = -1;
+			const int nx = x + rcGetDirOffsetX(dir);
+			const int ny = y + rcGetDirOffsetY(dir);
+			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
+			{
+				const rcCompactCell& nc = chf.cells[nx+ny*chf.width];
+				ni = (int)nc.index + rcGetCon(s, dir);
+			}
+			if (ni == -1)
+			{
+				// Should not happen.
+				return;
+			}
+			x = nx;
+			y = ny;
+			i = ni;
+			dir = (dir+3) & 0x3;	// Rotate CCW
+		}
+		
+		if (starti == i && startDir == dir)
+		{
+			break;
+		}
+	}
+
+	// Remove adjacent duplicates.
+	if (cont.size() > 1)
+	{
+		for (int i = 0; i < cont.size(); )
+		{
+			int ni = (i+1) % cont.size();
+			if (cont[i] == cont[ni])
+			{
+				for (int j = i; j < cont.size()-1; ++j)
+					cont[j] = cont[j+1];
+				cont.pop();
+			}
+			else
+				++i;
+		}
+	}
+}
+
+static bool filterSmallRegions(rcContext* ctx, int minRegionArea, int mergeRegionSize,
+							   unsigned short& maxRegionId,
+							   rcCompactHeightfield& chf,
+							   unsigned short* srcReg)
+{
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	const int nreg = maxRegionId+1;
+	rcRegion* regions = (rcRegion*)rcAlloc(sizeof(rcRegion)*nreg, RC_ALLOC_TEMP);
+	if (!regions)
+	{
+		ctx->log(RC_LOG_ERROR, "filterSmallRegions: Out of memory 'regions' (%d).", nreg);
+		return false;
+	}
+
+	// Construct regions
+	for (int i = 0; i < nreg; ++i)
+		new(&regions[i]) rcRegion((unsigned short)i);
+	
+	// Find edge of a region and find connections around the contour.
+	for (int y = 0; y < h; ++y)
+	{
+		for (int x = 0; x < w; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				unsigned short r = srcReg[i];
+				if (r == 0 || r >= nreg)
+					continue;
+				
+				rcRegion& reg = regions[r];
+				reg.spanCount++;
+				
+				
+				// Update floors.
+				for (int j = (int)c.index; j < ni; ++j)
+				{
+					if (i == j) continue;
+					unsigned short floorId = srcReg[j];
+					if (floorId == 0 || floorId >= nreg)
+						continue;
+					addUniqueFloorRegion(reg, floorId);
+				}
+				
+				// Have found contour
+				if (reg.connections.size() > 0)
+					continue;
+				
+				reg.areaType = chf.areas[i];
+				
+				// Check if this cell is next to a border.
+				int ndir = -1;
+				for (int dir = 0; dir < 4; ++dir)
+				{
+					if (isSolidEdge(chf, srcReg, x, y, i, dir))
+					{
+						ndir = dir;
+						break;
+					}
+				}
+				
+				if (ndir != -1)
+				{
+					// The cell is at border.
+					// Walk around the contour to find all the neighbours.
+					walkContour(x, y, i, ndir, chf, srcReg, reg.connections);
+				}
+			}
+		}
+	}
+
+	// Remove too small regions.
+	rcIntArray stack(32);
+	rcIntArray trace(32);
+	for (int i = 0; i < nreg; ++i)
+	{
+		rcRegion& reg = regions[i];
+		if (reg.id == 0 || (reg.id & RC_BORDER_REG))
+			continue;                       
+		if (reg.spanCount == 0)
+			continue;
+		if (reg.visited)
+			continue;
+		
+		// Count the total size of all the connected regions.
+		// Also keep track of the regions connects to a tile border.
+		bool connectsToBorder = false;
+		int spanCount = 0;
+		stack.resize(0);
+		trace.resize(0);
+
+		reg.visited = true;
+		stack.push(i);
+		
+		while (stack.size())
+		{
+			// Pop
+			int ri = stack.pop();
+			
+			rcRegion& creg = regions[ri];
+
+			spanCount += creg.spanCount;
+			trace.push(ri);
+
+			for (int j = 0; j < creg.connections.size(); ++j)
+			{
+				if (creg.connections[j] & RC_BORDER_REG)
+				{
+					connectsToBorder = true;
+					continue;
+				}
+				rcRegion& nreg = regions[creg.connections[j]];
+				if (nreg.visited)
+					continue;
+				if (nreg.id == 0 || (nreg.id & RC_BORDER_REG))
+					continue;
+				// Visit
+				stack.push(nreg.id);
+				nreg.visited = true;
+			}
+		}
+		
+		// If the accumulated regions size is too small, remove it.
+		// Do not remove areas which connect to tile borders
+		// as their size cannot be estimated correctly and removing them
+		// can potentially remove necessary areas.
+		if (spanCount < minRegionArea && !connectsToBorder)
+		{
+			// Kill all visited regions.
+			for (int j = 0; j < trace.size(); ++j)
+			{
+				regions[trace[j]].spanCount = 0;
+				regions[trace[j]].id = 0;
+			}
+		}
+	}
+		
+	// Merge too small regions to neighbour regions.
+	int mergeCount = 0 ;
+	do
+	{
+		mergeCount = 0;
+		for (int i = 0; i < nreg; ++i)
+		{
+			rcRegion& reg = regions[i];
+			if (reg.id == 0 || (reg.id & RC_BORDER_REG))
+				continue;                       
+			if (reg.spanCount == 0)
+				continue;
+			
+			// Check to see if the region should be merged.
+			if (reg.spanCount > mergeRegionSize && isRegionConnectedToBorder(reg))
+				continue;
+			
+			// Small region with more than 1 connection.
+			// Or region which is not connected to a border at all.
+			// Find smallest neighbour region that connects to this one.
+			int smallest = 0xfffffff;
+			unsigned short mergeId = reg.id;
+			for (int j = 0; j < reg.connections.size(); ++j)
+			{
+				if (reg.connections[j] & RC_BORDER_REG) continue;
+				rcRegion& mreg = regions[reg.connections[j]];
+				if (mreg.id == 0 || (mreg.id & RC_BORDER_REG)) continue;
+				if (mreg.spanCount < smallest &&
+					canMergeWithRegion(reg, mreg) &&
+					canMergeWithRegion(mreg, reg))
+				{
+					smallest = mreg.spanCount;
+					mergeId = mreg.id;
+				}
+			}
+			// Found new id.
+			if (mergeId != reg.id)
+			{
+				unsigned short oldId = reg.id;
+				rcRegion& target = regions[mergeId];
+				
+				// Merge neighbours.
+				if (mergeRegions(target, reg))
+				{
+					// Fixup regions pointing to current region.
+					for (int j = 0; j < nreg; ++j)
+					{
+						if (regions[j].id == 0 || (regions[j].id & RC_BORDER_REG)) continue;
+						// If another region was already merged into current region
+						// change the nid of the previous region too.
+						if (regions[j].id == oldId)
+							regions[j].id = mergeId;
+						// Replace the current region with the new one if the
+						// current regions is neighbour.
+						replaceNeighbour(regions[j], oldId, mergeId);
+					}
+					mergeCount++;
+				}
+			}
+		}
+	}
+	while (mergeCount > 0);
+	
+	// Compress region Ids.
+	for (int i = 0; i < nreg; ++i)
+	{
+		regions[i].remap = false;
+		if (regions[i].id == 0) continue;       // Skip nil regions.
+		if (regions[i].id & RC_BORDER_REG) continue;    // Skip external regions.
+		regions[i].remap = true;
+	}
+	
+	unsigned short regIdGen = 0;
+	for (int i = 0; i < nreg; ++i)
+	{
+		if (!regions[i].remap)
+			continue;
+		unsigned short oldId = regions[i].id;
+		unsigned short newId = ++regIdGen;
+		for (int j = i; j < nreg; ++j)
+		{
+			if (regions[j].id == oldId)
+			{
+				regions[j].id = newId;
+				regions[j].remap = false;
+			}
+		}
+	}
+	maxRegionId = regIdGen;
+	
+	// Remap regions.
+	for (int i = 0; i < chf.spanCount; ++i)
+	{
+		if ((srcReg[i] & RC_BORDER_REG) == 0)
+			srcReg[i] = regions[srcReg[i]].id;
+	}
+	
+	for (int i = 0; i < nreg; ++i)
+		regions[i].~rcRegion();
+	rcFree(regions);
+	
+	return true;
+}
+
+
+bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD);
+	
+	if (chf.dist)
+	{
+		rcFree(chf.dist);
+		chf.dist = 0;
+	}
+	
+	unsigned short* src = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!src)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildDistanceField: Out of memory 'src' (%d).", chf.spanCount);
+		return false;
+	}
+	unsigned short* dst = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!dst)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildDistanceField: Out of memory 'dst' (%d).", chf.spanCount);
+		rcFree(src);
+		return false;
+	}
+	
+	unsigned short maxDist = 0;
+
+	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD_DIST);
+	
+	calculateDistanceField(chf, src, maxDist);
+	chf.maxDistance = maxDist;
+	
+	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD_DIST);
+	
+	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD_BLUR);
+	
+	// Blur
+	if (boxBlur(chf, 1, src, dst) != src)
+		rcSwap(src, dst);
+	
+	// Store distance.
+	chf.dist = src;
+	
+	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD_BLUR);
+
+	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD);
+	
+	rcFree(dst);
+	
+	return true;
+}
+
+static void paintRectRegion(int minx, int maxx, int miny, int maxy, unsigned short regId,
+							rcCompactHeightfield& chf, unsigned short* srcReg)
+{
+	const int w = chf.width;	
+	for (int y = miny; y < maxy; ++y)
+	{
+		for (int x = minx; x < maxx; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				if (chf.areas[i] != RC_NULL_AREA)
+					srcReg[i] = regId;
+			}
+		}
+	}
+}
+
+
+static const unsigned short RC_NULL_NEI = 0xffff;
+
+struct rcSweepSpan
+{
+	unsigned short rid;	// row id
+	unsigned short id;	// region id
+	unsigned short ns;	// number samples
+	unsigned short nei;	// neighbour id
+};
+
+bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
+							const int borderSize, const int minRegionArea, const int mergeRegionArea)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_REGIONS);
+	
+	const int w = chf.width;
+	const int h = chf.height;
+	unsigned short id = 1;
+	
+	rcScopedDelete<unsigned short> srcReg = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP);
+	if (!srcReg)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildRegionsMonotone: Out of memory 'src' (%d).", chf.spanCount);
+		return false;
+	}
+	memset(srcReg,0,sizeof(unsigned short)*chf.spanCount);
+
+	const int nsweeps = rcMax(chf.width,chf.height);
+	rcScopedDelete<rcSweepSpan> sweeps = (rcSweepSpan*)rcAlloc(sizeof(rcSweepSpan)*nsweeps, RC_ALLOC_TEMP);
+	if (!sweeps)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildRegionsMonotone: Out of memory 'sweeps' (%d).", nsweeps);
+		return false;
+	}
+	
+	
+	// Mark border regions.
+	if (borderSize > 0)
+	{
+		// Make sure border will not overflow.
+		const int bw = rcMin(w, borderSize);
+		const int bh = rcMin(h, borderSize);
+		// Paint regions
+		paintRectRegion(0, bw, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
+		paintRectRegion(w-bw, w, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
+		paintRectRegion(0, w, 0, bh, id|RC_BORDER_REG, chf, srcReg); id++;
+		paintRectRegion(0, w, h-bh, h, id|RC_BORDER_REG, chf, srcReg); id++;
+	}
+	
+	rcIntArray prev(256);
+
+	// Sweep one line at a time.
+	for (int y = borderSize; y < h-borderSize; ++y)
+	{
+		// Collect spans from this row.
+		prev.resize(id+1);
+		memset(&prev[0],0,sizeof(int)*id);
+		unsigned short rid = 1;
+		
+		for (int x = borderSize; x < w-borderSize; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				const rcCompactSpan& s = chf.spans[i];
+				if (chf.areas[i] == RC_NULL_AREA) continue;
+				
+				// -x
+				unsigned short previd = 0;
+				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
+				{
+					const int ax = x + rcGetDirOffsetX(0);
+					const int ay = y + rcGetDirOffsetY(0);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);
+					if ((srcReg[ai] & RC_BORDER_REG) == 0 && chf.areas[i] == chf.areas[ai])
+						previd = srcReg[ai];
+				}
+				
+				if (!previd)
+				{
+					previd = rid++;
+					sweeps[previd].rid = previd;
+					sweeps[previd].ns = 0;
+					sweeps[previd].nei = 0;
+				}
+
+				// -y
+				if (rcGetCon(s,3) != RC_NOT_CONNECTED)
+				{
+					const int ax = x + rcGetDirOffsetX(3);
+					const int ay = y + rcGetDirOffsetY(3);
+					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);
+					if (srcReg[ai] && (srcReg[ai] & RC_BORDER_REG) == 0 && chf.areas[i] == chf.areas[ai])
+					{
+						unsigned short nr = srcReg[ai];
+						if (!sweeps[previd].nei || sweeps[previd].nei == nr)
+						{
+							sweeps[previd].nei = nr;
+							sweeps[previd].ns++;
+							prev[nr]++;
+						}
+						else
+						{
+							sweeps[previd].nei = RC_NULL_NEI;
+						}
+					}
+				}
+
+				srcReg[i] = previd;
+			}
+		}
+		
+		// Create unique ID.
+		for (int i = 1; i < rid; ++i)
+		{
+			if (sweeps[i].nei != RC_NULL_NEI && sweeps[i].nei != 0 &&
+				prev[sweeps[i].nei] == (int)sweeps[i].ns)
+			{
+				sweeps[i].id = sweeps[i].nei;
+			}
+			else
+			{
+				sweeps[i].id = id++;
+			}
+		}
+		
+		// Remap IDs
+		for (int x = borderSize; x < w-borderSize; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+y*w];
+			
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				if (srcReg[i] > 0 && srcReg[i] < rid)
+					srcReg[i] = sweeps[srcReg[i]].id;
+			}
+		}
+	}
+
+	ctx->startTimer(RC_TIMER_BUILD_REGIONS_FILTER);
+
+	// Filter out small regions.
+	chf.maxRegions = id;
+	if (!filterSmallRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg))
+		return false;
+
+	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FILTER);
+	
+	// Store the result out.
+	for (int i = 0; i < chf.spanCount; ++i)
+		chf.spans[i].reg = srcReg[i];
+	
+	ctx->stopTimer(RC_TIMER_BUILD_REGIONS);
+
+	return true;
+}
+
+bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
+					const int borderSize, const int minRegionArea, const int mergeRegionArea)
+{
+	rcAssert(ctx);
+	
+	ctx->startTimer(RC_TIMER_BUILD_REGIONS);
+	
+	const int w = chf.width;
+	const int h = chf.height;
+	
+	rcScopedDelete<unsigned short> buf = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount*4, RC_ALLOC_TEMP);
+	if (!buf)
+	{
+		ctx->log(RC_LOG_ERROR, "rcBuildRegions: Out of memory 'tmp' (%d).", chf.spanCount*4);
+		return false;
+	}
+	
+	ctx->startTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
+	
+	rcIntArray stack(1024);
+	rcIntArray visited(1024);
+	
+	unsigned short* srcReg = buf;
+	unsigned short* srcDist = buf+chf.spanCount;
+	unsigned short* dstReg = buf+chf.spanCount*2;
+	unsigned short* dstDist = buf+chf.spanCount*3;
+	
+	memset(srcReg, 0, sizeof(unsigned short)*chf.spanCount);
+	memset(srcDist, 0, sizeof(unsigned short)*chf.spanCount);
+	
+	unsigned short regionId = 1;
+	unsigned short level = (chf.maxDistance+1) & ~1;
+
+	// TODO: Figure better formula, expandIters defines how much the 
+	// watershed "overflows" and simplifies the regions. Tying it to
+	// agent radius was usually good indication how greedy it could be.
+//	const int expandIters = 4 + walkableRadius * 2;
+	const int expandIters = 8;
+
+	// Mark border regions.
+	paintRectRegion(0, borderSize, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+	paintRectRegion(w-borderSize, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+	paintRectRegion(0, w, 0, borderSize, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+	paintRectRegion(0, w, h-borderSize, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+	
+	while (level > 0)
+	{
+		level = level >= 2 ? level-2 : 0;
+		
+		ctx->startTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
+		
+		// Expand current regions until no empty connected cells found.
+		if (expandRegions(expandIters, level, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
+		{
+			rcSwap(srcReg, dstReg);
+			rcSwap(srcDist, dstDist);
+		}
+		
+		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
+		
+		ctx->startTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
+		
+		// Mark new regions with IDs.
+		for (int y = 0; y < h; ++y)
+		{
+			for (int x = 0; x < w; ++x)
+			{
+				const rcCompactCell& c = chf.cells[x+y*w];
+				for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+				{
+					if (chf.dist[i] < level || srcReg[i] != 0 || chf.areas[i] == RC_NULL_AREA)
+						continue;
+					
+					if (floodRegion(x, y, i, level, regionId, chf, srcReg, srcDist, stack))
+						regionId++;
+				}
+			}
+		}
+		
+		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
+		
+	}
+	
+	// Expand current regions until no empty connected cells found.
+	if (expandRegions(expandIters*8, 0, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
+	{
+		rcSwap(srcReg, dstReg);
+		rcSwap(srcDist, dstDist);
+	}
+	
+	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
+	
+	ctx->startTimer(RC_TIMER_BUILD_REGIONS_FILTER);
+	
+	// Filter out small regions.
+	chf.maxRegions = regionId;
+	if (!filterSmallRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg))
+		return false;
+	
+	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FILTER);
+		
+	// Write the result out.
+	for (int i = 0; i < chf.spanCount; ++i)
+		chf.spans[i].reg = srcReg[i];
+	
+	ctx->stopTimer(RC_TIMER_BUILD_REGIONS);
+	
+	return true;
+}
+
+
diff -r dc4fc5c8b306 src/server/collision/CMakeLists.txt
--- a/src/server/collision/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/collision/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -15,6 +15,7 @@
 file(GLOB_RECURSE sources_Management Management/*.cpp Management/*.h)
 file(GLOB_RECURSE sources_Maps Maps/*.cpp Maps/*.h)
 file(GLOB_RECURSE sources_Models Models/*.cpp Models/*.h)
+file(GLOB_RECURSE sources_Pathfinding Pathfinding/*.cpp Pathfinding/*.h)
 file(GLOB sources_localdir *.cpp *.h)
 
 if( USE_COREPCH AND MSVC )
@@ -29,22 +30,53 @@
   ${sources_Management}
   ${sources_Maps}
   ${sources_Models}
+  ${sources_Pathfinding}
   ${sources_localdir}
 )
 
 include_directories(
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
   ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
   ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
   ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Management
   ${CMAKE_CURRENT_SOURCE_DIR}/Maps
   ${CMAKE_CURRENT_SOURCE_DIR}/Models
+  ${CMAKE_CURRENT_SOURCE_DIR}/Pathfinding
   ${CMAKE_BINARY_DIR}
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
diff -r dc4fc5c8b306 src/server/collision/Management/VMapManager2.h
--- a/src/server/collision/Management/VMapManager2.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/collision/Management/VMapManager2.h	Tue Nov 30 23:02:11 2010 -0500
@@ -106,6 +106,9 @@
                 return getMapFileName(pMapId);
             }
             virtual bool existsMap(const char* pBasePath, unsigned int pMapId, int x, int y);
+
+        public:
+            void getInstanceMapTree(InstanceTreeMap &instanceMapTree);
     };
 }
 #endif
diff -r dc4fc5c8b306 src/server/collision/Maps/MapTree.h
--- a/src/server/collision/Maps/MapTree.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/collision/Maps/MapTree.h	Tue Nov 30 23:02:11 2010 -0500
@@ -80,6 +80,9 @@
             void UnloadMapTile(uint32 tileX, uint32 tileY, VMapManager2 *vm);
             bool isTiled() const { return iIsTiled; }
             uint32 numLoadedTiles() const { return iLoadedTiles.size(); }
+
+        public:
+            void getModelInstances(ModelInstance* &models, uint32 &count);
     };
 
     struct AreaInfo
diff -r dc4fc5c8b306 src/server/collision/Models/ModelInstance.h
--- a/src/server/collision/Models/ModelInstance.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/collision/Models/ModelInstance.h	Tue Nov 30 23:02:11 2010 -0500
@@ -75,6 +75,9 @@
             G3D::Matrix3 iInvRot;
             float iInvScale;
             WorldModel *iModel;
+
+        public:
+            WorldModel* const getWorldModel();
     };
 } // namespace VMAP
 
diff -r dc4fc5c8b306 src/server/collision/Models/WorldModel.h
--- a/src/server/collision/Models/WorldModel.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/collision/Models/WorldModel.h	Tue Nov 30 23:02:11 2010 -0500
@@ -66,6 +66,8 @@
             uint32 iType;    //!< liquid type
             float *iHeight;  //!< (tilesX + 1)*(tilesY + 1) height values
             uint8 *iFlags;   //!< info if liquid tile is used
+        public:
+            void getPosInfo(uint32 &tilesX, uint32 &tilesY, Vector3 &corner) const;
     };
 
     /*! holding additional info for WMO group files */
@@ -98,6 +100,9 @@
             std::vector<MeshTriangle> triangles;
             BIH meshTree;
             WmoLiquid *iLiquid;
+
+        public:
+            void getMeshData(std::vector<Vector3> &vertices, std::vector<MeshTriangle> &triangles, WmoLiquid* &liquid);
     };
     /*! Holds a model (converted M2 or WMO) in its original coordinate space */
     class WorldModel
@@ -117,6 +122,9 @@
             uint32 RootWMOID;
             std::vector<GroupModel> groupModels;
             BIH groupTree;
+
+        public:
+            void getGroupModels(std::vector<GroupModel> &groupModels);
     };
 } // namespace VMAP
 
diff -r dc4fc5c8b306 src/server/collision/Pathfinding/PathInfo.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/collision/Pathfinding/PathInfo.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,759 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "Creature.h"
+#include "PathInfo.h"
+#include "Map.h"
+#include "DetourCommon.h"
+
+////////////////// PathInfo //////////////////
+PathInfo::PathInfo(Unit const* owner, const float destX, const float destY, const float destZ, bool useStraightPath) : m_pathPolyRefs(NULL), 
+    m_polyLength(0), m_type(PATHFIND_BLANK), m_useStraightPath(useStraightPath), m_sourceUnit(owner), 
+    m_navMesh(NULL), m_navMeshQuery(NULL)
+{
+    PathNode endPoint(destX, destY, destZ);
+    setEndPosition(endPoint);
+
+    float x,y,z;
+    m_sourceUnit->GetPosition(x, y, z);
+    PathNode startPoint(x, y, z);
+    setStartPosition(startPoint);
+
+    sLog.outDebug("++ PathInfo::PathInfo for %u \n", m_sourceUnit->GetGUID());
+
+    const Map* map = m_sourceUnit->GetBaseMap();
+    if (map->IsPathfindingEnabled()) 
+        m_navMesh = map->GetNavMesh(); 
+ 
+    if (m_navMesh) 
+    {
+        m_navMeshQuery = dtAllocNavMeshQuery();
+        ASSERT(m_navMeshQuery);
+        if (DT_SUCCESS != m_navMeshQuery->init(m_navMesh, MESH_MAX_NODES))
+        {
+            sLog.outError("%u's PathInfo navMeshQuery failed to init", m_sourceUnit->GetGUID());
+            return;
+        }
+
+        BuildPolyPath(startPoint, endPoint);
+    }
+    else
+    {
+        BuildShortcut();
+        m_type = PathType(PATHFIND_NORMAL | PATHFIND_NOT_USING_PATH);
+    }
+}
+
+PathInfo::~PathInfo()
+{
+    sLog.outDebug("++ PathInfo::~PathInfo() for %u \n", m_sourceUnit->GetGUID());
+
+    if (m_pathPolyRefs)
+        delete [] m_pathPolyRefs;
+
+    // m_navMesh is not ours to delete
+    if (m_navMesh && m_navMeshQuery)
+        dtFreeNavMeshQuery(m_navMeshQuery);
+}
+
+bool PathInfo::Update(const float destX, const float destY, const float destZ, bool useStraightPath)
+{
+    PathNode newDest(destX, destY, destZ);
+    PathNode oldDest = getEndPosition();
+    setEndPosition(newDest);
+
+    float x, y, z;
+    m_sourceUnit->GetPosition(x, y, z);
+    PathNode newStart(x, y, z);
+    PathNode oldStart = getStartPosition();
+    setStartPosition(newStart);
+
+    m_useStraightPath = useStraightPath;
+
+    sLog.outDebug("++ PathInfo::Update() for %u \n", m_sourceUnit->GetGUID());
+
+    // make sure navMesh works - we can run on map w/o mmap
+    if (!m_navMesh)
+    {
+        BuildShortcut();
+        m_type = PathType(PATHFIND_NORMAL | PATHFIND_NOT_USING_PATH);
+        return true;
+    }
+
+    float dist = 2*m_sourceUnit->GetObjectSize();
+    bool oldDestInRange = inRange(oldDest, newDest, dist, dist);
+
+    // this can happen only if caller did a bad job calculating the need for path update
+    if (oldDestInRange && inRange(newStart, oldStart, dist, dist))
+        return false;
+
+    // check if destination moved - if not we can optimize something here
+    // we are following old, precalculated path?
+    if (oldDestInRange && m_pathPoints.size() > 2)
+    {
+        // our target is not moving - we just coming closer
+        // we are moving on precalculated path - enjoy the ride
+ 
+        m_pathPoints.crop(1, 0); 
+        setNextPosition(m_pathPoints[1]); 
+ 
+        return false;
+    }
+    else
+    {
+        // target moved, so we need to update the poly path
+        BuildPolyPath(newStart, newDest);
+        return true;
+    }
+}
+
+dtPolyRef PathInfo::getPathPolyByPosition(dtPolyRef *polyPath, uint32 polyPathSize, PathNode p, float *distance)
+{
+    if (!m_navMeshQuery || !polyPath || !polyPathSize)
+        return INVALID_POLYREF;
+
+    float point[VERTEX_SIZE] = {p.y, p.z, p.x};
+    dtPolyRef nearestPoly = INVALID_POLYREF;
+    float minDist2d = FLT_MAX; 
+    float minDist3d = 0.0f; 
+ 
+    for (uint32 i = 0; i < polyPathSize; ++i) 
+    { 
+        float closestPoint[VERTEX_SIZE]; 
+        if (DT_SUCCESS != m_navMeshQuery->closestPointOnPoly(polyPath[i], point, closestPoint)) 
+            continue; 
+ 
+        float d = dtVdist2DSqr(point, closestPoint); 
+        if (d < minDist2d) 
+        { 
+            minDist2d = d; 
+            nearestPoly = m_pathPolyRefs[i]; 
+            minDist3d = dtVdistSqr(point, closestPoint); 
+        } 
+ 
+        if (minDist2d < 1.0f) // shortcut out - close enough for us 
+            break;
+    }
+
+    if (distance) 
+        *distance = dtSqrt(minDist3d); 
+
+    return (minDist2d < 4.0f) ? nearestPoly : INVALID_POLYREF;
+}
+
+void PathInfo::BuildPolyPath(PathNode startPos, PathNode endPos)
+{
+    // *** getting start/end poly logic ***
+
+    float distToStartPoly, distToEndPoly;
+
+    // first we check the current path
+    // if the current path doesn't contain the current poly,
+    // we need to use the expensive navMesh.findNearestPoly
+    dtPolyRef startPoly = getPathPolyByPosition(m_pathPolyRefs, m_polyLength, startPos, &distToStartPoly); 
+    dtPolyRef endPoly = getPathPolyByPosition(m_pathPolyRefs, m_polyLength, endPos, &distToEndPoly); 
+
+    float startPoint[VERTEX_SIZE] = {startPos.y, startPos.z, startPos.x};
+    float endPoint[VERTEX_SIZE] = {endPos.y, endPos.z, endPos.x};
+
+    // we don't have it in our old path
+    // try to get it by findNearestPoly()
+    // use huge vertical range here
+    if (startPoly == INVALID_POLYREF || endPoly == INVALID_POLYREF)
+    {
+        float extents[VERTEX_SIZE] = {3.f, 200.f, 3.f};    // bounds of poly search area
+        dtQueryFilter filter = createFilter();
+        float closestPoint[VERTEX_SIZE];
+
+        if (startPoly == INVALID_POLYREF)
+        {
+            if (DT_SUCCESS == m_navMeshQuery->findNearestPoly(startPoint, extents, &filter, &startPoly, closestPoint))
+                distToStartPoly = dtVdist(closestPoint, startPoint);
+        }
+
+        if (endPoly == INVALID_POLYREF)
+        {
+            if (DT_SUCCESS == m_navMeshQuery->findNearestPoly(endPoint, extents, &filter, &endPoly, closestPoint))
+            distToEndPoly = dtVdist(closestPoint, endPoint);
+        }
+    }
+
+    // we have a hole in our mesh
+    // make shortcut path and mark it as NOPATH ( with flying exception )
+    // its up to caller how he will use this info
+    if (startPoly == INVALID_POLYREF || endPoly == INVALID_POLYREF)
+    {
+        sLog.outDebug("++ BuildPolyPath :: (startPoly == 0 || endPoly == 0)\n");
+        BuildShortcut();
+        m_type = (m_sourceUnit->GetTypeId() == TYPEID_UNIT && ((Creature*)m_sourceUnit)->canFly()) 
+            ? PathType(PATHFIND_NORMAL | PATHFIND_NOT_USING_PATH) : PATHFIND_NOPATH; 
+
+        return;
+    }
+
+    // we may need a better number here
+    bool farFromPoly = (distToStartPoly > 7.0f || distToEndPoly > 7.0f);
+    if (farFromPoly)
+    {
+        sLog.outDebug("++ BuildPolyPath :: farFromPoly distToStartPoly=%.3f distToEndPoly=%.3f\n", distToStartPoly, distToEndPoly);
+ 
+        bool buildShotrcut = false; 
+        if (m_sourceUnit->GetTypeId() == TYPEID_UNIT) 
+        { 
+            Creature* owner = (Creature*)m_sourceUnit; 
+ 
+            if (m_sourceUnit->GetBaseMap()->IsUnderWater(endPos.x, endPos.y, endPos.z)) 
+            { 
+                sLog.outDebug("++ BuildPolyPath :: underWater case\n"); 
+                if (owner->canSwim() || owner->isPet()) 
+                    buildShotrcut = true; 
+            } 
+            else 
+            { 
+                sLog.outDebug("++ BuildPolyPath :: flying case\n"); 
+                if (owner->canFly()) 
+                    buildShotrcut = true; 
+            } 
+        } 
+ 
+        if (buildShotrcut) 
+        {
+            BuildShortcut();
+            m_type = PathType(PATHFIND_NORMAL | PATHFIND_NOT_USING_PATH);
+            return;
+        }
+        else
+        {
+            float closestPoint[VERTEX_SIZE];
+            // we may want to use closestPointOnPolyBoundary instead
+            if (DT_SUCCESS == m_navMeshQuery->closestPointOnPoly(endPoly, endPoint, closestPoint))
+            {
+                dtVcopy(endPoint, closestPoint);
+                setActualEndPosition(PathNode(endPoint[2],endPoint[0],endPoint[1]));
+            }
+
+            m_type = PATHFIND_INCOMPLETE;
+        }
+    }
+
+    // *** poly path generating logic ***
+
+    // start and end are on same polygon
+    // just need to move in straight line
+    if (startPoly == endPoly)
+    {
+        sLog.outDebug("++ BuildPolyPath :: (startPoly == endPoly)\n");
+
+        BuildShortcut();
+
+        m_pathPolyRefs = new dtPolyRef[1];
+        m_pathPolyRefs[0] = startPoly;
+        m_polyLength = 1;
+
+        m_type = farFromPoly ? PATHFIND_INCOMPLETE : PATHFIND_NORMAL;
+        sLog.outDebug("++ BuildPolyPath :: path type %d\n", m_type);
+        return;
+    }
+
+    // look for startPoly/endPoly in current path
+    // TODO: we can merge it with getPathPolyByPosition() loop
+    bool startPolyFound = false;
+    bool endPolyFound = false;
+    uint32 pathStartIndex, pathEndIndex;
+
+    if (m_polyLength)
+    {
+        for (pathStartIndex = 0; pathStartIndex < m_polyLength; ++pathStartIndex)
+            if (m_pathPolyRefs[pathStartIndex] == startPoly)
+            {
+                startPolyFound = true;
+                break;
+            }
+
+        for (pathEndIndex = m_polyLength-1; pathEndIndex > pathStartIndex; --pathEndIndex)
+            if (m_pathPolyRefs[pathEndIndex] == endPoly)
+            {
+                endPolyFound = true;
+                break;
+            }
+    }
+
+    if (startPolyFound && endPolyFound)
+    {
+        sLog.outDebug("++ BuildPolyPath :: (startPolyFound && endPolyFound)\n");
+
+        // we moved along the path and the target did not move out of our old poly-path
+        // our path is a simple subpath case, we have all the data we need
+        // just "cut" it out
+
+        m_polyLength = pathEndIndex - pathStartIndex + 1;
+
+        dtPolyRef* newPolyRefs = new dtPolyRef[m_polyLength];
+        memcpy(newPolyRefs, m_pathPolyRefs+pathStartIndex, m_polyLength*sizeof(dtPolyRef));
+
+        delete [] m_pathPolyRefs;
+        m_pathPolyRefs = newPolyRefs;
+    }
+    else if (startPolyFound && !endPolyFound)
+    {
+        sLog.outDebug("++ BuildPolyPath :: (startPolyFound && !endPolyFound)\n");
+
+        // we are moving on the old path but target moved out
+        // so we have atleast part of poly-path ready
+
+        m_polyLength -= pathStartIndex;
+
+        // try to adjust the suffix of the path instead of recalculating entire length
+        // at given interval the target cannot get too far from its last location
+        // thus we have less poly to cover
+        // sub-path of optimal path is optimal
+
+        // take ~80% of the original length
+        // TODO : play with the values here
+        uint32 prefixPolyLength = uint32(m_polyLength*0.8f + 0.5f);
+        dtPolyRef prefixPathPolys[MAX_PATH_LENGTH];
+        memcpy(prefixPathPolys, m_pathPolyRefs+pathStartIndex, prefixPolyLength*sizeof(dtPolyRef));
+
+        dtPolyRef suffixStartPoly = prefixPathPolys[prefixPolyLength-1];
+
+        // we need any point on our suffix start poly to generate poly-path, so we need last poly in prefix data
+        float suffixEndPoint[VERTEX_SIZE];
+        if (DT_SUCCESS != m_navMeshQuery->closestPointOnPoly(suffixStartPoly, endPoint, suffixEndPoint))
+        {
+            // suffixStartPoly is invalid somehow, or the navmesh is broken => error state
+            sLog.outError("%u's Path Build failed: invalid polyRef in path", m_sourceUnit->GetGUID());
+
+            BuildShortcut();
+            m_type = PATHFIND_NOPATH;
+            return;
+        }
+
+        // generate suffix
+        dtQueryFilter filter = createFilter();
+        dtPolyRef suffixPathPolys[MAX_PATH_LENGTH];
+
+        uint32 suffixPolyLength = 0; 
+ 
+        dtStatus dtResult = m_navMeshQuery->findPath( 
+                                suffixStartPoly,    // start polygon 
+                                endPoly,            // end polygon 
+                                suffixEndPoint,     // start position 
+                                endPoint,           // end position 
+                                &filter,            // polygon search filter 
+                                suffixPathPolys,    // [out] path 
+                                (int*)&suffixPolyLength, 
+                                MAX_PATH_LENGTH-prefixPolyLength);   // max number of polygons in output path 
+ 
+        if (!suffixPolyLength || dtResult != DT_SUCCESS) 
+        {
+            // this is probably an error state, but we'll leave it
+            // and hopefully recover on the next Update
+            // we still need to copy our preffix
+            sLog.outError("%u's Path Build failed: 0 length path", m_sourceUnit->GetGUID());
+        }
+
+        sLog.outDebug("++  m_polyLength=%u prefixPolyLength=%u suffixPolyLength=%u \n",m_polyLength, prefixPolyLength, suffixPolyLength);
+
+        // new path = prefix + suffix - overlap
+        m_polyLength = prefixPolyLength + suffixPolyLength - 1;
+        delete [] m_pathPolyRefs;
+        m_pathPolyRefs = new dtPolyRef[m_polyLength];
+
+        // copy the part of the old path we keep - prefix
+        memcpy(m_pathPolyRefs, prefixPathPolys, prefixPolyLength*sizeof(dtPolyRef));
+
+        // copy the newly created suffix - skip first poly, we have it at prefix end
+        if (suffixPathPolys)
+            memcpy(m_pathPolyRefs+prefixPolyLength, suffixPathPolys+1, (suffixPolyLength-1)*sizeof(dtPolyRef));
+    }
+    else
+    {
+        sLog.outDebug("++ BuildPolyPath :: (!startPolyFound && !endPolyFound)\n");
+
+        // either we have no path at all -> first run
+        // or something went really wrong -> we aren't moving along the path to the target
+        // just generate new path
+
+        // free and invalidate old path data
+        clear();
+
+        dtQueryFilter filter = createFilter();      // use special filter so we use proper terrain types
+        dtPolyRef pathPolys[MAX_PATH_LENGTH];
+        m_polyLength = 0;
+
+        dtStatus dtResult = m_navMeshQuery->findPath(
+            startPoly,          // start polygon
+            endPoly,            // end polygon
+            startPoint,         // start position
+            endPoint,           // end position
+            &filter,            // polygon search filter
+            pathPolys,          // [out] path
+            (int*)&m_polyLength,
+            MAX_PATH_LENGTH);   // max number of polygons in output path
+
+        if (!m_polyLength || dtResult != DT_SUCCESS)
+        {
+            // only happens if we passed bad data to findPath(), or navmesh is messed up
+            sLog.outError("%u's Path Build failed: 0 length path", m_sourceUnit->GetGUID());
+            BuildShortcut();
+            m_type = PATHFIND_NOPATH;
+            return;
+        }
+
+        m_pathPolyRefs = new dtPolyRef[m_polyLength];
+        memcpy(m_pathPolyRefs, pathPolys, m_polyLength*sizeof(dtPolyRef));
+    }
+
+    // by now we know what type of path we can get
+    if (m_pathPolyRefs[m_polyLength - 1] == endPoly && !(m_type & PATHFIND_INCOMPLETE))
+        m_type = PATHFIND_NORMAL;
+    else
+        m_type = PATHFIND_INCOMPLETE;
+
+    // generate the point-path out of our up-to-date poly-path
+    BuildPointPath(startPoint, endPoint);
+}
+
+void PathInfo::BuildPointPath(float *startPoint, float *endPoint)
+{
+    // get the actual reachable point on last poly in path
+    float closestPoint[VERTEX_SIZE];
+    if ((m_type & PATHFIND_INCOMPLETE) && DT_SUCCESS == m_navMeshQuery->closestPointOnPoly(m_pathPolyRefs[m_polyLength-1], endPoint, closestPoint))
+    {
+        dtVcopy(endPoint, closestPoint);
+        setActualEndPosition(PathNode(endPoint[2],endPoint[0],endPoint[1]));
+    }
+
+    float pathPoints[MAX_POINT_PATH_LENGTH*VERTEX_SIZE];
+    uint32 pointCount = 0;
+    dtStatus dtResult = DT_FAILURE;
+    if (m_useStraightPath)
+    {
+        dtResult = m_navMeshQuery->findStraightPath(
+            startPoint,         // start position
+            endPoint,           // end position
+            m_pathPolyRefs,     // current path
+            m_polyLength,       // lenth of current path
+            pathPoints,         // [out] path corner points
+            NULL,               // [out] flags
+            NULL,               // [out] shortened path
+            (int*)&pointCount,
+            MAX_POINT_PATH_LENGTH);   // maximum number of points/polygons to use
+    }
+    else
+    {
+        dtResult = findSmoothPath(
+            startPoint,         // start position
+            endPoint,           // end position
+            m_pathPolyRefs,     // current path
+            m_polyLength,       // length of current path
+            pathPoints,         // [out] path corner points
+            (int*)&pointCount, 
+            MAX_POINT_PATH_LENGTH);    // maximum number of points
+    }
+
+    if (pointCount < 2 || dtResult != DT_SUCCESS)
+    {
+        // only happens if pass bad data to findStraightPath or navmesh is broken
+        // single point paths can be generated here 
+        // TODO : check the exact cases
+        sLog.outDebug("++ PathInfo::BuildPointPath FAILED! path sized %d returned\n", pointCount);
+        BuildShortcut();
+        m_type = PATHFIND_NOPATH;
+        return;
+    }
+
+    m_pathPoints.resize(pointCount);
+    for (uint32 i = 0; i < pointCount; ++i)
+        m_pathPoints.set(i, PathNode(pathPoints[i*VERTEX_SIZE+2], pathPoints[i*VERTEX_SIZE], pathPoints[i*VERTEX_SIZE+1]));
+
+    // first point is always our current location - we need the next one
+    setNextPosition(m_pathPoints[1]);
+
+    sLog.outDebug("++ PathInfo::BuildPointPath path type %d size %d poly-size %d\n", m_type, pointCount, m_polyLength);
+}
+
+void PathInfo::BuildShortcut()
+{
+    clear();
+
+    // make two point path, our curr pos is the start, and dest is the end
+    m_pathPoints.resize(2);
+
+    // set start and a default next position
+    m_pathPoints.set(0, getStartPosition());
+    m_pathPoints.set(1, getActualEndPosition());
+
+    setNextPosition(getActualEndPosition());
+
+    m_type = PATHFIND_SHORTCUT;
+}
+
+dtQueryFilter PathInfo::createFilter()
+{
+    dtQueryFilter filter;
+
+    if (m_sourceUnit->GetTypeId() != TYPEID_UNIT)
+        return filter;
+
+    Creature* creature = (Creature*)m_sourceUnit;
+    unsigned short includeFlags = 0; 
+    unsigned short excludeFlags = 0; 
+
+    if (creature->canWalk())
+        includeFlags |= NAV_GROUND;          // walk
+
+    // creatures don't take environmental damage
+    if (creature->canSwim() || creature->isPet()) 
+        includeFlags |= (NAV_WATER | NAV_MAGMA | NAV_SLIME);           // swim 
+
+    // allow creatures to cheat and use different movement types if they are moved
+    // forcefully into terrain they can't normally move in
+    if (creature->IsInWater() || creature->IsUnderWater())
+        includeFlags |= getNavTerrain(creature->GetPositionX(),creature->GetPositionY(),creature->GetPositionZ());
+
+    filter.setIncludeFlags(includeFlags); 
+    filter.setExcludeFlags(excludeFlags); 
+
+    return filter;
+}
+
+NavTerrain PathInfo::getNavTerrain(float x, float y, float z)
+{
+    LiquidData data;
+    m_sourceUnit->GetBaseMap()->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &data);
+
+    switch(data.type)
+    {
+        case MAP_LIQUID_TYPE_WATER:
+        case MAP_LIQUID_TYPE_OCEAN:
+            return NAV_WATER;
+        case MAP_LIQUID_TYPE_MAGMA:
+            return NAV_MAGMA;
+        case MAP_LIQUID_TYPE_SLIME:
+            return NAV_SLIME;
+        default:
+            return NAV_EMPTY;
+    }
+}
+
+uint32 PathInfo::fixupCorridor(dtPolyRef* path, const uint32 npath, const uint32 maxPath, const dtPolyRef* visited, const uint32 nvisited)
+{
+    int32 furthestPath = -1;
+    int32 furthestVisited = -1;
+
+    // Find furthest common polygon.
+    for (int32 i = npath-1; i >= 0; --i)
+    {
+        bool found = false;
+        for (int32 j = nvisited-1; j >= 0; --j)
+        {
+            if (path[i] == visited[j])
+            {
+                furthestPath = i;
+                furthestVisited = j;
+                found = true;
+            }
+        }
+        if (found)
+            break;
+    }
+
+    // If no intersection found just return current path.
+    if (furthestPath == -1 || furthestVisited == -1)
+        return npath;
+
+    // Concatenate paths.
+
+    // Adjust beginning of the buffer to include the visited.
+    uint32 req = nvisited - furthestVisited;
+    uint32 orig = uint32(furthestPath+1) < npath ? furthestPath+1 : npath;
+    uint32 size = npath-orig > 0 ? npath-orig : 0;
+    if (req+size > maxPath)
+        size = maxPath-req;
+
+    if (size)
+        memmove(path+req, path+orig, size*sizeof(dtPolyRef));
+
+    // Store visited
+    for (uint32 i = 0; i < req; ++i)
+        path[i] = visited[(nvisited-1)-i];
+
+    return req+size;
+}
+
+bool PathInfo::getSteerTarget(const float* startPos, const float* endPos, const float minTargetDist, const dtPolyRef* path, const uint32 pathSize, float* steerPos, unsigned char& steerPosFlag, dtPolyRef& steerPosRef) 
+{
+    // Find steer target.
+    static const uint32 MAX_STEER_POINTS = 3;
+    float steerPath[MAX_STEER_POINTS*VERTEX_SIZE];
+    unsigned char steerPathFlags[MAX_STEER_POINTS];
+    dtPolyRef steerPathPolys[MAX_STEER_POINTS];
+    uint32 nsteerPath = 0; 
+    dtStatus dtResult = m_navMeshQuery->findStraightPath(startPos, endPos, path, pathSize, steerPath, steerPathFlags, steerPathPolys, (int*)&nsteerPath, MAX_STEER_POINTS); 
+    if (!nsteerPath || DT_SUCCESS != dtResult)
+        return false;
+
+    // Find vertex far enough to steer to.
+    uint32 ns = 0;
+    while (ns < nsteerPath)
+    {
+        // Stop at Off-Mesh link or when point is further than slop away.
+        if ((steerPathFlags[ns] & DT_STRAIGHTPATH_OFFMESH_CONNECTION) || !inRangeYZX(&steerPath[ns*VERTEX_SIZE], startPos, minTargetDist, 1000.0f))
+            break;
+        ns++;
+    }
+    // Failed to find good point to steer to.
+    if (ns >= nsteerPath)
+        return false;
+
+    dtVcopy(steerPos, &steerPath[ns*VERTEX_SIZE]);
+    steerPos[1] = startPos[1];
+    steerPosFlag = steerPathFlags[ns];
+    steerPosRef = steerPathPolys[ns];
+
+    return true;
+}
+
+dtStatus PathInfo::findSmoothPath(const float* startPos, const float* endPos, const dtPolyRef* polyPath, const uint32 polyPathSize, float* smoothPath, int* straightPathCount, const uint32 maxSmoothPathSize) 
+{
+    ASSERT(polyPathSize <= MAX_PATH_LENGTH);
+    *straightPathCount = 0;
+    uint32 nsmoothPath = 0;
+
+    dtPolyRef polys[MAX_PATH_LENGTH];
+    memcpy(polys, polyPath, sizeof(dtPolyRef)*polyPathSize);
+    uint32 npolys = polyPathSize;
+
+    float iterPos[VERTEX_SIZE], targetPos[VERTEX_SIZE];
+    if (DT_SUCCESS != m_navMeshQuery->closestPointOnPolyBoundary(polys[0], startPos, iterPos))
+        return DT_FAILURE;
+
+    if (DT_SUCCESS != m_navMeshQuery->closestPointOnPolyBoundary(polys[npolys-1], endPos, targetPos))
+        return DT_FAILURE;
+
+    dtVcopy(&smoothPath[nsmoothPath*VERTEX_SIZE], iterPos);
+    nsmoothPath++;
+
+    // Move towards target a small advancement at a time until target reached or
+    // when ran out of memory to store the path.
+    while (npolys && nsmoothPath < maxSmoothPathSize)
+    {
+        // Find location to steer towards.
+        float steerPos[VERTEX_SIZE];
+        unsigned char steerPosFlag;
+        dtPolyRef steerPosRef = INVALID_POLYREF;
+
+        if (!getSteerTarget(iterPos, targetPos, SMOOTH_PATH_SLOP, polys, npolys, steerPos, steerPosFlag, steerPosRef))
+            break;
+
+        bool endOfPath = (steerPosFlag & DT_STRAIGHTPATH_END);
+        bool offMeshConnection = (steerPosFlag & DT_STRAIGHTPATH_OFFMESH_CONNECTION);
+
+        // Find movement delta.
+        float delta[VERTEX_SIZE];
+        dtVsub(delta, steerPos, iterPos);
+        float len = dtSqrt(dtVdot(delta,delta));
+        // If the steer target is end of path or off-mesh link, do not move past the location.
+        if ((endOfPath || offMeshConnection) && len < SMOOTH_PATH_STEP_SIZE)
+            len = 1.0f;
+        else
+            len = SMOOTH_PATH_STEP_SIZE / len;
+
+        float moveTgt[VERTEX_SIZE];
+        dtVmad(moveTgt, iterPos, delta, len);
+
+        // Move
+        float result[VERTEX_SIZE];
+        const static uint32 MAX_VISIT_POLY = 16; 
+        dtPolyRef visited[MAX_VISIT_POLY]; 
+        dtQueryFilter filter = createFilter();
+
+        uint32 nvisited = 0;
+        m_navMeshQuery->moveAlongSurface(polys[0], iterPos, moveTgt, &filter, result, visited, (int*)&nvisited, MAX_VISIT_POLY);
+
+        npolys = fixupCorridor(polys, npolys, MAX_PATH_LENGTH, visited, nvisited);
+
+        m_navMeshQuery->getPolyHeight(polys[0], result, &result[1]);
+        dtVcopy(iterPos, result);
+
+        // Handle end of path and off-mesh links when close enough.
+        if (endOfPath && inRangeYZX(iterPos, steerPos, SMOOTH_PATH_SLOP, 2.0f))
+        {
+            // Reached end of path.
+            dtVcopy(iterPos, targetPos);
+            if (nsmoothPath < maxSmoothPathSize)
+            {
+                dtVcopy(&smoothPath[nsmoothPath*VERTEX_SIZE], iterPos);
+                nsmoothPath++;
+            }
+            break;
+        }
+        else if (offMeshConnection && inRangeYZX(iterPos, steerPos, SMOOTH_PATH_SLOP, 2.0f))
+        {
+            // Reached off-mesh connection.
+            float startPos[VERTEX_SIZE], endPos[VERTEX_SIZE];
+
+            // Advance the path up to and over the off-mesh connection.
+            dtPolyRef prevRef = INVALID_POLYREF;
+            dtPolyRef polyRef = polys[0];
+            uint32 npos = 0;
+            while (npos < npolys && polyRef != steerPosRef)
+            {
+                prevRef = polyRef;
+                polyRef = polys[npos];
+                npos++;
+            }
+
+            for (uint32 i = npos; i < npolys; ++i)
+                polys[i-npos] = polys[i];
+
+            npolys -= npos;
+
+            // Handle the connection.
+            if (DT_SUCCESS == m_navMesh->getOffMeshConnectionPolyEndPoints(prevRef, polyRef, startPos, endPos))
+            {
+                if (nsmoothPath < maxSmoothPathSize)
+                {
+                    dtVcopy(&smoothPath[nsmoothPath*VERTEX_SIZE], startPos);
+                    nsmoothPath++;
+                    // Hack to make the dotted path not visible during off-mesh connection.
+                    if (nsmoothPath & 1)
+                    {
+                        dtVcopy(&smoothPath[nsmoothPath*VERTEX_SIZE], startPos);
+                        nsmoothPath++;
+                    }
+                }
+                // Move position at the other side of the off-mesh link.
+                dtVcopy(iterPos, endPos);
+                m_navMeshQuery->getPolyHeight(polys[0], iterPos, &iterPos[1]);
+            }
+        }
+
+        // Store results.
+        if (nsmoothPath < maxSmoothPathSize)
+        {
+            dtVcopy(&smoothPath[nsmoothPath*VERTEX_SIZE], iterPos);
+            nsmoothPath++;
+        }
+    }
+
+    *straightPathCount = nsmoothPath;
+    return DT_SUCCESS;
+}
diff -r dc4fc5c8b306 src/server/collision/Pathfinding/PathInfo.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/collision/Pathfinding/PathInfo.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_PATHINFO_H
+#define TRINITY_PATHINFO_H
+
+#include "Path.h"
+#include "DetourNavMesh.h"
+#include "DetourNavMeshQuery.h"
+
+class Unit;
+
+// 128*6.0f=768y  number_of_points*interval = max_path_len
+// this is way more than actual evade range
+// I think we can safely cut those down even more
+#define MESH_MAX_NODES          1024
+#define MAX_PATH_LENGTH         128
+#define MAX_POINT_PATH_LENGTH   128
+
+#define SMOOTH_PATH_STEP_SIZE   6.0f
+#define SMOOTH_PATH_SLOP        0.4f
+
+#define VERTEX_SIZE       3
+
+#define INVALID_POLYREF   0
+
+// see src/tools/mmaps_generator/TerrainBuilder.h
+enum NavTerrain
+{
+    NAV_EMPTY   = 0x00,
+    NAV_GROUND  = 0x01,
+    NAV_MAGMA   = 0x02,
+    NAV_SLIME   = 0x04,
+    NAV_WATER   = 0x08,
+    NAV_UNUSED1 = 0x10,
+    NAV_UNUSED2 = 0x20, 
+    NAV_UNUSED3 = 0x40, 
+    NAV_UNUSED4 = 0x80 
+    // we only have 8 bits 
+};
+
+enum PathType
+{
+    PATHFIND_BLANK          = 0x0000,   // path not built yet
+    PATHFIND_NORMAL         = 0x0001,   // normal path
+    PATHFIND_SHORTCUT       = 0x0002,   // travel through obstacles, terrain, air, etc (old behavior)
+    PATHFIND_INCOMPLETE     = 0x0004,   // we have partial path to follow - getting closer to target
+    PATHFIND_NOPATH         = 0x0008,   // no valid path at all or error in generating one
+    PATHFIND_NOT_USING_PATH = 0x0010    // used when we are either flying/swiming or on map w/o mmaps
+};
+
+class PathInfo
+{
+    public:
+        PathInfo(Unit const* owner, const float destX, const float destY, const float destZ, bool useStraightPath = false);
+        ~PathInfo();
+
+        // return value : true if new path was calculated 
+        bool Update(const float destX, const float destY, const float destZ, bool useStraightPath = false);
+
+        inline void getStartPosition(float &x, float &y, float &z) { x = m_startPosition.x; y = m_startPosition.y; z = m_startPosition.z; }
+        inline void getNextPosition(float &x, float &y, float &z) { x = m_nextPosition.x; y = m_nextPosition.y; z = m_nextPosition.z; }
+        inline void getEndPosition(float &x, float &y, float &z) { x = m_endPosition.x; y = m_endPosition.y; z = m_endPosition.z; }
+        inline void getActualEndPosition(float &x, float &y, float &z) { x = m_actualEndPosition.x; y = m_actualEndPosition.y; z = m_actualEndPosition.z; }
+
+        inline PathNode getStartPosition() const { return m_startPosition; }
+        inline PathNode getNextPosition() const { return m_nextPosition; }
+        inline PathNode getEndPosition() const { return m_endPosition; }
+        inline PathNode getActualEndPosition() const { return m_actualEndPosition; }
+
+        inline PointPath& getFullPath() { return m_pathPoints; }
+        inline PathType getPathType() const {return m_type;}
+
+    private:
+
+        dtPolyRef   *   m_pathPolyRefs;     // array of detour polygon references
+        uint32          m_polyLength;       // number of polygons in the path
+
+        PointPath       m_pathPoints;       // our actual (x,y,z) path to the target
+        uint32          m_pointPathPointer; // points to current triple in m_pathPoints - used when dest do not change
+        // the triple is the one that is currently being moved toward
+        PathType        m_type;             // tells what kind of path this is
+
+        bool            m_useStraightPath;  // type of path will be generated
+
+        PathNode        m_startPosition;    // {x, y, z} of current location
+        PathNode        m_nextPosition;     // {x, y, z} of next location on the path
+        PathNode        m_endPosition;      // {x, y, z} of the destination
+        PathNode        m_actualEndPosition;  // {x, y, z} of the closest possible point to given destination
+
+        const Unit* const   m_sourceUnit;       // the unit that is moving 
+        const dtNavMesh*    m_navMesh;          // the nav mesh 
+        dtNavMeshQuery*     m_navMeshQuery;     // the nav mesh query used to find the path
+
+        inline void setNextPosition(PathNode point) { m_nextPosition = point; }
+        inline void setStartPosition(PathNode point) { m_startPosition = point; }
+        inline void setEndPosition(PathNode point) { m_actualEndPosition = point; m_endPosition = point; }
+        inline void setActualEndPosition(PathNode point) { m_actualEndPosition = point; }
+
+        inline void clear()
+        {
+            delete [] m_pathPolyRefs;
+            m_pathPolyRefs = NULL;
+            m_polyLength = 0;
+            m_pathPoints.clear();
+        }
+
+        dtPolyRef getPathPolyByPosition(dtPolyRef *polyPath, uint32 polyPathSize, PathNode p, float *distance = NULL);
+
+        void BuildPolyPath(PathNode startPos, PathNode endPos);
+        void BuildPointPath(float *startPoint, float *endPoint);
+        void BuildShortcut();
+
+        NavTerrain getNavTerrain(float x, float y, float z);
+        dtQueryFilter createFilter();
+
+        // smooth path functions
+        uint32 fixupCorridor(dtPolyRef* path, const uint32 npath, const uint32 maxPath, const dtPolyRef* visited, const uint32 nvisited);
+        bool getSteerTarget(const float* startPos, const float* endPos, const float minTargetDist, const dtPolyRef* path, const uint32 pathSize, float* steerPos, unsigned char& steerPosFlag, dtPolyRef& steerPosRef);
+        dtStatus findSmoothPath(const float* startPos, const float* endPos, const dtPolyRef* polyPath, const uint32 polyPathSize, float* smoothPath, int* straightPathCount, const uint32 smoothPathMaxSize);
+};
+
+inline bool inRangeYZX(const float* v1, const float* v2, const float r, const float h)
+{
+    const float dx = v2[0] - v1[0];
+    const float dy = v2[1] - v1[1]; // elevation
+    const float dz = v2[2] - v1[2];
+    return (dx*dx + dz*dz) < r*r && fabsf(dy) < h;
+}
+
+inline bool inRange(const PathNode p1, const PathNode p2,
+    const float r, const float h)
+{
+    const float dx = p2.x - p1.x;
+    const float dy = p2.y - p1.y;
+    const float dz = p2.z - p1.z;
+    return (dx*dx + dy*dy) < r*r && fabsf(dz) < h;
+}
+
+#endif
diff -r dc4fc5c8b306 src/server/collision/Pathfinding/TileReader.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/collision/Pathfinding/TileReader.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "TileReader.h"
+#include "Log.h"
+
+MmapTileReader::MmapTileReader(char* fileName)
+    : m_mmapTileFile(NULL), m_currentTile(0)
+{
+    m_mmapTileFile = fopen(fileName, "rb");
+
+    if (!m_mmapTileFile)
+        return;
+
+    uint32 length;
+
+    length = fread(&m_header, 1, sizeof(mmapTileHeader), m_mmapTileFile);
+    if (length != sizeof(mmapTileHeader))
+        memset(&m_header, 0, sizeof(mmapTileHeader));
+}
+
+MmapTileReader::~MmapTileReader()
+{
+    if (m_mmapTileFile)
+        fclose(m_mmapTileFile);
+}
+
+bool MmapTileReader::check()
+{
+    // TODO: log error/debug
+    if (!m_mmapTileFile)
+        return false;
+
+    if (m_header.mmapMagic != MMAP_MAGIC)
+        return false;
+
+    if (m_header.dtVersion != DT_NAVMESH_VERSION)
+        return false;
+
+    if (m_header.tileCount == 0)
+        return false;
+
+    return true;
+}
+
+bool MmapTileReader::read(unsigned char* &data, uint32 &dataLength)
+{
+    if (!m_mmapTileFile || m_header.tileCount <= m_currentTile++)
+        return false;
+
+    uint32 length;
+
+    length = fread(&dataLength, 1, sizeof(dataLength), m_mmapTileFile);
+    if (sizeof(dataLength) != length)
+        return false;
+
+    data = (unsigned char*)dtAlloc(dataLength, DT_ALLOC_PERM);
+    ASSERT(data);
+
+    length = fread(data, 1, dataLength, m_mmapTileFile);
+    if (length != dataLength)
+    {
+        dtFree(data);
+        return false;
+    }
+
+    return true;
+}
\ No newline at end of file
diff -r dc4fc5c8b306 src/server/collision/Pathfinding/TileReader.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/collision/Pathfinding/TileReader.h	Tue Nov 30 23:02:11 2010 -0500
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _TILEREADER_H
+#define _TILEREADER_H
+
+#include "DetourNavMesh.h"
+
+/*  mmap tile structure  */
+#define MMAP_MAGIC 0x4d4d4150   // 'MMAP'
+#define MMAP_VERSION 1
+
+struct mmapTileHeader
+{
+    uint32 mmapMagic;
+    uint32 dtVersion;
+    uint32 mmapVersion;
+    uint32 tileCount;
+    bool usesHiRes : 1;
+    bool usesLiquids : 1;
+};
+
+class MmapTileReader
+{
+public:
+    MmapTileReader(char* fileName);
+    ~MmapTileReader();
+
+    bool check();
+    bool read(unsigned char* &data, uint32 &dataLength);
+
+private:
+    FILE* m_mmapTileFile;
+    mmapTileHeader m_header;
+    uint32 m_currentTile;
+};
+
+#endif  // _TILEREADER_H
\ No newline at end of file
diff -r dc4fc5c8b306 src/server/game/AI/CoreAI/PetAI.cpp
--- a/src/server/game/AI/CoreAI/PetAI.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/AI/CoreAI/PetAI.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -211,7 +211,7 @@
             SpellCastTargets targets;
             targets.setUnitTarget(target);
 
-            if (!me->HasInArc(M_PI, target))
+            if (!me->HasInArc(M_PI, target->GetPositionX(), target->GetPositionY()))
             {
                 me->SetInFront(target);
                 if (target && target->GetTypeId() == TYPEID_PLAYER)
diff -r dc4fc5c8b306 src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/CMakeLists.txt	Tue Nov 30 23:02:11 2010 -0500
@@ -105,8 +105,11 @@
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Pathfinding
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
diff -r dc4fc5c8b306 src/server/game/Combat/ThreatManager.cpp
--- a/src/server/game/Combat/ThreatManager.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Combat/ThreatManager.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -246,7 +246,15 @@
 void ThreatContainer::modifyThreatPercent(Unit *pVictim, int32 iPercent)
 {
     if (HostileReference* ref = getReferenceByTarget(pVictim))
-        ref->addThreatPercent(iPercent);
+    {
+        if (iPercent < -100)
+        {
+            ref->removeReference();
+            delete ref;
+        }
+        else
+            ref->addThreatPercent(iPercent);
+    }
 }
 
 //============================================================
diff -r dc4fc5c8b306 src/server/game/Entities/Object/Object.cpp
--- a/src/server/game/Entities/Object/Object.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Object/Object.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -1520,6 +1520,30 @@
     return ((angle >= lborder) && (angle <= rborder));
 }
 
+bool WorldObject::HasInArc(const float arcangle, const float x, const float y) const
+{
+    // always have self in arc
+    if (x == m_positionX && y == m_positionY)
+        return true;
+
+    float arc = arcangle;
+
+    // move arc to range 0.. 2*pi
+    arc = MapManager::NormalizeOrientation(arc);
+
+    float angle = GetAngle(x, y);
+    angle -= m_orientation;
+
+    // move angle to range -pi ... +pi
+    angle = MapManager::NormalizeOrientation(angle);
+    if (angle > M_PI)
+        angle -= 2.0f*M_PI;
+
+    float lborder =  -1 * (arc/2.0f);                       // in range -pi..0
+    float rborder = (arc/2.0f);                             // in range 0..pi
+    return (( angle >= lborder ) && ( angle <= rborder ));
+}
+
 bool WorldObject::IsInBetween(const WorldObject *obj1, const WorldObject *obj2, float size) const
 {
     if (GetPositionX() > std::max(obj1->GetPositionX(), obj2->GetPositionX())
@@ -1537,12 +1561,12 @@
 
 bool WorldObject::isInFront(WorldObject const* target, float distance,  float arc) const
 {
-    return IsWithinDist(target, distance) && HasInArc(arc, target);
+    return IsWithinDist(target, distance) && HasInArc(arc, target->GetPositionX(), target->GetPositionY());
 }
 
 bool WorldObject::isInBack(WorldObject const* target, float distance, float arc) const
 {
-    return IsWithinDist(target, distance) && !HasInArc(2 * M_PI - arc, target);
+    return IsWithinDist(target, distance) && !HasInArc(2 * M_PI - arc, target->GetPositionX(), target->GetPositionY());
 }
 
 void WorldObject::GetRandomPoint(const Position &pos, float distance, float &rand_x, float &rand_y, float &rand_z) const
@@ -1807,7 +1831,7 @@
     if (distance < combatReach)
         return true;
 
-    if (!HasInArc(M_PI, obj))
+    if (!HasInArc(M_PI, obj->GetPositionX(), obj->GetPositionY()))
         return false;
 
     for (uint32 i = 0; i < TOTAL_STEALTH_TYPES; ++i)
diff -r dc4fc5c8b306 src/server/game/Entities/Object/Object.h
--- a/src/server/game/Entities/Object/Object.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Object/Object.h	Tue Nov 30 23:02:11 2010 -0500
@@ -672,6 +672,15 @@
             float d = GetExactDist2d(obj) - GetObjectSize() - obj->GetObjectSize();
             return d > 0.0f ? d : 0.0f;
         }
+        float GetDistanceSqr(float x, float y, float z) const
+        {
+            float dx = GetPositionX() - x;
+            float dy = GetPositionY() - y;
+            float dz = GetPositionZ() - z;
+            float sizefactor = GetObjectSize();
+            float dist = dx*dx+dy*dy+dz*dz-sizefactor;
+            return (dist > 0 ? dist : 0);
+        }
         float GetDistance2d(float x, float y) const
         {
             float d = GetExactDist2d(x, y) - GetObjectSize();
@@ -714,6 +723,7 @@
         bool isInBack(WorldObject const* target, float distance, float arc = M_PI) const;
 
         bool IsInBetween(const WorldObject *obj1, const WorldObject *obj2, float size = 0) const;
+        bool HasInArc( const float arcangle, const float x, const float y) const;
 
         virtual void CleanupsBeforeDelete(bool finalCleanup = true);  // used in destructor or explicitly before mass creature delete to remove cross-references to already deleted units
 
diff -r dc4fc5c8b306 src/server/game/Entities/Player/Player.cpp
--- a/src/server/game/Entities/Player/Player.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Player/Player.cpp	Tue Nov 30 23:02:11 2010 -0500
@@ -1348,7 +1348,7 @@
                     }
                 }
                 //120 degrees of radiant range
-                else if (!HasInArc(2*M_PI/3, pVictim))
+                else if (!HasInArc(2*M_PI/3, pVictim->GetPositionX(), pVictim->GetPositionY()))
                 {
                     setAttackTimer(BASE_ATTACK,100);
                     if (m_swingErrorMsg != 2)               // send single time (client auto repeat)
@@ -1376,7 +1376,7 @@
             {
                 if (!IsWithinMeleeRange(pVictim))
                     setAttackTimer(OFF_ATTACK,100);
-                else if (!HasInArc(2*M_PI/3, pVictim))
+                else if (!HasInArc(2*M_PI/3, pVictim->GetPositionX(), pVictim->GetPositionY()))
                     setAttackTimer(OFF_ATTACK,100);
                 else
                 {
diff -r dc4fc5c8b306 src/server/game/Entities/Unit/Unit.cpp
--- a/src/server/game/Entities/Unit/Unit.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Unit/Unit.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -53,6 +53,7 @@
 #include "TemporarySummon.h"
 #include "Vehicle.h"
 #include "Transport.h"
+#include "PathInfo.h"
 
 #include <math.h>
 
@@ -1360,7 +1361,7 @@
 
     // If this is a creature and it attacks from behind it has a probability to daze it's victim
     if ((damageInfo->hitOutCome == MELEE_HIT_CRIT || damageInfo->hitOutCome == MELEE_HIT_CRUSHING || damageInfo->hitOutCome == MELEE_HIT_NORMAL || damageInfo->hitOutCome == MELEE_HIT_GLANCING) &&
-        GetTypeId() != TYPEID_PLAYER && !this->ToCreature()->IsControlledByPlayer() && !pVictim->HasInArc(M_PI, this)
+        GetTypeId() != TYPEID_PLAYER && !this->ToCreature()->IsControlledByPlayer() && !pVictim->HasInArc(M_PI, this->GetPositionX(), this->GetPositionY())
         && (pVictim->GetTypeId() == TYPEID_PLAYER || !pVictim->ToCreature()->isWorldBoss()))
     {
         // -probability is between 0% and 40%
@@ -2300,7 +2301,7 @@
     // Dodge chance
 
     // only players can't dodge if attacker is behind
-    if (pVictim->GetTypeId() == TYPEID_PLAYER && !pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && !pVictim->HasInArc(M_PI,this->GetPositionX(), this->GetPositionY()) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
     {
         sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
     }
@@ -2329,7 +2330,7 @@
     // parry & block chances
 
     // check if attack comes from behind, nobody can parry or block if attacker is behind
-    if (!pVictim->HasInArc(M_PI, this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    if (!pVictim->HasInArc(M_PI, this->GetPositionX(), this->GetPositionY()) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
         sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind.");
     else
     {
@@ -2505,7 +2506,7 @@
 
 bool Unit::isSpellBlocked(Unit *pVictim, SpellEntry const * /*spellProto*/, WeaponAttackType attackType)
 {
-    if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    if (pVictim->HasInArc(M_PI,this->GetPositionX(), this->GetPositionY()) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
     {
         // Check creatures flags_extra for disable block
         if (pVictim->GetTypeId() == TYPEID_UNIT &&
@@ -2612,7 +2613,7 @@
     if (attType == RANGED_ATTACK)
     {
         // only if in front
-        if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        if (pVictim->HasInArc(M_PI,this->GetPositionX(), this->GetPositionY()) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
         {
             int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
             tmp+=deflect_chance;
@@ -2623,7 +2624,7 @@
     }
 
     // Check for attack from behind
-    if (!pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    if (!pVictim->HasInArc(M_PI,this->GetPositionX(), this->GetPositionY()) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
     {
         // Can`t dodge from behind in PvP (but its possible in PvE)
         if (pVictim->GetTypeId() == TYPEID_PLAYER)
@@ -2788,7 +2789,7 @@
         return SPELL_MISS_RESIST;
 
     // cast by caster in front of victim
-    if (pVictim->HasInArc(M_PI, this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    if (pVictim->HasInArc(M_PI, this->GetPositionX(), this->GetPositionY()) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
     {
         int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
         tmp += deflect_chance;
@@ -3329,12 +3330,12 @@
 
 bool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const
 {
-    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);
+    return IsWithinDistInMap(target, distance) && HasInArc(arc, target->GetPositionX(), target->GetPositionY());
 }
 
 bool Unit::isInBackInMap(Unit const* target, float distance, float arc) const
 {
-    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);
+    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target->GetPositionX(), target->GetPositionY());
 }
 
 void Unit::SetFacingToObject(WorldObject* pObject)
@@ -5941,7 +5942,7 @@
             if (dummySpell->SpellFamilyFlags[1] & 0x8)
             {
                 // check attack comes not from behind
-                if (!HasInArc(M_PI, pVictim))
+                if (!HasInArc(M_PI, pVictim->GetPositionX(), pVictim->GetPositionY()))
                     return false;
 
                 triggered_spell_id = 22858;
@@ -11878,6 +11879,31 @@
         SetInCombatWith(target);
         target->SetInCombatWith(this);
     }
+            
+    // check if currently selected target is reachable
+    // NOTE: path alrteady generated from AttackStart()
+    if(!GetMotionMaster()->isReachable())
+    {
+        // remove all taunts
+        RemoveAurasByType(SPELL_AURA_MOD_TAUNT); 
+
+        if(m_ThreatManager.getThreatList().size() < 2)
+        {
+            // only one target in list, we have to evade after timer
+            // TODO: make timer - inside Creature class
+            ((Creature*)this)->AI()->EnterEvadeMode();
+        }
+        else
+        {
+            // remove unreachable target from our threat list
+            // next iteration we will select next possible target
+            m_HostileRefManager.deleteReference(target);
+            m_ThreatManager.modifyThreatPercent(target, -101);
+                    
+            _removeAttacker(target);
+        }
+    }
+
     Unit *who = target->GetCharmerOrOwnerOrSelf();
     if (who->GetTypeId() == TYPEID_PLAYER)
       SetContestedPvP(who->ToPlayer());
@@ -16932,6 +16958,113 @@
     return amount;
 }
 
+void Unit::MonsterMoveByPath(float x, float y, float z, uint32 speed, bool smoothPath)
+{
+    PathInfo path(this, x, y, z, !smoothPath);
+
+    if (path.getPathType() & PATHFIND_NOPATH)
+        return;
+
+    PointPath pointPath = path.getFullPath();
+    uint32 size = pointPath.size();
+    // tiny hack for underwater charge cases
+    pointPath[size-1].x = x;
+    pointPath[size-1].y = y;
+    pointPath[size-1].z = z;
+
+    uint32 traveltime = uint32(pointPath.GetTotalLength() / float(speed));
+    MonsterMoveByPath(pointPath, 1, pointPath.size(), traveltime);
+}
+
+template<typename PathElem, typename PathNode>
+void Unit::MonsterMoveByPath(Path<PathElem,PathNode> const& path, uint32 start, uint32 end, uint32 transitTime)
+{
+    SendMonsterMoveByPath(path, start, end, transitTime);
+
+    if (GetTypeId() != TYPEID_PLAYER)
+   {
+        Creature* c = (Creature*)this;
+        // Creature relocation acts like instant movement generator, so current generator expects interrupt/reset calls to react properly
+        if (!c->GetMotionMaster()->empty())
+            if (MovementGenerator *movgen = c->GetMotionMaster()->top())
+                return;
+
+        GetMap()->CreatureRelocation((Creature*)this, path[end-1].x, path[end-1].y, path[end-1].z, 0.0f);
+
+        // finished relocation, movegen can different from top before creature relocation,
+        // but apply Reset expected to be safe in any case
+        if (!c->GetMotionMaster()->empty())
+            if (MovementGenerator *movgen = c->GetMotionMaster()->top())
+                return;
+    }
+}
+
+template void Unit::MonsterMoveByPath<PathNode>(const Path<PathNode> &, uint32, uint32, uint32);
+
+template<typename Elem, typename Node>
+void Unit::SendMonsterMoveByPath(Path<Elem,Node> const& path, uint32 start, uint32 end, uint32 traveltime)
+{
+    uint32 pathSize = end - start;
+
+    if (pathSize < 1)
+    {
+        SendMonsterMove(GetPositionX(), GetPositionY(), GetPositionZ(), 0);
+        return;
+    }
+
+    if (pathSize == 1)
+    {
+        SendMonsterMove(path[start].x, path[start].y, path[start].z, traveltime);
+        return;
+    }
+
+    uint32 packSize = (GetUnitMovementFlags() & SplineFlags(SPLINEFLAG_FLYING | SPLINEFLAG_CATMULL_ROM)) ? pathSize*4*3 : 4*3 + (pathSize-1)*4;
+    WorldPacket data( SMSG_MONSTER_MOVE, (GetPackGUID().size()+1+4+4+4+4+1+4+4+4+packSize) );
+    data.append(GetPackGUID());
+    data << uint8(0);
+    data << GetPositionX();
+    data << GetPositionY();
+    data << GetPositionZ();
+    data << uint32(getMSTime());
+    data << uint8(0);
+    data << uint32(((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) || isInFlight()) ? (SPLINEFLAG_FLYING|SPLINEFLAG_WALKING) : SPLINEFLAG_WALKING);
+    data << uint32(traveltime);
+    data << uint32(pathSize);
+
+    if (GetUnitMovementFlags() & SplineFlags(SPLINEFLAG_FLYING | SPLINEFLAG_CATMULL_ROM))
+    {
+        // sending a taxi flight path
+        for(uint32 i = start; i < end; ++i)
+        {
+            data << float(path[i].x);
+            data << float(path[i].y);
+            data << float(path[i].z);
+        }
+    }
+    else
+    {
+        // sending a series of points
+
+        // destination
+        data << path[end-1].x;
+        data << path[end-1].y;
+        data << path[end-1].z;
+
+        // all other points are relative to the center of the path
+        float mid_X = (GetPositionX() + path[end-1].x) * 0.5f;
+        float mid_Y = (GetPositionY() + path[end-1].y) * 0.5f;
+        float mid_Z = (GetPositionZ() + path[end-1].z) * 0.5f;
+
+        for (uint32 i = start; i < end - 1; ++i)
+            data.appendPackXYZ(mid_X - path[i].x, mid_Y - path[i].y, mid_Z - path[i].z);
+    }
+
+    SendMessageToSet(&data, true);
+}
+
+template void Unit::SendMonsterMoveByPath<PathNode>(const Path<PathNode> &, uint32, uint32, uint32);
+template void Unit::SendMonsterMoveByPath<TaxiPathNodePtr, const TaxiPathNodeEntry>(const Path<TaxiPathNodePtr, const TaxiPathNodeEntry> &, uint32, uint32, uint32);
+
 void CharmInfo::SetIsCommandAttack(bool val)
 {
     m_isCommandAttack = val;
diff -r dc4fc5c8b306 src/server/game/Entities/Unit/Unit.h
--- a/src/server/game/Entities/Unit/Unit.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Entities/Unit/Unit.h	Tue Nov 30 23:02:12 2010 -0500
@@ -1461,8 +1461,11 @@
         void SendMonsterMoveWithSpeedToCurrentDestination(Player* player = NULL);
         void SendMovementFlagUpdate();
 
+        void MonsterMoveByPath(float x, float y, float z, uint32 speed, bool smoothPath = true);
         template<typename PathElem, typename PathNode>
-        void SendMonsterMoveByPath(Path<PathElem,PathNode> const& path, uint32 start, uint32 end);
+        void MonsterMoveByPath(Path<PathElem,PathNode> const& path, uint32 start, uint32 end, uint32 transitTime = 0);
+        template<typename PathElem, typename PathNode>
+        void SendMonsterMoveByPath(Path<PathElem,PathNode> const& path, uint32 start, uint32 end, uint32 traveltime);
 
         void SendChangeCurrentVictimOpcode(HostileReference* pHostileReference);
         void SendClearThreatListOpcode();
@@ -2149,30 +2152,4 @@
     };
 }
 
-template<typename Elem, typename Node>
-inline void Unit::SendMonsterMoveByPath(Path<Elem,Node> const& path, uint32 start, uint32 end)
-{
-    uint32 traveltime = uint32(path.GetTotalLength(start, end) * 32);
-    uint32 pathSize = end - start;
-    WorldPacket data(SMSG_MONSTER_MOVE, (GetPackGUID().size()+1+4+4+4+4+1+4+4+4+pathSize*4*3));
-    data.append(GetPackGUID());
-    data << uint8(0);
-    data << GetPositionX();
-    data << GetPositionY();
-    data << GetPositionZ();
-    data << uint32(getMSTime());
-    data << uint8(0);
-    data << uint32(((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) || isInFlight()) ? (SPLINEFLAG_FLYING|SPLINEFLAG_WALKING) : SPLINEFLAG_WALKING);
-    data << uint32(traveltime);
-    data << uint32(pathSize);
-
-    for (uint32 i = start; i < end; ++i)
-    {
-        data << float(path[i].x);
-        data << float(path[i].y);
-        data << float(path[i].z);
-    }
-
-    SendMessageToSet(&data, true);
-}
 #endif
diff -r dc4fc5c8b306 src/server/game/Maps/Map.cpp
--- a/src/server/game/Maps/Map.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Maps/Map.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -30,12 +30,20 @@
 #include "MapManager.h"
 #include "ObjectMgr.h"
 #include "Group.h"
+#include "DetourNavMesh.h"
+#include "DetourNavMeshQuery.h"
+#include "PathInfo.h"
+#include "TileReader.h"
 
 #define DEFAULT_GRID_EXPIRY     300
 #define MAX_GRID_LOAD_TIME      50
 #define MAX_CREATURE_ATTACK_RADIUS  (45.0f * sWorld.getRate(RATE_CREATURE_AGGRO))
 
 GridState* si_GridStates[MAX_GRID_STATE];
+uint32 packTileID(int x, int y)
+{
+    return uint32(x << 16 | y);
+}
 
 Map::~Map()
 {
@@ -54,6 +62,12 @@
 
     if (!m_scriptSchedule.empty())
         sWorld.DecreaseScheduledScriptCount(m_scriptSchedule.size());
+
+    if (m_navMesh)
+    {
+        dtFreeNavMesh(m_navMesh);
+        m_navMesh = NULL;
+    }
 }
 
 bool Map::ExistMap(uint32 mapid,int gx,int gy)
@@ -170,7 +184,10 @@
 {
     LoadMap(gx,gy);
     if (i_InstanceId == 0)
+    {
         LoadVMap(gx, gy);                                   // Only load the data for the base map
+        LoadNavMesh(gx,gy);
+    }
 }
 
 void Map::InitStateMachine()
@@ -192,7 +209,7 @@
 Map::Map(uint32 id, time_t expiry, uint32 InstanceId, uint8 SpawnMode, Map* _parent):
 i_mapEntry (sMapStore.LookupEntry(id)), i_spawnMode(SpawnMode), i_InstanceId(InstanceId),
 m_unloadTimer(0), m_VisibleDistance(DEFAULT_VISIBILITY_DISTANCE),
-m_VisibilityNotifyPeriod(DEFAULT_VISIBILITY_NOTIFY_PERIOD),
+m_VisibilityNotifyPeriod(DEFAULT_VISIBILITY_NOTIFY_PERIOD), m_navMesh(NULL)/*, m_navMeshQuery(NULL)*/,
 m_activeNonPlayersIter(m_activeNonPlayers.end()), i_gridExpiry(expiry), i_scriptLock(false)
 {
     m_parentMap = (_parent ? _parent : this);
@@ -968,6 +985,7 @@
             }
             // x and y are swapped
             VMAP::VMapFactory::createOrGetVMapManager()->unloadMap(GetId(), gx, gy);
+            UnloadNavMesh(gx, gy);
         }
         else
             ((MapInstanced*)m_parentMap)->RemoveGridMapReference(GridPair(gx, gy));
@@ -2642,3 +2660,212 @@
     if (m_mapRefIter == player->GetMapRef())
         m_mapRefIter = m_mapRefIter->nocheck_prev();
 }
+
+void Map::LoadNavMesh(int gx, int gy)
+{
+    if (!m_navMesh)
+    {
+        uint32 pathLen = sWorld.GetDataPath().length() + strlen("mmaps/%03i.mmap")+1;
+        char *fileName = new char[pathLen];
+        snprintf(fileName, pathLen, (sWorld.GetDataPath()+"mmaps/%03i.mmap").c_str(), GetId());
+
+        FILE* file = fopen(fileName, "rb");
+        if (!file)
+        {
+            sLog.outDebug("Could not open mmap file '%s'", fileName);
+            delete [] fileName;
+            return;
+        }
+
+        dtNavMeshParams params;
+        fread(&params, sizeof(dtNavMeshParams), 1, file);
+        fclose(file);
+        delete [] fileName;
+
+        m_navMesh = dtAllocNavMesh();
+        if (!m_navMesh->init(&params))
+        {
+            dtFreeNavMesh(m_navMesh);
+            m_navMesh = NULL;
+            sLog.outError("Failed to initialize mmap %03u from file %s", GetId(), fileName);
+            return;
+        }
+    }
+
+    // check if we already have this tile loaded
+    uint32 packedGridPos = packTileID(gx, gy);
+    if (m_mmapLoadedTiles.find(packedGridPos) != m_mmapLoadedTiles.end())
+        sLog.outError("Asked to load already loaded navmesh tile. %03u%02i%02i.mmtile", GetId(), gx, gy);
+
+    // mmaps/0000000.mmtile
+    uint32 pathLen = sWorld.GetDataPath().length() + strlen("mmaps/%03i%02i%02i.mmtile")+1;
+    char *fileName = new char[pathLen];
+    snprintf(fileName, pathLen, (sWorld.GetDataPath()+"mmaps/%03i%02i%02i.mmtile").c_str(), GetId(), gx, gy);
+
+    MmapTileReader reader(fileName);
+
+    if (reader.check())
+    {
+        std::list<dtTileRef>* newTiles = new std::list<dtTileRef>;
+        m_mmapLoadedTiles.insert(std::pair<uint32, std::list<dtTileRef>*>(packedGridPos, newTiles));
+
+        unsigned char* data = NULL;
+        uint32 length = 0;
+
+        while (reader.read(data, length))
+        {
+            dtMeshHeader* header = (dtMeshHeader*)data;
+            dtTileRef tileRef = 0;
+
+            // memory allocated for data is now managed by detour, and will be deallocated when the tile is removed
+            dtStatus dtResult = m_navMesh->addTile(data, length, DT_TILE_FREE_DATA, 0, &tileRef);
+            switch(dtResult)
+            {
+                case DT_SUCCESS:
+                {
+                    newTiles->push_back(tileRef);
+                    sLog.outDetail("Loaded mmtile %03i[%02i,%02i] into %03i[%02i,%02i]", GetId(), gx, gy, GetId(), header->x, header->y);
+                }
+                break;
+                case DT_FAILURE_DATA_MAGIC:
+                {
+                    sLog.outError("%03u%02i%02i.mmtile has an invalid tile header", GetId(), gx, gy);
+                    dtFree(data);
+                }
+                break;
+                case DT_FAILURE_DATA_VERSION:
+                {
+                    sLog.outError("%03u%02i%02i.mmtile was built with Detour v%i, expected v%i",GetId(), gx, gy, header->version, DT_NAVMESH_VERSION);
+                    dtFree(data);
+                }
+                break;
+                case DT_FAILURE_OUT_OF_MEMORY:
+                case DT_FAILURE:
+                default:
+                {
+                    sLog.outError("Could not load %03u%02i%02i.mmtile into navmesh", GetId(), gx, gy);
+                    dtFree(data);
+                }
+                break;
+            }
+        }
+    }
+
+    delete [] fileName;
+}
+
+void Map::UnloadNavMesh(int gx, int gy)
+{
+    // navMesh was not loaded for this map
+    if (!m_navMesh)
+        return;
+
+    uint32 packedGridPos = packTileID(gx, gy);
+    if (m_mmapLoadedTiles.find(packedGridPos) == m_mmapLoadedTiles.end())
+    {
+        sLog.outDebug("Asked to unload not loaded navmesh tile. %03u%02i%02i.mmtile", GetId(), gx, gy);
+        return;
+    }
+
+    std::list<dtTileRef>* tiles = m_mmapLoadedTiles[packedGridPos];
+    std::list<dtTileRef> removedTiles;
+    bool success = true;
+
+    for (std::list<dtTileRef>::iterator it = tiles->begin(); it != tiles->end(); ++it)
+    {
+        // unload, and mark as non loaded
+        if(DT_SUCCESS != m_navMesh->removeTile(*it, NULL, NULL))
+            success = false;
+        else
+            removedTiles.push_back(*it);
+    }
+
+    if (success)
+    {
+        sLog.outDetail("Unloaded mmtile %03i[%02i,%02i] from %03i", GetId(), gx, gy, GetId());
+        delete tiles;
+        m_mmapLoadedTiles.erase(packedGridPos);
+    }
+    else
+    {
+        for (std::list<dtTileRef>::iterator it = removedTiles.begin(); it != removedTiles.end(); ++it)
+            tiles->remove(*it);
+
+        // because the Terrain unloads the grid, this is technically a memory leak
+        // if the grid is later loaded, dtNavMesh::addTile will return errors for the dtTileRefs we were unable to unload
+        sLog.outError("Could not unload tile from navmesh (%03u%02i%02i.mmtile)", GetId(), gx, gy);
+    }
+}
+
+std::set<uint32> Map::s_mmapDisabledIds = std::set<uint32>();
+
+void Map::preventPathfindingOnMaps(std::string ignoreMapIds)
+{
+    s_mmapDisabledIds.clear();
+
+    char* mapList = new char[ignoreMapIds.length()+1];
+    strcpy(mapList, ignoreMapIds.c_str());
+
+    char* idstr = strtok(mapList, ",");
+
+    while (idstr)
+    {
+        s_mmapDisabledIds.insert(uint32(atoi(idstr)));
+        idstr = strtok(NULL, ",");
+    }
+
+    delete[] mapList;
+}
+
+Position Map::MoveToNextPositionOnPathLocation(const float startx, const float starty, const float startz, const float endx, const float endy, const float endz)
+{
+    //convert to nav coords.
+    float startPos[3]               = { starty, startz, startx };
+    float endPos[3]                 = { endy, endz, endx };
+    float mPolyPickingExtents[3]    = { 2.00f, 4.00f, 2.00f };
+    dtQueryFilter* mPathFilter = new dtQueryFilter();
+    int gx = 32 - (startx/533.333333f);
+    int gy = 32 - (starty/533.333333f);
+    Position pos = Position();
+    pos.m_positionX = endx;
+    pos.m_positionY = endy;
+    pos.m_positionZ = endz;
+    dtNavMesh* NavMesh = m_navMesh;
+    dtNavMeshQuery* m_navMeshQuery = dtAllocNavMeshQuery();
+    if (NavMesh)
+    {
+        //dtStatus mStartRef =  m_navMeshQuery->findNearestPoly(startPos,mPolyPickingExtents,mPathFilter,0,0); 
+        //dtStatus mEndRef   = m_navMeshQuery->findNearestPoly(endPos,mPolyPickingExtents,mPathFilter,0,0);
+        //if (mStartRef != 0 && mEndRef != 0)
+        //{
+        //    dtPolyRef mPathResults[50];
+
+        //    int mNumPathResults = DT_SUCCESS == m_navMeshQuery->findPath(mStartRef, mEndRef,startPos, endPos, mPathFilter ,mPathResults,50,50);//TODO: CHANGE ME
+        //    if (mNumPathResults <= 0)
+        //    {
+        //        return pos;
+        //    }
+        //    float actualpath[3*20];
+        //    unsigned char* flags = 0;
+        //    dtPolyRef* polyrefs = 0;
+        //    int mNumPathPoints = DT_SUCCESS == m_navMeshQuery->findStraightPath(startPos, endPos,mPathResults, mNumPathResults, actualpath, flags, polyrefs,20,20);
+        //    if (mNumPathPoints < 3)
+        //        return pos;
+        //    pos.m_positionX = actualpath[5]; //0 3 6
+        //    pos.m_positionY = actualpath[3]; //1 4 7
+        //    pos.m_positionZ = actualpath[4]; //2 5 8
+        //    return pos;
+        //}
+    }
+    return pos;
+}
+
+bool Map::IsPathfindingEnabled() const
+{ 
+    return sWorld.getBoolConfig(CONFIG_PATHFINDING_ENABLED) && s_mmapDisabledIds.find(GetId()) == s_mmapDisabledIds.end();
+}
+
+dtNavMesh const* Map::GetNavMesh() const
+{
+    return m_navMesh;
+}
diff -r dc4fc5c8b306 src/server/game/Maps/Map.h
--- a/src/server/game/Maps/Map.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Maps/Map.h	Tue Nov 30 23:02:12 2010 -0500
@@ -20,6 +20,9 @@
 #define TRINITY_MAP_H
 
 #include "Define.h"
+#include "DetourNavMesh.h"
+#include "DetourAlloc.h"
+
 #include <ace/RW_Thread_Mutex.h>
 #include <ace/Thread_Mutex.h>
 
@@ -33,6 +36,7 @@
 
 #include <bitset>
 #include <list>
+#include <set>
 
 class Unit;
 class WorldPacket;
@@ -64,7 +68,7 @@
 // Map file format defines
 //******************************************
 #define MAP_MAGIC             'SPAM'
-#define MAP_VERSION_MAGIC     '1.1v'
+#define MAP_VERSION_MAGIC     '1.2v'
 #define MAP_AREA_MAGIC        'AERA'
 #define MAP_HEIGHT_MAGIC      'TGHM'
 #define MAP_LIQUID_MAGIC      'QILM'
@@ -80,6 +84,8 @@
     uint32 heightMapSize;
     uint32 liquidMapOffset;
     uint32 liquidMapSize;
+    uint32 holesOffset;
+    uint32 holesSize;
 };
 
 #define MAP_AREA_NO_AREA      0x0001
@@ -307,7 +313,6 @@
 
         time_t GetGridExpiry(void) const { return i_gridExpiry; }
         uint32 GetId(void) const { return i_mapEntry->MapID; }
-
         static bool ExistMap(uint32 mapid, int gx, int gy);
         static bool ExistVMap(uint32 mapid, int gx, int gy);
 
@@ -331,6 +336,7 @@
         float GetWaterLevel(float x, float y) const;
         bool IsInWater(float x, float y, float z, LiquidData *data = 0) const;
         bool IsUnderWater(float x, float y, float z) const;
+        Position MoveToNextPositionOnPathLocation(const float startx, const float starty, const float startz, const float endx, const float endy, const float endz);
 
         static uint32 GetAreaIdByAreaFlag(uint16 areaflag,uint32 map_id);
         static uint32 GetZoneIdByAreaFlag(uint16 areaflag,uint32 map_id);
@@ -567,6 +573,17 @@
             else
                 m_activeNonPlayers.erase(obj);
         }
+    public:
+        dtNavMesh const* GetNavMesh() const;
+        static void preventPathfindingOnMaps(std::string ignoreMapIds); 
+        bool IsPathfindingEnabled() const; 
+
+    private:
+        void LoadNavMesh(int gx, int gy);
+        void UnloadNavMesh(int gx, int gy);
+        dtNavMesh* m_navMesh;
+        UNORDERED_MAP<uint32, std::list<dtTileRef>*> m_mmapLoadedTiles;    // maps [map grid coords] to [dtTile]
+        static std::set<uint32> s_mmapDisabledIds;      // stores list of mapids which do not use pathfinding
 };
 
 enum InstanceResetMethod
diff -r dc4fc5c8b306 src/server/game/Movement/MotionMaster.cpp
--- a/src/server/game/Movement/MotionMaster.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MotionMaster.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -283,16 +283,18 @@
 void
 MotionMaster::MovePoint(uint32 id, float x, float y, float z)
 {
+    bool usePathfinding = true;
+
     if (i_owner->GetTypeId() == TYPEID_PLAYER)
     {
         sLog.outStaticDebug("Player (GUID: %u) targeted point (Id: %u X: %f Y: %f Z: %f)", i_owner->GetGUIDLow(), id, x, y, z);
-        Mutate(new PointMovementGenerator<Player>(id,x,y,z), MOTION_SLOT_ACTIVE);
+        Mutate(new PointMovementGenerator<Player>(id,x,y,z, usePathfinding), MOTION_SLOT_ACTIVE);
     }
     else
     {
         sLog.outStaticDebug("Creature (Entry: %u GUID: %u) targeted point (ID: %u X: %f Y: %f Z: %f)",
             i_owner->GetEntry(), i_owner->GetGUIDLow(), id, x, y, z);
-        Mutate(new PointMovementGenerator<Creature>(id,x,y,z), MOTION_SLOT_ACTIVE);
+        Mutate(new PointMovementGenerator<Creature>(id,x,y,z, usePathfinding), MOTION_SLOT_ACTIVE);
     }
 }
 
@@ -324,6 +326,7 @@
 {
     uint32 moveFlag = SPLINEFLAG_TRAJECTORY | SPLINEFLAG_WALKING;
     uint32 time = uint32(speedZ * 100);
+    bool usePathfinding = true;
 
     // Instantly interrupt non melee spells being casted
     if (i_owner->IsNonMeleeSpellCasted(true))
@@ -334,13 +337,13 @@
     if (i_owner->GetTypeId() == TYPEID_PLAYER)
     {
         sLog.outStaticDebug("Player (GUID: %u) jump to point (X: %f Y: %f Z: %f)", i_owner->GetGUIDLow(), x, y, z);
-        Mutate(new PointMovementGenerator<Player>(0,x,y,z), MOTION_SLOT_CONTROLLED);
+        Mutate(new PointMovementGenerator<Player>(0,x,y,z, usePathfinding), MOTION_SLOT_CONTROLLED);
     }
     else
     {
         sLog.outStaticDebug("Creature (Entry: %u GUID: %u) jump to point (X: %f Y: %f Z: %f)",
             i_owner->GetEntry(), i_owner->GetGUIDLow(), x, y, z);
-        Mutate(new PointMovementGenerator<Creature>(0,x,y,z), MOTION_SLOT_CONTROLLED);
+        Mutate(new PointMovementGenerator<Creature>(0,x,y,z, usePathfinding), MOTION_SLOT_CONTROLLED);
     }
 
     i_owner->SendMonsterMove(x, y, z, moveFlag, time, speedZ);
@@ -349,6 +352,8 @@
 void
 MotionMaster::MoveCharge(float x, float y, float z, float speed, uint32 id)
 {
+    bool usePathfinding = true;
+
     if (Impl[MOTION_SLOT_CONTROLLED] && Impl[MOTION_SLOT_CONTROLLED]->GetMovementGeneratorType() != DISTRACT_MOTION_TYPE)
         return;
 
@@ -357,13 +362,13 @@
     if (i_owner->GetTypeId() == TYPEID_PLAYER)
     {
         sLog.outStaticDebug("Player (GUID: %u) charge point (X: %f Y: %f Z: %f)", i_owner->GetGUIDLow(), x, y, z);
-        Mutate(new PointMovementGenerator<Player>(id,x,y,z), MOTION_SLOT_CONTROLLED);
+        Mutate(new PointMovementGenerator<Player>(id,x,y,z, usePathfinding), MOTION_SLOT_CONTROLLED);
     }
     else
     {
         sLog.outStaticDebug("Creature (Entry: %u GUID: %u) charge point (X: %f Y: %f Z: %f)",
             i_owner->GetEntry(), i_owner->GetGUIDLow(), x, y, z);
-        Mutate(new PointMovementGenerator<Creature>(id,x,y,z), MOTION_SLOT_CONTROLLED);
+        Mutate(new PointMovementGenerator<Creature>(id,x,y,z, usePathfinding), MOTION_SLOT_CONTROLLED);
     }
 }
 
diff -r dc4fc5c8b306 src/server/game/Movement/MotionMaster.h
--- a/src/server/game/Movement/MotionMaster.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MotionMaster.h	Tue Nov 30 23:02:12 2010 -0500
@@ -24,8 +24,8 @@
 #include "SharedDefines.h"
 #include "Object.h"
 
+class Unit;
 class MovementGenerator;
-class Unit;
 
 // Creature Entry ID used for waypoints show, visible only for GMs
 #define VISUAL_WAYPOINT 1
@@ -86,7 +86,6 @@
         typedef std::vector<_Ty> ExpireList;
         int i_top;
 
-        bool empty() const { return (i_top < 0); }
         void pop() { Impl[i_top] = NULL; --i_top; }
         void push(_Ty _Val) { ++i_top; Impl[i_top] = _Val; }
 
@@ -94,6 +93,7 @@
         void InitTop();
     public:
 
+        bool empty() const { return (i_top < 0); }
         explicit MotionMaster(Unit *unit) : i_top(-1), i_owner(unit), m_expList(NULL), m_cleanFlag(MMCF_NONE)
         {
             for (uint8 i = 0; i < MAX_MOTION_SLOT; ++i)
@@ -164,6 +164,9 @@
         void MovePath(uint32 path_id, bool repeatable);
         void MoveRotate(uint32 time, RotateDirection direction);
 
+        // given destination unreachable? due to pathfinding or other
+        virtual bool isReachable() const { return true; }
+
         MovementGeneratorType GetCurrentMovementGeneratorType() const;
         MovementGeneratorType GetMotionSlotType(int slot) const;
 
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerator.h
--- a/src/server/game/Movement/MovementGenerator.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerator.h	Tue Nov 30 23:02:12 2010 -0500
@@ -45,6 +45,9 @@
         virtual void unitSpeedChanged() { }
 
         virtual bool GetDestination(float& /*x*/, float& /*y*/, float& /*z*/) const { return false; }
+
+        // given destination unreachable? due to pathfinsing or other
+        virtual bool isReachable() const { return true; }
 };
 
 template<class T, class D>
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -52,8 +52,15 @@
 
     CreatureTraveller traveller(owner);
 
-    uint32 travel_time = i_destinationHolder.SetDestination(traveller, x, y, z);
-    modifyTravelTime(travel_time);
+    i_destinationHolder.SetDestination(traveller, x, y, z, false);
+
+    PathInfo path(&owner, x, y, z);
+    PointPath pointPath = path.getFullPath();
+
+    float speed = traveller.Speed() * 0.001f; // in ms
+    uint32 traveltime = uint32(pointPath.GetTotalLength() / speed);
+    modifyTravelTime(traveltime);
+    owner.SendMonsterMoveByPath(pointPath, 1, pointPath.size(), traveltime);
     owner.clearUnitState(UNIT_STAT_ALL_STATE & ~UNIT_STAT_EVADE);
 }
 
@@ -63,7 +70,7 @@
     CreatureTraveller traveller(owner);
     i_destinationHolder.UpdateTraveller(traveller, time_diff);
 
-    if (time_diff > i_travel_timer)
+    if (time_diff > i_travel_time)
     {
         owner.AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
 
@@ -83,7 +90,7 @@
         return false;
     }
 
-    i_travel_timer -= time_diff;
+    i_travel_time -= time_diff;
 
     return true;
 }
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h	Tue Nov 30 23:02:12 2010 -0500
@@ -22,6 +22,7 @@
 #include "MovementGenerator.h"
 #include "DestinationHolder.h"
 #include "Traveller.h"
+#include "PathInfo.h"
 
 class Creature;
 
@@ -41,7 +42,7 @@
         void Finalize(Creature &) {}
         void Reset(Creature &);
         bool Update(Creature &, const uint32 &);
-        void modifyTravelTime(uint32 travel_time) { i_travel_timer = travel_time; }
+        void modifyTravelTime(uint32 travel_time) { i_travel_time = travel_time; }
         MovementGeneratorType GetMovementGeneratorType() { return HOME_MOTION_TYPE; }
 
         bool GetDestination(float& x, float& y, float& z) const { i_destinationHolder.GetDestination(x,y,z); return true; }
@@ -51,7 +52,7 @@
         DestinationHolder< Traveller<Creature> > i_destinationHolder;
 
         float ori;
-        uint32 i_travel_timer;
+        uint32 i_travel_time;
 };
 #endif
 
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -22,6 +22,7 @@
 #include "CreatureAI.h"
 #include "DestinationHolderImp.h"
 #include "World.h"
+#include "PathInfo.h"
 
 //----- Point Movement Generator
 template<class T>
@@ -30,7 +31,17 @@
     unit.StopMoving();
     Traveller<T> traveller(unit);
     // knockback effect has UNIT_STAT_JUMPING set,so if here we disable sentmonstermove there will be creature position sync problem between client and server
-    i_destinationHolder.SetDestination(traveller,i_x,i_y,i_z, true /* !unit.hasUnitState(UNIT_STAT_JUMPING)*/);
+    i_destinationHolder.SetDestination(traveller, i_x, i_y, i_z, !m_usePathfinding);
+
+    if (m_usePathfinding)
+    {
+        PathInfo path(&unit, i_x, i_y, i_z);
+        PointPath pointPath = path.getFullPath();
+
+        float speed = traveller.Speed() * 0.001f; // in ms
+        uint32 traveltime = uint32(pointPath.GetTotalLength() / speed);
+        unit.SendMonsterMoveByPath(pointPath, 1, pointPath.size(), traveltime);
+    }
 }
 
 template<class T>
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/PointMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h	Tue Nov 30 23:02:12 2010 -0500
@@ -29,8 +29,8 @@
 : public MovementGeneratorMedium< T, PointMovementGenerator<T> >
 {
     public:
-        PointMovementGenerator(uint32 _id, float _x, float _y, float _z) : id(_id),
-            i_x(_x), i_y(_y), i_z(_z), i_nextMoveTime(0), arrived(false) {}
+        PointMovementGenerator(uint32 _id, float _x, float _y, float _z, bool _usePathfinding) : id(_id),
+            i_x(_x), i_y(_y), i_z(_z), i_nextMoveTime(0), arrived(false), m_usePathfinding(_usePathfinding) {}
 
         void Initialize(T &);
         void Finalize(T &unit);
@@ -45,6 +45,7 @@
     private:
         uint32 id;
         float i_x,i_y,i_z;
+        bool m_usePathfinding;
         TimeTracker i_nextMoveTime;
         DestinationHolder< Traveller<T> > i_destinationHolder;
         bool arrived;
@@ -55,7 +56,7 @@
 {
     public:
         AssistanceMovementGenerator(float _x, float _y, float _z) :
-            PointMovementGenerator<Creature>(0, _x, _y, _z) {}
+            PointMovementGenerator<Creature>(0, _x, _y, _z, true) {}
 
         MovementGeneratorType GetMovementGeneratorType() { return ASSISTANCE_MOTION_TYPE; }
         void Finalize(Unit &);
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -24,33 +24,17 @@
 #include "DestinationHolderImp.h"
 #include "World.h"
 
-#define SMALL_ALPHA 0.05f
-
 #include <cmath>
-/*
-struct StackCleaner
-{
-    Creature &i_creature;
-    StackCleaner(Creature &creature) : i_creature(creature) {}
-    void Done(void) { i_creature.StopMoving(); }
-    ~StackCleaner()
-    {
-        i_creature->Clear();
-    }
-};
-*/
 
 template<class T>
 TargetedMovementGenerator<T>::TargetedMovementGenerator(Unit &target, float offset, float angle)
-: TargetedMovementGeneratorBase(target)
-, i_offset(offset), i_angle(angle), i_recalculateTravel(false)
+: TargetedMovementGeneratorBase(target), i_offset(offset), i_angle(angle), i_recalculateTravel(false), i_path(NULL), m_pathPointsSent(0)
 {
     target.GetPosition(i_targetX, i_targetY, i_targetZ);
 }
 
 template<class T>
-bool
-TargetedMovementGenerator<T>::_setTargetLocation(T &owner)
+bool TargetedMovementGenerator<T>::_setTargetLocation(T &owner)
 {
     if (!i_target.isValid() || !i_target->IsInWorld())
         return false;
@@ -59,7 +43,9 @@
         return false;
 
     float x, y, z;
+    owner.GetPosition(x, y, z);
     Traveller<T> traveller(owner);
+
     if (i_destinationHolder.HasDestination())
     {
         if (i_destinationHolder.HasArrived())
@@ -104,7 +90,6 @@
                 return false;
             }
         }
-
         if (i_target->GetExactDistSq(i_targetX, i_targetY, i_targetZ) < 0.01f)
             return false;
     }
@@ -141,9 +126,52 @@
         if (i_destinationHolder.HasDestination() && i_destinationHolder.GetDestinationDiff(x,y,z) < bothObjectSize)
             return;
     */
-    i_destinationHolder.SetDestination(traveller, x, y, z);
+
+    bool newPathCalculated = true;
+    if (!i_path)
+        i_path = new PathInfo(&owner, x, y, z);
+    else
+        newPathCalculated = i_path->Update(x, y, z);
+
+    i_path->getNextPosition(x, y, z);
+
+    // nothing we can do here ...
+    if (i_path->getPathType() & PATHFIND_NOPATH)
+        return true;
+
+    PointPath pointPath = i_path->getFullPath();
+
+    if (i_destinationHolder.HasArrived() && m_pathPointsSent)
+        --m_pathPointsSent;
+
+    i_path->getNextPosition(x, y, z);
+    i_destinationHolder.SetDestination(traveller, x, y, z, false);
+    
+    // send the path if:
+    //    we have brand new path
+    //    we have visited almost all of the previously sent points
+    //    movespeed has changed
+    //    the owner is stopped (caused by some movement effects)
+    if (newPathCalculated || m_pathPointsSent < 2 || i_recalculateTravel || owner.IsStopped())
+    {
+        // send 10 nodes, or send all nodes if there are less than 10 left
+        m_pathPointsSent = std::min<uint32>(10, pointPath.size() - 1);
+        uint32 endIndex = m_pathPointsSent + 1;
+
+        // dist to next node + world-unit length of the path
+        x -= owner.GetPositionX();
+        y -= owner.GetPositionY();
+        z -= owner.GetPositionZ();
+        float dist = sqrt(x*x + y*y + z*z) + pointPath.GetTotalLength(1, endIndex);
+
+        // calculate travel time, set spline, then send path
+        uint32 traveltime = uint32(dist / (traveller.Speed()*0.001f));
+        owner.SendMonsterMoveByPath(pointPath, 1, endIndex, traveltime);
+    }
+
+    //i_destinationHolder.SetDestination(traveller, x, y, z);
     owner.addUnitState(UNIT_STAT_CHASE);
-    i_destinationHolder.StartTravel(traveller);
+    //i_destinationHolder.StartTravel(traveller);
     return true;
 }
 
@@ -172,8 +200,7 @@
 }
 
 template<class T>
-bool
-TargetedMovementGenerator<T>::Update(T &owner, const uint32 & time_diff)
+bool TargetedMovementGenerator<T>::Update(T &owner, const uint32 & time_diff)
 {
     if (!i_target.isValid() || !i_target->IsInWorld())
         return false;
@@ -196,47 +223,95 @@
     if (!owner.hasUnitState(UNIT_STAT_FOLLOW) && owner.getVictim() != i_target.getTarget())
         return true;
 
+    if (i_path && (i_path->getPathType() & PATHFIND_NOPATH))
+        return true;
+
     Traveller<T> traveller(owner);
 
     if (!i_destinationHolder.HasDestination())
         _setTargetLocation(owner);
-    else if (owner.IsStopped() && !i_destinationHolder.HasArrived())
-    {
-        owner.addUnitState(UNIT_STAT_CHASE);
-        i_destinationHolder.StartTravel(traveller);
-        return true;
+
+    if (i_destinationHolder.UpdateTraveller(traveller, time_diff, i_recalculateTravel || owner.IsStopped()))
+    { 
+        // put targeted movement generators on a higher priority
+        if (owner.GetCombatReach())
+            i_destinationHolder.ResetUpdate(100);
+
+        float dist = owner.GetCombatReach() + i_target.getTarget()->GetCombatReach() + sWorld.getRate(RATE_TARGET_POS_RECALCULATION_RANGE);
+
+        float x,y,z;
+        i_target->GetPosition(x, y, z);
+        PathNode next_point(x, y, z);
+
+        bool targetMoved = false, needNewDest = false;
+        if (i_path)
+        {
+            PathNode end_point = i_path->getEndPosition();
+            next_point = i_path->getNextPosition();
+            needNewDest = i_destinationHolder.HasArrived() && !inRange(next_point, i_path->getActualEndPosition(), dist, 2*dist);
+
+            // GetClosePoint() will always return a point on the ground, so we need to
+            // handle the difference in elevation when the creature is flying
+            if (owner.GetTypeId() == TYPEID_UNIT && ((Creature*)&owner)->canFly())
+                targetMoved = i_target->GetDistanceSqr(end_point.x, end_point.y, end_point.z) >= dist*dist;
+            else
+                targetMoved = i_target->GetDistance2d(end_point.x, end_point.y) >= dist;
+
+            if (!i_path || targetMoved || needNewDest || i_recalculateTravel || owner.IsStopped())
+            {
+                // (re)calculate path
+                _setTargetLocation(owner);
+
+                next_point = i_path->getNextPosition();
+
+                // Set new Angle For Map::
+                owner.SetOrientation(owner.GetAngle(next_point.x, next_point.y));
+            }
+            // Update the Angle of the target only for Map::, no need to send packet for player
+            else if (!i_angle && !owner.HasInArc(0.01f, next_point.x, next_point.y))
+               owner.SetOrientation(owner.GetAngle(next_point.x, next_point.y));
+
+           if ((owner.IsStopped() && !i_destinationHolder.HasArrived()) || i_recalculateTravel)
+           {
+               i_recalculateTravel = false;
+
+               //Angle update will take place into owner.StopMoving()
+               owner.SetOrientation(owner.GetAngle(next_point.x, next_point.y));
+
+               /*owner.StopMoving();
+               static_cast<D*>(this)->_reachTarget(owner);*/
+               if (owner.IsWithinMeleeRange(i_target.getTarget()) && !owner.hasUnitState(UNIT_STAT_FOLLOW))
+                  owner.Attack(i_target.getTarget(), true);
+           }
+        }
     }
 
-    if (i_destinationHolder.UpdateTraveller(traveller, time_diff))
+ /*   float x,y,z;
+    i_target->GetPosition(x, y, z);
+    PathNode next_point(x, y, z);
+    // target moved
+    if (i_targetX != i_target->GetPositionX() || i_targetY != i_target->GetPositionY() || i_targetZ != i_target->GetPositionZ())
     {
-        // put targeted movement generators on a higher priority
-        //if (owner.GetObjectSize())
-        //i_destinationHolder.ResetUpdate(50);
+        if (!owner.hasUnitState(UNIT_STAT_FOLLOW))
+            owner.SetOrientation(owner.GetAngle(next_point.x, next_point.y));
+        i_target->GetPosition(i_targetX, i_targetY, i_targetZ);
+    }
 
-        // target moved
-        if (i_targetX != i_target->GetPositionX() || i_targetY != i_target->GetPositionY()
-            || i_targetZ != i_target->GetPositionZ())
-        {
-            if (_setTargetLocation(owner) || !owner.hasUnitState(UNIT_STAT_FOLLOW))
-                owner.SetInFront(i_target.getTarget());
-            i_target->GetPosition(i_targetX, i_targetY, i_targetZ);
-        }
+    if ((owner.IsStopped() && !i_destinationHolder.HasArrived()) || i_recalculateTravel)
+    {
+        i_recalculateTravel = false;
 
-        if ((owner.IsStopped() && !i_destinationHolder.HasArrived()) || i_recalculateTravel)
-        {
-            i_recalculateTravel = false;
-            //Angle update will take place into owner.StopMoving()
-            owner.SetInFront(i_target.getTarget());
+        //Angle update will take place into owner.StopMoving()
+        owner.SetOrientation(owner.GetAngle(next_point.x, next_point.y));
 
-            owner.StopMoving();
-            if (owner.IsWithinMeleeRange(i_target.getTarget()) && !owner.hasUnitState(UNIT_STAT_FOLLOW))
-                owner.Attack(i_target.getTarget(),true);
-        }
+        owner.StopMoving();
+        if (owner.IsWithinMeleeRange(i_target.getTarget()) && !owner.hasUnitState(UNIT_STAT_FOLLOW))
+            owner.Attack(i_target.getTarget(), true);
     }
 
     // Implemented for PetAI to handle resetting flags when pet owner reached
     if (i_destinationHolder.HasArrived())
-        MovementInform(owner);
+        MovementInform(owner);*/
 
     return true;
 }
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h	Tue Nov 30 23:02:12 2010 -0500
@@ -23,6 +23,7 @@
 #include "DestinationHolder.h"
 #include "Traveller.h"
 #include "FollowerReference.h"
+#include "PathInfo.h"
 
 class TargetedMovementGeneratorBase
 {
@@ -58,6 +59,11 @@
             return true;
         }
 
+        bool IsReachable() const
+        {
+            return (i_path) ? (i_path->getPathType() & PATHFIND_NORMAL) : true;
+        }
+
         void unitSpeedChanged() { i_recalculateTravel=true; }
     private:
 
@@ -66,8 +72,12 @@
         float i_offset;
         float i_angle;
         DestinationHolder< Traveller<T> > i_destinationHolder;
+        float i_targetX, i_targetY, i_targetZ;
+
+    protected:
+        PathInfo* i_path;
+        uint32 m_pathPointsSent;
         bool i_recalculateTravel;
-        float i_targetX, i_targetY, i_targetZ;
 };
 #endif
 
diff -r dc4fc5c8b306 src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -255,7 +255,10 @@
     i_destinationHolder.SetDestination(traveller, (*i_path)[i_currentNode].x, (*i_path)[i_currentNode].y, (*i_path)[i_currentNode].z, false);
     // For preloading end grid
     InitEndGridInfo();
-    player.SendMonsterMoveByPath(GetPath(), GetCurrentNode(), GetPathAtMapEnd());
+    TaxiPathNodeList path = GetPath();
+    uint32 pathEndPoint = GetPathAtMapEnd();
+    uint32 traveltime = uint32(32.0f*path.GetTotalLength(GetCurrentNode(),pathEndPoint));
+    player.SendMonsterMoveByPath(path,GetCurrentNode(),pathEndPoint, traveltime);
 }
 
 void FlightPathMovementGenerator::Finalize(Player & player)
@@ -368,330 +371,3 @@
 
 
 
-//
-// Unique1's ASTAR Pathfinding Code... For future use & reference...
-//
-
-#ifdef __PATHFINDING__
-
-int GetFCost(int to, int num, int parentNum, float *gcost); // Below...
-
-int ShortenASTARRoute(short int *pathlist, int number)
-{                                                           // Wrote this to make the routes a little smarter (shorter)... No point looping back to the same places... Unique1
-    short int temppathlist[MAX_PATHLIST_NODES];
-    int count = 0;
-    //    int count2 = 0;
-    int temp, temp2;
-    int link;
-    int upto = 0;
-
-    for (temp = number; temp >= 0; temp--)
-    {
-        qboolean shortened = qfalse;
-
-        for (temp2 = 0; temp2 < temp; temp2++)
-        {
-            for (link = 0; link < nodes[pathlist[temp]].enodenum; link++)
-            {
-                if (nodes[pathlist[temp]].links[link].flags & PATH_BLOCKED)
-                    continue;
-
-                //if ((bot->client->ps.eFlags & EF_TANK) && nodes[bot->current_node].links[link].flags & PATH_NOTANKS)    //if this path is blocked, skip it
-                //    continue;
-
-                //if (nodes[nodes[pathlist[temp]].links[link].targetNode].origin[2] > nodes[pathlist[temp]].origin[2] + 32)
-                //    continue;
-
-                if (nodes[pathlist[temp]].links[link].targetNode == pathlist[temp2])
-                {                                           // Found a shorter route...
-                    //if (OrgVisible(nodes[pathlist[temp2]].origin, nodes[pathlist[temp]].origin, -1))
-                    {
-                        temppathlist[count] = pathlist[temp2];
-                        temp = temp2;
-                        ++count;
-                        shortened = qtrue;
-                    }
-                }
-            }
-        }
-
-        if (!shortened)
-        {
-            temppathlist[count] = pathlist[temp];
-            ++count;
-        }
-    }
-
-    upto = count;
-
-    for (temp = 0; temp < count; temp++)
-    {
-        pathlist[temp] = temppathlist[upto];
-        --upto;
-    }
-
-    G_Printf("ShortenASTARRoute: Path size reduced from %i to %i nodes...n", number, count);
-    return count;
-}
-
-/*
-===========================================================================
-CreatePathAStar
-This function uses the A* pathfinding algorithm to determine the
-shortest path between any two nodes.
-It's fairly complex, so I'm not really going to explain it much.
-Look up A* and binary heaps for more info.
-pathlist stores the ideal path between the nodes, in reverse order,
-and the return value is the number of nodes in that path
-===========================================================================
-*/
-int CreatePathAStar(gentity_t *bot, int from, int to, short int *pathlist)
-{
-    //all the data we have to hold...since we can't do dynamic allocation, has to be MAX_NODES
-    //we can probably lower this later - eg, the open list should never have more than at most a few dozen items on it
-    short int openlist[MAX_NODES+1];                        //add 1 because it's a binary heap, and they don't use 0 - 1 is the first used index
-    float gcost[MAX_NODES];
-    int fcost[MAX_NODES];
-    char list[MAX_NODES];                                   //0 is neither, 1 is open, 2 is closed - char because it's the smallest data type
-    short int parent[MAX_NODES];
-
-    short int numOpen = 0;
-    short int atNode, temp, newnode=-1;
-    qboolean found = qfalse;
-    int count = -1;
-    float gc;
-    int i, u, v, m;
-    vec3_t vec;
-
-    //clear out all the arrays
-    memset(openlist, 0, sizeof(short int)*(MAX_NODES+1));
-    memset(fcost, 0, sizeof(int)*MAX_NODES);
-    memset(list, 0, sizeof(char)*MAX_NODES);
-    memset(parent, 0, sizeof(short int)*MAX_NODES);
-    memset(gcost, -1, sizeof(float)*MAX_NODES);
-
-    //make sure we have valid data before calculating everything
-    if ((from == NODE_INVALID) || (to == NODE_INVALID) || (from >= MAX_NODES) || (to >= MAX_NODES) || (from == to))
-        return -1;
-
-    openlist[1] = from;                                     //add the starting node to the open list
-    ++numOpen;
-    gcost[from] = 0;                                        //its f and g costs are obviously 0
-    fcost[from] = 0;
-
-    while (1)
-    {
-        if (numOpen != 0)                                   //if there are still items in the open list
-        {
-            //pop the top item off of the list
-            atNode = openlist[1];
-            list[atNode] = 2;                               //put the node on the closed list so we don't check it again
-            --numOpen;
-
-            openlist[1] = openlist[numOpen+1];              //move the last item in the list to the top position
-            v = 1;
-
-            //this while loop reorders the list so that the new lowest fcost is at the top again
-            while (1)
-            {
-                u = v;
-                if ((2*u+1) < numOpen)                      //if both children exist
-                {
-                    if (fcost[openlist[u]] >= fcost[openlist[2*u]])
-                        v = 2*u;
-                    if (fcost[openlist[v]] >= fcost[openlist[2*u+1]])
-                        v = 2*u+1;
-                }
-                else
-                {
-                    if ((2*u) < numOpen)                    //if only one child exists
-                    {
-                        if (fcost[openlist[u]] >= fcost[openlist[2*u]])
-                            v = 2*u;
-                    }
-                }
-
-                if (u != v)                                 //if they're out of order, swap this item with its parent
-                {
-                    temp = openlist[u];
-                    openlist[u] = openlist[v];
-                    openlist[v] = temp;
-                }
-                else
-                    break;
-            }
-
-            for (i = 0; i < nodes[atNode].enodenum; ++i)    //loop through all the links for this node
-            {
-                newnode = nodes[atNode].links[i].targetNode;
-
-                //if this path is blocked, skip it
-                if (nodes[atNode].links[i].flags & PATH_BLOCKED)
-                    continue;
-                //if this path is blocked, skip it
-                if (bot->client && (bot->client->ps.eFlags & EF_TANK) && nodes[atNode].links[i].flags & PATH_NOTANKS)
-                    continue;
-                //skip any unreachable nodes
-                if (bot->client && (nodes[newnode].type & NODE_ALLY_UNREACHABLE) && (bot->client->sess.sessionTeam == TEAM_ALLIES))
-                    continue;
-                if (bot->client && (nodes[newnode].type & NODE_AXIS_UNREACHABLE) && (bot->client->sess.sessionTeam == TEAM_AXIS))
-                    continue;
-
-                if (list[newnode] == 2)                     //if this node is on the closed list, skip it
-                    continue;
-
-                if (list[newnode] != 1)                     //if this node is not already on the open list
-                {
-                    openlist[++numOpen] = newnode;          //add the new node to the open list
-                    list[newnode] = 1;
-                    parent[newnode] = atNode;               //record the node's parent
-
-                    if (newnode == to)                      //if we've found the goal, don't keep computing paths!
-                        break;                              //this will break the 'for' and go all the way to 'if (list[to] == 1)'
-
-                    //store it's f cost value
-                    fcost[newnode] = GetFCost(to, newnode, parent[newnode], gcost);
-
-                    //this loop re-orders the heap so that the lowest fcost is at the top
-                    m = numOpen;
-                    while (m != 1)                          //while this item isn't at the top of the heap already
-                    {
-                        //if it has a lower fcost than its parent
-                        if (fcost[openlist[m]] <= fcost[openlist[m/2]])
-                        {
-                            temp = openlist[m/2];
-                            openlist[m/2] = openlist[m];
-                            openlist[m] = temp;             //swap them
-                            m /= 2;
-                        }
-                        else
-                            break;
-                    }
-                }
-                else                                        //if this node is already on the open list
-                {
-                    gc = gcost[atNode];
-                    VectorSubtract(nodes[newnode].origin, nodes[atNode].origin, vec);
-                    gc += VectorLength(vec);                //calculate what the gcost would be if we reached this node along the current path
-
-                    if (gc < gcost[newnode])                //if the new gcost is less (ie, this path is shorter than what we had before)
-                    {
-                        parent[newnode] = atNode;           //set the new parent for this node
-                        gcost[newnode] = gc;                //and the new g cost
-
-                        for (i = 1; i < numOpen; ++i)       //loop through all the items on the open list
-                        {
-                            if (openlist[i] == newnode)     //find this node in the list
-                            {
-                                //calculate the new fcost and store it
-                                fcost[newnode] = GetFCost(to, newnode, parent[newnode], gcost);
-
-                                //reorder the list again, with the lowest fcost item on top
-                                m = i;
-                                while (m != 1)
-                                {
-                                    //if the item has a lower fcost than it's parent
-                                    if (fcost[openlist[m]] < fcost[openlist[m/2]])
-                                    {
-                                        temp = openlist[m/2];
-                                        openlist[m/2] = openlist[m];
-                                        openlist[m] = temp; //swap them
-                                        m /= 2;
-                                    }
-                                    else
-                                        break;
-                                }
-                                break;                      //exit the 'for' loop because we already changed this node
-                            }                               //if
-                        }                                   //for
-                    }                                       //if (gc < gcost[newnode])
-                }                                           //if (list[newnode] != 1) --> else
-            }                                               //for (loop through links)
-        }                                                   //if (numOpen != 0)
-        else
-        {
-            found = qfalse;                                 //there is no path between these nodes
-            break;
-        }
-
-        if (list[to] == 1)                                  //if the destination node is on the open list, we're done
-        {
-            found = qtrue;
-            break;
-        }
-    }                                                       //while (1)
-
-    if (found == qtrue)                                     //if we found a path
-    {
-        //G_Printf("%s - path found!n", bot->client->pers.netname);
-        count = 0;
-
-        temp = to;                                          //start at the end point
-        while (temp != from)                                //travel along the path (backwards) until we reach the starting point
-        {
-            pathlist[count++] = temp;                       //add the node to the pathlist and increment the count
-            temp = parent[temp];                            //move to the parent of this node to continue the path
-        }
-
-        pathlist[count++] = from;                           //add the beginning node to the end of the pathlist
-
-        #ifdef __BOT_SHORTEN_ROUTING__
-        count = ShortenASTARRoute(pathlist, count);         // This isn't working... Dunno why.. Unique1
-        #endif                                              //__BOT_SHORTEN_ROUTING__
-    }
-    else
-    {
-        //G_Printf("^1*** ^4BOT DEBUG^5: (CreatePathAStar) There is no route between node ^7%i^5 and node ^7%i^5.n", from, to);
-        count = CreateDumbRoute(from, to, pathlist);
-
-        if (count > 0)
-        {
-            #ifdef __BOT_SHORTEN_ROUTING__
-            count = ShortenASTARRoute(pathlist, count);     // This isn't working... Dunno why.. Unique1
-            #endif                                          //__BOT_SHORTEN_ROUTING__
-            return count;
-        }
-    }
-
-    return count;                                           //return the number of nodes in the path, -1 if not found
-}
-
-/*
-===========================================================================
-GetFCost
-Utility function used by A* pathfinding to calculate the
-cost to move between nodes towards a goal.  Using the A*
-algorithm F = G + H, G here is the distance along the node
-paths the bot must travel, and H is the straight-line distance
-to the goal node.
-Returned as an int because more precision is unnecessary and it
-will slightly speed up heap access
-===========================================================================
-*/
-int GetFCost(int to, int num, int parentNum, float *gcost)
-{
-    float gc = 0;
-    float hc = 0;
-    vec3_t v;
-
-    if (gcost[num] == -1)
-    {
-        if (parentNum != -1)
-        {
-            gc = gcost[parentNum];
-            VectorSubtract(nodes[num].origin, nodes[parentNum].origin, v);
-            gc += VectorLength(v);
-        }
-        gcost[num] = gc;
-    }
-    else
-        gc = gcost[num];
-
-    VectorSubtract(nodes[to].origin, nodes[num].origin, v);
-    hc = VectorLength(v);
-
-    return (int)(gc + hc);
-}
-#endif                                                      //__PATHFINDING__
-
-
diff -r dc4fc5c8b306 src/server/game/Movement/Waypoints/Path.h
--- a/src/server/game/Movement/Waypoints/Path.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Movement/Waypoints/Path.h	Tue Nov 30 23:02:12 2010 -0500
@@ -20,10 +20,12 @@
 #define TRINITYCORE_PATH_H
 
 #include "Common.h"
-#include <vector>
+#include <deque>
 
-struct SimplePathNode
+struct PathNode
 {
+    PathNode(): x(0.0f), y(0.0f), z(0.0f) { }
+    PathNode(float _x, float _y, float _z): x(_x), y(_y), z(_z) { }
     float x, y, z;
 };
 template<typename PathElem, typename PathNode = PathElem>
@@ -34,8 +36,21 @@
         size_t size() const { return i_nodes.size(); }
         bool empty() const { return i_nodes.empty(); }
         void resize(unsigned int sz) { i_nodes.resize(sz); }
+        void crop(unsigned int start, unsigned int end)
+        {
+            while(start && !i_nodes.empty())
+            {
+                i_nodes.pop_front();
+                --start;
+            }
+
+            while(end && !i_nodes.empty())
+            {
+                i_nodes.pop_back();
+                --end;
+            }
+        }
         void clear() { i_nodes.clear(); }
-        void erase(uint32 idx) { i_nodes.erase(i_nodes.begin()+idx); }
 
         float GetTotalLength(uint32 start, uint32 end) const
         {
@@ -76,10 +91,10 @@
         void set(size_t idx, PathElem elem) { i_nodes[idx] = elem; }
 
     protected:
-        std::vector<PathElem> i_nodes;
+        std::deque<PathElem> i_nodes;
 };
 
-typedef Path<SimplePathNode> SimplePath;
+typedef Path<PathNode> PointPath;
 
 #endif
 
diff -r dc4fc5c8b306 src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Scripting/ScriptLoader.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -60,6 +60,7 @@
 void AddSC_tele_commandscript();
 void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
+void AddSC_pathfinding_commandscript();
 
 #ifdef SCRIPTS
 //world
@@ -644,6 +645,7 @@
     AddSC_tele_commandscript();
     AddSC_titles_commandscript();
     AddSC_wp_commandscript();
+    AddSC_pathfinding_commandscript();
 }
 
 void AddWorldScripts()
diff -r dc4fc5c8b306 src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/Spell.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -4959,7 +4959,7 @@
                     return SPELL_FAILED_TARGET_AURASTATE;
 
         //Must be behind the target.
-        if (m_spellInfo->AttributesEx2 == SPELL_ATTR_EX2_UNK20 && m_spellInfo->AttributesEx & SPELL_ATTR_EX_UNK9 && target->HasInArc(static_cast<float>(M_PI), m_caster)
+        if (m_spellInfo->AttributesEx2 == SPELL_ATTR_EX2_UNK20 && m_spellInfo->AttributesEx & SPELL_ATTR_EX_UNK9 && target->HasInArc(static_cast<float>(M_PI), m_caster->GetPositionX(), m_caster->GetPositionY())
             //Exclusion for Pounce: Facing Limitation was removed in 2.0.1, but it still uses the same, old Ex-Flags
             && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags.IsEqual(0x20000,0,0)))
             //Mutilate no longer requires you be behind the target as of patch 3.0.3
@@ -4972,7 +4972,7 @@
         }
 
         //Target must be facing you.
-        if ((m_spellInfo->Attributes == (SPELL_ATTR_UNK4 | SPELL_ATTR_NOT_SHAPESHIFT | SPELL_ATTR_UNK18 | SPELL_ATTR_STOP_ATTACK_TARGET)) && !target->HasInArc(static_cast<float>(M_PI), m_caster))
+        if ((m_spellInfo->Attributes == (SPELL_ATTR_UNK4 | SPELL_ATTR_NOT_SHAPESHIFT | SPELL_ATTR_UNK18 | SPELL_ATTR_STOP_ATTACK_TARGET)) && !target->HasInArc(static_cast<float>(M_PI), m_caster->GetPositionX(), m_caster->GetPositionY()))
         {
             SendInterrupted(2);
             return SPELL_FAILED_NOT_INFRONT;
@@ -5062,7 +5062,7 @@
                 {
                     // spell different for friends and enemies
                     // hurt version required facing
-                    if (m_targets.getUnitTarget() && !m_caster->IsFriendlyTo(m_targets.getUnitTarget()) && !m_caster->HasInArc(static_cast<float>(M_PI), m_targets.getUnitTarget()))
+                    if (m_targets.getUnitTarget() && !m_caster->IsFriendlyTo(m_targets.getUnitTarget()) && !m_caster->HasInArc(static_cast<float>(M_PI), m_targets.getUnitTarget()->GetPositionX(), m_targets.getUnitTarget()->GetPositionY()))
                         return SPELL_FAILED_UNIT_NOT_INFRONT;
                 }
                 else if (m_spellInfo->SpellIconID == 33 && m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_FIRE_NOVA)
@@ -5846,7 +5846,7 @@
             return !m_IsTriggeredSpell ? SPELL_FAILED_TOO_CLOSE : SPELL_FAILED_DONT_REPORT;
 
         if (m_caster->GetTypeId() == TYPEID_PLAYER &&
-            (m_spellInfo->FacingCasterFlags & SPELL_FACING_FLAG_INFRONT) && !m_caster->HasInArc(static_cast<float>(M_PI), target))
+            (m_spellInfo->FacingCasterFlags & SPELL_FACING_FLAG_INFRONT) && !m_caster->HasInArc(static_cast<float>(M_PI), target->GetPositionX(), target->GetPositionY()))
             return !m_IsTriggeredSpell ? SPELL_FAILED_UNIT_NOT_INFRONT : SPELL_FAILED_DONT_REPORT;
     }
 
diff -r dc4fc5c8b306 src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/Spells/SpellEffects.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -5973,7 +5973,7 @@
 
     float x, y, z;
     target->GetContactPoint(m_caster, x, y, z);
-    m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+    m_caster->MonsterMoveByPath(x, y, z, 25, false);
 
     // not all charge effects used in negative spells
     if (!IsPositiveSpell(m_spellInfo->Id) && m_caster->GetTypeId() == TYPEID_PLAYER)
@@ -5986,7 +5986,7 @@
     {
         float x, y, z;
         m_targets.m_dstPos.GetPosition(x, y, z);
-        m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+        m_caster->MonsterMoveByPath(x, y, z, 25, false);
     }
 }
 
diff -r dc4fc5c8b306 src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/World/World.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -71,6 +71,7 @@
 #include "WeatherMgr.h"
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
+#include "MemoryManagement.h"
 
 volatile bool World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -1125,6 +1126,9 @@
     bool enableHeight = sConfig.GetBoolDefault("vmap.enableHeight", true);
     bool enablePetLOS = sConfig.GetBoolDefault("vmap.petLOS", true);
     std::string ignoreSpellIds = sConfig.GetStringDefault("vmap.ignoreSpellIds", "");
+    m_bool_configs[CONFIG_PATHFINDING_ENABLED] = sConfig.GetBoolDefault("mMaps.Enabled", true);
+    std::string ignoreMapIds = sConfig.GetStringDefault("mMaps.ignoreMapIds", "");
+    Map::preventPathfindingOnMaps(ignoreMapIds);
 
     if (!enableHeight)
         sLog.outError("VMap height checking disabled! Creatures movements and other various things WILL be broken! Expect no support.");
@@ -1134,6 +1138,7 @@
     VMAP::VMapFactory::preventSpellsFromBeingTestedForLoS(ignoreSpellIds.c_str());
     sLog.outString("WORLD: VMap support included. LineOfSight:%i, getHeight:%i, indoorCheck:%i PetLOS:%i", enableLOS, enableHeight, enableIndoor, enablePetLOS);
     sLog.outString("WORLD: VMap data directory is: %svmaps",m_dataPath.c_str());
+    sLog.outString("WORLD: Pathfinding %sabled", getBoolConfig(CONFIG_PATHFINDING_ENABLED) ? "en" : "dis");
 
     m_int_configs[CONFIG_MAX_WHO] = sConfig.GetIntDefault("MaxWhoListReturns", 49);
     m_bool_configs[CONFIG_PET_LOS] = sConfig.GetBoolDefault("vmap.petLOS", true);
@@ -1189,6 +1194,9 @@
 {
     ///- Initialize the random number generator
     srand((unsigned int)time(NULL));
+
+    ///- Initialize detour memory management
+    dtAllocSetCustom(dtCustomAlloc, dtCustomFree);
 
     ///- Initialize config settings
     LoadConfigSettings();
diff -r dc4fc5c8b306 src/server/game/World/World.h
--- a/src/server/game/World/World.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/game/World/World.h	Tue Nov 30 23:02:12 2010 -0500
@@ -162,6 +162,7 @@
     CONFIG_DUNGEON_FINDER_ENABLE,
     CONFIG_AUTOBROADCAST,
     CONFIG_ALLOW_TICKETS,
+    CONFIG_PATHFINDING_ENABLED,
     BOOL_CONFIG_VALUE_COUNT
 };
 
diff -r dc4fc5c8b306 src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -56,6 +56,7 @@
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
@@ -72,6 +73,7 @@
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Pathfinding
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
diff -r dc4fc5c8b306 src/server/scripts/Commands/CMakeLists.txt
--- a/src/server/scripts/Commands/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/Commands/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -17,6 +17,7 @@
   Commands/cs_titles.cpp
   Commands/cs_quest.cpp
   Commands/cs_reload.cpp
+  Commands/cs_pathfinding.cpp
 #  Commands/cs_list.cpp
 #  Commands/cs_lookup.cpp
 #  Commands/cs_pdump.cpp
diff -r dc4fc5c8b306 src/server/scripts/Commands/cs_pathfinding.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/scripts/Commands/cs_pathfinding.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* ScriptData
+Name: cs_pathfinding
+%Complete: 100
+Comment: Commands for Pathfinding
+Category: commandscripts
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include "Chat.h"
+#include "PathInfo.h"
+
+class pathfinding_commandscript : public CommandScript
+{
+    public:
+        pathfinding_commandscript() : CommandScript("pathfinding_commandscript") { }
+
+        ChatCommand* GetCommands() const
+        {
+            static ChatCommand pathfindingCommandTable[] = 
+            { 
+                { "path",           SEC_GAMEMASTER,     false, &HandleMmapPathCommand,           "", NULL },
+                { "loc",            SEC_GAMEMASTER,     false, &HandleMmapLocCommand,            "", NULL },
+                { "loadedtiles",    SEC_GAMEMASTER,     false, &HandleMmapLoadedTilesCommand,    "", NULL },
+                { "stats",          SEC_GAMEMASTER,     false, &HandleMmapStatsCommand,          "", NULL },
+                { "",               SEC_ADMINISTRATOR,  false, &HandleMmap,                      "", NULL },
+                { NULL,             0,                  false, NULL,                             "", NULL }
+            };
+            static ChatCommand CommandTable[] =
+            {
+                { "pathfinding",    SEC_GAMEMASTER,     false, NULL,                              "", pathfindingCommandTable },
+                { NULL,             0,                  false, NULL,                              "", NULL }
+            };
+            return CommandTable;
+        }
+
+        static bool HandleMmapPathCommand(ChatHandler* handler, const char* args)
+        {
+            if (!handler->GetSession()->GetPlayer()->GetBaseMap()->GetNavMesh())
+            {
+                handler->PSendSysMessage("NavMesh not loaded for current map.");
+                return true;
+            }
+
+            handler->PSendSysMessage("mmap path:");
+
+            // units
+            Player* player = handler->GetSession()->GetPlayer();
+            Unit* target = handler->getSelectedUnit();
+            if (!player || !target)
+            {
+                handler->PSendSysMessage("Invalid target/source selection.");
+                return true;
+            }
+
+            char* para = strtok((char*)args, " ");
+
+            bool useStraightPath = false;
+            if (para && strcmp(para, "true") == 0)
+                useStraightPath = true;
+
+            // unit locations
+            float x, y, z;
+            player->GetPosition(x, y, z);
+
+            // path
+            PathInfo path(target, x, y, z, useStraightPath);
+            PointPath pointPath = path.getFullPath();
+            handler->PSendSysMessage("%s's path to %s:", target->GetName(), player->GetName());
+            handler->PSendSysMessage("Building %s", useStraightPath ? "StraightPath" : "SmoothPath");
+            handler->PSendSysMessage("length %i type %u", pointPath.size(), path.getPathType());
+
+            PathNode start = path.getStartPosition();
+            PathNode next = path.getNextPosition();
+            PathNode end = path.getEndPosition();
+            PathNode actualEnd = path.getActualEndPosition();
+
+            handler->PSendSysMessage("start      (%.3f, %.3f, %.3f)", start.x, start.y, start.z);
+            handler->PSendSysMessage("next       (%.3f, %.3f, %.3f)", next.x, next.y, next.z);
+            handler->PSendSysMessage("end        (%.3f, %.3f, %.3f)", end.x, end.y, end.z);
+            handler->PSendSysMessage("actual end (%.3f, %.3f, %.3f)", actualEnd.x, actualEnd.y, actualEnd.z);
+
+            if (!player->isGameMaster())
+                handler->PSendSysMessage("Enable GM mode to see the path points.");
+
+            // this entry visible only to GM's with "gm on"
+            static const uint32 WAYPOINT_NPC_ENTRY = 1;
+            for (uint32 i = 0; i < pointPath.size(); ++i)
+                player->SummonCreature(WAYPOINT_NPC_ENTRY, pointPath[i].x, pointPath[i].y, pointPath[i].z, 0, TEMPSUMMON_TIMED_DESPAWN, 9000);
+
+            return true;
+        }
+
+        static bool HandleMmapLocCommand(ChatHandler* handler, const char* args)
+        {
+            handler->PSendSysMessage("mmap tileloc:");
+
+            // grid tile location
+            Player* player = handler->GetSession()->GetPlayer();
+
+            int32 gx = 32 - player->GetPositionX() / 533.33333f;
+            int32 gy = 32 - player->GetPositionY() / 533.33333f;
+
+            handler->PSendSysMessage("%03u%02i%02i.mmtile", player->GetMapId(), gy, gx);
+            handler->PSendSysMessage("gridloc [%i,%i]", gx, gy);
+
+            // calculate navmesh tile location
+            const dtNavMesh* navmesh = player->GetBaseMap()->GetNavMesh();
+
+            if (!navmesh)
+            {
+                handler->PSendSysMessage("NavMesh not loaded for current map.");
+                return true;
+            }
+
+            dtNavMeshQuery* query = dtAllocNavMeshQuery();
+            ASSERT(query);
+            query->init(navmesh, MESH_MAX_NODES);
+
+            const float* min = navmesh->getParams()->orig;
+
+            float x, y, z;
+            player->GetPosition(x, y, z);
+            float location[VERTEX_SIZE] = {y, z, x};
+            float extents[VERTEX_SIZE] = {2.f,4.f,2.f};
+
+            int32 tilex = int32((y - min[0]) / 533.33333);
+            int32 tiley = int32((x - min[2]) / 533.33333);
+
+            handler->PSendSysMessage("Calc   [%02i,%02i]", tilex, tiley);
+
+            // navmesh poly -> navmesh tile location
+            dtQueryFilter filter = dtQueryFilter();
+            dtPolyRef polyRef = INVALID_POLYREF;
+            query->findNearestPoly(location, extents, &filter, &polyRef, NULL);
+
+            if (polyRef == INVALID_POLYREF)
+                handler->PSendSysMessage("Dt     [??,??] (invalid poly, probably no tile loaded)");
+            else
+            {
+                const dtMeshTile* tile;
+                const dtPoly* poly;
+                navmesh->getTileAndPolyByRef(polyRef, &tile, &poly);
+                if (tile)
+                    handler->PSendSysMessage("Dt     [%02i,%02i]", tile->header->x, tile->header->y);
+                else
+                    handler->PSendSysMessage("Dt     [??,??] (no tile loaded)");
+            }
+
+            // mmtile file header -> navmesh tile location
+            uint32 pathLen = sWorld.GetDataPath().length() + strlen("mmaps/%03i%02i%02i.mmtile")+1;
+            char *fileName = new char[pathLen];
+            snprintf(fileName, pathLen, (char*)(sWorld.GetDataPath()+"mmaps/%03i%02i%02i.mmtile").c_str(), player->GetMapId(), gx, gy);
+
+            FILE* file = fopen(fileName, "rb");
+            if (!file)
+                handler->PSendSysMessage("mmtile [??,??] (file %03u%02i%02i.mmtile not found)", player->GetMapId(), gx, gy);
+            else
+            {
+                fseek(file, 0, SEEK_END);
+                int32 length = ftell(file);
+                fseek(file, 0, SEEK_SET);
+
+                unsigned char* data = new unsigned char[length];
+                fread(data, length, 1, file);
+                fclose(file);
+
+                dtMeshHeader* header = (dtMeshHeader*)data;
+
+                handler->PSendSysMessage("mmtile [%02i,%02i]", header->x, header->y);
+
+                delete [] data;
+            }
+
+            delete [] fileName;
+            dtFreeNavMeshQuery(query);
+            return true;
+        }
+
+        static bool HandleMmapLoadedTilesCommand(ChatHandler* handler, const char* args)
+        {
+            const dtNavMesh* navmesh = handler->GetSession()->GetPlayer()->GetBaseMap()->GetNavMesh();
+
+            if (!navmesh)
+            {
+                handler->PSendSysMessage("NavMesh not loaded for current map.");
+                return true;
+            }
+
+            handler->PSendSysMessage("mmap loadedtiles:");
+
+            dtNavMeshQuery* query = dtAllocNavMeshQuery();
+            ASSERT(query);
+            query->init(navmesh, MESH_MAX_NODES);
+
+            for (int32 i = 0; i < navmesh->getMaxTiles(); ++i)
+            {
+                const dtMeshTile* tile = navmesh->getTile(i);
+                if (!tile || !tile->header)
+                    continue;
+
+                handler->PSendSysMessage("[%02i,%02i]", tile->header->x, tile->header->y);
+            }
+
+            dtFreeNavMeshQuery(query);
+            return true;
+        }
+
+        static bool HandleMmapStatsCommand(ChatHandler* handler, const char* args)
+        {
+            handler->PSendSysMessage("mmap stats:");
+            handler->PSendSysMessage("  global mmap pathfinding is %sabled", sWorld.getBoolConfig(CONFIG_PATHFINDING_ENABLED) ? "en" : "dis");
+
+            const dtNavMesh* navmesh = handler->GetSession()->GetPlayer()->GetBaseMap()->GetNavMesh();
+
+            if (!navmesh)
+            {
+                handler->PSendSysMessage("NavMesh not loaded for current map.");
+                return true;
+            }
+
+            uint32 tileCount = 0;
+            uint32 nodeCount = 0;
+            uint32 polyCount = 0;
+            uint32 vertCount = 0;
+            uint32 triCount = 0;
+            uint32 triVertCount = 0;
+            uint32 dataSize = 0;
+            for (int32 i = 0; i < navmesh->getMaxTiles(); ++i)
+            {
+                const dtMeshTile* tile = navmesh->getTile(i);
+                if (!tile || !tile->header)
+                    continue;
+
+                tileCount ++;
+                nodeCount += tile->header->bvNodeCount;
+                polyCount += tile->header->polyCount;
+                vertCount += tile->header->vertCount;
+                triCount += tile->header->detailTriCount;
+                triVertCount += tile->header->detailVertCount;
+                dataSize += tile->dataSize;
+            }
+
+            handler->PSendSysMessage("Navmesh stats:");
+            handler->PSendSysMessage(" %u tiles loaded", tileCount);
+            handler->PSendSysMessage(" %u BVTree nodes", nodeCount);
+            handler->PSendSysMessage(" %u polygons (%u vertices)", polyCount, vertCount);
+            handler->PSendSysMessage(" %u triangles (%u vertices)", triCount, triVertCount);
+            handler->PSendSysMessage(" %.2f MB of data (not including pointers)", ((float)dataSize / sizeof(unsigned char)) / 1048576);
+
+            return true;
+        }
+
+        static bool HandleMmap(ChatHandler* handler, const char* args) 
+        {
+            std::string argstr = (char*)args; 
+            if (argstr == "on") 
+            { 
+                sWorld.setBoolConfig(CONFIG_PATHFINDING_ENABLED, true);
+                handler->SendSysMessage("WORLD: mmaps are now ENABLED (individual map settings still in effect)");
+            }
+
+            if (argstr == "off")
+            { 
+                sWorld.setBoolConfig(CONFIG_PATHFINDING_ENABLED, false); 
+                handler->SendSysMessage("WORLD: mmaps are now DISABLED"); 
+            } 
+            return true;
+        } 
+};
+
+void AddSC_pathfinding_commandscript()
+{
+    new pathfinding_commandscript();
+}
diff -r dc4fc5c8b306 src/server/scripts/EasternKingdoms/Karazhan/boss_nightbane.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_nightbane.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_nightbane.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -329,7 +329,7 @@
                 if (TailSweepTimer <= diff)
                 {
                     if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
-                        if (!me->HasInArc(M_PI, pTarget))
+                        if (!me->HasInArc(M_PI, pTarget->GetPositionX(), pTarget->GetPositionY()))
                             DoCast(pTarget, SPELL_TAIL_SWEEP);
                     TailSweepTimer = 15000;
                 } else TailSweepTimer -= diff;
diff -r dc4fc5c8b306 src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -1299,7 +1299,7 @@
             if (BackwardLungeTimer <= diff)
             {
                 Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true);
-                if (pTarget && !me->HasInArc(M_PI, pTarget))
+                if (pTarget && !me->HasInArc(M_PI, pTarget->GetPositionX(), pTarget->GetPositionY()))
                 {
                     DoCast(pTarget, SPELL_BACKWARD_LUNGE);
                     BackwardLungeTimer = urand(15000,30000);
diff -r dc4fc5c8b306 src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -191,7 +191,7 @@
             {
                 if (isFlameBreathing)
                 {
-                    if (!me->HasInArc(M_PI/6, pTarget))
+                    if (!me->HasInArc(M_PI/6, pTarget->GetPositionX(), pTarget->GetPositionY()))
                         damage = 0;
                 }
             }
diff -r dc4fc5c8b306 src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -262,7 +262,7 @@
                 if (me->IsWithinDistInMap(who, attackRadius))
                 {
                     // Check first that object is in an angle in front of this one before LoS check
-                    if (me->HasInArc(M_PI/2.0f, who) && me->IsWithinLOSInMap(who))
+                    if (me->HasInArc(M_PI/2.0f, who->GetPositionX(), who->GetPositionY()) && me->IsWithinLOSInMap(who))
                     {
                         AttackStart(who);
                     }
diff -r dc4fc5c8b306 src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -271,7 +271,7 @@
                         Map::PlayerList const &PlayerList = pMap->GetPlayers();
                         for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
                         {
-                            if (i->getSource() && i->getSource()->isAlive() && me->HasInArc(float(diff/20000*M_PI*2),i->getSource()) && me->IsWithinDist(i->getSource(), SPOUT_DIST) && !i->getSource()->IsInWater())
+                            if (i->getSource() && i->getSource()->isAlive() && me->HasInArc(float(diff/20000*M_PI*2), i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) && me->IsWithinDist(i->getSource(), SPOUT_DIST) && !i->getSource()->IsInWater())
                                 DoCast(i->getSource(), SPELL_SPOUT, true);//only knock back palyers in arc, in 100yards, not in water
                         }
                     }
diff -r dc4fc5c8b306 src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -244,7 +244,7 @@
                         else
                         {
                             Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0);
-                            if (!me->HasInArc(2.5f, pTarget))
+                            if (!me->HasInArc(2.5f, pTarget->GetPositionX(), pTarget->GetPositionY()))
                                 pTarget = me->getVictim();
                             if (pTarget)
                                 DoCast(pTarget, SPELL_ARCANE_MISSILES);
diff -r dc4fc5c8b306 src/server/shared/CMakeLists.txt
--- a/src/server/shared/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/shared/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -54,6 +54,8 @@
   ${CMAKE_BINARY_DIR}
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
   ${CMAKE_SOURCE_DIR}/dep/sockets/include
   ${CMAKE_SOURCE_DIR}/dep/utf8cpp
   ${CMAKE_SOURCE_DIR}/src/server
diff -r dc4fc5c8b306 src/server/shared/Threading/MemoryManagement.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/shared/Threading/MemoryManagement.h	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef _MEMORYMANAGEMENT_H
+#define _MEMORYMANAGEMENT_H
+
+#include "DetourAlloc.h"
+
+inline void* dtCustomAlloc(int size, dtAllocHint hint)
+{
+    return (void*)new unsigned char[size];
+}
+
+inline void dtCustomFree(void* ptr)
+{
+    delete [] ptr;
+}
+
+#endif
\ No newline at end of file
diff -r dc4fc5c8b306 src/server/worldserver/CMakeLists.txt
--- a/src/server/worldserver/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/worldserver/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -48,6 +48,7 @@
   ${CMAKE_SOURCE_DIR}/dep/sockets/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/shared
@@ -165,6 +166,8 @@
   collision
   g3dlib
   gsoap
+  Recast
+  Detour
   ${JEMALLOC_LIB}
   ${READLINE_LIBRARY}
   ${TERMCAP_LIBRARY}
diff -r dc4fc5c8b306 src/server/worldserver/worldserver.conf.dist
--- a/src/server/worldserver/worldserver.conf.dist	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/server/worldserver/worldserver.conf.dist	Tue Nov 30 23:02:12 2010 -0500
@@ -307,6 +307,22 @@
 #                     0 - (Disabled, somewhat less CPU usage)
 
 vmap.enableIndoorCheck = 1
+
+#
+#    mMaps.ignoreMapIds
+#        Description: Disable mmap pathfinding on the listed maps.
+#        Default:     1 - (Enabled) List of map ids with delimiter ','
+#                     0 - (Disabled)
+
+mMaps.ignoreMapsIds = ""
+
+#
+#    mMaps.Enabled
+#        Description: Enable/Disable pathfinding using mmaps
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+mMaps.Enabled = 1
 
 #
 #    DetectPosCollision
diff -r dc4fc5c8b306 src/tools/CMakeLists.txt
--- a/src/tools/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/tools/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -8,6 +8,7 @@
 # WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 # implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
+add_subdirectory(movements_extractor)
 add_subdirectory(map_extractor)
 add_subdirectory(vmap3_assembler)
 add_subdirectory(vmap3_extractor)
diff -r dc4fc5c8b306 src/tools/map_extractor/System.cpp
--- a/src/tools/map_extractor/System.cpp	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/tools/map_extractor/System.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -275,11 +275,11 @@
 //
 
 // Map file format data
-static char const* MAP_MAGIC         = "MAPS";
-static char const* MAP_VERSION_MAGIC = "v1.1";
-static char const* MAP_AREA_MAGIC    = "AREA";
-static char const* MAP_HEIGHT_MAGIC  = "MHGT";
-static char const* MAP_LIQUID_MAGIC  = "MLIQ";
+#define MAP_MAGIC             'SPAM'
+#define MAP_VERSION_MAGIC     '1.2v'
+#define MAP_AREA_MAGIC        'AERA'
+#define MAP_HEIGHT_MAGIC      'TGHM'
+#define MAP_LIQUID_MAGIC      'QILM'
 
 struct map_fileheader
 {
@@ -292,6 +292,8 @@
     uint32 heightMapSize;
     uint32 liquidMapOffset;
     uint32 liquidMapSize;
+    uint32 holesOffset; 
+    uint32 holesSize; 
 };
 
 #define MAP_AREA_NO_AREA      0x0001
@@ -382,8 +384,8 @@
 
     // Prepare map header
     map_fileheader map;
-    map.mapMagic = *(uint32 const*)MAP_MAGIC;
-    map.versionMagic = *(uint32 const*)MAP_VERSION_MAGIC;
+    map.mapMagic = uint32(MAP_MAGIC);
+    map.versionMagic = uint32(MAP_VERSION_MAGIC);
     map.buildMagic = build;
 
     // Get area flags data
@@ -426,7 +428,7 @@
     map.areaMapSize   = sizeof(map_areaHeader);
 
     map_areaHeader areaHeader;
-    areaHeader.fourcc = *(uint32 const*)MAP_AREA_MAGIC;
+    areaHeader.fourcc = uint32(MAP_AREA_MAGIC);
     areaHeader.flags = 0;
     if (fullAreaData)
     {
@@ -555,7 +557,7 @@
     map.heightMapSize = sizeof(map_heightHeader);
 
     map_heightHeader heightHeader;
-    heightHeader.fourcc = *(uint32 const*)MAP_HEIGHT_MAGIC;
+    heightHeader.fourcc = uint32(MAP_HEIGHT_MAGIC);
     heightHeader.flags = 0;
     heightHeader.gridHeight    = minHeight;
     heightHeader.gridMaxHeight = maxHeight;
@@ -790,7 +792,7 @@
         }
         map.liquidMapOffset = map.heightMapOffset + map.heightMapSize;
         map.liquidMapSize = sizeof(map_liquidHeader);
-        liquidHeader.fourcc = *(uint32 const*)MAP_LIQUID_MAGIC;
+        liquidHeader.fourcc = uint32(MAP_LIQUID_MAGIC);
         liquidHeader.flags = 0;
         liquidHeader.liquidType = 0;
         liquidHeader.offsetX = minX;
@@ -817,6 +819,25 @@
         if (!(liquidHeader.flags & MAP_LIQUID_NO_HEIGHT))
             map.liquidMapSize += sizeof(float)*liquidHeader.width*liquidHeader.height;
     }
+
+    // map hole info 
+    uint16 holes[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID]; 
+    if(map.liquidMapOffset) 
+        map.holesOffset = map.liquidMapOffset + map.liquidMapSize; 
+    else 
+        map.holesOffset = map.heightMapOffset + map.heightMapSize; 
+    map.holesSize = sizeof(holes); 
+    memset(holes, 0, map.holesSize); 
+    for(int i = 0; i < ADT_CELLS_PER_GRID; ++i) 
+    { 
+        for(int j = 0; j < ADT_CELLS_PER_GRID; ++j) 
+        { 
+            adt_MCNK * cell = cells->getMCNK(i,j); 
+            if(!cell) 
+                continue; 
+            holes[i][j] = cell->holes; 
+        } 
+    } 
 
     // Ok all data prepared - store it
     FILE *output=fopen(filename2, "wb");
@@ -864,6 +885,10 @@
                 fwrite(&liquid_height[y+liquidHeader.offsetY][liquidHeader.offsetX], sizeof(float), liquidHeader.width, output);
         }
     }
+ 
+    // store hole data
+    fwrite(holes, map.holesSize, 1, output);
+
     fclose(output);
 
     return true;
diff -r dc4fc5c8b306 src/tools/map_extractor/adt.h
--- a/src/tools/map_extractor/adt.h	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/tools/map_extractor/adt.h	Tue Nov 30 23:02:12 2010 -0500
@@ -93,7 +93,8 @@
     uint32 sizeMCSH;
     uint32 areaid;
     uint32 nMapObjRefs;
-    uint32 holes;
+    uint16 holes;           // locations where models pierce the heightmap
+    uint16 pad;
     uint16 s[2];
     uint32 data1;
     uint32 data2;
@@ -286,4 +287,6 @@
     adt_MHDR *a_grid;
 };
 
+bool isHole(int holes, int i, int j); 
+
 #endif
diff -r dc4fc5c8b306 src/tools/movements_extractor/CMakeLists.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,75 @@
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+set(sources 
+    mMapsGenerator.cpp 
+    MapBuilder.cpp 
+    TerrainBuilder.cpp 
+    VMapExtensions.cpp 
+)
+
+# definitions
+add_definitions(-DNO_CORE_FUNCS)
+add_definitions(-DDEBUG)
+add_definitions(-DNO_vsnprintf)
+
+include_directories(
+  ${ACE_INCLUDE_DIR}
+  ${MYSQL_INCLUDE_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/libmpq
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/acelite
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database/Implementation
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+)
+
+add_executable(movements_extractor
+    ${sources}
+)
+
+target_link_libraries(movements_extractor
+  ${MYSQL_LIBRARY}
+  ${ACE_LIBRARY}
+  ${BZIP2_LIBRARIES}
+  ${ZLIB_LIBRARIES}
+  Recast
+  Detour
+  collision
+  g3dlib
+  shared
+)
+
+if( UNIX )
+  install(TARGETS movements_extractor DESTINATION bin)
+elseif( WIN32 )
+  install(TARGETS movements_extractor DESTINATION "${CMAKE_INSTALL_PREFIX}")
+endif()
\ No newline at end of file
diff -r dc4fc5c8b306 src/tools/movements_extractor/MapBuilder.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/MapBuilder.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,1486 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mMapCommon.h"
+#include "MapBuilder.h"
+#include "VMapManager2.h"
+#include "MapTree.h"
+#include "ModelInstance.h"
+#include "DetourNavMeshBuilder.h"
+#include "DetourCommon.h"
+#include "LoginDatabase.h"
+
+LoginDatabaseWorkerPool LoginDatabase;
+
+namespace Pathfinding
+{
+    MapBuilder::MapBuilder(float maxWalkableAngle,
+                           bool skipLiquid,
+                           bool skipContinents, bool skipJunkMaps, bool skipBattlegrounds,
+                           bool hiResHeightmaps, bool debugOutput) :
+                           m_vmapManager(NULL),
+                           m_terrainBuilder(NULL),
+                           m_debugOutput        (debugOutput),
+                           m_skipContinents     (skipContinents),
+                           m_skipJunkMaps       (skipJunkMaps),
+                           m_skipBattlegrounds  (skipBattlegrounds),
+                           m_maxWalkableAngle   (maxWalkableAngle),
+                           m_rcContext          (NULL)
+    {
+        m_vmapManager = new VMapManager2();
+        m_terrainBuilder = new TerrainBuilder(skipLiquid, hiResHeightmaps);
+
+        m_rcContext = new rcContext;
+
+        discoverTiles();
+    }
+
+    MapBuilder::~MapBuilder()
+    {
+        for (TileList::iterator it = m_tiles.begin(); it != m_tiles.end(); ++it)
+        {
+            (*it).second->clear();
+            delete (*it).second;
+        }
+        m_tiles.clear();
+
+        delete m_terrainBuilder;
+        delete m_vmapManager;
+        delete m_rcContext;
+    }
+
+    void MapBuilder::discoverTiles()
+    {
+        uint32 i;
+        vector<string> files;
+        uint32 mapID, tileX, tileY, tileID, count = 0;;
+        char filter[12];
+
+        printf("Discovering maps... ");
+        getDirContents(files, "maps");
+        for (i = 0; i < files.size(); ++i)
+        {
+            mapID = uint32(atoi(files[i].substr(0,3).c_str()));
+            if (m_tiles.find(mapID) == m_tiles.end())
+            {
+                m_tiles.insert(pair<uint32,set<uint32>*>(mapID, new set<uint32>));
+                count++;
+            }
+        }
+
+        files.clear();
+        getDirContents(files, "vmaps", "*.vmtree");
+        for (i = 0; i < files.size(); ++i)
+        {
+            mapID = uint32(atoi(files[i].substr(0,3).c_str()));
+            m_tiles.insert(pair<uint32,set<uint32>*>(mapID, new set<uint32>));
+            count++;
+        }
+        printf("found %u.\n", count);
+
+        count = 0;
+        printf("Discovering tiles... ");
+        for (TileList::iterator itr = m_tiles.begin(); itr != m_tiles.end(); ++itr)
+        {
+            set<uint32>* tiles = (*itr).second;
+            mapID = (*itr).first;
+
+            sprintf(filter, "%03u*.vmtile", mapID);
+            files.clear();
+            getDirContents(files, "vmaps", filter);
+            for (i = 0; i < files.size(); ++i)
+            {
+                tileX = uint32(atoi(files[i].substr(7,2).c_str()));
+                tileY = uint32(atoi(files[i].substr(4,2).c_str()));
+                tileID = StaticMapTree::packTileID(tileY, tileX);
+
+                tiles->insert(tileID);
+                count++;
+            }
+            sprintf(filter, "%03u*", mapID);
+            files.clear();
+            getDirContents(files, "maps", filter);
+            for (i = 0; i < files.size(); ++i)
+            {
+                tileY = uint32(atoi(files[i].substr(3,2).c_str()));
+                tileX = uint32(atoi(files[i].substr(5,2).c_str()));
+                tileID = StaticMapTree::packTileID(tileX, tileY);
+
+                if (tiles->insert(tileID).second)
+                    count++;
+            }
+        }
+        printf("found %u.\n\n", count);
+    }
+
+    set<uint32>* MapBuilder::getTileList(uint32 mapID)
+    {
+        TileList::iterator itr = m_tiles.find(mapID);
+        if (itr != m_tiles.end())
+            return (*itr).second;
+
+        set<uint32>* tiles = new set<uint32>;
+        m_tiles.insert(pair<uint32, set<uint32>*>(mapID, tiles));
+        return tiles;
+    }
+
+    void MapBuilder::buildAll()
+    {
+        for (TileList::iterator it = m_tiles.begin(); it != m_tiles.end(); ++it)
+        {
+            uint32 mapID = (*it).first;
+            if (!shouldSkipMap(mapID)) 
+                build(mapID); 
+        }
+    }
+
+    void MapBuilder::build(uint32 mapID)
+    {
+        printf("Building map %03u:\n", mapID);
+
+        set<uint32>* tiles = getTileList(mapID);
+
+        // vars that are used in multiple locations...
+        uint32 i, j, tileX, tileY;
+        float bmin[3], bmax[3], lmin[3], lmax[3];
+
+        // scope the model data arrays
+        do
+        {
+            MeshData meshData;
+
+            // make sure we process maps which don't have tiles
+            if (!tiles->size())
+            {
+                // initialize the static tree, which loads WDT models
+                if (!loadVMap(mapID, 64, 64, meshData) || !(meshData.solidVerts.size() || meshData.liquidVerts.size()))
+                    continue;
+
+                // get the coord bounds of the model data
+                if (meshData.solidVerts.size() && meshData.liquidVerts.size())
+                {
+                    rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax);
+                    rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax);
+                    rcVmin(bmin, lmin);
+                    rcVmax(bmax, lmax);
+                }
+                else if (meshData.solidVerts.size())
+                {
+                    rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax);
+                }
+                else
+                { 
+                    rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax);
+                }
+
+                // convert coord bounds to grid bounds
+                uint32 minX, minY, maxX, maxY;
+                maxX = 32 - bmin[0] / GRID_SIZE;
+                maxY = 32 - bmin[2] / GRID_SIZE;
+                minX = 32 - bmax[0] / GRID_SIZE;
+                minY = 32 - bmax[2] / GRID_SIZE;
+
+                // add all tiles within bounds to tile list.
+                for (i = minX; i <= maxX; ++i)
+                    for (j = minY; j <= maxY; ++j)
+                        tiles->insert(StaticMapTree::packTileID(i, j));
+            }
+        } while(0);
+
+        // build navMesh
+        dtNavMesh* navMesh = NULL;
+        buildNavMesh(mapID, navMesh);
+        if (!navMesh)
+        {
+            printf("Failed creating navmesh!              \n");
+            printf("Failed!                               \n\n");
+            return;
+        }
+
+        // more data storage
+        G3D::Array<float> allVerts;
+        G3D::Array<int> allTris;
+        char tileString[10];
+        
+        // now start building mmtiles for each tile
+        printf("We have %i tiles.                          \n", (unsigned int)tiles->size());
+        for (set<uint32>::iterator it = tiles->begin(); it != tiles->end(); ++it)
+        {
+            // unpack tile coords
+            StaticMapTree::unpackTileID((*it), tileX, tileY);
+
+            if (shouldSkipTile(mapID, tileX, tileY))
+                continue;
+
+            sprintf(tileString, "[%02u,%02u]: ", tileX, tileY);
+
+            allVerts.fastClear();
+            allTris.fastClear();
+
+            MeshData meshData;
+
+            // get heightmap data
+            printf("%s Loading heightmap...                           \r", tileString);
+            m_terrainBuilder->loadMap(mapID, tileX, tileY, meshData);
+
+            // get model data
+            printf("%s Loading models...                              \r", tileString);
+            loadVMap(mapID, tileY, tileX, meshData);
+
+            // we only want tiles that people can actually walk on
+            if (!meshData.solidVerts.size() && !meshData.liquidVerts.size())
+                continue;
+
+            printf("%s Aggregating mesh data...                        \r", tileString);
+
+            // remove unused vertices
+            cleanVertices(meshData.solidVerts, meshData.solidTris);
+            cleanVertices(meshData.liquidVerts, meshData.liquidTris);
+
+            // gather all mesh data for final data check, and bounds calculation
+            allTris.append(meshData.liquidTris);
+            allVerts.append(meshData.liquidVerts);
+            copyIndices(allTris, meshData.solidTris, allVerts.size() / 3);
+            allVerts.append(meshData.solidVerts);
+            
+            if (!allVerts.size() || !allTris.size())
+                continue;
+
+            // get bounds of current tile
+            getTileBounds(tileX, tileY, allVerts.getCArray(), allVerts.size() / 3, bmin, bmax);
+
+            allVerts.fastClear();
+            allTris.fastClear();
+
+            // build navmesh tile
+            buildMoveMapTile(mapID,
+                             tileX,
+                             tileY,
+                             meshData,
+                             bmin,
+                             bmax,
+                             navMesh);
+        }
+
+        m_vmapManager->unloadMap(mapID);
+
+        dtFreeNavMesh(navMesh);
+
+        printf("Map creating successfull!                          \n\n");
+    }
+
+    void MapBuilder::buildTile(uint32 mapID, uint32 tileX, uint32 tileY)
+    {
+        printf("Building map %03u, tile [%02u,%02u]\n", mapID, tileX, tileY);
+
+        float bmin[3], bmax[3], lmin[3], lmax[3]; 
+        MeshData meshData; 
+
+        // make sure we process maps which don't have tiles
+        // initialize the static tree, which loads WDT models
+        loadVMap(mapID, 64, 64, meshData);
+
+        // get the coord bounds of the model data
+        if (meshData.solidVerts.size() || meshData.liquidVerts.size())
+        {
+            // get the coord bounds of the model data 
+            if (meshData.solidVerts.size() && meshData.liquidVerts.size()) 
+            { 
+                rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax); 
+                rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax); 
+                rcVmin(bmin, lmin); 
+                rcVmax(bmax, lmax); 
+            } 
+            else if (meshData.solidVerts.size()) 
+            { 
+                rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax); 
+            } 
+            else 
+            { 
+                rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax); 
+            } 
+
+            // convert coord bounds to grid bounds
+            uint32 minX, minY, maxX, maxY;
+            maxX = 32 - bmin[0] / GRID_SIZE;
+            maxY = 32 - bmin[2] / GRID_SIZE;
+            minX = 32 - bmax[0] / GRID_SIZE;
+            minY = 32 - bmax[2] / GRID_SIZE;
+
+            // if specified tile is outside of bounds, give up now
+            if (tileX < minX || tileX > maxX)
+                return;
+            if (tileY < minY || tileY > maxY)
+                return;
+        }
+
+        // build navMesh
+        dtNavMesh* navMesh = NULL;
+        buildNavMesh(mapID, navMesh);
+        if (!navMesh)
+        {
+            printf("Failed creating navmesh!              \n");
+            printf("Failed!                               \n\n");
+            return;
+        }
+
+        G3D::Array<float> allVerts;
+        G3D::Array<int> allTris;
+        char tileString[10];
+        sprintf(tileString, "[%02u,%02u]: ", tileX, tileY);
+
+        do
+        {
+            MeshData meshData;
+
+            // get heightmap data
+            printf("%s Loading heightmap...                           \r", tileString);
+            m_terrainBuilder->loadMap(mapID, tileX, tileY, meshData);
+
+            // get model data
+            printf("%s Loading models...                              \r", tileString);
+            loadVMap(mapID, tileY, tileX, meshData);
+
+            // if there is no data, give up now
+            if (!meshData.solidVerts.size() && !meshData.liquidVerts.size())
+                break;
+
+            printf("%s Aggregating mesh data...                        \r", tileString);
+
+            // remove unused vertices
+            cleanVertices(meshData.solidVerts, meshData.solidTris);
+            cleanVertices(meshData.liquidVerts, meshData.liquidTris);
+
+            // gather all mesh data for final data check, and bounds calculation
+            allTris.append(meshData.liquidTris);
+            allVerts.append(meshData.liquidVerts);
+            copyIndices(allTris, meshData.solidTris, allVerts.size() / 3);
+            allVerts.append(meshData.solidVerts);
+
+            if (!allVerts.size() || !allTris.size())
+                break;
+
+            // get bounds of current tile
+            getTileBounds(tileX, tileY, allVerts.getCArray(), allVerts.size() / 3, bmin, bmax);
+
+            allVerts.clear();
+            allTris.clear();
+
+            // build navmesh tile
+            buildMoveMapTile(mapID,
+                                tileX,
+                                tileY,
+                                meshData,
+                                bmin,
+                                bmax,
+                                navMesh);
+
+        } while(0);
+
+        dtFreeNavMesh(navMesh);
+
+        printf("%s Complete!                                      \n\n", tileString);
+    }
+
+    bool MapBuilder::loadVMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData)
+    {
+        int result = m_vmapManager->loadMap("vmaps", mapID, tileX, tileY);
+        bool retval = false;
+
+        do
+        {
+            if (result == VMAP_LOAD_RESULT_ERROR)
+                break;
+
+            ModelInstance* models = NULL;
+            uint32 count = 0;
+
+            InstanceTreeMap instanceTrees;
+            ((VMapManager2*)m_vmapManager)->getInstanceMapTree(instanceTrees);
+
+            if (!instanceTrees[mapID])
+                break;
+
+            instanceTrees[mapID]->getModelInstances(models, count);
+
+            if (!models || !count)
+                break;
+
+            uint32 i;
+            for (i = 0; i < count; ++i)
+            {
+                ModelInstance instance = models[i];
+
+                // model instances exist in tree even though there are instances of that model in this tile
+                WorldModel* worldModel = instance.getWorldModel();
+                if (!worldModel)
+                    continue;
+
+                // now we have a model to add to the meshdata
+                retval = true;
+
+                vector<GroupModel> groupModels;
+                worldModel->getGroupModels(groupModels);
+
+                // all M2s need to have triangle indices reversed
+                bool isM2 = instance.name.find(".m2") != instance.name.npos || instance.name.find(".M2") != instance.name.npos;
+
+                // transform data
+                float scale = models[i].iScale;
+                G3D::Matrix3 rotation = G3D::Matrix3::fromEulerAnglesZYX(-1*G3D::pi()*instance.iRot.y/180.f, -1*G3D::pi()*instance.iRot.x/180.f, -1*G3D::pi()*instance.iRot.z/180.f);
+                Vector3 position = instance.iPos;
+                position.x -= 32*GRID_SIZE;
+                position.y -= 32*GRID_SIZE;
+
+                for (vector<GroupModel>::iterator it = groupModels.begin(); it != groupModels.end(); ++it)
+                {
+                    vector<Vector3> tempVertices;
+                    vector<Vector3> transformedVertices;
+                    vector<MeshTriangle> tempTriangles;
+                    WmoLiquid* liquid = NULL;
+
+                    (*it).getMeshData(tempVertices, tempTriangles, liquid);
+
+                    // first handle collision mesh
+                    transform(tempVertices, transformedVertices, scale, rotation, position);
+
+                    int offset = meshData.solidVerts.size() / 3;
+
+                    copyVertices(transformedVertices, meshData.solidVerts);
+                    copyIndices(tempTriangles, meshData.solidTris, offset, isM2);
+
+                    // now handle liquid data
+                    if (liquid)
+                    {
+                        vector<Vector3> liqVerts;
+                        vector<int> liqTris;
+                        uint32 tilesX, tilesY, vertsX, vertsY;
+                        Vector3 corner;
+                        liquid->getPosInfo(tilesX, tilesY, corner);
+                        vertsX = tilesX + 1;
+                        vertsY = tilesY + 1;
+                        uint8* flags = liquid->GetFlagsStorage();
+                        float* data = liquid->GetHeightStorage();
+                        uint8 type;
+
+                        // convert liquid type to NavTerrain
+                        switch (liquid->GetType())
+                        {
+                            case 0:
+                            case 1:
+                                type = NAV_WATER;
+                                break;
+                            case 2:
+                                type = NAV_MAGMA;
+                                break;
+                            case 3:
+                                type = NAV_SLIME;
+                                break;
+                        }
+
+                        // indexing is weird...
+                        // after a lot of trial and error, this is what works:
+                        // vertex = y*vertsX+x
+                        // tile   = x*tilesY+y
+                        // flag   = y*tilesY+x
+
+                        Vector3 vert;
+                        for (uint32 x = 0; x < vertsX; ++x)
+                            for (uint32 y = 0; y < vertsY; ++y)
+                            {
+                                vert = Vector3(corner.x + x * GRID_PART_SIZE, corner.y + y * GRID_PART_SIZE, data[y*vertsX + x]);
+                                vert = vert * rotation * scale + position;
+                                vert.x *= -1.f;
+                                vert.y *= -1.f;
+                                liqVerts.push_back(vert);
+                            }
+
+                        int idx1, idx2, idx3, idx4;
+                        uint32 square;
+                        for (uint32 x = 0; x < tilesX; ++x)
+                            for (uint32 y = 0; y < tilesY; ++y)
+                                if ((flags[x+y*tilesX] & 0x0f) != 0x0f)
+                                {
+                                    square = x * tilesY + y;
+                                    idx1 = square+x;
+                                    idx2 = square+1+x;
+                                    idx3 = square+tilesY+1+1+x;
+                                    idx4 = square+tilesY+1+x;
+
+                                    // top triangle
+                                    liqTris.push_back(idx3);
+                                    liqTris.push_back(idx2);
+                                    liqTris.push_back(idx1);
+                                    // bottom triangle
+                                    liqTris.push_back(idx4);
+                                    liqTris.push_back(idx3);
+                                    liqTris.push_back(idx1);
+                                }
+
+                        uint32 liqOffset = meshData.liquidVerts.size() / 3;
+                        for (uint32 i = 0; i < liqVerts.size(); ++i)
+                            meshData.liquidVerts.append(liqVerts[i].y, liqVerts[i].z, liqVerts[i].x);
+                        for (uint32 i = 0; i < liqTris.size() / 3; ++i)
+                        {
+                            meshData.liquidTris.append(liqTris[i*3+1] + liqOffset, liqTris[i*3+2] + liqOffset, liqTris[i*3] + liqOffset);
+                            meshData.liquidType.append(type);
+                        }
+                    }
+                }
+            }
+        }
+        while (false);
+
+        m_vmapManager->unloadMap(mapID, tileX, tileY);
+
+        return retval;
+    }
+
+    void MapBuilder::transform(vector<Vector3> source, vector<Vector3> &transformedVertices, float scale, G3D::Matrix3 rotation, Vector3 position)
+    {
+        for (vector<Vector3>::iterator it = source.begin(); it != source.end(); ++it)
+        {
+            // apply tranform, then mirror along the horizontal axes
+            Vector3 v((*it) * rotation * scale + position);
+            v.x *= -1.f;
+            v.y *= -1.f;
+            transformedVertices.push_back(v);
+        }
+    }
+
+    void MapBuilder::copyVertices(vector<Vector3> source, G3D::Array<float> &dest)
+    {
+        for (vector<Vector3>::iterator it = source.begin(); it != source.end(); ++it)
+        {
+            dest.push_back((*it).y);
+            dest.push_back((*it).z);
+            dest.push_back((*it).x);
+        }
+    }
+
+    void MapBuilder::copyIndices(vector<MeshTriangle> source, G3D::Array<int> &dest, int offset, bool flip)
+    {
+        if (flip)
+        {
+            for (vector<MeshTriangle>::iterator it = source.begin(); it != source.end(); ++it)
+            {
+                dest.push_back((*it).idx2+offset);
+                dest.push_back((*it).idx1+offset);
+                dest.push_back((*it).idx0+offset);
+            }
+        }
+        else
+        {
+            for (vector<MeshTriangle>::iterator it = source.begin(); it != source.end(); ++it)
+            {
+                dest.push_back((*it).idx0+offset);
+                dest.push_back((*it).idx1+offset);
+                dest.push_back((*it).idx2+offset);
+            }
+        }
+    }
+
+    void MapBuilder::copyIndices(G3D::Array<int> &dest, G3D::Array<int> source, int offset)
+    {
+        int* src = source.getCArray();
+        for (int i = 0; i < source.size(); ++i)
+            dest.append(src[i] + offset);
+    }
+
+    void MapBuilder::cleanVertices(G3D::Array<float> &verts, G3D::Array<int> &tris)
+    {
+        map<int, int> vertMap;
+
+        int* t = tris.getCArray();
+        float* v = verts.getCArray();
+
+        // collect all the vertex indices from triangle
+        for (int i = 0; i < tris.size(); ++i)
+        {
+            if (vertMap.find(t[i]) != vertMap.end())
+                continue;
+
+            vertMap.insert(std::pair<int, int>(t[i], 0));
+        }
+
+        // collect the vertices
+        G3D::Array<float> cleanVerts;
+        int index, count = 0;
+        for (map<int, int>::iterator it = vertMap.begin(); it != vertMap.end(); ++it)
+        {
+            index = (*it).first;
+            (*it).second = count;
+            cleanVerts.append(v[index*3], v[index*3+1], v[index*3+2]);
+            count++;
+        }
+        verts.fastClear();
+        verts.append(cleanVerts);
+        cleanVerts.clear();
+
+        // update triangles to use new indices
+        for (int i = 0; i < tris.size(); ++i)
+        {
+            map<int, int>::iterator it;
+            if ((it = vertMap.find(t[i])) == vertMap.end())
+                continue;
+
+            t[i] = (*it).second;
+        }
+
+        vertMap.clear();
+    }
+
+    void MapBuilder::buildNavMesh(uint32 mapID, dtNavMesh* &navMesh)
+    {
+        set<uint32>* tiles = getTileList(mapID);
+
+        // old code for non-statically assigned bitmask sizes:
+        ///*** calculate number of bits needed to store tiles & polys ***/
+        //uint32 tileCount = tiles->size() * rcSqr(TILES_PER_MMTILE);
+        //tileBits = dtIlog2(dtNextPow2(tileCount);
+        //if (tileBits < 1) tileBits = 1;                                     // need at least one bit!
+        //polyBits = sizeof(dtPolyRef)*8 - SALT_MIN_BITS - tileBits;
+
+        int tileBits = STATIC_TILE_BITS;
+        int polyBits = STATIC_POLY_BITS;
+
+        int maxTiles = 1 << tileBits;
+        int maxPolysPerTile = 1 << polyBits;
+
+        /***          calculate bounds of map         ***/
+
+        uint32 tileXMin = 64, tileYMin = 64, tileXMax = 0, tileYMax = 0, tileX, tileY;
+        for (set<uint32>::iterator it = tiles->begin(); it != tiles->end(); ++it)
+        {
+            StaticMapTree::unpackTileID((*it), tileX, tileY);
+
+            if (tileX > tileXMax)
+                tileXMax = tileX;
+            else if (tileX < tileXMin)
+                tileXMin = tileX;
+
+            if (tileY > tileYMax)
+                tileYMax = tileY;
+            else if (tileY < tileYMin)
+                tileYMin = tileY;
+        }
+
+        float bmin[3], bmax[3];
+
+        // use Max because '32 - tileX' is negative for values over 32
+        getTileBounds(tileXMax, tileYMax, NULL, 0, bmin, bmax);
+
+        /***       now create the navmesh       ***/
+
+        // navmesh creation params
+        dtNavMeshParams navMeshParams;
+        memset(&navMeshParams, 0, sizeof(dtNavMeshParams));
+        navMeshParams.tileWidth = GRID_SIZE / TILES_PER_MMTILE;
+        navMeshParams.tileHeight = GRID_SIZE / TILES_PER_MMTILE;
+        rcVcopy(navMeshParams.orig, bmin);
+        navMeshParams.maxTiles = maxTiles;
+        navMeshParams.maxPolys = maxPolysPerTile;
+
+        navMesh = dtAllocNavMesh();
+        printf("Creating navMesh...                     \r");
+        if (!navMesh->init(&navMeshParams))
+        {
+            printf("Failed creating navmesh!                \n");
+            return;
+        }
+
+        char fileName[25];
+        sprintf(fileName, "mmaps/%03u.mmap", mapID);
+
+        FILE* file = fopen(fileName, "wb");
+        if (!file)
+        {
+            dtFreeNavMesh(navMesh);
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", fileName);
+            perror(message);
+            return;
+        }
+
+        // now that we know navMesh params are valid, we can write them to file
+        fwrite(&navMeshParams, sizeof(dtNavMeshParams), 1, file);
+        fclose(file);
+    }
+
+    void MapBuilder::buildMoveMapTile(uint32 mapID, uint32 tileX, uint32 tileY,
+                                      MeshData meshData, float bmin[3], float bmax[3],
+                                      dtNavMesh* navMesh)
+    {
+        // console output
+        char tileString[10];
+        sprintf(tileString, "[%02i,%02i]: ", tileX, tileY);
+
+        // open the file for writing
+        char fileName[255];
+        sprintf(fileName, "mmaps/%03u%02i%02i.mmtile", mapID, tileY, tileX);
+        FILE* file = fopen(fileName, "wb");
+        if (!file)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", fileName);
+            perror(message);
+            return;
+        }
+
+        mmapTileHeader header(m_terrainBuilder);
+        fwrite(&header, sizeof(header), 1, file);
+
+        float cellSize = .5f;       // larger number => less voxels => faster build time
+                                    // too large, and tight spaces won't be pathable.
+        float agentHeight = 1.5f;
+        float agentRadius = .1f;
+        float agentMaxClimb = 1.65f;
+
+        IntermediateValues iv;
+        initIntermediateValues(iv);
+
+        float* tVerts = meshData.solidVerts.getCArray();
+        int tVertCount = meshData.solidVerts.size() / 3;
+        int* tTris = meshData.solidTris.getCArray();
+        int tTriCount = meshData.solidTris.size() / 3;
+
+        float* lVerts = meshData.liquidVerts.getCArray();
+        int lVertCount = meshData.liquidVerts.size() / 3;
+        int* lTris = meshData.liquidTris.getCArray();
+        int lTriCount = meshData.liquidTris.size() / 3;
+        uint8* lTriFlags = meshData.liquidType.getCArray();
+
+        // init detour tile bounds
+        float tileMin[3], tileMax[3];
+        rcVcopy(tileMin, bmin);
+        rcVcopy(tileMax, bmax);
+
+        /* init mmtile config */
+        rcConfig config;
+        memset(&config, 0, sizeof(rcConfig));
+        config.maxVertsPerPoly = 6;
+
+        // these are WORLD UNIT based metrics
+        config.cs = cellSize;
+        config.ch = .3f;
+        config.walkableSlopeAngle = m_maxWalkableAngle;
+
+        // these are VOXEL-based metrics
+        config.tileSize = (int)ceilf(TILE_SIZE / config.cs);
+        config.walkableRadius = (int)ceilf(agentRadius / config.cs);
+        config.borderSize = config.walkableRadius + 3;
+        config.maxEdgeLen = 1500;
+        config.walkableHeight = (int)ceilf(agentHeight / config.ch);
+        config.walkableClimb = (int)ceilf(agentHeight / config.ch);
+        config.minRegionArea = (int)rcSqr(50);
+        config.mergeRegionArea = (int)rcSqr(20);
+        config.maxSimplificationError = 1.3f;
+        config.detailSampleDist = config.cs * 16.f;
+        config.detailSampleMaxError = config.ch * 1.f;
+
+        vector<dtTileRef> finishedTiles;
+
+        for (uint32 x = 0; x < TILES_PER_MMTILE; ++x)
+        {
+            tileMin[0] = bmin[0] + TILE_SIZE * x;
+            tileMax[0] = tileMin[0] + TILE_SIZE;
+
+            for (uint32 y = 0; y < TILES_PER_MMTILE; ++y)
+            {
+                tileMin[2] = bmin[2] + TILE_SIZE * y;
+                tileMax[2] = tileMin[2] + TILE_SIZE;
+
+                clearIntermediateValues(iv);
+
+                /* tile-specific config settings */
+                rcVcopy(config.bmin, tileMin);
+                rcVcopy(config.bmax, tileMax);
+
+                // pad bounds with a border
+                float pad = config.borderSize*config.cs;
+                config.bmin[0] -= pad;
+                config.bmin[2] -= pad;
+                config.bmax[0] += pad;
+                config.bmax[2] += pad;
+
+                // this sets the dimensions of the heightfield - should maybe happen before border padding
+                rcCalcGridSize(config.bmin, config.bmax, config.cs, &config.width, &config.height);
+
+                /* start build */
+
+                // build heightfield
+                printf("%s Building Recast Heightfield...          \r", tileString);
+                iv.heightfield = rcAllocHeightfield();
+                if (!iv.heightfield || !rcCreateHeightfield(m_rcContext, *iv.heightfield, config.width, config.height, config.bmin, config.bmax, config.cs, config.ch))
+                {
+                    printf("%s Failed building heightfield!            \n", tileString);
+                    continue;
+                }
+
+                printf("%s Rasterizing triangles...                   \r", tileString);
+
+                // flag walkable terrain triangles
+                iv.triFlags = (unsigned char*)dtAlloc(sizeof(unsigned char)*tTriCount, DT_ALLOC_PERM);
+                memset(iv.triFlags, NAV_GROUND, tTriCount*sizeof(unsigned char));
+                rcClearUnwalkableTriangles(m_rcContext, config.walkableSlopeAngle, tVerts, tVertCount, tTris, tTriCount, iv.triFlags);
+                rcRasterizeTriangles(m_rcContext, tVerts, tVertCount, tTris, iv.triFlags, tTriCount, *iv.heightfield, config.walkableClimb);
+                dtFree(iv.triFlags);
+                iv.triFlags = NULL;
+
+                // filter out unwalkable spans (order of calls matters, see rcFilterLowHangingWalkableObstacles)
+                rcFilterLowHangingWalkableObstacles(m_rcContext, config.walkableClimb, *iv.heightfield);
+                rcFilterLedgeSpans(m_rcContext, config.walkableHeight, config.walkableClimb, *iv.heightfield);
+                rcFilterWalkableLowHeightSpans(m_rcContext, config.walkableHeight, *iv.heightfield);
+
+                // do after filtering because same rules don't apply to swimming
+                rcRasterizeTriangles(m_rcContext, lVerts, lVertCount, lTris, lTriFlags, lTriCount, *iv.heightfield, config.walkableClimb);
+
+                // compact heightfield spans
+                printf("%s Compacting heightfield...               \r", tileString);
+                iv.compactHeightfield = rcAllocCompactHeightfield();
+                if (!iv.compactHeightfield || !rcBuildCompactHeightfield(m_rcContext, config.walkableHeight, config.walkableClimb, *iv.heightfield, *iv.compactHeightfield))
+                {
+                    printf("%s Failed compacting heightfield!            \n", tileString);
+                    continue;
+                }
+
+                if (!m_debugOutput)
+                {
+                    rcFreeHeightField(iv.heightfield);
+                    iv.heightfield = NULL;
+                }
+
+                // build polymesh intermediates
+                printf("%sEroding walkable area width...          \r", tileString);
+                if (!rcErodeWalkableArea(m_rcContext, config.walkableRadius, *iv.compactHeightfield))
+                {
+                    printf("%s Failed eroding area!                    \n", tileString);
+                    continue;
+                }
+
+                printf("%sSmoothing area boundaries...          \r", tileString);
+                if (!rcMedianFilterWalkableArea(m_rcContext, *iv.compactHeightfield))
+                {
+                    printf("%s Failed median filter!                    \n", tileString);
+                    continue;
+                }
+
+                printf("%s Building distance field...              \r", tileString);
+                if (!rcBuildDistanceField(m_rcContext, *iv.compactHeightfield))
+                {
+                    printf("%s Failed building distance field!         \n", tileString);
+                    continue;
+                }
+
+                // bottleneck is here
+                printf("%s Building regions...                     \r", tileString);
+                if (!rcBuildRegions(m_rcContext, *iv.compactHeightfield, config.borderSize, config.minRegionArea, config.mergeRegionArea))
+                {
+                    printf("%s Failed building regions!                \n", tileString);
+                    continue;
+                }
+
+                printf("%sBuilding contours...                    \r", tileString);
+                iv.contours = rcAllocContourSet();
+                if (!iv.contours || !rcBuildContours(m_rcContext, *iv.compactHeightfield, config.maxSimplificationError, config.maxEdgeLen, *iv.contours))
+                {
+                    printf("%s Failed building contours!               \n", tileString);
+                    continue;
+                }
+
+                // build polymesh
+                printf("%sBuilding polymesh...                    \r", tileString);
+                iv.polyMesh = rcAllocPolyMesh();
+                if (!iv.polyMesh || !rcBuildPolyMesh(m_rcContext, *iv.contours, config.maxVertsPerPoly, *iv.polyMesh))
+                {
+                    printf("%s Failed building polymesh!               \n", tileString);
+                    continue;
+                }
+
+                printf("%sBuilding polymesh detail...             \r", tileString);
+                iv.polyMeshDetail = rcAllocPolyMeshDetail();
+                if (!iv.polyMeshDetail || !rcBuildPolyMeshDetail(m_rcContext, *iv.polyMesh, *iv.compactHeightfield, config.detailSampleDist, config.detailSampleMaxError, *iv.polyMeshDetail))
+                {
+                    printf("%s Failed building polymesh detail!        \n", tileString);
+                    continue;
+                }
+
+                if (!m_debugOutput)
+                {
+                    rcFreeCompactHeightfield(iv.compactHeightfield);
+                    iv.compactHeightfield = NULL;
+                    rcFreeContourSet(iv.contours);
+                    iv.contours = NULL;
+                }
+
+                // this might be handled within Recast at some point
+                // very important, without this tiles do not get connected to neighbors!!
+                printf("%s Cleaning vertex padding...              \r", tileString);
+                for (int i = 0; i < iv.polyMesh->nverts; ++i)
+                {
+                    unsigned short* v = &iv.polyMesh->verts[i*3];
+                    v[0] -= (unsigned short)config.borderSize;
+                    v[2] -= (unsigned short)config.borderSize;
+                }
+
+                // polymesh vertex indices are stored with ushorts in detour, can't have more than 65535
+                if (iv.polyMesh->nverts >= 0xffff)
+                {
+                    printf("%s Too many vertices!                      \n", tileString);
+                    continue;
+                }
+
+                printf("%s Setting polys as walkable...            \r", tileString);
+                // handle area type here
+                // TODO: special flag for DYNAMIC polygons, ie surfaces that can be turned on and off
+                for (int i = 0; i < iv.polyMesh->npolys; ++i)
+                    if (iv.polyMesh->areas[i] & RC_WALKABLE_AREA)
+                        iv.polyMesh->flags[i] = iv.polyMesh->areas[i];
+
+                dtNavMeshCreateParams params;
+                memset(&params, 0, sizeof(params));
+                params.verts = iv.polyMesh->verts;
+                params.vertCount = iv.polyMesh->nverts;
+                params.polys = iv.polyMesh->polys;
+                params.polyAreas = iv.polyMesh->areas;
+                params.polyFlags = iv.polyMesh->flags;
+                params.polyCount = iv.polyMesh->npolys;
+                params.nvp = iv.polyMesh->nvp;
+                params.detailMeshes = iv.polyMeshDetail->meshes;
+                params.detailVerts = iv.polyMeshDetail->verts;
+                params.detailVertsCount = iv.polyMeshDetail->nverts;
+                params.detailTris = iv.polyMeshDetail->tris;
+                params.detailTriCount = iv.polyMeshDetail->ntris;
+                params.walkableHeight = agentHeight;
+                params.walkableRadius = agentRadius;
+                params.walkableClimb = agentMaxClimb;
+                float pos[3] = {(tileMin[0] + tileMax[0]) / 2, 0.f, (tileMin[2] + tileMax[2]) / 2}; // center of current dtTile
+                navMesh->calcTileLoc(pos, &params.tileX, &params.tileY);
+                rcVcopy(params.bmin, tileMin);
+                rcVcopy(params.bmax, tileMax);
+                params.cs = config.cs;
+                params.ch = config.ch;
+                params.tileSize = config.tileSize;
+
+                // will hold final navmesh
+                unsigned char* navData = NULL;
+                int navDataSize = 0;
+
+                // these values are checked within dtCreateNavMeshData - handle them here
+                // so we have a clear error message
+                if (params.nvp > DT_VERTS_PER_POLYGON)
+                {
+                    printf("%s Invalid verts-per-polygon value!        \n", tileString);
+                    continue;
+                }
+                if (params.vertCount >= 0xffff)
+                {
+                    printf("%s Too many vertices!                      \n", tileString);
+                    continue;
+                }
+                if (!params.vertCount || !params.verts)
+                {
+                    // occurs mostly when adjacent tiles have models
+                    // loaded but those models don't span into this tile
+
+                    // message is an annoyance
+                    //printf("%sNo vertices to build tile!              \n", tileString);
+                    continue;
+                }
+                if (!params.polyCount || !params.polys)
+                {
+                    printf("%s No polygons to build tile!              \n", tileString);
+                    continue;
+                }
+                if (!params.detailMeshes || !params.detailVerts || !params.detailTris)
+                {
+                    printf("%s No detail mesh to build tile!           \n", tileString);
+                    continue;
+                }
+
+                printf("%s Building navmesh tile...                \r", tileString);
+                if (!dtCreateNavMeshData(&params, &navData, &navDataSize))
+                {
+                    printf("%s Failed building navmesh tile!           \n", tileString);
+                    continue;
+                }
+
+                dtTileRef tileRef = 0;
+                printf("%s Adding tile to navmesh...                \r", tileString);
+                // DT_TILE_FREE_DATA tells detour to unallocate memory when the tile
+                // is removed via removeTile()
+                dtStatus dtResult = navMesh->addTile(navData, navDataSize, 0, 0, &tileRef);
+                if (!tileRef || dtResult != DT_SUCCESS)
+                {
+                    printf("%s Failed adding tile to navmesh!           \n", tileString);
+                    continue;
+                }
+
+                // store tile ref so that tile can be written to disk later
+                finishedTiles.push_back(tileRef);
+                ++header.tileCount;
+
+                // TODO: writing this to file does no good, debug data is just overwritten by next tile
+                //if (m_debugOutput)
+                //{
+                //    for (int i = 0; i < iv.polyMesh->nverts; ++i)
+                //    {
+                //        unsigned short* v = &iv.polyMesh->verts[i*3];
+                //        v[0] += (unsigned short)config.borderSize;
+                //        v[2] += (unsigned short)config.borderSize;
+                //    }
+                //    writeIV(mapID, tileX, tileY, iv);
+                //}
+            }
+        }
+
+        printf("%s Writing to file...                      \r", tileString);
+        for (vector<dtTileRef>::iterator it = finishedTiles.begin(); it != finishedTiles.end(); ++it)
+        {
+            int dataSize;
+            unsigned char* data;
+
+            // remove the tile from the mesh, and retrieve the tile's data so that
+            // we can write it to disk
+            navMesh->removeTile(*it, &data, &dataSize);
+
+            fwrite(&dataSize, sizeof(dataSize), 1, file);
+            fwrite(data, sizeof(unsigned char), dataSize, file);
+
+            // free memory used by tile
+            dtFree(data);
+        }
+
+        // re-write header, so that tilecount is up to date
+        fseek(file, 0, SEEK_SET);
+        fwrite(&header, sizeof(header), 1, file);
+        fclose(file);
+
+        if (m_debugOutput)
+            generateObjFile(mapID, tileX, tileY, meshData);
+
+        m_rcContext->resetLog();
+    }
+
+    void MapBuilder::getTileBounds(uint32 tileX, uint32 tileY, float* verts, int vertCount, float* bmin, float* bmax)
+    {
+        // this is for elevation
+        if (verts && vertCount)
+            rcCalcBounds(verts, vertCount, bmin, bmax);
+        else
+        {
+            bmin[1] = FLT_MIN;
+            bmax[1] = FLT_MAX;
+        }
+
+        // this is for width and depth
+        bmax[0] = (32 - int(tileX)) * GRID_SIZE;
+        bmax[2] = (32 - int(tileY)) * GRID_SIZE;
+        bmin[0] = bmax[0] - GRID_SIZE;
+        bmin[2] = bmax[2] - GRID_SIZE;
+    }
+
+    void MapBuilder::initIntermediateValues(IntermediateValues &iv)
+    {
+        iv.compactHeightfield = NULL;
+        iv.heightfield = NULL;
+        iv.triFlags = NULL;
+        iv.contours = NULL;
+        iv.polyMesh = NULL;
+        iv.polyMeshDetail = NULL;
+    }
+
+    void MapBuilder::clearIntermediateValues(IntermediateValues &iv)
+    {
+        rcFreeCompactHeightfield(iv.compactHeightfield); iv.compactHeightfield = NULL;
+        rcFreeHeightField(iv.heightfield); iv.heightfield = NULL;
+        rcFreeContourSet(iv.contours); iv.contours = NULL;
+        rcFreePolyMesh(iv.polyMesh); iv.polyMesh = NULL;
+        rcFreePolyMeshDetail(iv.polyMeshDetail); iv.polyMeshDetail = NULL;
+        dtFree(iv.triFlags); iv.triFlags = NULL;
+    }
+
+    void MapBuilder::generateObjFile(uint32 mapID, uint32 tileX, uint32 tileY, MeshData meshData)
+    {
+        generateRealObj(mapID, tileX, tileY, meshData);
+
+        char tileString[25];
+        sprintf(tileString, "[%02u,%02u]: ", tileX, tileY);
+        printf("%s Writing debug output...                       \r", tileString);
+
+        char objFileName[255];
+        sprintf(objFileName, "meshes/%03u.map", mapID);
+
+        FILE* objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        char b = '\0';
+        fwrite(&b, sizeof(char), 1, objFile);
+        fclose(objFile);
+
+        sprintf(objFileName, "meshes/%03u%02u%02u.mesh", mapID, tileY, tileX);
+        objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        G3D::Array<float> allVerts;
+        G3D::Array<int> allTris;
+
+        allTris.append(meshData.liquidTris);
+        allVerts.append(meshData.liquidVerts);
+        copyIndices(allTris, meshData.solidTris, allVerts.size() / 3);
+        allVerts.append(meshData.solidVerts);
+
+        float* verts = allVerts.getCArray();
+        int vertCount = allVerts.size() / 3;
+        int* tris = allTris.getCArray();
+        int triCount = allTris.size() / 3;
+
+        fwrite(&vertCount, sizeof(int), 1, objFile);
+        fwrite(verts, sizeof(float), vertCount*3, objFile);
+        fflush(objFile);
+
+        fwrite(&triCount, sizeof(int), 1, objFile);
+        fwrite(tris, sizeof(int), triCount*3, objFile);
+        fflush(objFile);
+
+        fclose(objFile);
+    }
+
+    void MapBuilder::generateRealObj(uint32 mapID, uint32 tileX, uint32 tileY, MeshData meshData)
+    {
+        char objFileName[255];
+        sprintf(objFileName, "meshes/map%03u.obj", mapID);
+
+        FILE* objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        G3D::Array<float> allVerts;
+        G3D::Array<int> allTris;
+
+        allTris.append(meshData.liquidTris);
+        allVerts.append(meshData.liquidVerts);
+        copyIndices(allTris, meshData.solidTris, allVerts.size() / 3);
+        allVerts.append(meshData.solidVerts);
+
+        float* verts = allVerts.getCArray();
+        int* tris = allTris.getCArray();
+
+        for (int i = 0; i < allVerts.size() / 3; i++)
+            fprintf(objFile, "v %f %f %f\n", verts[i*3], verts[i*3 + 1], verts[i*3 + 2]);
+
+        for (int i = 0; i < allTris.size() / 3; i++)
+            fprintf(objFile, "f %i %i %i\n", tris[i*3] + 1, tris[i*3 + 1] + 1, tris[i*3 + 2] + 1);
+
+        fclose(objFile);
+    }
+
+    void MapBuilder::writeIV(uint32 mapID, uint32 tileX, uint32 tileY, IntermediateValues iv)
+    {
+        char fileName[255];
+        char tileString[25];
+        FILE* file;
+
+        sprintf(tileString, "[%02u,%02u]: ", tileX, tileY);
+
+        printf("%s Writing debug output...                       \r", tileString);
+
+        string name("meshes/%03u%02i%02i.");
+
+#define DEBUG_WRITE(fileExtension,data) \
+        sprintf(fileName, (name + fileExtension).c_str(), mapID, tileY, tileX); \
+        file = fopen(fileName, "wb"); \
+        if (!file) \
+        { \
+            char message[1024]; \
+            sprintf(message, "%s Failed to open %s for writing!\n",  tileString, fileName); \
+            perror(message); \
+        } \
+        else \
+            debugWrite(file, data); \
+        if(file) fclose(file); \
+        printf("%s Writing debug output...                       \r", tileString)
+
+        DEBUG_WRITE("hf", iv.heightfield);
+        DEBUG_WRITE("chf", iv.compactHeightfield);
+        DEBUG_WRITE("cs", iv.contours);
+        DEBUG_WRITE("pmesh", iv.polyMesh);
+        DEBUG_WRITE("dmesh", iv.polyMeshDetail);
+
+#undef DEBUG_WRITE
+    }
+
+    void MapBuilder::debugWrite(FILE* file, const rcHeightfield* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->cs), sizeof(float), 1, file);
+        fwrite(&(mesh->ch), sizeof(float), 1, file);
+        fwrite(&(mesh->width), sizeof(int), 1, file);
+        fwrite(&(mesh->height), sizeof(int), 1, file);
+        fwrite(mesh->bmin, sizeof(float), 3, file);
+        fwrite(mesh->bmax, sizeof(float), 3, file);
+
+        for (int y = 0; y < mesh->height; ++y)
+            for (int x = 0; x < mesh->width; ++x)
+            {
+                rcSpan* span = mesh->spans[x+y*mesh->width];
+
+                // first, count the number of spans
+                int spanCount = 0;
+                while (span)
+                {
+                    spanCount++;
+                    span = span->next;
+                }
+
+                // write the span count
+                fwrite(&spanCount, sizeof(int), 1, file);
+
+                // write the spans
+                span = mesh->spans[x+y*mesh->width];
+                while (span)
+                {
+                    fwrite(span, sizeof(rcSpan), 1, file);
+                    span = span->next;
+                }
+            }
+    }
+
+    void MapBuilder::debugWrite(FILE* file, const rcCompactHeightfield* chf)
+    {
+        if (!file | !chf)
+            return;
+
+        fwrite(&(chf->width), sizeof(chf->width), 1, file);
+        fwrite(&(chf->height), sizeof(chf->height), 1, file);
+        fwrite(&(chf->spanCount), sizeof(chf->spanCount), 1, file);
+
+        fwrite(&(chf->walkableHeight), sizeof(chf->walkableHeight), 1, file);
+        fwrite(&(chf->walkableClimb), sizeof(chf->walkableClimb), 1, file);
+
+        fwrite(&(chf->maxDistance), sizeof(chf->maxDistance), 1, file);
+        fwrite(&(chf->maxRegions), sizeof(chf->maxRegions), 1, file);
+
+        fwrite(chf->bmin, sizeof(chf->bmin), 1, file);
+        fwrite(chf->bmax, sizeof(chf->bmax), 1, file);
+
+        fwrite(&(chf->cs), sizeof(chf->cs), 1, file);
+        fwrite(&(chf->ch), sizeof(chf->ch), 1, file);
+
+        int tmp = 0;
+        if (chf->cells) tmp |= 1;
+        if (chf->spans) tmp |= 2;
+        if (chf->dist) tmp |= 4;
+        if (chf->areas) tmp |= 8;
+
+        fwrite(&tmp, sizeof(tmp), 1, file);
+
+        if (chf->cells)
+            fwrite(chf->cells, sizeof(rcCompactCell), chf->width*chf->height, file);
+        if (chf->spans)
+            fwrite(chf->spans, sizeof(rcCompactSpan), chf->spanCount, file);
+        if (chf->dist)
+            fwrite(chf->dist, sizeof(unsigned short), chf->spanCount, file);
+        if (chf->areas)
+            fwrite(chf->areas, sizeof(unsigned char), chf->spanCount, file);
+    }
+
+    void MapBuilder::debugWrite(FILE* file, const rcContourSet* cs)
+    {
+        if (!file || !cs)
+            return;
+
+        fwrite(&(cs->cs), sizeof(float), 1, file);
+        fwrite(&(cs->ch), sizeof(float), 1, file);
+        fwrite(cs->bmin, sizeof(float), 3, file);
+        fwrite(cs->bmax, sizeof(float), 3, file);
+        fwrite(&(cs->nconts), sizeof(int), 1, file);
+        for (int i = 0; i < cs->nconts; ++i)
+        {
+            fwrite(&cs->conts[i].area, sizeof(unsigned char), 1, file);
+            fwrite(&cs->conts[i].reg, sizeof(unsigned short), 1, file);
+            fwrite(&cs->conts[i].nverts, sizeof(int), 1, file);
+            fwrite(cs->conts[i].verts, sizeof(int), cs->conts[i].nverts*4, file);
+            fwrite(&cs->conts[i].nrverts, sizeof(int), 1, file);
+            fwrite(cs->conts[i].rverts, sizeof(int), cs->conts[i].nrverts*4, file);
+        }
+    }
+
+    void MapBuilder::debugWrite(FILE* file, const rcPolyMesh* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->cs), sizeof(float), 1, file);
+        fwrite(&(mesh->ch), sizeof(float), 1, file);
+        fwrite(&(mesh->nvp), sizeof(int), 1, file);
+        fwrite(mesh->bmin, sizeof(float), 3, file);
+        fwrite(mesh->bmax, sizeof(float), 3, file);
+        fwrite(&(mesh->nverts), sizeof(int), 1, file);
+        fwrite(mesh->verts, sizeof(unsigned short), mesh->nverts*3, file);
+        fwrite(&(mesh->npolys), sizeof(int), 1, file);
+        fwrite(mesh->polys, sizeof(unsigned short), mesh->npolys*mesh->nvp*2, file);
+        fwrite(mesh->flags, sizeof(unsigned short), mesh->npolys, file);
+        fwrite(mesh->areas, sizeof(unsigned char), mesh->npolys, file);
+        fwrite(mesh->regs, sizeof(unsigned short), mesh->npolys, file);
+    }
+
+    void MapBuilder::debugWrite(FILE* file, const rcPolyMeshDetail* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->nverts), sizeof(int), 1, file);
+        fwrite(mesh->verts, sizeof(float), mesh->nverts*3, file);
+        fwrite(&(mesh->ntris), sizeof(int), 1, file);
+        fwrite(mesh->tris, sizeof(char), mesh->ntris*4, file);
+        fwrite(&(mesh->nmeshes), sizeof(int), 1, file);
+        fwrite(mesh->meshes, sizeof(int), mesh->nmeshes*4, file);
+    }
+
+    bool MapBuilder::shouldSkipMap(uint32 mapID)
+    {
+        if (m_skipContinents)
+            switch (mapID)
+            {
+                case 0:
+                case 1:
+                case 530:
+                case 571:
+                    return true;
+                default:
+                    break;
+            }
+
+        if (m_skipJunkMaps)
+            switch (mapID)
+            {
+                case 13:    // test.wdt
+                case 25:    // ScottTest.wdt
+                case 29:    // Test.wdt
+                case 42:    // Colin.wdt
+                case 169:   // EmeraldDream.wdt (unused, and very large)
+                case 451:   // development.wdt
+                case 573:   // ExteriorTest.wdt
+                case 597:   // CraigTest.wdt
+                case 605:   // development_nonweighted.wdt
+                case 606:   // QA_DVD.wdt
+                    return true;
+                default:
+                    if (isTransportMap(mapID))
+                        return true;
+                    break;
+            }
+
+        if (m_skipBattlegrounds)
+            switch (mapID)
+            {
+                case 30:    // AV
+                case 37:    // ?
+                case 489:   // WSG
+                case 529:   // AB
+                case 566:   // EotS
+                case 607:   // SotA
+                case 628:   // IoC
+                    return true;
+                default:
+                    break;
+            }
+
+        return false;
+    }
+
+    bool MapBuilder::isTransportMap(uint32 mapID)
+    {
+        switch (mapID)
+        {
+            // transport maps
+            case 582:
+            case 584:
+            case 586:
+            case 587:
+            case 588:
+            case 589:
+            case 590:
+            case 591:
+            case 592:
+            case 593:
+            case 594:
+            case 596:
+            case 610:
+            case 612:
+            case 613:
+            case 614:
+            case 620:
+            case 621:
+            case 622:
+            case 623:
+            case 641:
+            case 642:
+            case 647:
+            case 672:
+            case 673:
+            case 712:
+            case 713:
+            case 718:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    bool MapBuilder::shouldSkipTile(uint32 mapID, uint32 tileX, uint32 tileY)
+    {
+        char fileName[255];
+        sprintf(fileName, "mmaps/%03u%02i%02i.mmtile", mapID, tileY, tileX);
+        FILE* file = fopen(fileName, "rb");
+        if (!file)
+            return false;
+
+        mmapTileHeader header;
+        fread(&header, sizeof(header), 1, file);
+        fclose(file);
+
+        if (header.mmapMagic != MMAP_MAGIC || header.dtVersion != DT_NAVMESH_VERSION)
+            return false;
+
+        if (header.mmapVersion != MMAP_VERSION)
+            return false;
+
+        return true;
+    }
+}
diff -r dc4fc5c8b306 src/tools/movements_extractor/MapBuilder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/MapBuilder.h	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAP_BUILDER_H
+#define _MAP_BUILDER_H
+
+#include <vector>
+#include <set>
+#include <map>
+
+#include "TerrainBuilder.h"
+#include "IVMapManager.h"
+#include "WorldModel.h"
+#include "Recast.h"
+#include "DetourNavMesh.h"
+
+using namespace std;
+using namespace VMAP;
+// G3D namespace typedefs conflicts with ACE typedefs
+
+#define MMAP_MAGIC 0x4d4d4150   // 'MMAP'
+#define MMAP_VERSION 1
+
+#define TILES_PER_MMTILE 16
+#define TILE_SIZE (GRID_SIZE / TILES_PER_MMTILE)
+
+namespace Pathfinding
+{
+    typedef map<uint32,set<uint32>*> TileList;
+
+    struct IntermediateValues
+    {
+        rcHeightfield* heightfield;
+        unsigned char* triFlags;
+        rcCompactHeightfield* compactHeightfield;
+        rcContourSet* contours;
+        rcPolyMesh* polyMesh;
+        rcPolyMeshDetail* polyMeshDetail;
+    };
+
+    struct mmapTileHeader
+    {
+        uint32 mmapMagic;
+        uint32 dtVersion;
+        uint32 mmapVersion;
+        uint32 tileCount;
+        bool usesHiRes : 1;
+        bool usesLiquids : 1;
+
+        mmapTileHeader() :
+            mmapMagic(MMAP_MAGIC),
+            dtVersion(DT_NAVMESH_VERSION),
+            mmapVersion(MMAP_VERSION),
+            tileCount(0)
+        {}
+
+        mmapTileHeader(TerrainBuilder* terrainBuilder) :
+            mmapMagic(MMAP_MAGIC),
+            dtVersion(DT_NAVMESH_VERSION),
+            mmapVersion(MMAP_VERSION),
+            tileCount(0)
+        {
+            usesHiRes = terrainBuilder->usesHiRes();
+            usesLiquids = terrainBuilder->usesLiquids();
+        }
+
+    private:
+        mmapTileHeader(const mmapTileHeader &header);
+    };
+
+    class MapBuilder
+    {
+        public:
+            MapBuilder(float maxWalkableAngle   = 60.f,
+                       bool skipLiquid          = false,
+                       bool skipContinents      = true,
+                       bool skipJunkMaps        = true,
+                       bool skipBattlegrounds   = true,
+                       bool hiResHeightmaps     = false,
+                       bool debugOutput         = false);
+
+            ~MapBuilder();
+
+            // builds all mmap tiles for the specified map id (ignores skip settings)
+            void build(uint32 mapID);
+
+            // builds an mmap tile for the specified map tile (ignores skip settings)
+            void buildTile(uint32 mapID, uint32 tileX, uint32 tileY);
+
+            // builds list of maps, then builds all of mmap tiles (based on the skip settings)
+            void buildAll();
+
+        private:
+            // detect maps and tiles
+            void discoverTiles();
+            set<uint32>* getTileList(uint32 mapID);
+
+            // load and unload models
+            bool loadVMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData);
+
+            // vert and triangle methods
+            void transform(vector<Vector3> original, vector<Vector3> &transformed,
+                           float scale, G3D::Matrix3 rotation, Vector3 position);
+            void copyVertices(vector<Vector3> source, G3D::Array<float> &dest);
+            void copyIndices(vector<MeshTriangle> source, G3D::Array<int> &dest, int offest, bool flip);
+            void copyIndices(G3D::Array<int> &dest, G3D::Array<int> src, int offset);
+            void cleanVertices(G3D::Array<float> &verts, G3D::Array<int> &tris);
+
+            // move map building
+            void buildMoveMap(uint32 mapID);
+            void buildNavMesh(uint32 mapID, dtNavMesh* &navMesh);
+            void buildMoveMapTile(uint32 mapID,
+                                  uint32 tileX,
+                                  uint32 tileY,
+                                  MeshData meshData,
+                                  float bmin[3],
+                                  float bmax[3],
+                                  dtNavMesh* navMesh);
+
+            void getTileBounds(uint32 tileX, uint32 tileY,
+                               float* verts, int vertCount,
+                               float* bmin, float* bmax);
+
+            void initIntermediateValues(IntermediateValues &iv);
+            void clearIntermediateValues(IntermediateValues &iv);
+
+            bool shouldSkipMap(uint32 mapID);
+            bool isTransportMap(uint32 mapID);
+            bool shouldSkipTile(uint32 mapID, uint32 tileX, uint32 tileY);
+
+            // debug output
+            void generateObjFile(uint32 mapID, uint32 tileX, uint32 tileY, MeshData meshData);
+            void generateRealObj(uint32 mapID, uint32 tileX, uint32 tileY, MeshData meshData);
+            void writeIV(uint32 mapID, uint32 tileX, uint32 tileY, IntermediateValues iv);
+            void debugWrite(FILE* file, const rcHeightfield* hf);
+            void debugWrite(FILE* file, const rcSpan* span);
+            void debugWrite(FILE* file, const rcCompactHeightfield* chf);
+            void debugWrite(FILE* file, const rcContourSet* cs);
+            void debugWrite(FILE* file, const rcPolyMesh* mesh);
+            void debugWrite(FILE* file, const rcPolyMeshDetail* mesh);
+
+            IVMapManager* m_vmapManager;
+            TerrainBuilder* m_terrainBuilder;
+
+            TileList m_tiles;
+
+            bool m_debugOutput;
+
+            bool m_skipContinents;
+            bool m_skipJunkMaps;
+            bool m_skipBattlegrounds;
+
+            float m_maxWalkableAngle;
+
+            rcContext* m_rcContext;
+    };
+}
+
+#endif
\ No newline at end of file
diff -r dc4fc5c8b306 src/tools/movements_extractor/TerrainBuilder.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/TerrainBuilder.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sstream>
+
+#include "TerrainBuilder.h"
+#include "Map.h"
+
+namespace Pathfinding
+{
+    TerrainBuilder::TerrainBuilder(bool skipLiquid, bool hiRes) :
+        m_hiResHeightMaps   (hiRes),
+        m_skipLiquid        (skipLiquid)
+    {
+    }
+
+    TerrainBuilder::~TerrainBuilder()
+    {
+    }
+
+    void TerrainBuilder::getLoopVars(Spot portion, int &loopStart, int &loopEnd, int &loopInc)
+    {
+        switch(portion)
+        {
+            case ENTIRE:
+                loopStart = 0;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = 1;
+                break;
+            case TOP:
+                loopStart = 0;
+                loopEnd = V8_SIZE;
+                loopInc = 1;
+                break;
+            case LEFT:
+                loopStart = 0;
+                loopEnd = V8_SIZE_SQ - V8_SIZE + 1;
+                loopInc = V8_SIZE;
+                break;
+            case RIGHT:
+                loopStart = V8_SIZE - 1;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = V8_SIZE;
+                break;
+            case BOTTOM:
+                loopStart = V8_SIZE_SQ - V8_SIZE;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = 1;
+                break;
+        }
+    }
+
+    void TerrainBuilder::loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData)
+    {
+        if (loadMap(mapID, tileX, tileY, meshData, ENTIRE))
+        {
+            loadMap(mapID, tileX+1, tileY, meshData, LEFT);
+            loadMap(mapID, tileX-1, tileY, meshData, RIGHT);
+            loadMap(mapID, tileX, tileY+1, meshData, TOP);
+            loadMap(mapID, tileX, tileY-1, meshData, BOTTOM);
+        }
+    }
+
+    bool TerrainBuilder::loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData, Spot portion)
+    {
+        char mapFileName[255];
+        sprintf(mapFileName, "maps/%03u%02u%02u.map", mapID, tileY, tileX);
+
+        FILE* mapFile = fopen(mapFileName, "rb");
+        if (!mapFile)
+            return false;
+
+        map_fileheader fheader;
+        fread(&fheader, sizeof(map_fileheader), 1, mapFile);
+
+        if (fheader.versionMagic != uint32(MAP_VERSION_MAGIC))
+        {
+            fclose(mapFile);
+            printf("%s is the wrong version, please extract new .map files\n", mapFileName);
+            return false;
+        }
+
+        map_heightHeader hheader;
+        fseek(mapFile, fheader.heightMapOffset, SEEK_SET);
+        fread(&hheader, sizeof(map_heightHeader), 1, mapFile);
+
+        bool haveTerrain = !(hheader.flags & MAP_HEIGHT_NO_HEIGHT);
+        bool haveLiquid = fheader.liquidMapOffset && !m_skipLiquid;
+
+        // no data in this map file
+        if (!haveTerrain && !haveLiquid)
+        {
+            fclose(mapFile);
+            return false;
+        }
+
+        // data used later
+        uint16 holes[16][16];
+        memset(holes, 0, sizeof(holes)); 
+        uint8 liquid_type[16][16]; 
+        memset(liquid_type, 0, sizeof(liquid_type)); 
+
+        G3D::Array<int> ltriangles;
+        G3D::Array<int> ttriangles;
+
+        // terrain data
+        if (haveTerrain)
+        {
+            int i;
+            float heightMultiplier;
+            float V9[V9_SIZE_SQ], V8[V8_SIZE_SQ];
+
+            if (hheader.flags & MAP_HEIGHT_AS_INT8)
+            {
+                uint8 v9[V9_SIZE_SQ];
+                uint8 v8[V8_SIZE_SQ];
+                fread(v9, sizeof(uint8), V9_SIZE_SQ, mapFile);
+                fread(v8, sizeof(uint8), V8_SIZE_SQ, mapFile);
+                heightMultiplier = (hheader.gridMaxHeight - hheader.gridHeight) / 255;
+
+                for (i = 0; i < V9_SIZE_SQ; ++i)
+                    V9[i] = (float)v9[i]*heightMultiplier + hheader.gridHeight;
+
+                if (m_hiResHeightMaps)
+                    for (i = 0; i < V8_SIZE_SQ; ++i)
+                        V8[i] = (float)v8[i]*heightMultiplier + hheader.gridHeight;
+            }
+            else if (hheader.flags & MAP_HEIGHT_AS_INT16)
+            {
+                uint16 v9[V9_SIZE_SQ];
+                uint16 v8[V8_SIZE_SQ];
+                fread(v9, sizeof(uint16), V9_SIZE_SQ, mapFile);
+                fread(v8, sizeof(uint16), V8_SIZE_SQ, mapFile);
+                heightMultiplier = (hheader.gridMaxHeight - hheader.gridHeight) / 65535;
+
+                for (i = 0; i < V9_SIZE_SQ; ++i)
+                    V9[i] = (float)v9[i]*heightMultiplier + hheader.gridHeight;
+
+                if (m_hiResHeightMaps)
+                    for (i = 0; i < V8_SIZE_SQ; ++i)
+                        V8[i] = (float)v8[i]*heightMultiplier + hheader.gridHeight;
+            }
+            else
+            {
+                fread(V9, sizeof(float), V9_SIZE_SQ, mapFile);
+                if (m_hiResHeightMaps)
+                    fread(V8, sizeof(float), V8_SIZE_SQ, mapFile);
+            }
+
+            // hole data
+            memset(holes, 0, fheader.holesSize);
+            fseek(mapFile, fheader.holesOffset, SEEK_SET);
+            fread(holes, fheader.holesSize, 1, mapFile);
+
+            int count = meshData.solidVerts.size() / 3;
+            float xoffset = (float(tileX)-32)*GRID_SIZE;
+            float yoffset = (float(tileY)-32)*GRID_SIZE;
+
+            float coord[3];
+
+            for (i = 0; i < V9_SIZE_SQ; ++i)
+            {
+                getHeightCoord(i, GRID_V9, xoffset, yoffset, coord, V9);
+                meshData.solidVerts.append(coord[0]);
+                meshData.solidVerts.append(coord[2]);
+                meshData.solidVerts.append(coord[1]);
+            }
+
+            if (m_hiResHeightMaps)
+                for (i = 0; i < V8_SIZE_SQ; ++i)
+                {
+                    getHeightCoord(i, GRID_V8, xoffset, yoffset, coord, V8);
+                    meshData.solidVerts.append(coord[0]);
+                    meshData.solidVerts.append(coord[2]);
+                    meshData.solidVerts.append(coord[1]);
+                }
+
+            int triInc, j, indices[3], loopStart, loopEnd, loopInc;
+            getLoopVars(portion, loopStart, loopEnd, loopInc);
+
+            triInc = m_hiResHeightMaps ? 1 : BOTTOM-TOP;
+
+            for (i = loopStart; i < loopEnd; i+=loopInc)
+                    for (j = TOP; j <= BOTTOM; j+=triInc)
+                    {
+                        getHeightTriangle(i, Spot(j), indices);
+                        ttriangles.append(indices[2] + count);
+                        ttriangles.append(indices[1] + count);
+                        ttriangles.append(indices[0] + count);
+                    }
+        }
+
+        // liquid data
+        if (haveLiquid)
+        {
+            do
+            {
+                map_liquidHeader lheader;
+                fseek(mapFile, fheader.liquidMapOffset, SEEK_SET);
+                fread(&lheader, sizeof(map_liquidHeader), 1, mapFile);
+
+                float* liquid_map = 0;
+
+                if (!(lheader.flags & MAP_LIQUID_NO_TYPE))
+                    fread(liquid_type, sizeof(liquid_type), 1, mapFile);
+
+                if (!(lheader.flags & MAP_LIQUID_NO_HEIGHT))
+                {
+                    liquid_map = new float [lheader.width*lheader.height];
+                    fread(liquid_map, sizeof(float), lheader.width*lheader.height, mapFile);
+                }
+
+                if (!liquid_type && !liquid_map)
+                    break;
+
+                int count = meshData.liquidVerts.size() / 3;
+                float xoffset = (float(tileX)-32)*GRID_SIZE;
+                float yoffset = (float(tileY)-32)*GRID_SIZE;
+
+                float coord[3];
+                int row, col;
+
+                // generate coordinates
+                if (!(lheader.flags & MAP_LIQUID_NO_HEIGHT))
+                {
+                    int j = 0;
+                    for (int i = 0; i < V9_SIZE_SQ; ++i)
+                    {
+                        row = i / V9_SIZE;
+                        col = i % V9_SIZE;
+                        if ((row < (lheader.offsetY) || row >= (lheader.offsetY + lheader.height)) ||
+                           (col < (lheader.offsetX) || col >= (lheader.offsetX + lheader.width)))
+                        {
+                            // dummy vert using invalid height
+                            meshData.liquidVerts.append((xoffset+col*GRID_PART_SIZE)*-1, INVALID_MAP_LIQ_HEIGHT, (yoffset+row*GRID_PART_SIZE)*-1);
+                            continue;
+                        }
+
+                        getLiquidCoord(i, j, xoffset, yoffset, coord, liquid_map);
+                        meshData.liquidVerts.append(coord[0]);
+                        meshData.liquidVerts.append(coord[2]);
+                        meshData.liquidVerts.append(coord[1]);
+                        j++;
+                    }
+                }
+                else
+                {
+                    for (int i = 0; i < V9_SIZE_SQ; ++i)
+                    {
+                        row = i / V9_SIZE;
+                        col = i % V9_SIZE;
+                        meshData.liquidVerts.append((xoffset+col*GRID_PART_SIZE)*-1, lheader.liquidLevel, (yoffset+row*GRID_PART_SIZE)*-1);
+                    }
+                }
+
+                delete [] liquid_map;
+
+                int indices[3], loopStart, loopEnd, loopInc, triInc;
+                getLoopVars(portion, loopStart, loopEnd, loopInc);
+                triInc = BOTTOM-TOP;
+
+                // generate triangles
+                for (int i = loopStart; i < loopEnd; i+=loopInc)
+                    for (int j = TOP; j <= BOTTOM; j+= triInc)
+                    {
+                        getHeightTriangle(i, Spot(j), indices, true);
+                        ltriangles.append(indices[2] + count);
+                        ltriangles.append(indices[1] + count);
+                        ltriangles.append(indices[0] + count);
+                    }
+
+            }while(0);
+        }
+
+        fclose(mapFile);
+
+        // now that we have gathered the data, we can figure out which parts to keep:
+        // liquid above ground
+        // ground above any liquid type
+        // ground below <1.5 yard of water
+
+        int loopStart, loopEnd, loopInc, tTriCount;
+        bool useTerrain, useLiquid;
+
+        float* lverts = meshData.liquidVerts.getCArray();
+        float* tverts = meshData.solidVerts.getCArray();
+        int* ltris = ltriangles.getCArray();
+        int* ttris = ttriangles.getCArray();
+
+        getLoopVars(portion, loopStart, loopEnd, loopInc);
+        tTriCount = m_hiResHeightMaps ? 4 : 2;
+
+        if (ltriangles.size() || ttriangles.size())
+        {
+            for (int i = loopStart; i < loopEnd; i+=loopInc)
+            {
+                for (int j = 0; j < 2; ++j)
+                {
+                    // default is true, will change to false if needed
+                    useTerrain = true;
+                    useLiquid = true;
+                    uint8 liquidType;
+
+                    // if there is no liquid, don't use liquid
+                    if (!liquid_type ||
+                       !meshData.liquidVerts.size() ||
+                       !ltriangles.size())
+                        useLiquid = false;
+                    else
+                    {
+                        liquidType = getLiquidType(i, liquid_type);
+                        switch(liquidType)
+                        {
+                            default:
+                                useLiquid = false;
+                                break;
+                            case MAP_LIQUID_TYPE_WATER:
+                            case MAP_LIQUID_TYPE_OCEAN:
+                                // merge different types of water
+                                liquidType = NAV_WATER;
+                                break;
+                            case MAP_LIQUID_TYPE_MAGMA:
+                                liquidType = NAV_MAGMA;
+                                break;
+                            case MAP_LIQUID_TYPE_SLIME:
+                                liquidType = NAV_SLIME;
+                                break;
+                            case MAP_LIQUID_TYPE_DARK_WATER:
+                                // players should not be here, so logically neither should creatures
+                                useTerrain = false;
+                                useLiquid = false;
+                                break;
+                        }
+                    }
+
+                    // if there is no terrain, don't use terrain
+                    if (!ttriangles.size())
+                        useTerrain = false;
+
+                    // liquid is rendered as quads.  If any triangle has invalid height,
+                    // don't render any of the triangles in that quad
+                    if (useLiquid)
+                        if((&lverts[ltris[0]*3])[1] == INVALID_MAP_LIQ_HEIGHT ||
+                           (&lverts[ltris[1]*3])[1] == INVALID_MAP_LIQ_HEIGHT ||
+                           (&lverts[ltris[2]*3])[1] == INVALID_MAP_LIQ_HEIGHT)
+                        {
+                            useLiquid = false;
+                        }
+
+                    // if there is a hole here, don't use the terrain
+                    if (useTerrain)
+                        useTerrain = !isHole(i, holes);
+
+                    if (useTerrain && useLiquid)
+                    {
+                        // get the indexes of the corners of the quad
+                        int idx1, idx2, idx3;
+                        if (j == 0)
+                        {
+                            idx1 = 0;
+                            idx2 = 1;
+                            idx3 = tTriCount;   // accesses index from next triangle on low res
+                        }
+                        else
+                        {
+                            idx1 = 0;
+                            idx2 = 3*tTriCount/2-2;
+                            idx3 = 3*tTriCount/2-1;
+                        }
+
+                        if (useTerrain &&
+                            (&lverts[ltris[0]*3])[1] - 1.5f > (&tverts[ttris[idx1]*3])[1] &&
+                            (&lverts[ltris[1]*3])[1] - 1.5f > (&tverts[ttris[idx2]*3])[1] &&
+                            (&lverts[ltris[2]*3])[1] - 1.5f > (&tverts[ttris[idx3]*3])[1])
+                            useTerrain = false; // if the whole terrain triangle is 1.5yds under liquid, don't use it
+                        else if (useLiquid &&
+                                (&lverts[ltris[0]*3])[1] < (&tverts[ttris[idx1]*3])[1] &&
+                                (&lverts[ltris[1]*3])[1] < (&tverts[ttris[idx2]*3])[1] &&
+                                (&lverts[ltris[2]*3])[1] < (&tverts[ttris[idx3]*3])[1])
+                            useLiquid = false;  // if the whole liquid triangle is under terrain, don't use it
+                    }
+
+                    if (useLiquid)
+                    {
+                        meshData.liquidType.append(liquidType);
+                        for(int k = 0; k < 3; ++k)
+                            meshData.liquidTris.append(ltris[k]);
+                    }
+
+                    if (useTerrain)
+                        for(int k = 0; k < 3*tTriCount/2; ++k)
+                            meshData.solidTris.append(ttris[k]);
+
+                    // advance to next set of triangles
+                    ltris += 3;
+                    ttris += 3*tTriCount/2;
+                }
+            }
+        }
+
+        return meshData.solidTris.size() || meshData.liquidTris.size();
+    }
+
+    void TerrainBuilder::getHeightCoord(int index, Grid grid, float xOffset, float yOffset, float* coord, float* v)
+    {
+        // wow coords: x, y, height
+        // coord is mirroed about the horizontal axes
+        switch(grid)
+        {
+            case GRID_V9:
+                coord[0] = (xOffset + index%(V9_SIZE)*GRID_PART_SIZE) * -1.f;
+                coord[1] = (yOffset + (int)(index/(V9_SIZE))*GRID_PART_SIZE) * -1.f;
+                coord[2] = v[index];
+                break;
+            case GRID_V8:
+                coord[0] = (xOffset + index%(V8_SIZE)*GRID_PART_SIZE + GRID_PART_SIZE/2.f) * -1.f;
+                coord[1] = (yOffset + (int)(index/(V8_SIZE))*GRID_PART_SIZE + GRID_PART_SIZE/2.f) * -1.f;
+                coord[2] = v[index];
+                break;
+        }
+    }
+
+    void TerrainBuilder::getHeightTriangle(int square, Spot triangle, int* indices, bool liquid/* = false*/)
+    {
+        int rowOffset = square/V8_SIZE;
+        if (m_hiResHeightMaps && !liquid)
+            switch(triangle)
+            {
+                case TOP:
+                    indices[0] = square+rowOffset;                  //           0-----1 .... 128
+                    indices[1] = square+1+rowOffset;                //           |\ T /|
+                    indices[2] = (V9_SIZE_SQ)+square;               //           | \ / |
+                    break;                                          //           |L 0 R| .. 127
+                case LEFT:                                          //           | / \ |
+                    indices[0] = square+rowOffset;                  //           |/ B \|
+                    indices[1] = (V9_SIZE_SQ)+square;               //          129---130 ... 386
+                    indices[2] = square+V9_SIZE+rowOffset;          //           |\   /|
+                    break;                                          //           | \ / |
+                case RIGHT:                                         //           | 128 | .. 255
+                    indices[0] = square+1+rowOffset;                //           | / \ |
+                    indices[1] = square+V9_SIZE+1+rowOffset;        //           |/   \|
+                    indices[2] = (V9_SIZE_SQ)+square;               //          258---259 ... 515
+                    break;
+                case BOTTOM:
+                    indices[0] = (V9_SIZE_SQ)+square;
+                    indices[1] = square+V9_SIZE+1+rowOffset;
+                    indices[2] = square+V9_SIZE+rowOffset;
+                    break;
+                default: break;
+            }
+        else
+            switch(triangle)
+            {                                                           //           0-----1 .... 128
+                case TOP:                                               //           |\    |
+                    indices[0] = square+rowOffset;                      //           | \ T |
+                    indices[1] = square+1+rowOffset;                    //           |  \  |
+                    indices[2] = square+V9_SIZE+1+rowOffset;            //           | B \ |
+                    break;                                              //           |    \|
+                case BOTTOM:                                            //          129---130 ... 386
+                    indices[0] = square+rowOffset;                      //           |\    |
+                    indices[1] = square+V9_SIZE+1+rowOffset;            //           | \   |
+                    indices[2] = square+V9_SIZE+rowOffset;              //           |  \  |
+                    break;                                              //           |   \ |
+                default: break;
+            }                                                           //           |    \|
+                                                                        //          258---259 ... 515
+    }
+
+    void TerrainBuilder::getLiquidCoord(int index, int index2, float xOffset, float yOffset, float* coord, float* v)
+    {
+        // wow coords: x, y, height
+        // coord is mirroed about the horizontal axes
+        coord[0] = (xOffset + index%(V9_SIZE)*GRID_PART_SIZE) * -1.f;
+        coord[1] = (yOffset + (int)(index/(V9_SIZE))*GRID_PART_SIZE) * -1.f;
+        coord[2] = v[index2];
+    }
+
+    static uint16 holetab_h[4] = {0x1111, 0x2222, 0x4444, 0x8888};
+    static uint16 holetab_v[4] = {0x000F, 0x00F0, 0x0F00, 0xF000};
+
+    bool TerrainBuilder::isHole(int square, const uint16 holes[16][16])
+    {
+        int row = square / 128;
+        int col = square % 128;
+        int cellRow = row / 8;     // 8 squares per cell
+        int cellCol = col / 8;
+        int holeRow = row % 8 / 2;
+        int holeCol = (square - (row * 128 + cellCol * 8)) / 2;
+
+        uint16 hole = holes[cellRow][cellCol];
+        return (hole & holetab_h[holeCol] & holetab_v[holeRow]) != 0;
+    }
+
+    uint8 TerrainBuilder::getLiquidType(int square, const uint8 liquid_type[16][16])
+    {
+        int row = square / 128;
+        int col = square % 128;
+        int cellRow = row / 8;     // 8 squares per cell
+        int cellCol = col / 8;
+
+        return liquid_type[cellRow][cellCol];
+    }
+}
\ No newline at end of file
diff -r dc4fc5c8b306 src/tools/movements_extractor/TerrainBuilder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/TerrainBuilder.h	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MMAP_TERRAIN_BUILDER_H
+#define _MMAP_TERRAIN_BUILDER_H
+
+#include "mMapCommon.h"
+#include "Map.h"
+
+#include "G3D/Array.h"
+#include "G3D/Vector3.h"
+#include "G3D/Matrix3.h"
+
+using namespace Trinity;
+
+namespace Pathfinding
+{
+    enum Spot
+    {
+        TOP     = 1,
+        RIGHT   = 2,
+        LEFT    = 3,
+        BOTTOM  = 4,
+        ENTIRE  = 5
+    };
+
+    enum Grid
+    {
+        GRID_V8,
+        GRID_V9
+    };
+
+    static const int V9_SIZE = 129;
+    static const int V9_SIZE_SQ = V9_SIZE*V9_SIZE;
+    static const int V8_SIZE = 128;
+    static const int V8_SIZE_SQ = V8_SIZE*V8_SIZE;
+    static const float GRID_SIZE = 533.33333f;
+    static const float GRID_PART_SIZE = GRID_SIZE/V8_SIZE;
+
+    // see src/Tools/extractor/system.cpp, CONF_use_minHeight 
+    static const float INVALID_MAP_LIQ_HEIGHT = -500.f; 
+
+    struct MeshData
+    {
+        G3D::Array<float> solidVerts;
+        G3D::Array<int> solidTris;
+
+        G3D::Array<float> liquidVerts;
+        G3D::Array<int> liquidTris;
+        G3D::Array<uint8> liquidType;
+    };
+
+    // see also src/server/game/Movement/PathFinder.h
+    enum NavTerrain
+    {
+        NAV_GROUND  = 0x01,
+        NAV_MAGMA   = 0x02,
+        NAV_SLIME   = 0x04,
+        NAV_WATER   = 0x08,
+        NAV_UNUSED1 = 0x10,
+        NAV_UNUSED2 = 0x20, 
+        NAV_UNUSED3 = 0x40, 
+        NAV_UNUSED4 = 0x80 
+        // we only have 8 bits 
+
+    };
+
+    class TerrainBuilder
+    {
+        public:
+            TerrainBuilder(bool skipLiquid, bool hiRes);
+            ~TerrainBuilder();
+
+            void loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData);
+            inline bool usesHiRes() { return m_hiResHeightMaps; }
+            inline bool usesLiquids() { return !m_skipLiquid; }
+
+        private:
+
+            /// Loads a portion of a map's terrain
+            bool loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData &meshData, Spot portion);
+
+            /// Sets loop variables for selecting only certain parts of a map's terrain
+            void getLoopVars(Spot portion, int &loopStart, int &loopEnd, int &loopInc);
+
+            /// Controls map tesselation
+            bool m_hiResHeightMaps;
+            /// Controls whether liquids are loaded
+            bool m_skipLiquid;
+
+            /// Load the map terrain from file
+            bool loadHeightMap(uint32 mapID, uint32 tileX, uint32 tileY, G3D::Array<float> &vertices, G3D::Array<int> &triangles, Spot portion);
+
+            /// Get the vector coordinate for a specific position
+            void getHeightCoord(int index, Grid grid, float xOffset, float yOffset, float* coord, float* v);
+
+            /// Get the triangle's vector indices for a specific position
+            void getHeightTriangle(int square, Spot triangle, int* indices, bool liquid = false);
+
+            /// Determines if the specific position's triangles should be rendered
+            bool isHole(int square, const uint16 holes[16][16]);
+
+            /// Get the liquid vector coordinate for a specific position
+            void getLiquidCoord(int index, int index2, float xOffset, float yOffset, float* coord, float* v);
+
+            /// Get the liquid type for a specific position
+            uint8 getLiquidType(int square, const uint8 liquid_type[16][16]);
+
+            // hide parameterless and copy constructor
+            TerrainBuilder();
+            TerrainBuilder(const TerrainBuilder &tb);
+    };
+}
+
+#endif
diff -r dc4fc5c8b306 src/tools/movements_extractor/VMapExtensions.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/VMapExtensions.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <vector>
+#include "MapTree.h"
+#include "VMapManager2.h"
+#include "WorldModel.h"
+#include "ModelInstance.h"
+
+using namespace std;
+
+namespace VMAP
+{
+    // Need direct access to encapsulated VMAP data, so we add functions for MMAP generator
+    // maybe add MapBuilder as friend to all of the below classes would be better?
+
+    // declared in src/shared/vmap/MapTree.h
+    void StaticMapTree::getModelInstances(ModelInstance* &models, uint32 &count)
+    {
+        models = iTreeValues;
+        count = iNTreeValues;
+    }
+
+    // declared in src/shared/vmap/VMapManager2.h
+    void VMapManager2::getInstanceMapTree(InstanceTreeMap &instanceMapTree)
+    {
+        instanceMapTree = iInstanceMapTrees;
+    }
+
+    // declared in src/shared/vmap/WorldModel.h
+    void WorldModel::getGroupModels(vector<GroupModel> &groupModels)
+    {
+        groupModels = this->groupModels;
+    }
+    
+    // declared in src/shared/vmap/WorldModel.h
+    void GroupModel::getMeshData(vector<Vector3> &vertices, vector<MeshTriangle> &triangles, WmoLiquid* &liquid)
+    {
+        vertices = this->vertices;
+        triangles = this->triangles;
+        liquid = iLiquid;
+    }
+
+    // declared in src/shared/vmap/ModelInstance.h
+    WorldModel* const ModelInstance::getWorldModel()
+    {
+        return iModel;
+    }
+ 
+    // declared in src/shared/vmap/WorldModel.h 
+    void WmoLiquid::getPosInfo(uint32 &tilesX, uint32 &tilesY, Vector3 &corner) const 
+    { 
+        tilesX = iTilesX; 
+        tilesY = iTilesY; 
+        corner = iCorner; 
+    } 
+}
\ No newline at end of file
diff -r dc4fc5c8b306 src/tools/movements_extractor/mMapCommon.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/mMapCommon.h	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MMAP_COMMON_H
+#define _MMAP_COMMON_H
+
+#include <string>
+#include <vector>
+
+#include "Define.h"
+
+#ifndef _WIN32
+    #include <stddef.h>
+    #include <dirent.h>
+#endif
+
+#ifdef __linux__
+    #include <errno.h>
+#endif
+
+using namespace std;
+
+namespace Pathfinding
+{
+    inline bool matchWildcardFilter(const char* filter, const char* str)
+    {
+        if(!filter || !str)
+            return false;
+
+        // end on null character
+        while(*filter && *str)
+        {
+            if(*filter == '*')
+            {
+                if(*++filter == '\0')   // wildcard at end of filter means all remaing chars match
+                    return true;
+
+                while(true)
+                {
+                    if(*filter == *str)
+                        break;
+                    if(*str == '\0')
+                        return false;   // reached end of string without matching next filter character
+                    str++;
+                }
+            }
+            else if(*filter != *str)
+                return false;           // mismatch
+
+            filter++;
+            str++;
+        }
+
+        return ((*filter == '\0' || (*filter == '*' && *++filter == '\0')) && *str == '\0');
+    }
+
+    enum ListFilesResult
+    {
+        LISTFILE_DIRECTORY_NOT_FOUND = 0,
+        LISTFILE_OK = 1
+    };
+
+    inline ListFilesResult getDirContents(vector<string> &fileList, string dirpath = ".", string filter = "*", bool includeSubDirs = false)
+    {
+    #ifdef WIN32
+        HANDLE hFind;
+        WIN32_FIND_DATA findFileInfo;
+        string directory;
+
+        directory = dirpath + "/" + filter;
+
+        hFind = FindFirstFile(directory.c_str(), &findFileInfo);
+
+        if(hFind == INVALID_HANDLE_VALUE)
+            return LISTFILE_DIRECTORY_NOT_FOUND;
+        do
+        {
+            if(includeSubDirs || (findFileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
+                fileList.push_back(string(findFileInfo.cFileName));
+        }
+        while (FindNextFile(hFind, &findFileInfo));
+
+        FindClose(hFind);
+
+    #else
+        const char *p = dirpath.c_str();
+        DIR * dirp = opendir(p);
+        struct dirent * dp;
+        dirp = opendir(p);
+
+        while (dirp)
+        {
+            errno = 0;
+            if ((dp = readdir(dirp)) != NULL)
+            {
+                if(matchWildcardFilter(filter.c_str(), dp->d_name))
+                    fileList.push_back(string(dp->d_name));
+            }
+            else
+                break;
+        }
+
+        if(dirp)
+            closedir(dirp);
+        else
+            return LISTFILE_DIRECTORY_NOT_FOUND;
+    #endif
+
+        return LISTFILE_OK;
+    }
+}
+
+#endif
\ No newline at end of file
diff -r dc4fc5c8b306 src/tools/movements_extractor/mMapsGenerator.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/tools/movements_extractor/mMapsGenerator.cpp	Tue Nov 30 23:02:12 2010 -0500
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mMapCommon.h"
+#include "MapBuilder.h"
+
+using namespace Pathfinding;
+
+bool checkDirectories(bool debugOutput)
+{
+    vector<string> dirFiles;
+
+    if (getDirContents(dirFiles, "maps") == LISTFILE_DIRECTORY_NOT_FOUND || !dirFiles.size())
+    {
+        printf("'maps' directory is empty or does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (getDirContents(dirFiles, "vmaps", "*.vmtree") == LISTFILE_DIRECTORY_NOT_FOUND || !dirFiles.size())
+    {
+        printf("'vmaps' directory is empty or does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (getDirContents(dirFiles, "mmaps") == LISTFILE_DIRECTORY_NOT_FOUND)
+    {
+        printf("'mmaps' directory does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (debugOutput)
+        if (getDirContents(dirFiles, "meshes") == LISTFILE_DIRECTORY_NOT_FOUND)
+        {
+            printf("'meshes' directory does not exist (no place to put debugOutput files)\n");
+            return false;
+        }
+
+    return true;
+}
+
+void handleArgs(int argc, char** argv,
+               int &mapnum,
+               int &tileX,
+               int &tileY,
+               float &maxAngle,
+               bool &skipLiquid,
+               bool &skipContinents,
+               bool &skipJunkMaps,
+               bool &skipBattlegrounds,
+               bool &hiResHeightmaps,
+               bool &debugOutput,
+               bool &badParam)
+{
+    char zero[2] = "0";
+    int i;
+    char* param;
+    for (i = 1; i < argc; ++i)
+    {
+        if (strcmp(argv[i], "--maxAngle") == 0)
+        {
+            param = argv[++i];
+            if(!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            float maxangle = atof(param);
+            if (maxangle <= 90.f && maxangle >= 45.f)
+                maxAngle = maxangle;
+            else
+                printf("invalid option for '--maxAngle', using default\n");
+        }
+        else if (strcmp(argv[i], "--tile") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            char* stileX = strtok(param, ",");
+            char* stileY = strtok(NULL, ",");
+            int tilex = atoi(stileX);
+            int tiley = atoi(stileY);
+
+            if ((tilex > 0 && tilex < 64) || (tilex == 0 && strcmp(stileX, zero) == 0))
+                tileX = tilex;
+            if ((tiley > 0 && tiley < 64) || (tiley == 0 && strcmp(stileY, zero) == 0))
+                tileY = tiley;
+
+            if (tileX < 0 || tileY < 0)
+            {
+                printf("invalid tile coords.\n");
+                badParam = true;
+            }
+        }
+        else if (strcmp(argv[i], "--skipLiquid") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                skipLiquid = true;
+            else if (strcmp(param, "false") == 0)
+                skipLiquid = false;
+            else
+                printf("invalid option for '--skipLiquid', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipContinents") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                skipContinents = true;
+            else if (strcmp(param, "false") == 0)
+                skipContinents = false;
+            else
+                printf("invalid option for '--skipContinents', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipJunkMaps") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                skipJunkMaps = true;
+            else if (strcmp(param, "false") == 0)
+                skipJunkMaps = false;
+            else
+                printf("invalid option for '--skipJunkMaps', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipBattlegrounds") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                skipBattlegrounds = true;
+            else if(strcmp(param, "false") == 0)
+                skipBattlegrounds = false;
+            else
+                printf("invalid option for '--skipBattlegrounds', using default\n");
+        }
+        else if (strcmp(argv[i], "--hiResHeightmaps") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                hiResHeightmaps = true;
+            else if(strcmp(param, "false") == 0)
+                hiResHeightmaps = false;
+            else
+                printf("invalid option for '--hiResHeightmaps', using default\n");
+        }
+        else if (strcmp(argv[i], "--debugOutput") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+            {
+                badParam = true;
+                return;
+            }
+
+            if (strcmp(param, "true") == 0)
+                debugOutput = true;
+            else if (strcmp(param, "false") == 0)
+                debugOutput = false;
+            else
+                printf("invalid option for '--debugOutput', using default true\n");
+        }
+        else
+        {
+            int map = atoi(argv[i]);
+            if (map > 0 || (map == 0 && (strcmp(argv[i], zero) == 0)))
+                mapnum = map;
+            else
+            {
+                printf("bad parameter\n");
+                badParam = true;
+            }
+        }
+    }
+}
+
+int finish(const char* message, int returnValue)
+{
+    printf("%s", message);
+    getchar();
+    return returnValue;
+}
+
+int main(int argc, char** argv)
+{
+    int mapnum = -1;
+    float maxAngle = 60.f;
+    int tileX = -1, tileY = -1;
+    bool skipLiquid = false,
+         skipContinents = true,
+         skipJunkMaps = true,
+         skipBattlegrounds = true,
+         hiResHeightmaps = false,
+         debugOutput = false,
+         badParam = false;
+
+    handleArgs(argc,
+              argv,
+              mapnum,
+              tileX,
+              tileY,
+              maxAngle,
+              skipLiquid,
+              skipContinents,
+              skipJunkMaps,
+              skipBattlegrounds,
+              hiResHeightmaps,
+              debugOutput,
+              badParam);
+
+    if (badParam)
+        return finish("You have specified invalid parameters", -1);
+
+    if (mapnum == -1 && debugOutput)
+    {
+        printf("You have specifed debug output, but didn't specify a map to generate.\n");
+        printf("This will generate debug output for ALL maps.\n");
+        printf("Are you sure you want to continue? (y/n) ");
+        if(getchar() != 'y')
+            return 0;
+    }
+
+    if (!checkDirectories(debugOutput))
+        return finish("Press any key to close...", -1);
+
+    MapBuilder builder(maxAngle,
+                       skipLiquid,
+                       skipContinents,
+                       skipJunkMaps,
+                       skipBattlegrounds,
+                       hiResHeightmaps,
+                       debugOutput);
+
+    if (tileX > -1 && tileY > -1 && mapnum >= 0)
+        builder.buildTile(mapnum, tileX, tileY);
+    else if (mapnum >= 0)
+        builder.build(uint32(mapnum));
+    else
+        builder.buildAll();
+
+    return finish("mMaps Generating is done!", 1);
+}
+
diff -r dc4fc5c8b306 src/tools/vmap3_assembler/CMakeLists.txt
--- a/src/tools/vmap3_assembler/CMakeLists.txt	Tue Nov 30 21:32:00 2010 +0100
+++ b/src/tools/vmap3_assembler/CMakeLists.txt	Tue Nov 30 23:02:12 2010 -0500
@@ -15,6 +15,7 @@
   ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
   ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Pathfinding
   ${ACE_INCLUDE_DIR}
   ${ZLIB_INCLUDE_DIR}
 )
