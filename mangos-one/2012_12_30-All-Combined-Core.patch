From 21ac078a4b78d43da416f1e55c2047ffd2cb001e Mon Sep 17 00:00:00 2001
From: lordpsyan <realmsofwarcraft@gmail.com>
Date: Sun, 30 Dec 2012 19:46:48 -0600
Subject: [PATCH] 2012_12_30-All-Combined-Core

---
 FAKE.PLAYERS.README                                |   32 ++
 README.TELENPC2                                    |   18 +
 sql/Fake_Players/characters_fake_players.sql       |   37 ++
 sql/TeleNPC2/world_setup_npc_teleport.sql          |  120 +++++++
 sql/VIPAccounts/realmd-VIPAccount.sql              |    8 +
 sql/_extras/realmd_mangchat.sql                    |   21 ++
 .../2012_09_04-auth-account_access.sql             |   22 ++
 src/bindings/CMakeLists.txt                        |    2 +-
 src/game/AccountMgr.cpp                            |    3 +-
 src/game/CMakeLists.txt                            |    4 +
 src/game/Channel.cpp                               |    7 +
 src/game/Chat.cpp                                  |    5 +
 src/game/Chat.h                                    |    5 +
 src/game/ChatHandler.cpp                           |   13 +
 src/game/ConfusedMovementGenerator.cpp             |    5 +-
 src/game/Creature.cpp                              |    2 +
 src/game/FleeingMovementGenerator.cpp              |   12 +-
 src/game/Formulas.h                                |    3 +-
 src/game/Language.h                                |    5 +
 src/game/Level2.cpp                                |    8 +-
 src/game/Level3.cpp                                |   49 +++-
 src/game/MiscHandler.cpp                           |   33 ++
 src/game/Object.cpp                                |   47 +++
 src/game/Object.h                                  |    6 +
 src/game/Player.cpp                                |    9 +-
 src/game/Spell.cpp                                 |   13 -
 src/game/SpellEffects.cpp                          |   40 +-
 src/game/Teleport/sc_npc_teleport.cpp              |  377 ++++++++++++++++++++
 src/game/Teleport/sc_npc_teleport.h                |  151 ++++++++
 src/game/World.cpp                                 |   15 +-
 src/game/World.h                                   |    4 +
 src/game/WorldSession.cpp                          |    4 +-
 src/game/WorldSession.h                            |    4 +-
 src/game/WorldSocket.cpp                           |   56 ++--
 src/game/mangchat/IRCClient.cpp                    |  179 +++++++++
 src/game/mangchat/IRCClient.h                      |  154 ++++++++
 src/game/mangchat/IRCHandler.cpp                   |  297 +++++++++++++++
 src/game/mangchat/IRCMgr.cpp                       |  136 +++++++
 src/game/mangchat/IRCMgr.h                         |   50 +++
 src/game/mangchat/IRCSock.cpp                      |  134 +++++++
 src/mangosd/CliRunnable.cpp                        |    2 +-
 src/mangosd/mangosd.conf.dist.in                   |   21 +-
 src/realmd/AuthSocket.cpp                          |    2 +-
 src/realmd/Main.cpp                                |    1 +
 win/VC100/game.vcxproj                             |    6 +
 win/VC100/game.vcxproj.filters                     |   21 ++
 46 files changed, 2061 insertions(+), 82 deletions(-)
 create mode 100644 FAKE.PLAYERS.README
 create mode 100644 README.TELENPC2
 create mode 100644 sql/Fake_Players/characters_fake_players.sql
 create mode 100644 sql/TeleNPC2/world_setup_npc_teleport.sql
 create mode 100644 sql/VIPAccounts/realmd-VIPAccount.sql
 create mode 100644 sql/_extras/realmd_mangchat.sql
 create mode 100644 sql/account_access/2012_09_04-auth-account_access.sql
 create mode 100644 src/game/Teleport/sc_npc_teleport.cpp
 create mode 100644 src/game/Teleport/sc_npc_teleport.h
 create mode 100644 src/game/mangchat/IRCClient.cpp
 create mode 100644 src/game/mangchat/IRCClient.h
 create mode 100644 src/game/mangchat/IRCHandler.cpp
 create mode 100644 src/game/mangchat/IRCMgr.cpp
 create mode 100644 src/game/mangchat/IRCMgr.h
 create mode 100644 src/game/mangchat/IRCSock.cpp

diff --git a/FAKE.PLAYERS.README b/FAKE.PLAYERS.README
new file mode 100644
index 0000000..d07ebf7
--- /dev/null
+++ b/FAKE.PLAYERS.README
@@ -0,0 +1,32 @@
+Original Script by: ain't got a clue.
+Rewritten and made better by: LordPsyan
+
+Fake players does exactly what the name suggests.. creates fake players for your realm.
+
+When a player clicks the "who" list, it will grab all players that are online, and then fill
+the rest with fake players from the `characters_fake` table until it shows 49. Any time a
+player logs in, it will remove a fake player, and replace it with the real online player. If
+a player logs out, it will remove that player from the list, and replace it with a fake one.
+
+This is a good thing for low population realms. It makes the realm look more populated.
+
+Currently, if you try to whisper a "fake" player, a message will appear saying they do not wish
+to be disturbed. This message currently comes up in red at top center of screen. 
+
+TODO:
+
+1. Fix location of message.
+2. Fix bug that posts the "do not disturb" message if you try to whisper someone who is offline.
+3. Set config option to have the Do Not Disturb Message on or off. 
+4. Set config file with custom Do Not Disturb message.
+5. GM command instead of config file option, to turn on or off the fake players.
+
+INSTALL:
+
+1). apply the patch to the core.
+
+2). Run the sql file (comes with 49 fake players, so you don't have to make your own) in your
+characters database.
+
+3). Set the config option to 1 or 0 to turn it on or off. You can modify the config file while
+server is running, and do .reload config to turn the fake players on or off.
diff --git a/README.TELENPC2 b/README.TELENPC2
new file mode 100644
index 0000000..354b52e
--- /dev/null
+++ b/README.TELENPC2
@@ -0,0 +1,18 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+Script Modified by: LordPsyan
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Patch the core with the patch file {date}-TeleNPC2-core.patch
+Patch ScriptDev2 with the patch {date}-TeleNPC2-ScriptDev2.patch
+
+Run the query world_setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/sql/Fake_Players/characters_fake_players.sql b/sql/Fake_Players/characters_fake_players.sql
new file mode 100644
index 0000000..7535045
--- /dev/null
+++ b/sql/Fake_Players/characters_fake_players.sql
@@ -0,0 +1,37 @@
+/*
+SQLyog Enterprise - MySQL GUI v8.18 
+MySQL - 5.1.66-0+squeeze1 : Database - lithathrad_characters
+*********************************************************************
+*/
+
+
+/*!40101 SET NAMES utf8 */;
+
+/*!40101 SET SQL_MODE=''*/;
+
+/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
+/*Table structure for table `characters_fake` */
+
+DROP TABLE IF EXISTS `characters_fake`;
+
+CREATE TABLE `characters_fake` (
+  `name` varchar(36) NOT NULL,
+  `race` mediumint(3) NOT NULL DEFAULT '0',
+  `class` mediumint(3) NOT NULL DEFAULT '0',
+  `level` mediumint(3) NOT NULL DEFAULT '0',
+  `zone` mediumint(9) NOT NULL DEFAULT '0',
+  `gender` mediumint(3) NOT NULL DEFAULT '0',
+  `online` mediumint(3) NOT NULL DEFAULT '0'
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `characters_fake` */
+
+insert  into `characters_fake`(`name`,`race`,`class`,`level`,`zone`,`gender`,`online`) values ('Drikish',10,8,80,22,0,2),('Sovelis',1,1,75,11,0,2),('Cuddles',10,2,99,37,0,2),('Epiasdv',8,4,80,1,0,2),('Mac',5,4,80,44,0,2),('Tiesto',8,6,80,15,0,2),('Ihavfacebook',11,7,80,44,1,2),('Mimik',10,4,80,24,0,2),('Deadmau',5,4,99,36,0,2),('Smoosh',8,1,80,29,0,2),('Shadowcrest',4,4,80,24,1,2),('Lolol',4,5,75,30,1,2),('Prox',11,1,80,28,1,2),('Rovip',10,4,80,13,0,2),('Ryan',10,8,80,17,0,2),('Holysmite',1,2,80,24,0,2),('Airagon',10,2,80,36,0,2),('Fracture',5,1,80,4,0,2),('Supershen',10,2,80,14,1,2),('Jana',2,4,75,41,0,2),('Gamm',2,1,75,35,0,2),('Emoarchie',10,8,80,2,0,2),('Melia',10,2,75,4,1,2),('Balu',6,11,75,10,0,2),('Jabari',2,1,75,5,0,2),('Sinan',10,2,75,6,0,2),('Shisha',10,4,75,9,1,2),('Killbill',1,4,75,8,0,2),('Gaby',4,11,75,12,1,2),('Fallen',4,4,75,37,0,2),('Druidita',6,11,75,47,0,2),('Pigolo',6,11,75,22,0,2),('Saga',10,2,75,22,0,2),('Deadmask',10,2,75,41,0,2),('Assasincz',4,4,75,41,0,2),('Petracz',1,4,75,28,1,2),('Aleks',10,2,75,20,0,2),('Cazadormen',4,4,75,14,1,2),('Kireth',1,2,75,9,1,2),('Liesma',1,1,75,5,1,2),('Tyller',1,1,75,46,0,2),('Astrabutaz',1,2,75,13,0,2),('Carlita',7,8,75,26,1,2),('beanie',10,2,80,40,0,2),('Nergal',10,3,75,22,0,2),('Smikis',10,5,75,39,0,2),('Peperoma',11,2,75,30,0,2),('May',1,2,75,32,1,2),('Keyadis',8,7,75,47,0,2),('Preatorian',10,2,75,29,0,2),('Mitza',1,9,75,1,0,2),('Keedor',10,2,75,21,0,2),('Kekw',4,3,75,1,1,2),('Wark',1,2,75,42,0,2),('Barrabus',10,2,75,6,0,2),('Malodetehepy',4,11,75,1,0,2),('Dranati',10,2,75,40,0,2),('Sorin',2,1,75,36,0,2),('Resan',4,4,75,18,0,2),('Silverhilt',1,1,75,31,1,2),('Chirica',10,2,75,2,0,2),('Trias',10,8,75,16,0,2),('Prdo',5,1,75,22,0,2),('Guten',8,7,75,36,0,2),('Sonsia',4,3,75,48,1,2),('Smikiss',10,4,75,37,0,2),('Ledy',4,1,75,34,1,2),('Rymar',5,4,75,9,0,2),('Rokass',5,1,75,38,0,2),('Waisha',10,3,75,11,1,2),('Xenon',4,1,75,16,0,2),('Palanoski',1,2,75,6,0,2),('Helona',6,11,75,47,1,2),('Skalons',2,1,75,14,0,2),('Zazlock',5,9,75,31,0,2),('Zazk',6,7,75,20,0,2),('Ezekiel',10,9,75,12,0,2),('Deiv',10,8,75,1,0,2),('Crashwar',5,1,75,16,0,2),('Bandaid',5,5,75,28,0,2),('Hunterherbie',4,3,75,3,0,2),('Cheesebeard',3,1,90,4,0,2),('Phin',7,8,75,3,0,2),('Prig',10,5,75,48,0,2),('Eraevel',10,5,75,28,1,2),('Bourne',5,4,75,47,0,2),('Twoogi',5,8,75,48,0,2),('Devon',5,4,76,6,0,2),('Ledystar',1,2,75,29,1,2),('Frostie',10,8,75,25,1,2),('Kie',5,4,99,38,0,2),('Reios',1,2,75,16,0,2),('Zero',4,4,75,30,0,2),('Wuk',2,1,75,1,0,2),('Sylvaediir',4,3,75,21,0,2),('Kansetsu',11,2,75,10,0,2),('Makura',11,2,75,44,1,2),('Demonia',11,2,75,17,1,2),('Stonebull',6,11,75,50,0,2),('Marianus',10,2,75,50,0,2);
+
+/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
+/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
+/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
+/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
diff --git a/sql/TeleNPC2/world_setup_npc_teleport.sql b/sql/TeleNPC2/world_setup_npc_teleport.sql
new file mode 100644
index 0000000..6ce39f2
--- /dev/null
+++ b/sql/TeleNPC2/world_setup_npc_teleport.sql
@@ -0,0 +1,120 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template` entry 100000
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `KillCredit1`, `KillCredit2`, `modelid_1`, `modelid_2`, `modelid_3`, `modelid_4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `unk16`, `unk17`, `RacialLeader`, `RegenHealth`, `equipment_id`, `trainer_id`, `vendor_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) values
+('100000','0','0','0','2202','0','2202','0','RoW Teleporter','',NULL,'0','70','70','5000','5000','0','0','2865','35','35','1','1','1.14286','1','1','60','165','0','97','1','1500','1500','0','0','0','0','0','0','0','0','50','100','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','1','1','1','1','1','0','0','0','0','0','npc_teleport');
diff --git a/sql/VIPAccounts/realmd-VIPAccount.sql b/sql/VIPAccounts/realmd-VIPAccount.sql
new file mode 100644
index 0000000..df317ed
--- /dev/null
+++ b/sql/VIPAccounts/realmd-VIPAccount.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `account_premium` (
+  `id` int(11) NOT NULL default '0' COMMENT 'Account id',
+  `setdate` bigint(40) NOT NULL default '0',
+  `unsetdate` bigint(40) NOT NULL default '0',
+  `premium_type` tinyint(4) unsigned NOT NULL default '1',
+  `active` tinyint(4) NOT NULL default '1',
+  PRIMARY KEY  (`id`,`setdate`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Premium Accounts';
\ No newline at end of file
diff --git a/sql/_extras/realmd_mangchat.sql b/sql/_extras/realmd_mangchat.sql
new file mode 100644
index 0000000..1cd9aae
--- /dev/null
+++ b/sql/_extras/realmd_mangchat.sql
@@ -0,0 +1,21 @@
+DROP TABLE IF EXISTS `mangchat`;
+CREATE TABLE `mangchat` (
+  `id` int(11) unsigned NOT NULL DEFAULT '0',
+  `host` text,
+  `port` int(11) NOT NULL DEFAULT '0',
+  `user` text,
+  `pass` text,
+  `nick` text,
+  `auth` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `mangchat_links`;
+CREATE TABLE `mangchat_links` (
+  `mangchat_id` int(11) unsigned NOT NULL DEFAULT '0',
+  `wow_channel` varchar(255) NOT NULL DEFAULT '',
+  `wow_channel_options` int(11) unsigned NOT NULL DEFAULT '0',
+  `irc_channel` varchar(255) NOT NULL DEFAULT '',
+  `irc_channel_options` int(11) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`mangchat_id`,`wow_channel`,`irc_channel`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/account_access/2012_09_04-auth-account_access.sql b/sql/account_access/2012_09_04-auth-account_access.sql
new file mode 100644
index 0000000..3120822
--- /dev/null
+++ b/sql/account_access/2012_09_04-auth-account_access.sql
@@ -0,0 +1,22 @@
+-- Table structure for `account_access`
+DROP TABLE IF EXISTS `account_access`;
+CREATE TABLE `account_access` (
+  `id` bigint(20) unsigned NOT NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL,
+  `RealmID` int(11) NOT NULL,
+  PRIMARY KEY (`id`,`RealmID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+-- export current gm account to the new table
+-- RealmID -1 = all realms
+INSERT INTO `account_access` (id, gmlevel, RealmID)
+SELECT `id`, `gmlevel`, -1 FROM `account` WHERE `gmlevel` > 0;
+-- Remove the gmlevel field from account
+ALTER TABLE account DROP COLUMN `gmlevel`;
+
+-- command table
+UPDATE command 
+SET help = 'Syntax: .account set gmlevel [$account] #level [#realmid]\r\n\r\nSet the security level for targeted player (can\'t be used at self) or for account $name to a level of #level on the realm #realmID.\r\n\r\n#level may range from 0 to 3.\r\n\r\n#reamID may be -1 for all realms.'
+WHERE name = 'account set gmlevel';
+
+INSERT INTO mangos_string VALUES 
+(11001, 'You have not chosen -1 or the current realmID that you are on.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
diff --git a/src/bindings/CMakeLists.txt b/src/bindings/CMakeLists.txt
index e6ca410..40a518e 100644
--- a/src/bindings/CMakeLists.txt
+++ b/src/bindings/CMakeLists.txt
@@ -18,5 +18,5 @@
 
 # Uncomment once you have cloned https://github.com/mangos-one/scripts
 # into the scripts subdirectory.
-#add_subdirectory(scripts)
+add_subdirectory(scripts)
 
diff --git a/src/game/AccountMgr.cpp b/src/game/AccountMgr.cpp
index 77a3468..7d7a301 100644
--- a/src/game/AccountMgr.cpp
+++ b/src/game/AccountMgr.cpp
@@ -89,6 +89,7 @@ AccountOpResult AccountMgr::DeleteAccount(uint32 accid)
 
     bool res =
         LoginDatabase.PExecute("DELETE FROM account WHERE id='%u'", accid) &&
+        LoginDatabase.PExecute("DELETE FROM account_access WHERE id ='%d'", accid) &&
         LoginDatabase.PExecute("DELETE FROM realmcharacters WHERE acctid='%u'", accid);
 
     LoginDatabase.CommitTransaction();
@@ -161,7 +162,7 @@ uint32 AccountMgr::GetId(std::string username)
 
 AccountTypes AccountMgr::GetSecurity(uint32 acc_id)
 {
-    QueryResult* result = LoginDatabase.PQuery("SELECT gmlevel FROM account WHERE id = '%u'", acc_id);
+    QueryResult* result = LoginDatabase.PQuery("SELECT gmlevel FROM account_access WHERE id = '%u'", acc_id);
     if (result)
     {
         AccountTypes sec = AccountTypes((*result)[0].GetInt32());
diff --git a/src/game/CMakeLists.txt b/src/game/CMakeLists.txt
index 75133af..8cff961 100644
--- a/src/game/CMakeLists.txt
+++ b/src/game/CMakeLists.txt
@@ -77,6 +77,10 @@ source_group("Movement"
     movement/util.cpp
 )
 
+source_group("MangChat"
+  REGULAR_EXPRESSION mangchat/.*
+)
+
 if(PCH)
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
 endif()
diff --git a/src/game/Channel.cpp b/src/game/Channel.cpp
index 023f80a..ca34ce1 100644
--- a/src/game/Channel.cpp
+++ b/src/game/Channel.cpp
@@ -20,6 +20,7 @@
 #include "ObjectMgr.h"
 #include "World.h"
 #include "SocialMgr.h"
+#include "mangchat/IRCMgr.h"
 
 Channel::Channel(const std::string& name, uint32 channel_id)
     : m_announce(true), m_moderate(false), m_name(name), m_flags(0), m_channelId(channel_id)
@@ -111,6 +112,9 @@ void Channel::Join(ObjectGuid p, const char* pass)
     MakeYouJoined(&data);
     SendToOne(&data, p);
 
+    // mangChat
+    sIRCMgr.HandleWoWChannelAction(m_name, ACTION_JOIN_CHANNEL, plr);
+
     JoinNotify(p);
 
     // if no owner first logged will become
@@ -156,6 +160,9 @@ void Channel::Leave(ObjectGuid p, bool send)
             SendToAll(&data);
         }
 
+        // mangChat
+        sIRCMgr.HandleWoWChannelAction(m_name, ACTION_LEAVE_CHANNEL, plr);
+
         LeaveNotify(p);
 
         if (changeowner)
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index a515f09..5bc3120 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -561,6 +561,11 @@ ChatCommand* ChatHandler::getCommandTable()
         { "spell_scripts",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellScriptsCommand,            "", NULL },
         { "spell_target_position",       SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellTargetPositionCommand,     "", NULL },
         { "spell_threats",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellThreatsCommand,            "", NULL },
+        // DEV -- FOR DEVELOPMENT SERVERS ONLY!!
+        { "gameobject_template",         SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadGameobjectTemplateCommand,      "", NULL },
+        { "item_template",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadItemTemplateCommand,            "", NULL },
+        { "creature_template",           SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadCreatureTemplateCommand,        "", NULL },
+        // DEV END
 
         { NULL,                          0,                 false, NULL,                                                     "", NULL }
     };
diff --git a/src/game/Chat.h b/src/game/Chat.h
index ecfca3a..137b5bd 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -452,6 +452,11 @@ protected:
     bool HandleReloadSpellThreatsCommand(char* args);
     bool HandleReloadSpellPetAurasCommand(char* args);
 
+        // DEV -- FOR DEVELOPMENT SERVERS ONLY!!
+        bool HandleReloadGameobjectTemplateCommand(char* args);
+        bool HandleReloadItemTemplateCommand(char* args);
+        bool HandleReloadCreatureTemplateCommand(char* args);
+        // DEV END
     bool HandleResetAllCommand(char* args);
     bool HandleResetHonorCommand(char* args);
     bool HandleResetLevelCommand(char* args);
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index f3d2fb8..3bb4a65 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -35,6 +35,7 @@
 #include "Util.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "mangchat/IRCMgr.h"
 
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
@@ -210,8 +211,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
             uint32 pSecurity = player ? player->GetSession()->GetSecurity() : SEC_PLAYER;
             if (!player || (tSecurity == SEC_PLAYER && pSecurity > SEC_PLAYER && !player->isAcceptWhispers()))
             {
+                // If Fake WHO List system on then show player DND
+                if (sWorld.getConfig(CONFIG_BOOL_FAKE_WHO_LIST))
+                {
+                    SendNotification(LANG_NOT_WHISPER);
+                    return;
+                }
+                else
+                {
                 SendPlayerNotFoundNotice(to);
                 return;
+                }
             }
 
             if (!sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_CHAT) && tSecurity == SEC_PLAYER && pSecurity == SEC_PLAYER)
@@ -441,6 +451,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
             if (msg.empty())
                 break;
 
+            // mangChat
+            sIRCMgr.HandleWoWChannelAction(channel, msg, _player);
+
             if (ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
                 if (Channel* chn = cMgr->GetChannel(channel, _player))
                     chn->Say(_player->GetObjectGuid(), msg.c_str(), lang);
diff --git a/src/game/ConfusedMovementGenerator.cpp b/src/game/ConfusedMovementGenerator.cpp
index 95cd258..979fb0d 100644
--- a/src/game/ConfusedMovementGenerator.cpp
+++ b/src/game/ConfusedMovementGenerator.cpp
@@ -77,11 +77,12 @@ bool ConfusedMovementGenerator<T>::Update(T& unit, const uint32& diff)
             float y = i_y + 10.0f * (rand_norm_f() - 0.5f);
             float z = i_z;
 
-            unit.UpdateAllowedPositionZ(x, y, z);
+            WorldLocation destLoc;
+            unit.GetFirstCollisionPosition(destLoc, 10.0f*(rand_norm_f() - 0.5f), unit.GetOrientation());
 
             PathFinder path(&unit);
             path.setPathLengthLimit(30.0f);
-            path.calculate(x, y, z);
+            path.calculate(destLoc.coord_x, destLoc.coord_y, (destLoc.coord_z + unit.GetObjectScale()));
             if (path.getPathType() & PATHFIND_NOPATH)
             {
                 i_nextMoveTime.Reset(urand(800, 1000));
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index 58d2903..c9096e8 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -390,6 +390,8 @@ bool Creature::UpdateEntry(uint32 Entry, Team team, const CreatureData* data /*=
         else
             SetPvP(false);
     }
+    if (GetCreatureInfo()->unit_flags & UNIT_FLAG_PVP || GetCreatureInfo()->unit_flags & UNIT_FLAG_PVP_ATTACKABLE)
+    SetPvP(true);
 
     for (int i = 0; i < CREATURE_MAX_SPELLS; ++i)
         m_spells[i] = GetCreatureInfo()->spells[i];
diff --git a/src/game/FleeingMovementGenerator.cpp b/src/game/FleeingMovementGenerator.cpp
index bf800ac..9aa9af5 100644
--- a/src/game/FleeingMovementGenerator.cpp
+++ b/src/game/FleeingMovementGenerator.cpp
@@ -98,14 +98,12 @@ bool FleeingMovementGenerator<T>::_getPoint(T& owner, float& x, float& y, float&
         angle = frand(0, 2 * M_PI_F);
     }
 
-    float curr_x, curr_y, curr_z;
-    owner.GetPosition(curr_x, curr_y, curr_z);
+    WorldLocation destLoc;
+    owner.GetFirstCollisionPosition(destLoc, dist, angle);
 
-    x = curr_x + dist * cos(angle);
-    y = curr_y + dist * sin(angle);
-    z = curr_z;
-
-    owner.UpdateAllowedPositionZ(x, y, z);
+    x = destLoc.coord_x;
+    y = destLoc.coord_y;
+    z = destLoc.coord_z + owner.GetObjectScale();
 
     return true;
 }
diff --git a/src/game/Formulas.h b/src/game/Formulas.h
index 8b004df..408f6bc 100644
--- a/src/game/Formulas.h
+++ b/src/game/Formulas.h
@@ -121,7 +121,8 @@ namespace MaNGOS
             if (u->GetTypeId() == TYPEID_UNIT && ((Creature*)u)->IsElite())
                 xp_gain *= 2;
 
-            return (uint32)(xp_gain * sWorld.getConfig(CONFIG_FLOAT_RATE_XP_KILL));
+            float premium_rate = pl->GetSession()->IsPremium() ? sWorld.getConfig(CONFIG_FLOAT_RATE_XP_KILL_PREMIUM) : 1.0f;
+            return (uint32)(xp_gain * sWorld.getConfig(CONFIG_FLOAT_RATE_XP_KILL) * premium_rate);
         }
 
         inline float xp_in_group_rate(uint32 count, bool isRaid)
diff --git a/src/game/Language.h b/src/game/Language.h
index 7c98002..580efbd 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -1020,9 +1020,14 @@ enum MangosStrings
     // Use for not-in-official-sources patches
     //                                    10000-10999
 
+    LANG_INVALID_REALMID                = 11001,
+
     // Use for custom patches             11000-11999
 
     // NOT RESERVED IDS                   12000-1999999999
+	// Fake Players
+    LANG_NOT_WHISPER                    = 12001,
+
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
 };
diff --git a/src/game/Level2.cpp b/src/game/Level2.cpp
index 2b256f8..250c555 100644
--- a/src/game/Level2.cpp
+++ b/src/game/Level2.cpp
@@ -2372,7 +2372,7 @@ bool ChatHandler::HandlePInfoCommand(char* args)
     AccountTypes security = SEC_PLAYER;
     std::string last_login = GetMangosString(LANG_ERROR);
 
-    QueryResult* result = LoginDatabase.PQuery("SELECT username,gmlevel,last_ip,last_login FROM account WHERE id = '%u'", accId);
+    QueryResult* result = LoginDatabase.PQuery("SELECT a.username,aa.gmlevel,a.last_ip,a.last_login FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE id = '%u'", accId);
     if (result)
     {
         Field* fields = result->Fetch();
@@ -4225,7 +4225,7 @@ bool ChatHandler::HandleLookupAccountEmailCommand(char* args)
     std::string email = emailStr;
     LoginDatabase.escape_string(email);
     //                                                 0   1         2        3        4
-    QueryResult* result = LoginDatabase.PQuery("SELECT id, username, last_ip, gmlevel, expansion FROM account WHERE email " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), email.c_str());
+    QueryResult* result = LoginDatabase.PQuery("SELECT a.id, a.username, a.last_ip, aa.gmlevel, a.expansion FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE email " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), email.c_str());
 
     return ShowAccountListHelper(result, &limit);
 }
@@ -4244,7 +4244,7 @@ bool ChatHandler::HandleLookupAccountIpCommand(char* args)
     LoginDatabase.escape_string(ip);
 
     //                                                 0   1         2        3        4
-    QueryResult* result = LoginDatabase.PQuery("SELECT id, username, last_ip, gmlevel, expansion FROM account WHERE last_ip " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), ip.c_str());
+    QueryResult* result = LoginDatabase.PQuery("SELECT a.id, a.username, a.last_ip, aa.gmlevel, a.expansion FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE last_ip " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), ip.c_str());
 
     return ShowAccountListHelper(result, &limit);
 }
@@ -4265,7 +4265,7 @@ bool ChatHandler::HandleLookupAccountNameCommand(char* args)
 
     LoginDatabase.escape_string(account);
     //                                                 0   1         2        3        4
-    QueryResult* result = LoginDatabase.PQuery("SELECT id, username, last_ip, gmlevel, expansion FROM account WHERE username " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), account.c_str());
+    QueryResult* result = LoginDatabase.PQuery("SELECT a.id, a.username, a.last_ip, aa.gmlevel, a.expansion FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE username " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), account.c_str());
 
     return ShowAccountListHelper(result, &limit);
 }
diff --git a/src/game/Level3.cpp b/src/game/Level3.cpp
index ea0ddfc..5a32bfa 100644
--- a/src/game/Level3.cpp
+++ b/src/game/Level3.cpp
@@ -1060,6 +1060,32 @@ bool ChatHandler::HandleLoadScriptsCommand(char* args)
     return true;
 }
 
+// DEV -- These functions should only be used in development mode - not on a production server
+bool ChatHandler::HandleReloadGameobjectTemplateCommand(char*)
+{
+    sLog.outString( "WARNING: Reloading gameobject_template" );
+    sObjectMgr.LoadGameobjectInfo();
+    SendGlobalSysMessage("WARNING: DB table `gameobject_template` reloaded.");
+    return true;
+}
+
+bool ChatHandler::HandleReloadItemTemplateCommand(char*)
+{
+    sLog.outString( "WARNING: Reloading item_template" );
+    sObjectMgr.LoadItemPrototypes();
+    SendGlobalSysMessage("WARNIONG: DB table `item_template` reloaded.");
+    return true;
+}
+
+bool ChatHandler::HandleReloadCreatureTemplateCommand(char*)
+{
+    sLog.outString( "WARNING: Reloading creature_template" );
+    sObjectMgr.LoadCreatureTemplates();
+    SendGlobalSysMessage("WARNING: DB table `creature_template` reloaded.");
+    return true;
+}
+// DEV END
+
 bool ChatHandler::HandleAccountSetGmLevelCommand(char* args)
 {
     char* accountStr = ExtractOptNotLastArg(&args);
@@ -1075,6 +1101,7 @@ bool ChatHandler::HandleAccountSetGmLevelCommand(char* args)
         return false;
 
     int32 gm;
+	uint32 gmRealmID = realmID;
     if (!ExtractInt32(&args, gm))
         return false;
 
@@ -1098,6 +1125,13 @@ bool ChatHandler::HandleAccountSetGmLevelCommand(char* args)
         SetSentErrorMessage(true);
         return false;
     }
+    /// Check if provided realmID is not current realmID, or isn't -1
+    if (gmRealmID != realmID && gmRealmID != -1)
+    {
+        SendSysMessage(LANG_INVALID_REALMID);
+        SetSentErrorMessage(true);
+        return false;
+    }
 
     if (targetPlayer)
     {
@@ -1106,7 +1140,18 @@ bool ChatHandler::HandleAccountSetGmLevelCommand(char* args)
     }
 
     PSendSysMessage(LANG_YOU_CHANGE_SECURITY, targetAccountName.c_str(), gm);
-    LoginDatabase.PExecute("UPDATE account SET gmlevel = '%i' WHERE id = '%u'", gm, targetAccountId);
+	// If gmRealmID is -1, delete all values for the account id, else, insert values for the specific realmID
+        if (gmRealmID == -1)
+        {
+            LoginDatabase.PExecute("DELETE FROM account_access WHERE id = '%u'", targetAccountId);
+            LoginDatabase.PExecute("INSERT INTO account_access VALUES ('%u', '%d', -1)", targetAccountId, gm);
+        }
+        else
+        {
+            LoginDatabase.PExecute("DELETE FROM account_access WHERE id = '%u' AND RealmID = '%d'", targetAccountId, realmID);
+            LoginDatabase.PExecute("INSERT INTO account_access VALUES ('%u','%d','%d')", targetAccountId, gm, realmID);
+        }
+    //LoginDatabase.PExecute("UPDATE account_access SET gmlevel = '%i' WHERE id = '%u'", gm, targetAccountId);
 
     return true;
 }
@@ -6067,7 +6112,7 @@ bool ChatHandler::HandleInstanceSaveDataCommand(char* /*args*/)
 bool ChatHandler::HandleGMListFullCommand(char* /*args*/)
 {
     ///- Get the accounts with GM Level >0
-    QueryResult* result = LoginDatabase.Query("SELECT username,gmlevel FROM account WHERE gmlevel > 0");
+    QueryResult* result = LoginDatabase.Query("SELECT a.username, aa.gmlevel FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE gmlevel > 0");
     if (result)
     {
         SendSysMessage(LANG_GMLIST);
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
index 70f558c..52387a8 100644
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -252,6 +252,39 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recv_data)
             break;
     }
 
+    if (sWorld.getConfig(CONFIG_BOOL_FAKE_WHO_LIST) && clientcount < 49)
+    {
+        // Fake players on WHO LIST                            0,   1,    2,   3,    4,   5
+        QueryResult *result = CharacterDatabase.Query("SELECT name,race,class,level,zone,gender FROM characters_fake WHERE online > 1");
+        if (result)
+        {
+            do
+            {
+                Field *fields = result->Fetch();
+
+                std::string pname = fields[0].GetCppString();    // player name
+                std::string gname;                                // guild name
+                uint32 lvl = fields[3].GetUInt32();                // player level
+                uint32 class_ = fields[2].GetUInt32();            // player class
+                uint32 race = fields[1].GetUInt32();            // player race
+                uint32 pzoneid = fields[4].GetUInt32();            // player zone id
+                uint8 gender = fields[5].GetUInt8();            // player gender
+
+                data << pname;                              // player name
+                data << gname;                              // guild name
+                data << uint32(lvl);                        // player level
+                data << uint32(class_);                     // player class
+                data << uint32(race);                       // player race
+                data << uint8(gender);                      // player gender
+                data << uint32(pzoneid);                    // player zone id
+
+                if ((++clientcount) == 49)
+                    break;
+            } while (result->NextRow());
+        }
+        delete result;
+    }
+
     uint32 count = m.size();
     data.put(0, clientcount);                               // insert right count, listed count
     data.put(4, count > 50 ? count : clientcount);          // insert right count, online count
diff --git a/src/game/Object.cpp b/src/game/Object.cpp
index a77662d..4024c1a 100644
--- a/src/game/Object.cpp
+++ b/src/game/Object.cpp
@@ -1306,6 +1306,53 @@ void WorldObject::UpdateAllowedPositionZ(float x, float y, float& z) const
     }
 }
 
+void WorldObject::MovePositionToFirstCollision(WorldLocation &pos, float dist, float angle)
+{
+    angle += m_position.o;
+    float destX, destY, destZ, ground, floor;
+ 
+    destX = pos.coord_x + dist * cos(angle);
+    destY = pos.coord_y + dist * sin(angle);
+    ground = GetMap()->GetTerrain()->GetHeight(destX, destY, MAX_HEIGHT, true);
+    floor = GetMap()->GetTerrain()->GetHeight(destX, destY, pos.coord_z, true);
+    destZ = fabs(ground - pos.coord_z) <= fabs(floor - pos.coord_z) ? ground : floor;
+
+    bool colPoint = GetMap()->GetObjectHitPos(pos.coord_x,pos.coord_y,pos.coord_z+0.5f,destX,destY,destZ+0.5f,destX,destY,destZ,-0.5f);
+
+    if (colPoint)
+    {
+        destX -= CONTACT_DISTANCE * cos(angle);
+        destY -= CONTACT_DISTANCE * sin(angle);
+        dist = sqrt((pos.coord_x - destX)*(pos.coord_x - destX) + (pos.coord_y - destY)*(pos.coord_y - destY));
+    }
+
+    float step = dist/10.0f;
+
+    for (int i = 0; i < 10; i++)
+    {
+        if (fabs(pos.coord_z - destZ) > ATTACK_DISTANCE)
+        {
+            destX -= step * cos(angle);
+            destY -= step * sin(angle);
+            ground = GetMap()->GetTerrain()->GetHeight(destX, destY, MAX_HEIGHT, true);
+            floor = GetMap()->GetTerrain()->GetHeight(destX, destY, pos.coord_z, true);
+            destZ = fabs(ground - pos.coord_z) <= fabs(floor - pos.coord_z) ? ground : floor;
+        }
+        else
+        {
+            pos.coord_x = destX;
+            pos.coord_y = destY;
+            pos.coord_z = destZ;
+            break;
+        }
+    }
+
+    MaNGOS::NormalizeMapCoord(pos.coord_x);
+    MaNGOS::NormalizeMapCoord(pos.coord_y);
+    UpdateGroundPositionZ(pos.coord_x, pos.coord_y, pos.coord_z);
+    pos.orientation = m_position.o;
+}
+
 bool WorldObject::IsPositionValid() const
 {
     return MaNGOS::IsValidMapCoord(m_position.x, m_position.y, m_position.z, m_position.o);
diff --git a/src/game/Object.h b/src/game/Object.h
index 6e12b0a..26b58b8 100644
--- a/src/game/Object.h
+++ b/src/game/Object.h
@@ -463,6 +463,12 @@ public:
     void UpdateGroundPositionZ(float x, float y, float& z) const;
     void UpdateAllowedPositionZ(float x, float y, float& z) const;
 
+    void MovePositionToFirstCollision(WorldLocation &pos, float dist, float angle);
+    void GetFirstCollisionPosition(WorldLocation &pos, float dist, float angle)
+        {
+            GetPosition(pos);
+            MovePositionToFirstCollision(pos, dist, angle);
+        }
     void GetRandomPoint(float x, float y, float z, float distance, float& rand_x, float& rand_y, float& rand_z) const;
 
     uint32 GetMapId() const { return m_mapId; }
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index d687126..6a8654a 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -1285,6 +1285,10 @@ void Player::Update(uint32 update_diff, uint32 p_time)
             // m_nextSave reseted in SaveToDB call
             SaveToDB();
             DETAIL_LOG("Player '%s' (GUID: %u) saved", GetName(), GetGUIDLow());
+            // If Fake WHO List system on then change player position with every SavePlayer Interval (usually 15min)
+            if (sWorld.getConfig(CONFIG_BOOL_FAKE_WHO_LIST))
+                CharacterDatabase.PExecute("UPDATE characters_fake SET zone = (FLOOR(50 * RAND()) + 1) WHERE online>1");
+                CharacterDatabase.PExecute("UPDATE characters_fake SET level=level+1 WHERE online>1 AND level<5");
         }
         else
             m_nextSave -= update_diff;
@@ -5892,7 +5896,8 @@ void Player::CheckAreaExploreAndOutdoor()
                 {
                     XP = uint32(sObjectMgr.GetBaseXP(p->area_level) * sWorld.getConfig(CONFIG_FLOAT_RATE_XP_EXPLORE));
                 }
-
+                if(GetSession()->IsPremium())
+                XP *= sWorld.getConfig(CONFIG_FLOAT_RATE_XP_EXPLORE_PREMIUM);
                 GiveXP(XP, NULL);
                 SendExplorationExperience(area, XP);
             }
@@ -13274,6 +13279,8 @@ void Player::RewardQuest(Quest const* pQuest, uint32 reward, Object* questGiver,
 
     // Used for client inform but rewarded only in case not max level
     uint32 xp = uint32(pQuest->XPValue(this) * sWorld.getConfig(CONFIG_FLOAT_RATE_XP_QUEST));
+    if (GetSession()->IsPremium())
+        xp *= sWorld.getConfig(CONFIG_FLOAT_RATE_XP_QUEST_PREMIUM);
 
     if (getLevel() < sWorld.getConfig(CONFIG_UINT32_MAX_PLAYER_LEVEL))
         GiveXP(xp , NULL);
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
index 4b00f91..0561a3b 100644
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -5005,19 +5005,6 @@ SpellCastResult Spell::CheckCast(bool strict)
             case SPELL_EFFECT_LEAP:
             case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
             {
-                float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-                float fx = m_caster->GetPositionX() + dis * cos(m_caster->GetOrientation());
-                float fy = m_caster->GetPositionY() + dis * sin(m_caster->GetOrientation());
-                // teleport a bit above terrain level to avoid falling below it
-                float fz = m_caster->GetTerrain()->GetHeight(fx, fy, m_caster->GetPositionZ(), true);
-                if (fz <= INVALID_HEIGHT)                   // note: this also will prevent use effect in instances without vmaps height enabled
-                    return SPELL_FAILED_TRY_AGAIN;
-
-                float caster_pos_z = m_caster->GetPositionZ();
-                // Control the caster to not climb or drop when +-fz > 8
-                if (!(fz <= caster_pos_z + 8 && fz >= caster_pos_z - 8))
-                    return SPELL_FAILED_TRY_AGAIN;
-
                 // not allow use this effect at battleground until battleground start
                 if (m_caster->GetTypeId() == TYPEID_PLAYER)
                     if (BattleGround const* bg = ((Player*)m_caster)->GetBattleGround())
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index 2a3c39d..fe50173 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -2409,12 +2409,15 @@ void Spell::EffectTeleportUnits(SpellEffectIndex eff_idx)
             else if (unitTarget->GetTypeId() == TYPEID_PLAYER)
                 pTarget = unitTarget->GetMap()->GetUnit(((Player*)unitTarget)->GetSelectionGuid());
 
-            // Init dest coordinates
-            float x = m_targets.m_destX;
-            float y = m_targets.m_destY;
-            float z = m_targets.m_destZ;
+            WorldLocation destLoc;
+            destLoc.coord_x = m_targets.m_destX;
+            destLoc.coord_y = m_targets.m_destY;
+            destLoc.coord_z = m_targets.m_destZ;
+
             float orientation = pTarget ? pTarget->GetOrientation() : unitTarget->GetOrientation();
-            unitTarget->NearTeleportTo(x, y, z, orientation, unitTarget == m_caster);
+            unitTarget->MovePositionToFirstCollision(destLoc, unitTarget->GetObjectScale(), orientation);
+
+            unitTarget->NearTeleportTo(destLoc.coord_x, destLoc.coord_y, (destLoc.coord_z + unitTarget->GetObjectScale()),orientation,unitTarget==m_caster);
             return;
         }
         default:
@@ -6003,18 +6006,12 @@ void Spell::EffectLeapForward(SpellEffectIndex eff_idx)
 
     if (m_spellInfo->rangeIndex == 1)                       // self range
     {
-        float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[eff_idx]));
-
-        // before caster
-        float fx, fy, fz;
-        unitTarget->GetClosePoint(fx, fy, fz, unitTarget->GetObjectBoundingRadius(), dis);
-        float ox, oy, oz;
-        unitTarget->GetPosition(ox, oy, oz);
-
-        if (unitTarget->GetMap()->GetObjectHitPos(ox, oy, oz + 0.5f, fx, fy, oz + 0.5f, fx, fy, fz, -0.5f))
-            unitTarget->UpdateAllowedPositionZ(fx, fy, fz);
-
-        unitTarget->NearTeleportTo(fx, fy, fz, unitTarget->GetOrientation(), unitTarget == m_caster);
+        float spellDist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[eff_idx]));
+ 
+        WorldLocation destLoc;    
+        unitTarget->GetFirstCollisionPosition(destLoc, spellDist, 0.0f);
+ 
+        unitTarget->NearTeleportTo(destLoc.coord_x, destLoc.coord_y, (destLoc.coord_z + unitTarget->GetObjectScale()), unitTarget->GetOrientation(), unitTarget == m_caster);
     }
 }
 
@@ -6125,14 +6122,17 @@ void Spell::EffectCharge(SpellEffectIndex /*eff_idx*/)
 
     // TODO: research more ContactPoint/attack distance.
     //3.666666 instead of ATTACK_DISTANCE(5.0f) in below seem to give more accurate result.
-    float x, y, z;
-    unitTarget->GetContactPoint(m_caster, x, y, z, 3.666666f);
+    float angle = unitTarget->GetAngle(m_caster) - unitTarget->GetOrientation();
+
+    WorldLocation pos;
+    unitTarget->GetContactPoint(m_caster, pos.coord_x, pos.coord_y, pos.coord_z);
+    unitTarget->GetFirstCollisionPosition(pos, unitTarget->GetObjectScale(), angle);
 
     if (unitTarget->GetTypeId() != TYPEID_PLAYER)
         ((Creature*)unitTarget)->StopMoving();
 
     // Only send MOVEMENTFLAG_WALK_MODE, client has strange issues with other move flags
-    m_caster->MonsterMoveWithSpeed(x, y, z, 24.f, true, true);
+    m_caster->MonsterMoveWithSpeed(pos.coord_x, pos.coord_y, (pos.coord_z + unitTarget->GetObjectScale()), 24.f, true, true);
 
     // not all charge effects used in negative spells
     if (unitTarget != m_caster && !IsPositiveSpell(m_spellInfo->Id))
diff --git a/src/game/Teleport/sc_npc_teleport.cpp b/src/game/Teleport/sc_npc_teleport.cpp
new file mode 100644
index 0000000..0733344
--- /dev/null
+++ b/src/game/Teleport/sc_npc_teleport.cpp
@@ -0,0 +1,377 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "Common.h"
+//#include "WorldPacket.h"
+#include "../WorldSession.h"
+#include "Database/DatabaseEnv.h"
+//#include "Util.h"
+#include "sc_npc_teleport.h"
+#include "../Player.h"
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+const uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetObjectGuid() == m_data0;
+    }
+
+    error_log("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {   
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        error_log("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            error_log("Invalid data0 (category: %u).", cat);
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            error_log("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        error_log("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            error_log("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        error_log("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        error_log("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        error_log("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        error_log("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            error_log("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        error_log("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    error_log("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult *result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        outstring_log("TSCR: Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetCppString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetCppString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        outstring_log("");
+        outstring_log("TSCR: >> Loaded %u npc_teleport.", nbDest);
+    } else outstring_log("TSCR: WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/game/Teleport/sc_npc_teleport.h b/src/game/Teleport/sc_npc_teleport.h
new file mode 100644
index 0000000..be4aa2d
--- /dev/null
+++ b/src/game/Teleport/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+        
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        const uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern DatabaseType WorldDatabase;
+
+#endif
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 4d676c3..bd8d1f9 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -66,6 +66,8 @@
 #include "CharacterDatabaseCleaner.h"
 #include "CreatureLinkingMgr.h"
 #include "Warden/WardenDataStorage.h"
+#include "mangchat/IRCMgr.h"
+#include "Teleport/sc_npc_teleport.h"
 
 INSTANTIATE_SINGLETON_1(World);
 
@@ -455,8 +457,12 @@ void World::LoadConfigSettings(bool reload)
     setConfigPos(CONFIG_FLOAT_RATE_DROP_ITEM_REFERENCED, "Rate.Drop.Item.Referenced", 1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_DROP_MONEY,           "Rate.Drop.Money", 1.0f);
     setConfig(CONFIG_FLOAT_RATE_XP_KILL,    "Rate.XP.Kill",    1.0f);
+    setConfig(CONFIG_FLOAT_RATE_XP_KILL_PREMIUM,         "Rate.XP.Kill.Premium", 1.0f);
     setConfig(CONFIG_FLOAT_RATE_XP_QUEST,   "Rate.XP.Quest",   1.0f);
+    setConfig(CONFIG_FLOAT_RATE_XP_QUEST_PREMIUM,        "Rate.XP.Quest.Premium", 1.0f);
     setConfig(CONFIG_FLOAT_RATE_XP_EXPLORE, "Rate.XP.Explore", 1.0f);
+    setConfig(CONFIG_FLOAT_RATE_XP_EXPLORE_PREMIUM,      "Rate.XP.Explore.Premium", 1.0f);
+
     setConfig(CONFIG_FLOAT_RATE_REPUTATION_GAIN,           "Rate.Reputation.Gain", 1.0f);
     setConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_KILL,  "Rate.Reputation.LowLevel.Kill", 1.0f);
     setConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_QUEST, "Rate.Reputation.LowLevel.Quest", 1.0f);
@@ -546,6 +552,7 @@ void World::LoadConfigSettings(bool reload)
     setConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_MAIL,    "AllowTwoSide.Interaction.Mail", false);
     setConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_WHO_LIST,            "AllowTwoSide.WhoList", false);
     setConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_ADD_FRIEND,          "AllowTwoSide.AddFriend", false);
+    setConfig(CONFIG_BOOL_FAKE_WHO_LIST,                      "Fake.WHO.List", false);
 
     setConfig(CONFIG_UINT32_STRICT_PLAYER_NAMES,  "StrictPlayerNames",  0);
     setConfig(CONFIG_UINT32_STRICT_CHARTER_NAMES, "StrictCharterNames", 0);
@@ -1262,7 +1269,7 @@ void World::SetInitialWorldSettings()
 
     sLog.outString("Loading CreatureEventAI Scripts...");
     sEventAIMgr.LoadCreatureEventAI_Scripts();
-
+	
     sLog.outString("Initializing Scripts...");
     switch (sScriptMgr.LoadScriptLibrary(MANGOS_SCRIPT_NAME))
     {
@@ -1349,12 +1356,18 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = sGameEventMgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    // depend on next event
 
+    sLog.outString("Loading TeleNPC2...");
+    LoadNpcTele();
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
     sLog.outString("Initialize AuctionHouseBot...");
     sAuctionBot.Initialize();
 
+    // mangChat
+    sLog.outString("Initialize MangChat...");
+    sIRCMgr.Initialize();
+
     sLog.outString("WORLD: World initialized");
 
     uint32 uStartInterval = WorldTimer::getMSTimeDiff(uStartTime, WorldTimer::getMSTime());
diff --git a/src/game/World.h b/src/game/World.h
index 7d680b3..dc6085d 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -217,8 +217,11 @@ enum eConfigFloatValues
     CONFIG_FLOAT_RATE_DROP_ITEM_REFERENCED,
     CONFIG_FLOAT_RATE_DROP_MONEY,
     CONFIG_FLOAT_RATE_XP_KILL,
+    CONFIG_FLOAT_RATE_XP_KILL_PREMIUM,
     CONFIG_FLOAT_RATE_XP_QUEST,
+    CONFIG_FLOAT_RATE_XP_QUEST_PREMIUM,
     CONFIG_FLOAT_RATE_XP_EXPLORE,
+    CONFIG_FLOAT_RATE_XP_EXPLORE_PREMIUM,
     CONFIG_FLOAT_RATE_RAF_XP,
     CONFIG_FLOAT_RATE_RAF_LEVELPERLEVEL,
     CONFIG_FLOAT_RATE_REPUTATION_GAIN,
@@ -289,6 +292,7 @@ enum eConfigBoolValues
     CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_MAIL,
     CONFIG_BOOL_ALLOW_TWO_SIDE_WHO_LIST,
     CONFIG_BOOL_ALLOW_TWO_SIDE_ADD_FRIEND,
+    CONFIG_BOOL_FAKE_WHO_LIST,
     CONFIG_BOOL_INSTANCE_IGNORE_LEVEL,
     CONFIG_BOOL_INSTANCE_IGNORE_RAID,
     CONFIG_BOOL_CAST_UNSTUCK,
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
index 0a974aa..a5f17a7 100644
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -80,9 +80,9 @@ bool WorldSessionFilter::Process(WorldPacket* packet)
 }
 
 /// WorldSession constructor
-WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale) :
+WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale) :
     LookingForGroup_auto_join(false), LookingForGroup_auto_add(false), m_muteTime(mute_time),
-    _player(NULL), m_Socket(sock), _security(sec), _accountId(id), m_expansion(expansion), _logoutTime(0),
+    _player(NULL), m_Socket(sock), _security(sec), _ispremium(ispremium), _accountId(id), m_expansion(expansion), _logoutTime(0),
     m_inQueue(false), m_playerLoading(false), m_playerLogout(false), m_playerRecentlyLogout(false), m_playerSave(false),
     m_sessionDbcLocale(sWorld.GetAvailableDbcLocale(locale)), m_sessionDbLocaleIndex(sObjectMgr.GetIndexForLocale(locale)),
     m_latency(0), m_tutorialState(TUTORIALDATA_UNCHANGED), m_Warden(NULL)
diff --git a/src/game/WorldSession.h b/src/game/WorldSession.h
index 928d704..ced5c5c 100644
--- a/src/game/WorldSession.h
+++ b/src/game/WorldSession.h
@@ -148,7 +148,7 @@ class MANGOS_DLL_SPEC WorldSession
     friend class CharacterHandler;
 
 public:
-    WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale);
+    WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale);
     ~WorldSession();
 
     bool PlayerLoading() const { return m_playerLoading; }
@@ -167,6 +167,7 @@ public:
     void SendQueryTimeResponse();
 
     AccountTypes GetSecurity() const { return _security; }
+    bool IsPremium() const { return _ispremium; }
     uint32 GetAccountId() const { return _accountId; }
     Player* GetPlayer() const { return _player; }
     char const* GetPlayerName() const;
@@ -765,6 +766,7 @@ private:
     AccountTypes _security;
     uint32 _accountId;
     uint8 m_expansion;
+    bool _ispremium;
 
     // Warden
     WardenBase *m_Warden;
diff --git a/src/game/WorldSocket.cpp b/src/game/WorldSocket.cpp
index 4c414b3..fb561e0 100644
--- a/src/game/WorldSocket.cpp
+++ b/src/game/WorldSocket.cpp
@@ -633,6 +633,7 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     uint8 expansion = 0;
     LocaleConstant locale;
     std::string account;
+    bool isPremium = false;
     Sha1Hash sha1;
     BigNumber v, s, g, N, K;
     WorldPacket packet, SendAddonPacked;
@@ -670,16 +671,15 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     QueryResult* result =
         LoginDatabase.PQuery("SELECT "
                              "id, "                      //0
-                             "gmlevel, "                 //1
-                             "sessionkey, "              //2
-                             "last_ip, "                 //3
-                             "locked, "                  //4
-                             "v, "                       //5
-                             "s, "                       //6
-                             "expansion, "               //7
-                             "mutetime, "                //8
-                             "locale, "                  //9
-                             "os "                       //10
+                             "sessionkey, "              //1
+                             "last_ip, "                 //2
+                             "locked, "                  //3
+                             "v, "                       //4
+                             "s, "                       //5
+                             "expansion, "               //6
+                             "mutetime, "                //7
+                             "locale "                   //8
+                             "os "                       //9
                              "FROM account "
                              "WHERE username = '%s'",
                              safe_account.c_str());
@@ -698,13 +698,13 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
 
     Field* fields = result->Fetch();
 
-    expansion = ((sWorld.getConfig(CONFIG_UINT32_EXPANSION) > fields[7].GetUInt8()) ? fields[7].GetUInt8() : sWorld.getConfig(CONFIG_UINT32_EXPANSION));
+    expansion = ((sWorld.getConfig(CONFIG_UINT32_EXPANSION) > fields[6].GetUInt8()) ? fields[6].GetUInt8() : sWorld.getConfig(CONFIG_UINT32_EXPANSION));
 
     N.SetHexStr("894B645E89E1535BBDAD5B8B290650530801B18EBFBF5E8FAB3C82872A3E9BB7");
-    g.SetDword(7);
+    g.SetDword(6);
 
-    v.SetHexStr(fields[5].GetString());
-    s.SetHexStr(fields[6].GetString());
+    v.SetHexStr(fields[4].GetString());
+    s.SetHexStr(fields[5].GetString());
 
     const char* sStr = s.AsHexStr();                        // Must be freed by OPENSSL_free()
     const char* vStr = v.AsHexStr();                        // Must be freed by OPENSSL_free()
@@ -717,9 +717,9 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     OPENSSL_free((void*) vStr);
 
     ///- Re-check ip locking (same check as in realmd).
-    if (fields[4].GetUInt8() == 1)  // if ip is locked
+    if (fields[3].GetUInt8() == 1)  // if ip is locked
     {
-        if (strcmp(fields[3].GetString(), GetRemoteAddress().c_str()))
+        if (strcmp(fields[2].GetString(), GetRemoteAddress().c_str()))
         {
             packet.Initialize(SMSG_AUTH_RESPONSE, 1);
             packet << uint8(AUTH_FAILED);
@@ -732,19 +732,19 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     }
 
     id = fields[0].GetUInt32();
-    security = fields[1].GetUInt16();
+    /*security = fields[1].GetUInt16();
     if (security > SEC_ADMINISTRATOR)                       // prevent invalid security settings in DB
-        security = SEC_ADMINISTRATOR;
+        security = SEC_ADMINISTRATOR;*/
 
-    K.SetHexStr(fields[2].GetString());
+    K.SetHexStr(fields[1].GetString());
 
-    time_t mutetime = time_t (fields[8].GetUInt64());
+    time_t mutetime = time_t (fields[7].GetUInt64());
 
-    locale = LocaleConstant(fields[9].GetUInt8());
+    locale = LocaleConstant(fields[8].GetUInt8());
     if (locale >= MAX_LOCALE)
         locale = LOCALE_enUS;
 
-    std::string os = fields[10].GetString();
+    std::string os = fields[9].GetString();
 
     delete result;
 
@@ -767,6 +767,16 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
         return -1;
     }
 
+    QueryResult* premresult =
+        LoginDatabase.PQuery ("SELECT 1 "
+                                "FROM account_premium "
+                                "WHERE id = '%u' "
+                                "AND active = 1",
+                                id);
+    if (premresult) // if account premium
+    {
+        isPremium = true;
+    }
     // Check locked state for server
     AccountTypes allowedAccountType = sWorld.GetPlayerSecurityLimit();
 
@@ -819,7 +829,7 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     stmt.PExecute(address.c_str(), account.c_str());
 
     // NOTE ATM the socket is single-threaded, have this in mind ...
-    ACE_NEW_RETURN(m_Session, WorldSession(id, this, AccountTypes(security), expansion, mutetime, locale), -1);
+    ACE_NEW_RETURN(m_Session, WorldSession(id, this, AccountTypes(security), isPremium, expansion, mutetime, locale), -1);
 
     m_Crypt.Init(&K);
 
diff --git a/src/game/mangchat/IRCClient.cpp b/src/game/mangchat/IRCClient.cpp
new file mode 100644
index 0000000..7d5e068
--- /dev/null
+++ b/src/game/mangchat/IRCClient.cpp
@@ -0,0 +1,179 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#include "IRCClient.h"
+#include "../ObjectMgr.h"
+#include "../World.h"
+#include "../ChannelMgr.h"
+#include "../Channel.h"
+#include "../Chat.h"
+
+IRCClient::IRCClient(string sHost, int iPort, string sUser, string sPass, string sNick, ChannelLinkMap WoWChannelLinks, ChannelLinkMap IRCChannelLinks, uint8 uiAuth) :
+m_bActive(true),
+m_sHost(sHost),
+m_iPort(iPort),
+m_sUser(sUser),
+m_sPass(sPass),
+m_sNick(sNick),
+m_mWoWLinks(WoWChannelLinks),
+m_mIRCLinks(IRCChannelLinks),
+m_uiAuth(uiAuth)
+{
+}
+
+IRCClient::~IRCClient()
+{
+    m_bActive = false;
+}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (mangosd)
+void IRCClient::run()
+{
+    // Before we begin we wait a while MaNGOS is still starting up.
+    ACE_Based::Thread::Sleep(500);
+
+    /* Connection count
+     */
+    int cCount = 0;
+
+    // Create a loop to keep the thread running untill active is set to false
+    while (m_bActive && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (InitSock())
+        {
+            // Connect To The IRC Server
+            sLog.outString("MangChat: Connecting to %s Try # %d", m_sHost.c_str(), cCount);
+
+            if (Connect(m_sHost.c_str(), m_iPort))
+            {
+                sLog.outString("MangChat: Connected And Logging In");
+
+                // On connection success reset the connection counter
+                cCount = 0;
+
+                // Login to the IRC server
+                if (Login(m_sNick, m_sUser, m_sPass))
+                {
+                    sLog.outString("MangChat: Logged In And Running!!");
+
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (m_bConnected && !World::IsStopped())
+                    {
+                        SockRecv();
+                    }
+                }
+
+                sLog.outString("MangChat: Connection To IRC Server Lost!");
+            }
+
+            // When an error occures or connection lost cleanup
+            Disconnect();
+
+            // Increase the connection counter
+            ++cCount;
+
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (cCount == MAX_CONNECT_ATTEMPT)
+                m_bActive = false;
+
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (m_bActive)
+                ACE_Based::Thread::Sleep(WAIT_CONNECT_TIME);
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            m_bActive = false;
+            sLog.outError("MangChat: Could not initialize socket");
+        }
+    }
+    // thread stays alive for calls from other threads
+}
+
+bool IRCClient::SendToIRC(string sData)
+{
+    if (m_bConnected)
+    {
+        if (send(SOCKET, sData.c_str(), sData.length(), 0) == -1)
+        {
+            sLog.outError("IRC Error: Socket Receive ** \n");
+            //Disconnect();
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool IRCClient::SendToIRCChannel(std::string sChannel, std::string sMessage)
+{
+    if (m_bConnected)
+        return SendToIRC("PRIVMSG #" + sChannel + " :" + sMessage + "\n");
+
+    return false;
+}
+
+void IRCClient::SendToWoWChannel(string sChannel, std::string sMessage)
+{
+    if (sChannel.length() < 1)
+        return;
+
+    // IRC-Protocol does not use a specific character encoding.
+    // TODO: Autoencode to UTF8 (as used in the wow client)
+
+    HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = channelMgr(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (Channel* chn = cMgr->GetChannel(sChannel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_CHANNEL, LANG_UNIVERSAL, sChannel.c_str(), ObjectGuid(), sMessage.c_str(), NULL);
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+string IRCClient::GetSubstring(string sContent, int iStartIdx, int iEndIdx)
+{
+    if (iStartIdx < 0 || iEndIdx < 0 ||
+        iEndIdx <= iStartIdx ||
+        sContent.length() < (uint32)iEndIdx)
+        return "";
+
+    return sContent.substr(iStartIdx, std::max(1, iEndIdx - iStartIdx));
+}
+
+int IRCClient::FindSubstring(string sContent, string sFind, int iOffset, int iIdxPlus)
+{
+    if (iOffset < 0 || sContent.length() <= (uint32)iOffset)
+        return -1;
+
+    int iIndex = sContent.find(sFind.c_str(), iOffset);
+
+    if (iIndex < 0)
+    {
+        return -1;
+    }
+    else
+        return iIndex + iIdxPlus;
+}
diff --git a/src/game/mangchat/IRCClient.h b/src/game/mangchat/IRCClient.h
new file mode 100644
index 0000000..b31719c
--- /dev/null
+++ b/src/game/mangchat/IRCClient.h
@@ -0,0 +1,154 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include "Common.h"
+#include "../Player.h"
+
+using namespace std;
+
+enum HardcodedOptions
+{
+    MAX_CONNECT_ATTEMPT = 20,
+    WAIT_CONNECT_TIME = 30000
+};
+
+enum MangChatAuthMethods
+{
+    AUTH_NO_AUTH = 0,
+    AUTH_NICKSERV_PW = 1,
+    AUTH_NICKSERV_USER_AND_PW = 2,
+    MAX_AUTH_METHODS = 3
+};
+
+enum MangChatChannelOptions
+{
+    OPTION_LINK_WITH_OTHER_CHANNEL = 1,
+    OPTION_DISPLAY_JOINS = 2,
+    OPTION_DISPLAY_LEAVES = 4,
+    OPTION_DISPLAY_GM_TAG = 8,
+    OPTION_DISPLAY_KICKS = 16
+};
+
+struct MangChatChannel
+{
+    public:
+        MangChatChannel(string _sChannel, uint16 _uiOptions) :
+            sChannel(_sChannel),
+            uiOptions(_uiOptions)
+            { }
+
+        string sChannel;
+        uint16 uiOptions;
+};
+
+typedef list<MangChatChannel> ChannelList;
+typedef map<string, ChannelList> ChannelLinkMap;
+
+// IRCClient main class
+class IRCClient : public ACE_Based::Runnable
+{
+    public:
+        IRCClient(string sHost, int iPort, string sUser, string sPass, string sNick, ChannelLinkMap WoWChannelLinks, ChannelLinkMap IRCChannelLinks, uint8 uiAuth);
+        ~IRCClient();
+
+        // ZThread Entry
+        void run();
+
+        // This function is called in Channel.cpp
+        void HandleJoinWoWChannel(Player* pPlayer, string sChannel);
+        // This function is called in Channel.cpp
+        void HandleLeaveWoWChannel(Player* pPlayer, string sChannel);
+        // This function is called in ChatHandler.cpp
+        void HandleSendMessage(Player* pPlayer, string sMessage, string sChannel);
+
+    private:
+        // Initialize socket library
+        bool InitSock();
+        // Connect to IRC Server
+        bool Connect(const char* cHost, int nPort);
+        // Login to IRC Server
+        bool Login(std::string sNick, std::string sUser, std::string sPass);
+        // Receives data from the socket.
+        void SockRecv();
+        // Processes the data received from IRC
+        void HandleReceivedData(std::string sData);
+
+        // Send raw data to IRC
+        bool SendToIRC(string sData);
+        // Send a message to the specified IRC channel
+        bool SendToIRCChannel(std::string sChannel, std::string sMessage);
+        // Sends a message to all players on the specified channel
+        void SendToWoWChannel(string sChannel, std::string sMessage);
+
+        /* Cut a piece out of a string
+         */
+        string GetSubstring(string sContent, int iStartIdx, int iEndIdx);
+
+        /* Searches the given string content
+           Returns -1 or the found position plus iIdxPlus
+         */
+        int FindSubstring(string sContent, string sFind, int iOffset, int iIdxPlus = 0);
+
+        // Disconnect from IRC and cleanup socket
+        void Disconnect();
+
+        /* IRCClient active
+         */
+        bool m_bActive;
+
+        /* Connected to IRC
+         */
+        bool m_bConnected;
+
+        /* IRC Server Host
+         */
+        string m_sHost;
+
+        /* IRC Server Port
+         */
+        int m_iPort;
+
+        /* IRC Username
+         */
+        string m_sUser;
+
+        /* IRC Password
+         */
+        string m_sPass;
+
+        /* IRC Nickname
+         */
+        string m_sNick;
+
+        /* WoW Channel : IRC Channel
+         */
+        ChannelLinkMap m_mWoWLinks;
+
+        /* IRC Channel : WoW Channel
+         */
+        ChannelLinkMap m_mIRCLinks;
+
+        /* Authenticationmethod
+         */
+        uint8 m_uiAuth;
+
+        // Socket indentifier
+        int SOCKET;
+};
+#endif
diff --git a/src/game/mangchat/IRCHandler.cpp b/src/game/mangchat/IRCHandler.cpp
new file mode 100644
index 0000000..a3591e8
--- /dev/null
+++ b/src/game/mangchat/IRCHandler.cpp
@@ -0,0 +1,297 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#include "IRCMgr.h"
+#include "IRCClient.h"
+#include "../World.h"
+#include "../Player.h"
+#include "../../shared/Log.h"
+
+void IRCMgr::HandleWoWChannelAction(string sChannel, string sMessage, Player* pPlayer)
+{
+    for (ClientList::const_iterator itr = m_lClients.begin(); itr != m_lClients.end(); ++itr)
+        (*itr)->HandleSendMessage(pPlayer, sMessage, sChannel);
+}
+
+void IRCClient::HandleSendMessage(Player* pPlayer, string sMessage, string sChannel)
+{
+    if (m_bConnected && pPlayer)
+    {
+        ChannelLinkMap::const_iterator itr = m_mWoWLinks.find(sChannel);
+
+        if (itr != m_mWoWLinks.end())
+        {
+            ChannelList channels = itr->second;
+
+            for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+            {
+                string sName = pPlayer->GetName();
+
+                if (pPlayer->isGameMaster() && (itr2->uiOptions & OPTION_DISPLAY_GM_TAG))
+                    sName = "[GM]" + sName;
+
+                SendToIRCChannel(itr2->sChannel, "<WoW>" + sName + ": " + sMessage);
+            }
+        }
+    }
+}
+
+void IRCMgr::HandleWoWChannelAction(string sChannel, ChannelAction action, Player* pPlayer)
+{
+    if (action == ACTION_JOIN_CHANNEL)
+    {
+        for (ClientList::const_iterator itr = m_lClients.begin(); itr != m_lClients.end(); ++itr)
+            (*itr)->HandleJoinWoWChannel(pPlayer, sChannel);
+    }
+    else if (action == ACTION_LEAVE_CHANNEL)
+    {
+        for (ClientList::const_iterator itr = m_lClients.begin(); itr != m_lClients.end(); ++itr)
+            (*itr)->HandleLeaveWoWChannel(pPlayer, sChannel);
+    }
+}
+
+void IRCClient::HandleJoinWoWChannel(Player* pPlayer, string sChannel)
+{
+    if (m_bConnected && pPlayer)
+    {
+        ChannelLinkMap::const_iterator itr = m_mWoWLinks.find(sChannel);
+
+        if (itr != m_mWoWLinks.end())
+        {
+            ChannelList channels = itr->second;
+
+            for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+            {
+                if (itr2->uiOptions & OPTION_DISPLAY_JOINS)
+                {
+                    string sName = pPlayer->GetName();
+
+                    if (pPlayer->isGameMaster() && (itr2->uiOptions & OPTION_DISPLAY_GM_TAG))
+                        sName = "[GM]" + sName;
+
+                    SendToIRCChannel(itr2->sChannel, sName + " ist dem Channel " + sChannel + " beigetreten!");
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::HandleLeaveWoWChannel(Player* pPlayer, string sChannel)
+{
+    if (m_bConnected && pPlayer)
+    {
+        ChannelLinkMap::const_iterator itr = m_mWoWLinks.find(sChannel);
+
+        if (itr != m_mWoWLinks.end())
+        {
+            ChannelList channels = itr->second;
+
+            for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+            {
+                if (itr2->uiOptions & OPTION_DISPLAY_LEAVES)
+                {
+                    string sName = pPlayer->GetName();
+
+                    if (pPlayer->isGameMaster() && (itr2->uiOptions & OPTION_DISPLAY_GM_TAG))
+                        sName = "[GM]" + sName;
+
+                    SendToIRCChannel(itr2->sChannel, sName + " hat den Channel " + sChannel + " verlassen.");
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::HandleReceivedData(std::string sData)
+{
+    if (GetSubstring(sData, 0, 5) == "ERROR")
+    {
+        Disconnect();
+    }
+    else if (GetSubstring(sData, 0, 4) == "PING")
+    {
+        SendToIRC("PONG " + GetSubstring(sData, 4, sData.size() - 4) + "\n");
+    }
+    else if (GetSubstring(sData, 0, 1) == ":")
+    {
+        /* Remove \r and \n
+         */
+        sData.erase(std::remove(sData.begin(), sData.end(), '\r'), sData.end());
+        sData.erase(std::remove(sData.begin(), sData.end(), '\n'), sData.end());
+
+        string sUser = GetSubstring(sData, 1, sData.find("!"));
+        string sCommand = GetSubstring(sData, FindSubstring(sData, " ", 0, 1), FindSubstring(sData, " ", FindSubstring(sData, " ", 0, 1)));
+
+        if (sCommand == "PRIVMSG")
+        {
+            string sChannel = GetSubstring(sData, FindSubstring(sData, "#", 0, 1), FindSubstring(sData, " ", FindSubstring(sData, "#", 0, 1)));
+
+            if (sChannel.length() > 0)
+            {
+                string sMessage = GetSubstring(sData, FindSubstring(sData, ":", 1, 1), sData.length());
+
+                DEBUG_LOG("IRCHandler: %s sends a message to channel %s", sUser.c_str(), sChannel.c_str());
+
+                if (sMessage.length() > 0 && sMessage.length() < 1024)
+                {
+                    ChannelLinkMap::const_iterator itr = m_mIRCLinks.find(sChannel);
+
+                    if (itr != m_mIRCLinks.end())
+                    {
+                        ChannelList channels = itr->second;
+                        string sFinalMessage = "<IRC>[" + sUser + "]: " + sMessage;
+
+                        for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+                            SendToWoWChannel(itr2->sChannel, sFinalMessage);
+                    }
+                }
+            }
+            /* ToDo: Handle private messages
+             */
+        }
+        else if (sCommand == "JOIN")
+        {
+            string sChannel = GetSubstring(sData, FindSubstring(sData, "#", 0, 1), sData.length()); // Channel without #
+
+            DEBUG_LOG("IRCHandler: %s joins channel %s", sUser.c_str(), sChannel.c_str());
+
+            if (sUser != m_sNick)
+            {
+                ChannelLinkMap::const_iterator itr = m_mIRCLinks.find(sChannel);
+
+                if (itr != m_mIRCLinks.end())
+                {
+                    ChannelList channels = itr->second;
+                    string sMessage = "<IRC>[" + sUser + "]: Ist dem IRC Channel beigetreten!";
+
+                    for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+                    {
+                        if (itr2->uiOptions & OPTION_DISPLAY_JOINS)
+                            SendToWoWChannel(itr2->sChannel, sMessage);
+                    }
+                }
+            }
+            else
+                SendToIRCChannel(sChannel, "MangChat Rewrite Hello! I am here and ready to start my job!");
+        }
+        else if (sCommand == "PART")
+        {
+            string sChannel = GetSubstring(sData, sData.find("#") + 1, sData.length()); // Channel without #
+
+            DEBUG_LOG("IRCHandler: %s leaves channel %s", sUser.c_str(), sChannel.c_str());
+
+            ChannelLinkMap::const_iterator itr = m_mIRCLinks.find(sChannel);
+
+            if (itr != m_mIRCLinks.end())
+            {
+                ChannelList channels = itr->second;
+                string sMessage = "<IRC>[" + sUser + "]: Hat den IRC Channel verlassen.";
+
+                for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+                {
+                    if (itr2->uiOptions & OPTION_DISPLAY_LEAVES)
+                        SendToWoWChannel(itr2->sChannel, sMessage);
+                }
+            }
+        }    
+        /*else if (sCommand == "QUIT")
+        {
+            // ToDo: Handle it if you want.
+            // We don't get channelnames here.
+        }*/
+        /*else if (sCommand == "NICK")
+        {
+            // ToDo: Handle it if you want.
+            // We don't get channelnames here.
+            string sNewNick = sData.substr(sData.find(":", 1) + 1, sData.length());
+        }*/
+        else if (sCommand == "KICK")
+        {
+            string sChannel = GetSubstring(sData, FindSubstring(sData, "#", 0, 1), FindSubstring(sData, " ", FindSubstring(sData, "#", 0, 1))); // Channel without #
+            string sWho = GetSubstring(sData, FindSubstring(sData, ":", 1, 1), sData.length());
+
+            DEBUG_LOG("IRCHandler: %s kicks %s from channel %s", sUser.c_str(), sWho.c_str(), sChannel.c_str());
+
+            if (sWho == m_sNick)
+            {
+                SendToIRC("JOIN #" + sChannel + "\n");
+                SendToIRCChannel(sChannel, "X_x Ich _darf_ den Channel nicht verlassen.");
+            }
+            else
+            {
+                ChannelLinkMap::const_iterator itr = m_mIRCLinks.find(sChannel);
+
+                if (itr != m_mIRCLinks.end())
+                {
+                    ChannelList channels = itr->second;
+                    string sMessage = "<IRC>[" + sWho + "]: Wurde vom Channel gekickt von " + sUser;
+
+                    for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+                    {
+                        if (itr2->uiOptions & OPTION_DISPLAY_KICKS)
+                            SendToWoWChannel(itr2->sChannel, sMessage);
+                    }
+                }
+            }
+        }
+        else if (sCommand == "001")
+        {
+            /* Authenticate to host
+             */
+            switch (m_uiAuth)
+            {
+                case AUTH_NO_AUTH:
+                    break;
+                case AUTH_NICKSERV_PW:
+                    SendToIRC("PRIVMSG nickserv :IDENTIFY " + m_sPass + "\n");
+                    break;
+                case AUTH_NICKSERV_USER_AND_PW:
+                    SendToIRC("PRIVMSG nickserv :IDENTIFY " + m_sNick + " " + m_sPass + "\n");
+                    break;
+                default:
+                    sLog.outError("mangChat: Unknown auth method '%u' with host '%s'", m_uiAuth, m_sHost.c_str());
+                    break;
+            }
+
+            /* Join all defined IRC Channels
+             */
+            list<string> lJoinedIRCChannels;
+
+            for (ChannelLinkMap::const_iterator itr = m_mWoWLinks.begin(); itr != m_mWoWLinks.end(); ++itr)
+            {
+                ChannelList channels = itr->second;
+
+                for (ChannelList::const_iterator itr2 = channels.begin(); itr2 != channels.end(); ++itr2)
+                {
+                    if (find(lJoinedIRCChannels.begin(), lJoinedIRCChannels.end(), itr2->sChannel) == lJoinedIRCChannels.end())
+                    {
+                        SendToIRC("JOIN #" + itr2->sChannel + "\n");
+                        lJoinedIRCChannels.push_back(itr2->sChannel);
+                    }
+                }
+            }
+
+            for (ChannelLinkMap::const_iterator itr = m_mIRCLinks.begin(); itr != m_mIRCLinks.end(); ++itr)
+            {
+                if (find(lJoinedIRCChannels.begin(), lJoinedIRCChannels.end(), itr->first) == lJoinedIRCChannels.end())
+                {
+                    SendToIRC("JOIN #" + itr->first + "\n");
+                    lJoinedIRCChannels.push_back(itr->first);
+                }
+            }
+        }
+    }
+}
diff --git a/src/game/mangchat/IRCMgr.cpp b/src/game/mangchat/IRCMgr.cpp
new file mode 100644
index 0000000..3c7a94c
--- /dev/null
+++ b/src/game/mangchat/IRCMgr.cpp
@@ -0,0 +1,136 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#include "IRCMgr.h"
+#include "Database/DatabaseEnv.h"
+
+#include "Policies/SingletonImp.h"
+INSTANTIATE_SINGLETON_1(IRCMgr);
+
+extern DatabaseType LoginDatabase;
+
+IRCMgr::IRCMgr()
+{
+}
+
+IRCMgr::~IRCMgr()
+{
+    for (ClientList::iterator itr = m_lClients.begin(); itr != m_lClients.end(); ++itr)
+        delete *itr;
+
+    m_lClients.clear();
+}
+
+void IRCMgr::Initialize()
+{
+    if (m_lClients.size())
+        return;
+
+    sLog.outString("%s\n%s\n%s\n%s",
+        "***************************************",
+        "**   MangChat Threaded IRC Client    **",
+        "**    rewrite by kid10 & wow4you     **",
+        "***************************************");
+
+    QueryResult* pResult = LoginDatabase.PQuery("SELECT mangchat_id, wow_channel, wow_channel_options, irc_channel, irc_channel_options FROM mangchat_links");
+
+    if (!pResult)
+    {
+        sLog.outErrorDb("mangChat: Could not load table 'mangchat_links'");
+        return;
+    }
+
+    typedef map<uint32, ChannelLinkMap> LinkedChannelsByService;
+
+    LinkedChannelsByService WoWLinkServiceMap;
+    LinkedChannelsByService IRCLinkServiceMap;
+
+    do
+    {
+        Field* pFields = pResult->Fetch();
+
+        uint32 uiId = pFields[0].GetUInt32();
+        string sWoWChannel = pFields[1].GetCppString();
+        uint16 uiWoWChannelOptions = pFields[2].GetUInt16();
+        string sIRCChannel = pFields[3].GetCppString();
+        uint16 uiIRCChannelOptions = pFields[4].GetUInt16();
+
+        if (uiWoWChannelOptions & OPTION_LINK_WITH_OTHER_CHANNEL)
+            WoWLinkServiceMap[uiId][sWoWChannel].push_back(MangChatChannel(sIRCChannel, uiIRCChannelOptions));
+
+        if (uiIRCChannelOptions & OPTION_LINK_WITH_OTHER_CHANNEL)
+            IRCLinkServiceMap[uiId][sIRCChannel].push_back(MangChatChannel(sWoWChannel, uiWoWChannelOptions));
+    }
+    while (pResult->NextRow());
+
+    delete pResult;
+
+    pResult = LoginDatabase.PQuery("SELECT id, host, port, user, pass, nick, auth FROM mangchat");
+
+    if (!pResult)
+    {
+        sLog.outErrorDb("mangChat: Could not load table 'mangchat'");
+        return;
+    }
+
+    sLog.outString("Set up %u mangChat connections...", pResult->GetRowCount());
+
+    do
+    {
+        Field* pFields = pResult->Fetch();
+
+        uint32 uiId = pFields[0].GetUInt32();
+
+        ChannelLinkMap WoWChannelLinks;
+        LinkedChannelsByService::const_iterator itr = WoWLinkServiceMap.find(uiId);
+
+        if (itr != WoWLinkServiceMap.end())
+            WoWChannelLinks = itr->second;
+
+        ChannelLinkMap IRCChannelLinks;
+        itr = IRCLinkServiceMap.find(uiId);
+
+        if (itr != IRCLinkServiceMap.end())
+            IRCChannelLinks = itr->second;
+
+        if (!WoWChannelLinks.size() && !IRCChannelLinks.size())
+        {
+            sLog.outErrorDb("mangChat: No channels linked in table 'mangchat_links' for Id '%u'", uiId);
+            continue;
+        }
+
+        uint8 uiAuth = pFields[6].GetUInt8();
+
+        if (uiAuth >= MAX_AUTH_METHODS)
+        {
+            sLog.outErrorDb("mangChat: Unknown auth method '%u' for Id '%u'", uiAuth, uiId);
+            continue;
+        }
+
+        IRCClient* pClient = new IRCClient(pFields[1].GetCppString(), pFields[2].GetInt32(), pFields[3].GetCppString(), pFields[4].GetCppString(),
+            pFields[5].GetCppString(), WoWChannelLinks, IRCChannelLinks, uiAuth);
+
+        m_lClients.push_back(pClient);
+
+        /* Start IRC Thread
+         */
+        ACE_Based::Thread irc(pClient);
+        irc.setPriority(ACE_Based::High);
+    }
+    while (pResult->NextRow());
+
+    delete pResult;
+}
diff --git a/src/game/mangchat/IRCMgr.h b/src/game/mangchat/IRCMgr.h
new file mode 100644
index 0000000..b64018b
--- /dev/null
+++ b/src/game/mangchat/IRCMgr.h
@@ -0,0 +1,50 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#ifndef _IRC_MGR_H
+#define _IRC_MGR_H
+
+#include "IRCClient.h"
+#include "../Player.h"
+#include "Policies/Singleton.h"
+
+enum ChannelAction
+{
+    ACTION_JOIN_CHANNEL = 1,
+    ACTION_LEAVE_CHANNEL = 2
+};
+
+using namespace std;
+
+typedef list<IRCClient*> ClientList;
+
+// IRCMgr main class
+class IRCMgr
+{
+    public:
+        IRCMgr();
+        ~IRCMgr();
+
+        void Initialize();
+
+        void HandleWoWChannelAction(string sChannel, ChannelAction action, Player* pPlayer);
+        void HandleWoWChannelAction(string sChannel, string sMessage, Player* pPlayer);
+
+    private:
+        ClientList m_lClients;
+};
+#endif
+#define sIRCMgr MaNGOS::Singleton<IRCMgr>::Instance()
diff --git a/src/game/mangchat/IRCSock.cpp b/src/game/mangchat/IRCSock.cpp
new file mode 100644
index 0000000..e2827fe
--- /dev/null
+++ b/src/game/mangchat/IRCSock.cpp
@@ -0,0 +1,134 @@
+/*
+ * MangChat for MaNGOS, the open source MMORPG-server
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify It Under The
+ * Terms Of The GNU General Public License
+ *
+ * Written and Developed by Cybrax <cybraxvd@gmail.com>, |Death| <death@hell360.net>,
+ * Lice <lice@yeuxverts.net>, Dj_baby, Sanaell, Tase, Shinzon <shinzon@wowgollum.com>,
+ * Xeross, 3raZar3, the orangevirus team <www.orangevir.us>, ...
+ *
+ * Rewritten by kid10
+ *
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+
+#include "IRCClient.h"
+#include "../../shared/Log.h"
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if(WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        sLog.outError("IRC Error: Winsock Initialization Error");
+        return false;
+    }
+    #endif
+    if ((SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        sLog.outError("IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if ( setsockopt ( SOCKET, SOL_SOCKET, SO_REUSEADDR, ( const char* ) &on, sizeof ( on ) ) == -1 )
+    {
+        sLog.outError("IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char* cHost, int nPort)
+{
+    m_bConnected = false;
+
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        sLog.outError("IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        sLog.outError("IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    //FD_ZERO(&sfdset);
+    //FD_SET(SOCKET,&sfdset);
+
+    m_bConnected = true;
+
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+
+    if (SendToIRC("HELLO\n"))
+        if (SendToIRC("PASS " + sPass + "\n"))
+            if (SendToIRC("NICK " + sNick + "\n"))
+                if (SendToIRC("USER " + sUser + " " + hostname + " " + sNick + " :" + sNick + "\n"))
+                    return true;
+
+    return false;
+}
+
+void IRCClient::SockRecv()
+{
+    char szBuffer[512]; // Max Data Size
+
+    memset(szBuffer, 0, 512);
+
+    int nBytesRecv = ::recv(SOCKET, szBuffer, 512 - 1, 0 );
+    if (nBytesRecv == -1)
+    {
+        sLog.outError("Connection lost.");
+        m_bConnected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            sLog.outError("Error occurred while receiving from socket.");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                HandleReceivedData(reply);
+            }
+        }
+    }
+}
+
+void IRCClient::Disconnect()
+{
+    if (SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(SOCKET);
+        //WSACleanup();
+        #else
+        close(SOCKET);
+        #endif
+    }
+}
diff --git a/src/mangosd/CliRunnable.cpp b/src/mangosd/CliRunnable.cpp
index c607100..a52e4a2 100644
--- a/src/mangosd/CliRunnable.cpp
+++ b/src/mangosd/CliRunnable.cpp
@@ -462,7 +462,7 @@ bool ChatHandler::HandleAccountOnlineListCommand(char* args)
 
     ///- Get the list of accounts ID logged to the realm
     //                                                 0   1         2        3        4
-    QueryResult* result = LoginDatabase.PQuery("SELECT id, username, last_ip, gmlevel, expansion FROM account WHERE active_realm_id = %u", realmID);
+    QueryResult* result = LoginDatabase.PQuery("SELECT a.id, a.username, a.last_ip, aa.gmlevel, a.expansion FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE active_realm_id = %u", realmID);
 
     return ShowAccountListHelper(result, &limit);
 }
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index ca6c27d..a466ea4 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -208,7 +208,7 @@ MaxOverspeedPings = 2
 GridUnload = 1
 GridCleanUpDelay = 300000
 MapUpdateInterval = 100
-ChangeWeatherInterval = 600000
+ChangeWeatherInterval = 5400000# 90 minutes
 PlayerSave.Interval = 900000
 PlayerSave.Stats.MinLevel = 0
 PlayerSave.Stats.SaveOnlyOnLogout = 1
@@ -821,6 +821,13 @@ Motd = "Welcome to the Massive Network Game Object Server."
 #        Default: 1 (allow)
 #                 0 (not allow)
 #
+#    Fake.WHO.List
+#        Add fake players to fill in WHO LIST (who is online list, "O" button) if there is less then
+#        49 real players online (need to set online=2 in character database in order to work)
+#        Default: 0 (disabled)
+#                 1 (enabled)
+#
+#
 ###################################################################################################################
 
 AllowTwoSide.Accounts = 0
@@ -833,6 +840,7 @@ AllowTwoSide.Interaction.Mail = 0
 AllowTwoSide.WhoList = 0
 AllowTwoSide.AddFriend = 0
 TalentsInspecting = 1
+Fake.Who.List = 0
 
 ###################################################################################################################
 # CREATURE AND GAMEOBJECT SETTINGS
@@ -1189,8 +1197,11 @@ Visibility.AIRelocationNotifyDelay = 1000
 #         Default: 1
 #
 #    Rate.XP.Kill
+#    Rate.XP.Kill.Premium
 #    Rate.XP.Quest
+#    Rate.XP.Quest.Premium
 #    Rate.XP.Explore
+#    Rate.XP.Explore.Premium
 #        XP rates
 #        Default: 1
 #
@@ -1333,8 +1344,11 @@ Rate.Drop.Item.Artifact = 1
 Rate.Drop.Item.Referenced = 1
 Rate.Drop.Money = 1
 Rate.XP.Kill    = 1
+Rate.XP.Kill.Premium    = 1
 Rate.XP.Quest   = 1
+Rate.XP.Quest.Premium   = 1
 Rate.XP.Explore = 1
+Rate.XP.Explore.Premium = 1
 Rate.Rest.InGame = 1
 Rate.Rest.Offline.InTavernOrCity = 1
 Rate.Rest.Offline.InWilderness = 1
@@ -1456,6 +1470,11 @@ BattleGround.PremadeGroupWaitForMatch = 1800000
 #    Arena.ArenaSeason.ID
 #        Current area season id, used for selection some rated arena settings.
 #        Default: 1
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
+#        XP rates Premium modifier
+#        Default: 1
 #
 #    Arena.StartRating
 #        Default Rating at team creation
diff --git a/src/realmd/AuthSocket.cpp b/src/realmd/AuthSocket.cpp
index 52b6611..1987799 100644
--- a/src/realmd/AuthSocket.cpp
+++ b/src/realmd/AuthSocket.cpp
@@ -397,7 +397,7 @@ bool AuthSocket::_HandleLogonChallenge()
         ///- Get the account details from the account table
         // No SQL injection (escaped user name)
 
-        result = LoginDatabase.PQuery("SELECT sha_pass_hash,id,locked,last_ip,gmlevel,v,s FROM account WHERE username = '%s'", _safelogin.c_str());
+        result = LoginDatabase.PQuery("SELECT a.sha_pass_hash,a.id,a.locked,a.last_ip,aa.gmlevel,a.v,a.s FROM account a LEFT JOIN account_access aa ON (a.id = aa.id)  WHERE username = '%s'", _safelogin.c_str());
         if (result)
         {
             ///- If the IP is 'locked', check that the player comes indeed from the correct IP address
diff --git a/src/realmd/Main.cpp b/src/realmd/Main.cpp
index b861a38..a4e83ea 100644
--- a/src/realmd/Main.cpp
+++ b/src/realmd/Main.cpp
@@ -253,6 +253,7 @@ extern int main(int argc, char** argv)
     // set expired bans to inactive
     LoginDatabase.BeginTransaction();
     LoginDatabase.Execute("UPDATE account_banned SET active = 0 WHERE unbandate<=UNIX_TIMESTAMP() AND unbandate<>bandate");
+	LoginDatabase.Execute("UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate");
     LoginDatabase.Execute("DELETE FROM ip_banned WHERE unbandate<=UNIX_TIMESTAMP() AND unbandate<>bandate");
     LoginDatabase.CommitTransaction();
 
diff --git a/win/VC100/game.vcxproj b/win/VC100/game.vcxproj
index e814587..cbf01bd 100644
--- a/win/VC100/game.vcxproj
+++ b/win/VC100/game.vcxproj
@@ -418,6 +418,10 @@
     <ClCompile Include="..\..\src\game\LootMgr.cpp" />
     <ClCompile Include="..\..\src\game\Mail.cpp" />
     <ClCompile Include="..\..\src\game\MailHandler.cpp" />
+    <ClCompile Include="..\..\src\game\mangchat\IRCClient.cpp" />
+    <ClCompile Include="..\..\src\game\mangchat\IRCHandler.cpp" />
+    <ClCompile Include="..\..\src\game\mangchat\IRCMgr.cpp" />
+    <ClCompile Include="..\..\src\game\mangchat\IRCSock.cpp" />
     <ClCompile Include="..\..\src\game\Map.cpp" />
     <ClCompile Include="..\..\src\game\MapManager.cpp" />
     <ClCompile Include="..\..\src\game\MapPersistentStateMgr.cpp" />
@@ -586,6 +590,8 @@
     <ClInclude Include="..\..\src\game\Language.h" />
     <ClInclude Include="..\..\src\game\LootMgr.h" />
     <ClInclude Include="..\..\src\game\Mail.h" />
+    <ClInclude Include="..\..\src\game\mangchat\IRCClient.h" />
+    <ClInclude Include="..\..\src\game\mangchat\IRCMgr.h" />
     <ClInclude Include="..\..\src\game\Map.h" />
     <ClInclude Include="..\..\src\game\MapManager.h" />
     <ClInclude Include="..\..\src\game\MapPersistentStateMgr.h" />
diff --git a/win/VC100/game.vcxproj.filters b/win/VC100/game.vcxproj.filters
index 22e1446..f2af62f 100644
--- a/win/VC100/game.vcxproj.filters
+++ b/win/VC100/game.vcxproj.filters
@@ -40,6 +40,9 @@
     <Filter Include="Warden">
       <UniqueIdentifier>{d88fe105-61c5-46b8-b008-c467a7b1b202}</UniqueIdentifier>
     </Filter>
+    <Filter Include="MangChat">
+      <UniqueIdentifier>{10b97d47-328c-472d-bfca-20bb3b61df9e}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\..\src\game\AccountMgr.cpp">
@@ -532,6 +535,18 @@
     <ClCompile Include="..\..\src\game\Warden\WardenWin.cpp">
       <Filter>Warden</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\game\mangchat\IRCClient.cpp">
+      <Filter>MangChat</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\mangchat\IRCSock.cpp">
+      <Filter>MangChat</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\mangchat\IRCHandler.cpp">
+      <Filter>MangChat</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\game\mangchat\IRCMgr.cpp">
+      <Filter>MangChat</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\game\AccountMgr.h">
@@ -1012,5 +1027,11 @@
     <ClInclude Include="..\..\src\game\Warden\WardenWin.h">
       <Filter>Warden</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\game\mangchat\IRCClient.h">
+      <Filter>MangChat</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\game\mangchat\IRCMgr.h">
+      <Filter>MangChat</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
-- 
1.7.2.5

